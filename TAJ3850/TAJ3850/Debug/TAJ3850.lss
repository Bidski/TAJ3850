
TAJ3850.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00006d48  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80008e00  80008e00  00009200  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000000b8  80009000  80009000  00009400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         000000dc  00000008  800090b8  00009808  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  000000e4  80009194  000098e4  2**0
                  ALLOC
  8 .bss          00004580  000000e8  000000e8  00000000  2**2
                  ALLOC
  9 .heap         00002998  00004668  00004668  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  00009c08  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000b40  00000000  00000000  00009c38  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00001674  00000000  00000000  0000a778  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   000174b8  00000000  00000000  0000bdec  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00001943  00000000  00000000  000232a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00008a7c  00000000  00000000  00024be7  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002394  00000000  00000000  0002d664  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006e18  00000000  00000000  0002f9f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000034be  00000000  00000000  00036810  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00b096de  00000000  00000000  00039cce  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00007000  00007000  00000000  2**0
                  ALLOC
 21 .userpage     00000008  80800000  80800000  00009c00  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 22 .debug_ranges 00000ab8  00000000  00000000  00b433b0  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf b3 b4 	sub	pc,pc,-19532

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf d3 b8 	sub	pc,pc,-11336

Disassembly of section .text:

80002008 <board_init>:
80002008:	eb cd 40 80 	pushm	r7,lr
#if defined (CONF_BOARD_AT45DBX)
#	define AT45DBX_MEM_CNT  1
#endif

void board_init(void)
{
8000200c:	1a 97       	mov	r7,sp
	gpio_configure_pin(LED0_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000200e:	30 3b       	mov	r11,3
80002010:	30 7c       	mov	r12,7
80002012:	f0 1f 00 17 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(LED1_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002016:	30 3b       	mov	r11,3
80002018:	30 8c       	mov	r12,8
8000201a:	f0 1f 00 15 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(LED2_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000201e:	30 3b       	mov	r11,3
80002020:	31 5c       	mov	r12,21
80002022:	f0 1f 00 13 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(LED3_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002026:	30 3b       	mov	r11,3
80002028:	31 6c       	mov	r12,22
8000202a:	f0 1f 00 11 	mcall	8000206c <board_init+0x64>

	gpio_configure_pin(GPIO_PUSH_BUTTON_0,GPIO_DIR_INPUT);
8000202e:	30 0b       	mov	r11,0
80002030:	32 2c       	mov	r12,34
80002032:	f0 1f 00 0f 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_PUSH_BUTTON_1,GPIO_DIR_INPUT);
80002036:	30 0b       	mov	r11,0
80002038:	32 3c       	mov	r12,35
8000203a:	f0 1f 00 0d 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_JOYSTICK_PUSH,GPIO_DIR_INPUT);
8000203e:	30 0b       	mov	r11,0
80002040:	30 dc       	mov	r12,13
80002042:	f0 1f 00 0b 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_JOYSTICK_LEFT,GPIO_DIR_INPUT);
80002046:	30 0b       	mov	r11,0
80002048:	32 6c       	mov	r12,38
8000204a:	f0 1f 00 09 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_JOYSTICK_UP,GPIO_DIR_INPUT);
8000204e:	30 0b       	mov	r11,0
80002050:	32 7c       	mov	r12,39
80002052:	f0 1f 00 07 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_JOYSTICK_DOWN,GPIO_DIR_INPUT);
80002056:	30 0b       	mov	r11,0
80002058:	32 8c       	mov	r12,40
8000205a:	f0 1f 00 05 	mcall	8000206c <board_init+0x64>
	// USART GPIO pin configuration.
	static const gpio_map_t COMPORT_GPIO_MAP = {
		{USART_RXD_PIN, USART_RXD_FUNCTION },
		{USART_TXD_PIN, USART_TXD_FUNCTION },
	};
	gpio_enable_module(COMPORT_GPIO_MAP,
8000205e:	30 2b       	mov	r11,2
80002060:	48 4c       	lddpc	r12,80002070 <board_init+0x68>
80002062:	f0 1f 00 05 	mcall	80002074 <board_init+0x6c>

	// Assign GPIO pins to USB.
	gpio_enable_module(USB_GPIO_MAP,
			sizeof(USB_GPIO_MAP) / sizeof(USB_GPIO_MAP[0]));
#endif
}
80002066:	e3 cd 80 80 	ldm	sp++,r7,pc
8000206a:	00 00       	add	r0,r0
8000206c:	80 00       	ld.sh	r0,r0[0x0]
8000206e:	2b c8       	sub	r8,-68
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	90 00       	ld.sh	r0,r8[0x0]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	2a 48       	sub	r8,-92

80002078 <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
80002078:	eb cd 40 80 	pushm	r7,lr
8000207c:	1a 97       	mov	r7,sp
8000207e:	20 4d       	sub	sp,16
		256,
		384,
		512,
		768,
		1024,
	};
80002080:	48 d9       	lddpc	r9,800020b4 <flashc_get_flash_size+0x3c>
80002082:	ee c8 00 10 	sub	r8,r7,16
80002086:	31 0a       	mov	r10,16
80002088:	12 9b       	mov	r11,r9
8000208a:	10 9c       	mov	r12,r8
8000208c:	f0 1f 00 0b 	mcall	800020b8 <flashc_get_flash_size+0x40>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
80002090:	fe 68 14 00 	mov	r8,-125952
80002094:	70 28       	ld.w	r8,r8[0x8]
80002096:	e2 18 e0 00 	andl	r8,0xe000,COH
8000209a:	ad 98       	lsr	r8,0xd
8000209c:	a1 78       	lsl	r8,0x1
8000209e:	ee 08 00 08 	add	r8,r7,r8
800020a2:	f1 08 ff f0 	ld.sh	r8,r8[-16]
800020a6:	5c 78       	castu.h	r8
800020a8:	ab 68       	lsl	r8,0xa
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
800020aa:	10 9c       	mov	r12,r8
800020ac:	2f cd       	sub	sp,-16
800020ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	90 10       	ld.sh	r0,r8[0x2]
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	8c 08       	ld.sh	r8,r6[0x0]

800020bc <flashc_set_wait_state>:
	return (AVR32_FLASHC.fcr & AVR32_FLASHC_FCR_FWS_MASK) >> AVR32_FLASHC_FCR_FWS_OFFSET;
}


void flashc_set_wait_state(unsigned int wait_state)
{
800020bc:	eb cd 40 80 	pushm	r7,lr
800020c0:	1a 97       	mov	r7,sp
800020c2:	20 2d       	sub	sp,8
800020c4:	ef 4c ff f8 	st.w	r7[-8],r12
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020c8:	fe 68 14 00 	mov	r8,-125952
800020cc:	70 08       	ld.w	r8,r8[0x0]
800020ce:	30 09       	mov	r9,0
800020d0:	ef 49 ff fc 	st.w	r7[-4],r9
800020d4:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800020dc:	5c 58       	castu.b	r8
800020de:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800020e2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800020e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020ea:	f1 d9 d0 c1 	bfins	r8,r9,0x6,0x1
800020ee:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800020f2:	fe 68 14 00 	mov	r8,-125952
800020f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800020fa:	91 09       	st.w	r8[0x0],r9
}
800020fc:	2f ed       	sub	sp,-8
800020fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002102:	d7 03       	nop

80002104 <flashc_set_bus_freq>:


void flashc_set_bus_freq(unsigned int cpu_f_hz)
{
80002104:	eb cd 40 80 	pushm	r7,lr
80002108:	1a 97       	mov	r7,sp
8000210a:	20 1d       	sub	sp,4
8000210c:	ef 4c ff fc 	st.w	r7[-4],r12
	if (cpu_f_hz >= AVR32_FLASHC_FWS_0_MAX_FREQ) {
80002110:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002114:	e0 69 8a 3f 	mov	r9,35391
80002118:	ea 19 01 f7 	orh	r9,0x1f7
8000211c:	12 38       	cp.w	r8,r9
8000211e:	e0 88 00 06 	brls	8000212a <flashc_set_bus_freq+0x26>
		// Set 1 WS.
		flashc_set_wait_state(1);
80002122:	30 1c       	mov	r12,1
80002124:	f0 1f 00 05 	mcall	80002138 <flashc_set_bus_freq+0x34>
80002128:	c0 48       	rjmp	80002130 <flashc_set_bus_freq+0x2c>
	} else {
		// Set 0 WS.
		flashc_set_wait_state(0);
8000212a:	30 0c       	mov	r12,0
8000212c:	f0 1f 00 03 	mcall	80002138 <flashc_set_bus_freq+0x34>
	}
}
80002130:	2f fd       	sub	sp,-4
80002132:	e3 cd 80 80 	ldm	sp++,r7,pc
80002136:	00 00       	add	r0,r0
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	20 bc       	sub	r12,11

8000213c <flashc_is_ready>:
 */
//! @{


bool flashc_is_ready(void)
{
8000213c:	eb cd 40 80 	pushm	r7,lr
80002140:	1a 97       	mov	r7,sp
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
80002142:	fe 68 14 00 	mov	r8,-125952
80002146:	70 28       	ld.w	r8,r8[0x8]
80002148:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000214c:	5c 58       	castu.b	r8
}
8000214e:	10 9c       	mov	r12,r8
80002150:	e3 cd 80 80 	ldm	sp++,r7,pc

80002154 <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
80002154:	eb cd 40 80 	pushm	r7,lr
80002158:	1a 97       	mov	r7,sp
	while (!flashc_is_ready());
8000215a:	f0 1f 00 05 	mcall	8000216c <flashc_default_wait_until_ready+0x18>
8000215e:	18 98       	mov	r8,r12
80002160:	ec 18 00 01 	eorl	r8,0x1
80002164:	5c 58       	castu.b	r8
80002166:	cf a1       	brne	8000215a <flashc_default_wait_until_ready+0x6>
}
80002168:	e3 cd 80 80 	ldm	sp++,r7,pc
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	21 3c       	sub	r12,19

80002170 <flashc_get_error_status>:
 *          Flash Status Register (FSR). This function is therefore not part of
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
80002170:	eb cd 40 80 	pushm	r7,lr
80002174:	1a 97       	mov	r7,sp
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80002176:	fe 68 14 00 	mov	r8,-125952
8000217a:	70 28       	ld.w	r8,r8[0x8]
8000217c:	e2 18 00 0c 	andl	r8,0xc,COH
			AVR32_FLASHC_FSR_PROGE_MASK);
}
80002180:	10 9c       	mov	r12,r8
80002182:	e3 cd 80 80 	ldm	sp++,r7,pc
80002186:	d7 03       	nop

80002188 <flashc_issue_command>:
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
80002188:	eb cd 40 80 	pushm	r7,lr
8000218c:	1a 97       	mov	r7,sp
8000218e:	20 3d       	sub	sp,12
80002190:	ef 4c ff f8 	st.w	r7[-8],r12
80002194:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80002198:	49 b8       	lddpc	r8,80002204 <flashc_issue_command+0x7c>
8000219a:	70 08       	ld.w	r8,r8[0x0]
8000219c:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8000219e:	fe 68 14 00 	mov	r8,-125952
800021a2:	70 18       	ld.w	r8,r8[0x4]
800021a4:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800021a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800021ac:	5c 58       	castu.b	r8
800021ae:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
800021b2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800021b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800021ba:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
800021be:	ef 48 ff fc 	st.w	r7[-4],r8
	if (page_number >= 0) {
800021c2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800021c6:	58 08       	cp.w	r8,0
800021c8:	c0 b5       	brlt	800021de <flashc_issue_command+0x56>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
800021ca:	ee f8 ff f4 	ld.w	r8,r7[-12]
800021ce:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800021d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800021d6:	f1 d9 d1 10 	bfins	r8,r9,0x8,0x10
800021da:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800021de:	3a 58       	mov	r8,-91
800021e0:	ef 68 ff fc 	st.b	r7[-4],r8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800021e4:	fe 68 14 00 	mov	r8,-125952
800021e8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800021ec:	91 19       	st.w	r8[0x4],r9
	flashc_error_status = flashc_get_error_status();
800021ee:	f0 1f 00 07 	mcall	80002208 <flashc_issue_command+0x80>
800021f2:	18 99       	mov	r9,r12
800021f4:	48 68       	lddpc	r8,8000220c <flashc_issue_command+0x84>
800021f6:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
800021f8:	48 38       	lddpc	r8,80002204 <flashc_issue_command+0x7c>
800021fa:	70 08       	ld.w	r8,r8[0x0]
800021fc:	5d 18       	icall	r8
}
800021fe:	2f dd       	sub	sp,-12
80002200:	e3 cd 80 80 	ldm	sp++,r7,pc
80002204:	00 00       	add	r0,r0
80002206:	00 08       	add	r8,r0
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	21 70       	sub	r0,23
8000220c:	00 00       	add	r0,r0
8000220e:	00 e8       	st.h	--r0,r8

80002210 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
80002210:	eb cd 40 80 	pushm	r7,lr
80002214:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
80002216:	3f fb       	mov	r11,-1
80002218:	30 3c       	mov	r12,3
8000221a:	f0 1f 00 03 	mcall	80002224 <flashc_clear_page_buffer+0x14>
}
8000221e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002222:	00 00       	add	r0,r0
80002224:	80 00       	ld.sh	r0,r0[0x0]
80002226:	21 88       	sub	r8,24

80002228 <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
80002228:	eb cd 40 80 	pushm	r7,lr
8000222c:	1a 97       	mov	r7,sp
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
8000222e:	fe 68 14 00 	mov	r8,-125952
80002232:	70 28       	ld.w	r8,r8[0x8]
80002234:	e2 18 00 20 	andl	r8,0x20,COH
80002238:	5f 18       	srne	r8
8000223a:	5c 58       	castu.b	r8
}
8000223c:	10 9c       	mov	r12,r8
8000223e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002242:	d7 03       	nop

80002244 <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
80002244:	eb cd 40 80 	pushm	r7,lr
80002248:	1a 97       	mov	r7,sp
8000224a:	20 1d       	sub	sp,4
8000224c:	ef 4c ff fc 	st.w	r7[-4],r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
80002250:	ee fb ff fc 	ld.w	r11,r7[-4]
80002254:	30 cc       	mov	r12,12
80002256:	f0 1f 00 05 	mcall	80002268 <flashc_quick_page_read+0x24>
	return flashc_is_page_erased();
8000225a:	f0 1f 00 05 	mcall	8000226c <flashc_quick_page_read+0x28>
8000225e:	18 98       	mov	r8,r12
}
80002260:	10 9c       	mov	r12,r8
80002262:	2f fd       	sub	sp,-4
80002264:	e3 cd 80 80 	ldm	sp++,r7,pc
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	21 88       	sub	r8,24
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	22 28       	sub	r8,34

80002270 <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
80002270:	eb cd 40 80 	pushm	r7,lr
80002274:	1a 97       	mov	r7,sp
80002276:	20 4d       	sub	sp,16
80002278:	ef 4c ff f4 	st.w	r7[-12],r12
8000227c:	16 98       	mov	r8,r11
8000227e:	ef 68 ff f0 	st.b	r7[-16],r8
	bool page_erased = true;
80002282:	30 18       	mov	r8,1
80002284:	ef 68 ff fb 	st.b	r7[-5],r8

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
80002288:	ee fb ff f4 	ld.w	r11,r7[-12]
8000228c:	30 2c       	mov	r12,2
8000228e:	f0 1f 00 10 	mcall	800022cc <flashc_erase_page+0x5c>
	if (check) {
80002292:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80002296:	30 08       	mov	r8,0
80002298:	f0 09 18 00 	cp.b	r9,r8
8000229c:	c1 20       	breq	800022c0 <flashc_erase_page+0x50>
		unsigned int error_status = flashc_error_status;
8000229e:	48 d8       	lddpc	r8,800022d0 <flashc_erase_page+0x60>
800022a0:	70 08       	ld.w	r8,r8[0x0]
800022a2:	ef 48 ff fc 	st.w	r7[-4],r8
		page_erased = flashc_quick_page_read(-1);
800022a6:	3f fc       	mov	r12,-1
800022a8:	f0 1f 00 0b 	mcall	800022d4 <flashc_erase_page+0x64>
800022ac:	18 98       	mov	r8,r12
800022ae:	ef 68 ff fb 	st.b	r7[-5],r8
		flashc_error_status |= error_status;
800022b2:	48 88       	lddpc	r8,800022d0 <flashc_erase_page+0x60>
800022b4:	70 09       	ld.w	r9,r8[0x0]
800022b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800022ba:	10 49       	or	r9,r8
800022bc:	48 58       	lddpc	r8,800022d0 <flashc_erase_page+0x60>
800022be:	91 09       	st.w	r8[0x0],r9
	}
	return page_erased;
800022c0:	ef 38 ff fb 	ld.ub	r8,r7[-5]
}
800022c4:	10 9c       	mov	r12,r8
800022c6:	2f cd       	sub	sp,-16
800022c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	21 88       	sub	r8,24
800022d0:	00 00       	add	r0,r0
800022d2:	00 e8       	st.h	--r0,r8
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	22 44       	sub	r4,36

800022d8 <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
800022d8:	eb cd 40 80 	pushm	r7,lr
800022dc:	1a 97       	mov	r7,sp
800022de:	20 1d       	sub	sp,4
800022e0:	ef 4c ff fc 	st.w	r7[-4],r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
800022e4:	ee fb ff fc 	ld.w	r11,r7[-4]
800022e8:	30 1c       	mov	r12,1
800022ea:	f0 1f 00 03 	mcall	800022f4 <flashc_write_page+0x1c>
}
800022ee:	2f fd       	sub	sp,-4
800022f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	21 88       	sub	r8,24

800022f8 <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
800022f8:	eb cd 40 80 	pushm	r7,lr
800022fc:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
800022fe:	3f fb       	mov	r11,-1
80002300:	30 fc       	mov	r12,15
80002302:	f0 1f 00 05 	mcall	80002314 <flashc_quick_user_page_read+0x1c>
	return flashc_is_page_erased();
80002306:	f0 1f 00 05 	mcall	80002318 <flashc_quick_user_page_read+0x20>
8000230a:	18 98       	mov	r8,r12
}
8000230c:	10 9c       	mov	r12,r8
8000230e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002312:	00 00       	add	r0,r0
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	21 88       	sub	r8,24
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	22 28       	sub	r8,34

8000231c <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
8000231c:	eb cd 40 80 	pushm	r7,lr
80002320:	1a 97       	mov	r7,sp
80002322:	20 1d       	sub	sp,4
80002324:	18 98       	mov	r8,r12
80002326:	ef 68 ff fc 	st.b	r7[-4],r8
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
8000232a:	3f fb       	mov	r11,-1
8000232c:	30 ec       	mov	r12,14
8000232e:	f0 1f 00 09 	mcall	80002350 <flashc_erase_user_page+0x34>
	return (check) ? flashc_quick_user_page_read() : true;
80002332:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80002336:	30 08       	mov	r8,0
80002338:	f0 09 18 00 	cp.b	r9,r8
8000233c:	c0 50       	breq	80002346 <flashc_erase_user_page+0x2a>
8000233e:	f0 1f 00 06 	mcall	80002354 <flashc_erase_user_page+0x38>
80002342:	18 98       	mov	r8,r12
80002344:	c0 28       	rjmp	80002348 <flashc_erase_user_page+0x2c>
80002346:	30 18       	mov	r8,1
}
80002348:	10 9c       	mov	r12,r8
8000234a:	2f fd       	sub	sp,-4
8000234c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	21 88       	sub	r8,24
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	22 f8       	sub	r8,47

80002358 <flashc_write_user_page>:


void flashc_write_user_page(void)
{
80002358:	eb cd 40 80 	pushm	r7,lr
8000235c:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
8000235e:	3f fb       	mov	r11,-1
80002360:	30 dc       	mov	r12,13
80002362:	f0 1f 00 03 	mcall	8000236c <flashc_write_user_page+0x14>
}
80002366:	e3 cd 80 80 	ldm	sp++,r7,pc
8000236a:	00 00       	add	r0,r0
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	21 88       	sub	r8,24

80002370 <flashc_memset8>:


volatile void *flashc_memset8(volatile void *dst, uint8_t src, size_t nbytes, bool erase)
{
80002370:	eb cd 40 80 	pushm	r7,lr
80002374:	1a 97       	mov	r7,sp
80002376:	20 4d       	sub	sp,16
80002378:	ef 4c ff fc 	st.w	r7[-4],r12
8000237c:	ef 4a ff f4 	st.w	r7[-12],r10
80002380:	12 98       	mov	r8,r9
80002382:	16 99       	mov	r9,r11
80002384:	ef 69 ff f8 	st.b	r7[-8],r9
80002388:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset16(dst, src | (uint16_t)src << 8, nbytes, erase);
8000238c:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80002390:	ef 3a ff f8 	ld.ub	r10,r7[-8]
80002394:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80002398:	a9 68       	lsl	r8,0x8
8000239a:	5c 88       	casts.h	r8
8000239c:	f5 e8 10 08 	or	r8,r10,r8
800023a0:	5c 88       	casts.h	r8
800023a2:	5c 78       	castu.h	r8
800023a4:	ee fa ff f4 	ld.w	r10,r7[-12]
800023a8:	10 9b       	mov	r11,r8
800023aa:	ee fc ff fc 	ld.w	r12,r7[-4]
800023ae:	f0 1f 00 04 	mcall	800023bc <flashc_memset8+0x4c>
800023b2:	18 98       	mov	r8,r12
}
800023b4:	10 9c       	mov	r12,r8
800023b6:	2f cd       	sub	sp,-16
800023b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	23 c0       	sub	r0,60

800023c0 <flashc_memset16>:


volatile void *flashc_memset16(volatile void *dst, uint16_t src, size_t nbytes, bool erase)
{
800023c0:	eb cd 40 80 	pushm	r7,lr
800023c4:	1a 97       	mov	r7,sp
800023c6:	20 4d       	sub	sp,16
800023c8:	ef 4c ff fc 	st.w	r7[-4],r12
800023cc:	ef 4a ff f4 	st.w	r7[-12],r10
800023d0:	12 98       	mov	r8,r9
800023d2:	16 99       	mov	r9,r11
800023d4:	ef 59 ff f8 	st.h	r7[-8],r9
800023d8:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset32(dst, src | (uint32_t)src << 16, nbytes, erase);
800023dc:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800023e0:	ef 1a ff f8 	ld.uh	r10,r7[-8]
800023e4:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800023e8:	b1 68       	lsl	r8,0x10
800023ea:	f5 e8 10 08 	or	r8,r10,r8
800023ee:	ee fa ff f4 	ld.w	r10,r7[-12]
800023f2:	10 9b       	mov	r11,r8
800023f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800023f8:	f0 1f 00 04 	mcall	80002408 <flashc_memset16+0x48>
800023fc:	18 98       	mov	r8,r12
}
800023fe:	10 9c       	mov	r12,r8
80002400:	2f cd       	sub	sp,-16
80002402:	e3 cd 80 80 	ldm	sp++,r7,pc
80002406:	00 00       	add	r0,r0
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	24 0c       	sub	r12,64

8000240c <flashc_memset32>:


volatile void *flashc_memset32(volatile void *dst, uint32_t src, size_t nbytes, bool erase)
{
8000240c:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002410:	1a 97       	mov	r7,sp
80002412:	20 6d       	sub	sp,24
80002414:	ef 4c ff fc 	st.w	r7[-4],r12
80002418:	ef 4b ff f8 	st.w	r7[-8],r11
8000241c:	ef 4a ff f4 	st.w	r7[-12],r10
80002420:	12 98       	mov	r8,r9
80002422:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
80002426:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000242a:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000242e:	30 01       	mov	r1,0
80002430:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002434:	ef 49 ff ec 	st.w	r7[-20],r9
80002438:	30 09       	mov	r9,0
8000243a:	ef 49 ff e8 	st.w	r7[-24],r9
8000243e:	ee f3 ff ec 	ld.w	r3,r7[-20]
80002442:	a1 63       	lsl	r3,0x0
80002444:	30 02       	mov	r2,0
80002446:	e1 e2 10 0a 	or	r10,r0,r2
8000244a:	e3 e3 10 0b 	or	r11,r1,r3
8000244e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002452:	ee fc ff fc 	ld.w	r12,r7[-4]
80002456:	f0 1f 00 04 	mcall	80002464 <flashc_memset32+0x58>
8000245a:	18 98       	mov	r8,r12
}
8000245c:	10 9c       	mov	r12,r8
8000245e:	2f ad       	sub	sp,-24
80002460:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	24 68       	sub	r8,70

80002468 <flashc_memset64>:


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
80002468:	eb cd 40 80 	pushm	r7,lr
8000246c:	1a 97       	mov	r7,sp
8000246e:	21 bd       	sub	sp,108
80002470:	ef 4c ff a4 	st.w	r7[-92],r12
80002474:	ee eb ff 9c 	st.d	r7[-100],r10
80002478:	ef 49 ff 98 	st.w	r7[-104],r9
8000247c:	ef 68 ff 94 	st.b	r7[-108],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
80002480:	30 08       	mov	r8,0
80002482:	30 09       	mov	r9,0
80002484:	ee e9 ff d8 	st.d	r7[-40],r8
	StructCVPtr dest_end;
	UnionCVPtr flash_page_source_end;
	bool incomplete_flash_page_end;
	Union64 flash_dword;
	UnionVPtr tmp;
	unsigned int error_status = 0;
80002488:	30 08       	mov	r8,0
8000248a:	ef 48 ff ec 	st.w	r7[-20],r8
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
8000248e:	f0 1f 00 fc 	mcall	8000287c <flashc_memset64+0x414>
80002492:	18 99       	mov	r9,r12
80002494:	30 08       	mov	r8,0
80002496:	ea 18 80 00 	orh	r8,0x8000
8000249a:	f2 08 00 08 	add	r8,r9,r8
8000249e:	ef 48 ff e4 	st.w	r7[-28],r8
	dest.u8ptr = dst;
800024a2:	ee f8 ff a4 	ld.w	r8,r7[-92]
800024a6:	ef 48 ff e0 	st.w	r7[-32],r8
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800024aa:	ee f8 ff e0 	ld.w	r8,r7[-32]
800024ae:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800024b2:	20 18       	sub	r8,1
800024b4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800024b8:	ef 48 ff f0 	st.w	r7[-16],r8
800024bc:	c1 f8       	rjmp	800024fa <flashc_memset64+0x92>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
800024be:	ee f9 ff f0 	ld.w	r9,r7[-16]
800024c2:	ef 38 ff a3 	ld.ub	r8,r7[-93]
800024c6:	ee 09 00 09 	add	r9,r7,r9
800024ca:	f3 68 ff d8 	st.b	r9[-40],r8
		src >>= 8;
800024ce:	ee f8 ff 9c 	ld.w	r8,r7[-100]
800024d2:	b9 68       	lsl	r8,0x18
800024d4:	ee f9 ff a0 	ld.w	r9,r7[-96]
800024d8:	a9 89       	lsr	r9,0x8
800024da:	f3 e8 10 08 	or	r8,r9,r8
800024de:	ef 48 ff a0 	st.w	r7[-96],r8
800024e2:	ee f8 ff 9c 	ld.w	r8,r7[-100]
800024e6:	a9 88       	lsr	r8,0x8
800024e8:	ef 48 ff 9c 	st.w	r7[-100],r8

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
800024ec:	ee f8 ff f0 	ld.w	r8,r7[-16]
800024f0:	20 18       	sub	r8,1
800024f2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800024f6:	ef 48 ff f0 	st.w	r7[-16],r8
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800024fa:	ee e8 ff 9c 	ld.d	r8,r7[-100]
800024fe:	58 08       	cp.w	r8,0
80002500:	5c 29       	cpc	r9
80002502:	cd e1       	brne	800024be <flashc_memset64+0x56>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
80002504:	ee f9 ff e0 	ld.w	r9,r7[-32]
80002508:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000250c:	f2 08 00 08 	add	r8,r9,r8
80002510:	ef 48 ff d4 	st.w	r7[-44],r8

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80002514:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002518:	e0 69 ff ff 	mov	r9,65535
8000251c:	ea 19 7f ff 	orh	r9,0x7fff
80002520:	12 38       	cp.w	r8,r9
80002522:	e0 8b 00 08 	brhi	80002532 <flashc_memset64+0xca>
		dest.u8ptr = AVR32_FLASH;
80002526:	30 08       	mov	r8,0
80002528:	ea 18 80 00 	orh	r8,0x8000
8000252c:	ef 48 ff e0 	st.w	r7[-32],r8
80002530:	c1 68       	rjmp	8000255c <flashc_memset64+0xf4>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
80002532:	ee f9 ff e4 	ld.w	r9,r7[-28]
80002536:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000253a:	10 39       	cp.w	r9,r8
8000253c:	e0 8b 00 10 	brhi	8000255c <flashc_memset64+0xf4>
80002540:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002544:	e0 69 ff ff 	mov	r9,65535
80002548:	ea 19 80 7f 	orh	r9,0x807f
8000254c:	12 38       	cp.w	r8,r9
8000254e:	e0 8b 00 07 	brhi	8000255c <flashc_memset64+0xf4>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80002552:	30 08       	mov	r8,0
80002554:	ea 18 80 80 	orh	r8,0x8080
80002558:	ef 48 ff e0 	st.w	r7[-32],r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
8000255c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002560:	e0 69 02 00 	mov	r9,512
80002564:	ea 19 80 80 	orh	r9,0x8080
80002568:	12 38       	cp.w	r8,r9
8000256a:	e0 88 00 09 	brls	8000257c <flashc_memset64+0x114>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
8000256e:	e0 68 02 00 	mov	r8,512
80002572:	ea 18 80 80 	orh	r8,0x8080
80002576:	ef 48 ff d4 	st.w	r7[-44],r8
8000257a:	c1 48       	rjmp	800025a2 <flashc_memset64+0x13a>
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
8000257c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002580:	30 09       	mov	r9,0
80002582:	ea 19 80 80 	orh	r9,0x8080
80002586:	12 38       	cp.w	r8,r9
80002588:	e0 8b 00 0d 	brhi	800025a2 <flashc_memset64+0x13a>
8000258c:	ee f9 ff d4 	ld.w	r9,r7[-44]
80002590:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002594:	10 39       	cp.w	r9,r8
80002596:	e0 88 00 06 	brls	800025a2 <flashc_memset64+0x13a>
		dest_end.u8ptr = flash_array_end.u8ptr;
8000259a:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000259e:	ef 48 ff d4 	st.w	r7[-44],r8
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
800025a2:	ee f8 ff d4 	ld.w	r8,r7[-44]
800025a6:	a1 c8       	cbr	r8,0x0
800025a8:	ef 48 ff cc 	st.w	r7[-52],r8
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
800025ac:	ee f8 ff cc 	ld.w	r8,r7[-52]
800025b0:	e0 18 ff fc 	andl	r8,0xfffc
800025b4:	ef 48 ff c4 	st.w	r7[-60],r8
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
800025b8:	ee f8 ff c4 	ld.w	r8,r7[-60]
800025bc:	e0 18 ff f8 	andl	r8,0xfff8
800025c0:	ef 48 ff bc 	st.w	r7[-68],r8

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800025c4:	c4 a9       	rjmp	80002858 <flashc_memset64+0x3f0>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800025c6:	f0 1f 00 af 	mcall	80002880 <flashc_memset64+0x418>
		error_status |= flashc_error_status;
800025ca:	fe f8 02 ba 	ld.w	r8,pc[698]
800025ce:	70 08       	ld.w	r8,r8[0x0]
800025d0:	ee f9 ff ec 	ld.w	r9,r7[-20]
800025d4:	f3 e8 10 08 	or	r8,r9,r8
800025d8:	ef 48 ff ec 	st.w	r7[-20],r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800025dc:	ee f8 ff bc 	ld.w	r8,r7[-68]
800025e0:	ef 48 ff f8 	st.w	r7[-8],r8
800025e4:	ee f8 ff e0 	ld.w	r8,r7[-32]
800025e8:	e0 18 fe 00 	andl	r8,0xfe00
800025ec:	f0 c8 fe 00 	sub	r8,r8,-512
800025f0:	ef 48 ff fc 	st.w	r7[-4],r8
800025f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800025f8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800025fc:	f0 09 0d 48 	min	r8,r8,r9
80002600:	ef 48 ff f4 	st.w	r7[-12],r8
80002604:	ee f8 ff f4 	ld.w	r8,r7[-12]
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
80002608:	ef 48 ff b4 	st.w	r7[-76],r8
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
				Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);

		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
8000260c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002610:	10 99       	mov	r9,r8
80002612:	e0 19 fe 00 	andl	r9,0xfe00
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
80002616:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000261a:	e0 18 fe 00 	andl	r8,0xfe00
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
				Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);

		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
8000261e:	10 39       	cp.w	r9,r8
80002620:	5f 28       	srhs	r8
80002622:	ef 68 ff eb 	st.b	r7[-21],r8
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80002626:	ee e8 ff d8 	ld.d	r8,r7[-40]
8000262a:	ee e9 ff ac 	st.d	r7[-84],r8

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
8000262e:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002632:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80002636:	c5 b0       	breq	800026ec <flashc_memset64+0x284>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
80002638:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000263c:	e0 18 fe 00 	andl	r8,0xfe00
80002640:	ef 48 ff a8 	st.w	r7[-88],r8
80002644:	c0 e8       	rjmp	80002660 <flashc_memset64+0x1f8>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
80002646:	ee fa ff a8 	ld.w	r10,r7[-88]
8000264a:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000264e:	f0 e8 00 00 	ld.d	r8,r8[0]
80002652:	f4 e9 00 00 	st.d	r10[0],r8
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
80002656:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000265a:	2f 88       	sub	r8,-8
8000265c:	ef 48 ff a8 	st.w	r7[-88],r8
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
80002660:	ee f9 ff a8 	ld.w	r9,r7[-88]
80002664:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002668:	e0 18 ff f8 	andl	r8,0xfff8
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
8000266c:	10 39       	cp.w	r9,r8
8000266e:	ce c3       	brcs	80002646 <flashc_memset64+0x1de>
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
80002670:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002674:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002678:	c3 a0       	breq	800026ec <flashc_memset64+0x284>
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
8000267a:	30 08       	mov	r8,0
8000267c:	ef 48 ff f0 	st.w	r7[-16],r8
80002680:	c1 38       	rjmp	800026a6 <flashc_memset64+0x23e>
					flash_dword.u8[i] = *tmp.u8ptr++;
80002682:	ee fa ff f0 	ld.w	r10,r7[-16]
80002686:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000268a:	11 89       	ld.ub	r9,r8[0x0]
8000268c:	5c 59       	castu.b	r9
8000268e:	ee 0a 00 0a 	add	r10,r7,r10
80002692:	f5 69 ff ac 	st.b	r10[-84],r9
80002696:	2f f8       	sub	r8,-1
80002698:	ef 48 ff a8 	st.w	r7[-88],r8
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
8000269c:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026a0:	2f f8       	sub	r8,-1
800026a2:	ef 48 ff f0 	st.w	r7[-16],r8
800026a6:	ee f8 ff e0 	ld.w	r8,r7[-32]
800026aa:	f3 d8 c0 03 	bfextu	r9,r8,0x0,0x3
800026ae:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026b2:	10 39       	cp.w	r9,r8
800026b4:	fe 9b ff e7 	brhi	80002682 <flashc_memset64+0x21a>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800026b8:	ee f8 ff e0 	ld.w	r8,r7[-32]
800026bc:	e0 18 ff f8 	andl	r8,0xfff8
800026c0:	ef 48 ff e0 	st.w	r7[-32],r8

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
800026c4:	ee f9 ff e0 	ld.w	r9,r7[-32]
800026c8:	ee f8 ff bc 	ld.w	r8,r7[-68]
800026cc:	10 39       	cp.w	r9,r8
800026ce:	c0 f2       	brcc	800026ec <flashc_memset64+0x284>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
800026d0:	ee fa ff e0 	ld.w	r10,r7[-32]
800026d4:	ee e8 ff ac 	ld.d	r8,r7[-84]
800026d8:	f4 e9 00 00 	st.d	r10[0],r8
800026dc:	f4 c8 ff f8 	sub	r8,r10,-8
800026e0:	ef 48 ff e0 	st.w	r7[-32],r8
					flash_dword.u64 = source.u64;
800026e4:	ee e8 ff d8 	ld.d	r8,r7[-40]
800026e8:	ee e9 ff ac 	st.d	r7[-84],r8
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
800026ec:	ee f8 ff b4 	ld.w	r8,r7[-76]
800026f0:	10 99       	mov	r9,r8
800026f2:	ee f8 ff e0 	ld.w	r8,r7[-32]
800026f6:	f2 08 01 08 	sub	r8,r9,r8
800026fa:	a3 58       	asr	r8,0x3
800026fc:	ef 48 ff f0 	st.w	r7[-16],r8
80002700:	c1 08       	rjmp	80002720 <flashc_memset64+0x2b8>
			*dest.u64ptr++ = source.u64;
80002702:	ee fa ff e0 	ld.w	r10,r7[-32]
80002706:	ee e8 ff d8 	ld.d	r8,r7[-40]
8000270a:	f4 e9 00 00 	st.d	r10[0],r8
8000270e:	f4 c8 ff f8 	sub	r8,r10,-8
80002712:	ef 48 ff e0 	st.w	r7[-32],r8
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80002716:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000271a:	20 18       	sub	r8,1
8000271c:	ef 48 ff f0 	st.w	r7[-16],r8
80002720:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002724:	58 08       	cp.w	r8,0
80002726:	ce e1       	brne	80002702 <flashc_memset64+0x29a>
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80002728:	ef 39 ff eb 	ld.ub	r9,r7[-21]
8000272c:	30 08       	mov	r8,0
8000272e:	f0 09 18 00 	cp.b	r9,r8
80002732:	c4 70       	breq	800027c0 <flashc_memset64+0x358>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
80002734:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002738:	ef 48 ff a8 	st.w	r7[-88],r8

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
8000273c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002740:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002744:	c3 80       	breq	800027b4 <flashc_memset64+0x34c>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80002746:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000274a:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000274e:	ef 48 ff f0 	st.w	r7[-16],r8
80002752:	c1 38       	rjmp	80002778 <flashc_memset64+0x310>
						flash_dword.u8[i] = *tmp.u8ptr++;
80002754:	ee fa ff f0 	ld.w	r10,r7[-16]
80002758:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000275c:	11 89       	ld.ub	r9,r8[0x0]
8000275e:	5c 59       	castu.b	r9
80002760:	ee 0a 00 0a 	add	r10,r7,r10
80002764:	f5 69 ff ac 	st.b	r10[-84],r9
80002768:	2f f8       	sub	r8,-1
8000276a:	ef 48 ff a8 	st.w	r7[-88],r8
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000276e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002772:	2f f8       	sub	r8,-1
80002774:	ef 48 ff f0 	st.w	r7[-16],r8
80002778:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000277c:	58 78       	cp.w	r8,7
8000277e:	fe 98 ff eb 	brls	80002754 <flashc_memset64+0x2ec>
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80002782:	ee fa ff e0 	ld.w	r10,r7[-32]
80002786:	ee e8 ff ac 	ld.d	r8,r7[-84]
8000278a:	f4 e9 00 00 	st.d	r10[0],r8
8000278e:	f4 c8 ff f8 	sub	r8,r10,-8
80002792:	ef 48 ff e0 	st.w	r7[-32],r8
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80002796:	c1 08       	rjmp	800027b6 <flashc_memset64+0x34e>
					*tmp.u64ptr = *tmp.u64ptr;
80002798:	ee fa ff a8 	ld.w	r10,r7[-88]
8000279c:	ee f8 ff a8 	ld.w	r8,r7[-88]
800027a0:	f0 e8 00 00 	ld.d	r8,r8[0]
800027a4:	f4 e9 00 00 	st.d	r10[0],r8
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
800027a8:	ee f8 ff a8 	ld.w	r8,r7[-88]
800027ac:	2f 88       	sub	r8,-8
800027ae:	ef 48 ff a8 	st.w	r7[-88],r8
800027b2:	c0 28       	rjmp	800027b6 <flashc_memset64+0x34e>
800027b4:	d7 03       	nop
800027b6:	ee f8 ff a8 	ld.w	r8,r7[-88]
800027ba:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800027be:	ce d1       	brne	80002798 <flashc_memset64+0x330>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
800027c0:	ee f8 ff e0 	ld.w	r8,r7[-32]
800027c4:	30 09       	mov	r9,0
800027c6:	ea 19 80 80 	orh	r9,0x8080
800027ca:	12 38       	cp.w	r8,r9
800027cc:	e0 8b 00 2b 	brhi	80002822 <flashc_memset64+0x3ba>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
800027d0:	ef 39 ff 94 	ld.ub	r9,r7[-108]
800027d4:	30 08       	mov	r8,0
800027d6:	f0 09 18 00 	cp.b	r9,r8
800027da:	c0 d0       	breq	800027f4 <flashc_memset64+0x38c>
				flashc_erase_page(-1, false);
800027dc:	30 0b       	mov	r11,0
800027de:	3f fc       	mov	r12,-1
800027e0:	f0 1f 00 2a 	mcall	80002888 <flashc_memset64+0x420>
				error_status |= flashc_error_status;
800027e4:	4a 88       	lddpc	r8,80002884 <flashc_memset64+0x41c>
800027e6:	70 08       	ld.w	r8,r8[0x0]
800027e8:	ee f9 ff ec 	ld.w	r9,r7[-20]
800027ec:	f3 e8 10 08 	or	r8,r9,r8
800027f0:	ef 48 ff ec 	st.w	r7[-20],r8
			}
			flashc_write_page(-1);
800027f4:	3f fc       	mov	r12,-1
800027f6:	f0 1f 00 26 	mcall	8000288c <flashc_memset64+0x424>
			error_status |= flashc_error_status;
800027fa:	4a 38       	lddpc	r8,80002884 <flashc_memset64+0x41c>
800027fc:	70 08       	ld.w	r8,r8[0x0]
800027fe:	ee f9 ff ec 	ld.w	r9,r7[-20]
80002802:	f3 e8 10 08 	or	r8,r9,r8
80002806:	ef 48 ff ec 	st.w	r7[-20],r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
8000280a:	ee f9 ff e0 	ld.w	r9,r7[-32]
8000280e:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002812:	10 39       	cp.w	r9,r8
80002814:	c2 23       	brcs	80002858 <flashc_memset64+0x3f0>
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80002816:	30 08       	mov	r8,0
80002818:	ea 18 80 80 	orh	r8,0x8080
8000281c:	ef 48 ff e0 	st.w	r7[-32],r8
80002820:	c1 c8       	rjmp	80002858 <flashc_memset64+0x3f0>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
80002822:	ef 39 ff 94 	ld.ub	r9,r7[-108]
80002826:	30 08       	mov	r8,0
80002828:	f0 09 18 00 	cp.b	r9,r8
8000282c:	c0 c0       	breq	80002844 <flashc_memset64+0x3dc>
				flashc_erase_user_page(false);
8000282e:	30 0c       	mov	r12,0
80002830:	f0 1f 00 18 	mcall	80002890 <flashc_memset64+0x428>
				error_status |= flashc_error_status;
80002834:	49 48       	lddpc	r8,80002884 <flashc_memset64+0x41c>
80002836:	70 08       	ld.w	r8,r8[0x0]
80002838:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000283c:	f3 e8 10 08 	or	r8,r9,r8
80002840:	ef 48 ff ec 	st.w	r7[-20],r8
			}
			flashc_write_user_page();
80002844:	f0 1f 00 14 	mcall	80002894 <flashc_memset64+0x42c>
			error_status |= flashc_error_status;
80002848:	48 f8       	lddpc	r8,80002884 <flashc_memset64+0x41c>
8000284a:	70 08       	ld.w	r8,r8[0x0]
8000284c:	ee f9 ff ec 	ld.w	r9,r7[-20]
80002850:	f3 e8 10 08 	or	r8,r9,r8
80002854:	ef 48 ff ec 	st.w	r7[-20],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
80002858:	ee f9 ff e0 	ld.w	r9,r7[-32]
8000285c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002860:	10 39       	cp.w	r9,r8
80002862:	fe 93 fe b2 	brlo	800025c6 <flashc_memset64+0x15e>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
80002866:	48 88       	lddpc	r8,80002884 <flashc_memset64+0x41c>
80002868:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000286c:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memset function does.
	return dst;
8000286e:	ee f8 ff a4 	ld.w	r8,r7[-92]
}
80002872:	10 9c       	mov	r12,r8
80002874:	2e 5d       	sub	sp,-108
80002876:	e3 cd 80 80 	ldm	sp++,r7,pc
8000287a:	00 00       	add	r0,r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	20 78       	sub	r8,7
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	22 10       	sub	r0,33
80002884:	00 00       	add	r0,r0
80002886:	00 e8       	st.h	--r0,r8
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	22 70       	sub	r0,39
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	22 d8       	sub	r8,45
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	23 1c       	sub	r12,49
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	23 58       	sub	r8,53

80002898 <flashc_memcpy>:


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
80002898:	eb cd 40 80 	pushm	r7,lr
8000289c:	1a 97       	mov	r7,sp
8000289e:	20 bd       	sub	sp,44
800028a0:	ef 4c ff e0 	st.w	r7[-32],r12
800028a4:	ef 4b ff dc 	st.w	r7[-36],r11
800028a8:	ef 4a ff d8 	st.w	r7[-40],r10
800028ac:	12 98       	mov	r8,r9
800028ae:	ef 68 ff d4 	st.b	r7[-44],r8
	uint16_t page_pos;
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
800028b2:	30 08       	mov	r8,0
800028b4:	ef 48 ff f0 	st.w	r7[-16],r8
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
800028b8:	ee f8 ff e0 	ld.w	r8,r7[-32]
800028bc:	ef 48 ff f8 	st.w	r7[-8],r8
	const uint8_t* src_buf=(const uint8_t*)src;
800028c0:	ee f8 ff dc 	ld.w	r8,r7[-36]
800028c4:	ef 48 ff fc 	st.w	r7[-4],r8
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
800028c8:	ee f8 ff e0 	ld.w	r8,r7[-32]
800028cc:	e0 69 ff ff 	mov	r9,65535
800028d0:	ea 19 80 7f 	orh	r9,0x807f
800028d4:	12 38       	cp.w	r8,r9
800028d6:	5f b8       	srhi	r8
800028d8:	ef 68 ff ef 	st.b	r7[-17],r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
800028dc:	ee f9 ff f8 	ld.w	r9,r7[-8]
800028e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028e4:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800028e8:	f2 08 01 08 	sub	r8,r9,r8
800028ec:	ef 48 ff f4 	st.w	r7[-12],r8

	while (nbytes) {
800028f0:	c9 18       	rjmp	80002a12 <flashc_memcpy+0x17a>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800028f2:	f0 1f 00 50 	mcall	80002a30 <flashc_memcpy+0x198>
		error_status |= flashc_error_status;
800028f6:	4d 08       	lddpc	r8,80002a34 <flashc_memcpy+0x19c>
800028f8:	70 08       	ld.w	r8,r8[0x0]
800028fa:	ee f9 ff f0 	ld.w	r9,r7[-16]
800028fe:	f3 e8 10 08 	or	r8,r9,r8
80002902:	ef 48 ff f0 	st.w	r7[-16],r8

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
80002906:	30 08       	mov	r8,0
80002908:	ef 58 ff ec 	st.h	r7[-20],r8
8000290c:	c4 b8       	rjmp	800029a2 <flashc_memcpy+0x10a>
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
8000290e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002912:	f0 e8 00 00 	ld.d	r8,r8[0]
80002916:	ee e9 ff e4 	st.d	r7[-28],r8

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
8000291a:	30 08       	mov	r8,0
8000291c:	ef 68 ff ee 	st.b	r7[-18],r8
80002920:	c2 d8       	rjmp	8000297a <flashc_memcpy+0xe2>
				if (nbytes && (flash_add == dest_add)) {
80002922:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002926:	58 08       	cp.w	r8,0
80002928:	c1 f0       	breq	80002966 <flashc_memcpy+0xce>
8000292a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000292e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002932:	10 39       	cp.w	r9,r8
80002934:	c1 91       	brne	80002966 <flashc_memcpy+0xce>
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80002936:	ef 39 ff ee 	ld.ub	r9,r7[-18]
8000293a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000293e:	11 88       	ld.ub	r8,r8[0x0]
80002940:	ee 09 00 09 	add	r9,r7,r9
80002944:	f3 68 ff e4 	st.b	r9[-28],r8
80002948:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000294c:	2f f8       	sub	r8,-1
8000294e:	ef 48 ff fc 	st.w	r7[-4],r8
					dest_add++;
80002952:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002956:	2f f8       	sub	r8,-1
80002958:	ef 48 ff f8 	st.w	r7[-8],r8
					nbytes--;
8000295c:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002960:	20 18       	sub	r8,1
80002962:	ef 48 ff d8 	st.w	r7[-40],r8
				}
				flash_add++;
80002966:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000296a:	2f f8       	sub	r8,-1
8000296c:	ef 48 ff f4 	st.w	r7[-12],r8
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
80002970:	ef 38 ff ee 	ld.ub	r8,r7[-18]
80002974:	2f f8       	sub	r8,-1
80002976:	ef 68 ff ee 	st.b	r7[-18],r8
8000297a:	ef 39 ff ee 	ld.ub	r9,r7[-18]
8000297e:	30 78       	mov	r8,7
80002980:	f0 09 18 00 	cp.b	r9,r8
80002984:	fe 98 ff cf 	brls	80002922 <flashc_memcpy+0x8a>
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
80002988:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000298c:	20 88       	sub	r8,8
8000298e:	10 9a       	mov	r10,r8
80002990:	ee e8 ff e4 	ld.d	r8,r7[-28]
80002994:	f4 e9 00 00 	st.d	r10[0],r8
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
80002998:	ef 08 ff ec 	ld.sh	r8,r7[-20]
8000299c:	2f 88       	sub	r8,-8
8000299e:	ef 58 ff ec 	st.h	r7[-20],r8
800029a2:	ef 09 ff ec 	ld.sh	r9,r7[-20]
800029a6:	e0 68 01 ff 	mov	r8,511
800029aa:	f0 09 19 00 	cp.h	r9,r8
800029ae:	fe 98 ff b0 	brls	8000290e <flashc_memcpy+0x76>
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
800029b2:	ef 39 ff d4 	ld.ub	r9,r7[-44]
800029b6:	30 08       	mov	r8,0
800029b8:	f0 09 18 00 	cp.b	r9,r8
800029bc:	c1 70       	breq	800029ea <flashc_memcpy+0x152>
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
800029be:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800029c2:	30 08       	mov	r8,0
800029c4:	f0 09 18 00 	cp.b	r9,r8
800029c8:	c0 50       	breq	800029d2 <flashc_memcpy+0x13a>
800029ca:	30 0c       	mov	r12,0
800029cc:	f0 1f 00 1b 	mcall	80002a38 <flashc_memcpy+0x1a0>
800029d0:	c0 58       	rjmp	800029da <flashc_memcpy+0x142>
800029d2:	30 0b       	mov	r11,0
800029d4:	3f fc       	mov	r12,-1
800029d6:	f0 1f 00 1a 	mcall	80002a3c <flashc_memcpy+0x1a4>
			error_status |= flashc_error_status;
800029da:	49 78       	lddpc	r8,80002a34 <flashc_memcpy+0x19c>
800029dc:	70 08       	ld.w	r8,r8[0x0]
800029de:	ee f9 ff f0 	ld.w	r9,r7[-16]
800029e2:	f3 e8 10 08 	or	r8,r9,r8
800029e6:	ef 48 ff f0 	st.w	r7[-16],r8
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
800029ea:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800029ee:	30 08       	mov	r8,0
800029f0:	f0 09 18 00 	cp.b	r9,r8
800029f4:	c0 40       	breq	800029fc <flashc_memcpy+0x164>
800029f6:	f0 1f 00 13 	mcall	80002a40 <flashc_memcpy+0x1a8>
800029fa:	c0 48       	rjmp	80002a02 <flashc_memcpy+0x16a>
800029fc:	3f fc       	mov	r12,-1
800029fe:	f0 1f 00 12 	mcall	80002a44 <flashc_memcpy+0x1ac>
		error_status |= flashc_error_status;
80002a02:	48 d8       	lddpc	r8,80002a34 <flashc_memcpy+0x19c>
80002a04:	70 08       	ld.w	r8,r8[0x0]
80002a06:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002a0a:	f3 e8 10 08 	or	r8,r9,r8
80002a0e:	ef 48 ff f0 	st.w	r7[-16],r8

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
80002a12:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a16:	58 08       	cp.w	r8,0
80002a18:	fe 91 ff 6d 	brne	800028f2 <flashc_memcpy+0x5a>
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
80002a1c:	48 68       	lddpc	r8,80002a34 <flashc_memcpy+0x19c>
80002a1e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002a22:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
80002a24:	ee f8 ff e0 	ld.w	r8,r7[-32]
}
80002a28:	10 9c       	mov	r12,r8
80002a2a:	2f 5d       	sub	sp,-44
80002a2c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	22 10       	sub	r0,33
80002a34:	00 00       	add	r0,r0
80002a36:	00 e8       	st.h	--r0,r8
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	23 1c       	sub	r12,49
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	22 70       	sub	r0,39
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	23 58       	sub	r8,53
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	22 d8       	sub	r8,45

80002a48 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002a48:	eb cd 40 80 	pushm	r7,lr
80002a4c:	1a 97       	mov	r7,sp
80002a4e:	20 4d       	sub	sp,16
80002a50:	ef 4c ff f4 	st.w	r7[-12],r12
80002a54:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80002a58:	30 08       	mov	r8,0
80002a5a:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80002a5e:	30 08       	mov	r8,0
80002a60:	ef 48 ff fc 	st.w	r7[-4],r8
80002a64:	c1 c8       	rjmp	80002a9c <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002a66:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a6a:	70 19       	ld.w	r9,r8[0x4]
80002a6c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a70:	70 08       	ld.w	r8,r8[0x0]
80002a72:	12 9b       	mov	r11,r9
80002a74:	10 9c       	mov	r12,r8
80002a76:	f0 1f 00 10 	mcall	80002ab4 <gpio_enable_module+0x6c>
80002a7a:	18 98       	mov	r8,r12
80002a7c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002a80:	f3 e8 10 08 	or	r8,r9,r8
80002a84:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80002a88:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a8c:	2f 88       	sub	r8,-8
80002a8e:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002a92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a96:	2f f8       	sub	r8,-1
80002a98:	ef 48 ff fc 	st.w	r7[-4],r8
80002a9c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002aa0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002aa4:	10 39       	cp.w	r9,r8
80002aa6:	ce 03       	brcs	80002a66 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
80002aa8:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80002aac:	10 9c       	mov	r12,r8
80002aae:	2f cd       	sub	sp,-16
80002ab0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	2a b8       	sub	r8,-85

80002ab8 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
80002ab8:	eb cd 40 80 	pushm	r7,lr
80002abc:	1a 97       	mov	r7,sp
80002abe:	20 3d       	sub	sp,12
80002ac0:	ef 4c ff f8 	st.w	r7[-8],r12
80002ac4:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002ac8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002acc:	a5 98       	lsr	r8,0x5
80002ace:	a9 68       	lsl	r8,0x8
80002ad0:	e0 28 f0 00 	sub	r8,61440
80002ad4:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
80002ad8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002adc:	58 18       	cp.w	r8,1
80002ade:	c1 e0       	breq	80002b1a <gpio_enable_module_pin+0x62>
80002ae0:	c0 63       	brcs	80002aec <gpio_enable_module_pin+0x34>
80002ae2:	58 28       	cp.w	r8,2
80002ae4:	c3 20       	breq	80002b48 <gpio_enable_module_pin+0x90>
80002ae6:	58 38       	cp.w	r8,3
80002ae8:	c4 70       	breq	80002b76 <gpio_enable_module_pin+0xbe>
80002aea:	c5 d8       	rjmp	80002ba4 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002aec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002af0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002af4:	30 19       	mov	r9,1
80002af6:	f2 08 09 48 	lsl	r8,r9,r8
80002afa:	10 99       	mov	r9,r8
80002afc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b00:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002b02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b06:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b0a:	30 19       	mov	r9,1
80002b0c:	f2 08 09 48 	lsl	r8,r9,r8
80002b10:	10 99       	mov	r9,r8
80002b12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b16:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b18:	c4 88       	rjmp	80002ba8 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002b1a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b1e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b22:	30 19       	mov	r9,1
80002b24:	f2 08 09 48 	lsl	r8,r9,r8
80002b28:	10 99       	mov	r9,r8
80002b2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b2e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002b30:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b34:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b38:	30 19       	mov	r9,1
80002b3a:	f2 08 09 48 	lsl	r8,r9,r8
80002b3e:	10 99       	mov	r9,r8
80002b40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b44:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b46:	c3 18       	rjmp	80002ba8 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002b48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b4c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b50:	30 19       	mov	r9,1
80002b52:	f2 08 09 48 	lsl	r8,r9,r8
80002b56:	10 99       	mov	r9,r8
80002b58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b5c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002b5e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b62:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b66:	30 19       	mov	r9,1
80002b68:	f2 08 09 48 	lsl	r8,r9,r8
80002b6c:	10 99       	mov	r9,r8
80002b6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b72:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b74:	c1 a8       	rjmp	80002ba8 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002b76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b7e:	30 19       	mov	r9,1
80002b80:	f2 08 09 48 	lsl	r8,r9,r8
80002b84:	10 99       	mov	r9,r8
80002b86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b8a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002b8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b90:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b94:	30 19       	mov	r9,1
80002b96:	f2 08 09 48 	lsl	r8,r9,r8
80002b9a:	10 99       	mov	r9,r8
80002b9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ba0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002ba2:	c0 38       	rjmp	80002ba8 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
80002ba4:	30 18       	mov	r8,1
80002ba6:	c0 d8       	rjmp	80002bc0 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002ba8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bac:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002bb0:	30 19       	mov	r9,1
80002bb2:	f2 08 09 48 	lsl	r8,r9,r8
80002bb6:	10 99       	mov	r9,r8
80002bb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bbc:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
80002bbe:	30 08       	mov	r8,0
}
80002bc0:	10 9c       	mov	r12,r8
80002bc2:	2f dd       	sub	sp,-12
80002bc4:	e3 cd 80 80 	ldm	sp++,r7,pc

80002bc8 <gpio_configure_pin>:
 *
 * \param pin The pin number.
 * \param flags The configuration.
 */
void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
80002bc8:	eb cd 40 80 	pushm	r7,lr
80002bcc:	1a 97       	mov	r7,sp
80002bce:	20 3d       	sub	sp,12
80002bd0:	ef 4c ff f8 	st.w	r7[-8],r12
80002bd4:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002bd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bdc:	a5 98       	lsr	r8,0x5
80002bde:	a9 68       	lsl	r8,0x8
80002be0:	e0 28 f0 00 	sub	r8,61440
80002be4:	ef 48 ff fc 	st.w	r7[-4],r8
	} else {
		gpio_port->pderc = 1 << (pin & 0x1F);
	}

#endif
	if (flags & GPIO_PULL_UP) {
80002be8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002bec:	e2 18 00 04 	andl	r8,0x4,COH
80002bf0:	c0 e0       	breq	80002c0c <gpio_configure_pin+0x44>
		gpio_port->puers = 1 << (pin & 0x1F);
80002bf2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bf6:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002bfa:	30 19       	mov	r9,1
80002bfc:	f2 08 09 48 	lsl	r8,r9,r8
80002c00:	10 99       	mov	r9,r8
80002c02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c06:	f1 49 00 74 	st.w	r8[116],r9
80002c0a:	c0 d8       	rjmp	80002c24 <gpio_configure_pin+0x5c>
	} else {
		gpio_port->puerc = 1 << (pin & 0x1F);
80002c0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c10:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c14:	30 19       	mov	r9,1
80002c16:	f2 08 09 48 	lsl	r8,r9,r8
80002c1a:	10 99       	mov	r9,r8
80002c1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c20:	f1 49 00 78 	st.w	r8[120],r9
	}

#endif

	/* Select interrupt level for group */
	if (flags & GPIO_INTERRUPT) {
80002c24:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c28:	e2 18 00 80 	andl	r8,0x80,COH
80002c2c:	c5 a0       	breq	80002ce0 <gpio_configure_pin+0x118>
		if (flags & GPIO_BOTHEDGES) {
80002c2e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c32:	e2 18 01 80 	andl	r8,0x180,COH
80002c36:	c1 a0       	breq	80002c6a <gpio_configure_pin+0xa2>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80002c38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c3c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c40:	30 19       	mov	r9,1
80002c42:	f2 08 09 48 	lsl	r8,r9,r8
80002c46:	10 99       	mov	r9,r8
80002c48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c4c:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
80002c50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c54:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c58:	30 19       	mov	r9,1
80002c5a:	f2 08 09 48 	lsl	r8,r9,r8
80002c5e:	10 99       	mov	r9,r8
80002c60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c64:	f1 49 00 b8 	st.w	r8[184],r9
80002c68:	c3 c8       	rjmp	80002ce0 <gpio_configure_pin+0x118>
		} else if (flags & GPIO_RISING) {
80002c6a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c6e:	e2 18 02 80 	andl	r8,0x280,COH
80002c72:	c1 a0       	breq	80002ca6 <gpio_configure_pin+0xde>
			gpio_port->imr0s = 1 << (pin & 0x1F);
80002c74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c78:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c7c:	30 19       	mov	r9,1
80002c7e:	f2 08 09 48 	lsl	r8,r9,r8
80002c82:	10 99       	mov	r9,r8
80002c84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c88:	f1 49 00 a4 	st.w	r8[164],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
80002c8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c90:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c94:	30 19       	mov	r9,1
80002c96:	f2 08 09 48 	lsl	r8,r9,r8
80002c9a:	10 99       	mov	r9,r8
80002c9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ca0:	f1 49 00 b8 	st.w	r8[184],r9
80002ca4:	c1 e8       	rjmp	80002ce0 <gpio_configure_pin+0x118>
		} else if (flags & GPIO_FALLING) {
80002ca6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002caa:	e2 18 03 80 	andl	r8,0x380,COH
80002cae:	c1 90       	breq	80002ce0 <gpio_configure_pin+0x118>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80002cb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cb4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002cb8:	30 19       	mov	r9,1
80002cba:	f2 08 09 48 	lsl	r8,r9,r8
80002cbe:	10 99       	mov	r9,r8
80002cc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cc4:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1s = 1 << (pin & 0x1F);
80002cc8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ccc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002cd0:	30 19       	mov	r9,1
80002cd2:	f2 08 09 48 	lsl	r8,r9,r8
80002cd6:	10 99       	mov	r9,r8
80002cd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cdc:	f1 49 00 b4 	st.w	r8[180],r9
		}
	}

	/* Select direction and initial pin state */
	if (flags & GPIO_DIR_OUTPUT) {
80002ce0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ce4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002ce8:	5c 58       	castu.b	r8
80002cea:	c2 c0       	breq	80002d42 <gpio_configure_pin+0x17a>
		if (flags & GPIO_INIT_HIGH) {
80002cec:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002cf0:	e2 18 00 02 	andl	r8,0x2,COH
80002cf4:	c0 e0       	breq	80002d10 <gpio_configure_pin+0x148>
			gpio_port->ovrs = 1 << (pin & 0x1F);
80002cf6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cfa:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002cfe:	30 19       	mov	r9,1
80002d00:	f2 08 09 48 	lsl	r8,r9,r8
80002d04:	10 99       	mov	r9,r8
80002d06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d0a:	f1 49 00 54 	st.w	r8[84],r9
80002d0e:	c0 d8       	rjmp	80002d28 <gpio_configure_pin+0x160>
		} else {
			gpio_port->ovrc = 1 << (pin & 0x1F);
80002d10:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d14:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002d18:	30 19       	mov	r9,1
80002d1a:	f2 08 09 48 	lsl	r8,r9,r8
80002d1e:	10 99       	mov	r9,r8
80002d20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d24:	f1 49 00 58 	st.w	r8[88],r9
		}

		gpio_port->oders = 1 << (pin & 0x1F);
80002d28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d2c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002d30:	30 19       	mov	r9,1
80002d32:	f2 08 09 48 	lsl	r8,r9,r8
80002d36:	10 99       	mov	r9,r8
80002d38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d3c:	f1 49 00 44 	st.w	r8[68],r9
80002d40:	c0 d8       	rjmp	80002d5a <gpio_configure_pin+0x192>
	} else {
		gpio_port->oderc = 1 << (pin & 0x1F);
80002d42:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d46:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002d4a:	30 19       	mov	r9,1
80002d4c:	f2 08 09 48 	lsl	r8,r9,r8
80002d50:	10 99       	mov	r9,r8
80002d52:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d56:	f1 49 00 48 	st.w	r8[72],r9
	}

	/* Enable GPIO */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002d5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002d62:	30 19       	mov	r9,1
80002d64:	f2 08 09 48 	lsl	r8,r9,r8
80002d68:	10 99       	mov	r9,r8
80002d6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d6e:	91 19       	st.w	r8[0x4],r9
}
80002d70:	2f dd       	sub	sp,-12
80002d72:	e3 cd 80 80 	ldm	sp++,r7,pc

80002d76 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80002d76:	eb cd 40 80 	pushm	r7,lr
80002d7a:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
80002d7c:	c0 08       	rjmp	80002d7c <_unhandled_interrupt+0x6>
80002d7e:	d7 03       	nop

80002d80 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80002d80:	eb cd 40 80 	pushm	r7,lr
80002d84:	1a 97       	mov	r7,sp
80002d86:	20 3d       	sub	sp,12
80002d88:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002d8c:	fe 78 08 00 	mov	r8,-63488
80002d90:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002d94:	f2 09 11 03 	rsub	r9,r9,3
80002d98:	28 09       	sub	r9,-128
80002d9a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80002d9e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002da2:	fe 78 08 00 	mov	r8,-63488
80002da6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002daa:	2c 09       	sub	r9,-64
80002dac:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80002db0:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002db4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002db8:	58 08       	cp.w	r8,0
80002dba:	c1 30       	breq	80002de0 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002dbc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002dc0:	48 b8       	lddpc	r8,80002dec <_get_interrupt_handler+0x6c>
80002dc2:	a1 79       	lsl	r9,0x1
80002dc4:	2f f9       	sub	r9,-1
80002dc6:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002dca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dce:	f0 08 12 00 	clz	r8,r8
80002dd2:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80002dd6:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002dd8:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002ddc:	70 08       	ld.w	r8,r8[0x0]
80002dde:	c0 28       	rjmp	80002de2 <_get_interrupt_handler+0x62>
80002de0:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80002de2:	10 9c       	mov	r12,r8
80002de4:	2f dd       	sub	sp,-12
80002de6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002dea:	00 00       	add	r0,r0
80002dec:	80 00       	ld.sh	r0,r0[0x0]
80002dee:	90 20       	ld.sh	r0,r8[0x4]

80002df0 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80002df0:	eb cd 40 80 	pushm	r7,lr
80002df4:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002df6:	48 38       	lddpc	r8,80002e00 <INTC_init_evba+0x10>
80002df8:	e3 b8 00 01 	mtsr	0x4,r8
}
80002dfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	8e 00       	ld.sh	r0,r7[0x0]

80002e04 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002e04:	eb cd 40 80 	pushm	r7,lr
80002e08:	1a 97       	mov	r7,sp
80002e0a:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80002e0c:	f0 1f 00 1f 	mcall	80002e88 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002e10:	30 08       	mov	r8,0
80002e12:	ef 48 ff f8 	st.w	r7[-8],r8
80002e16:	c3 18       	rjmp	80002e78 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002e18:	30 08       	mov	r8,0
80002e1a:	ef 48 ff fc 	st.w	r7[-4],r8
80002e1e:	c1 48       	rjmp	80002e46 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002e20:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e24:	49 a8       	lddpc	r8,80002e8c <INTC_init_interrupts+0x88>
80002e26:	a1 79       	lsl	r9,0x1
80002e28:	2f f9       	sub	r9,-1
80002e2a:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002e2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e32:	a3 68       	lsl	r8,0x2
80002e34:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002e38:	49 69       	lddpc	r9,80002e90 <INTC_init_interrupts+0x8c>
80002e3a:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80002e3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e40:	2f f8       	sub	r8,-1
80002e42:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
80002e46:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e4a:	49 18       	lddpc	r8,80002e8c <INTC_init_interrupts+0x88>
80002e4c:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002e50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e54:	10 39       	cp.w	r9,r8
80002e56:	fe 9b ff e5 	brhi	80002e20 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002e5a:	fe 78 08 00 	mov	r8,-63488
80002e5e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e62:	48 db       	lddpc	r11,80002e94 <INTC_init_interrupts+0x90>
80002e64:	48 da       	lddpc	r10,80002e98 <INTC_init_interrupts+0x94>
80002e66:	f6 0a 01 0a 	sub	r10,r11,r10
80002e6a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002e6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e72:	2f f8       	sub	r8,-1
80002e74:	ef 48 ff f8 	st.w	r7[-8],r8
80002e78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e7c:	59 18       	cp.w	r8,17
80002e7e:	fe 98 ff cd 	brls	80002e18 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
80002e82:	2f ed       	sub	sp,-8
80002e84:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	2d f0       	sub	r0,-33
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	90 20       	ld.sh	r0,r8[0x4]
80002e90:	80 00       	ld.sh	r0,r0[0x0]
80002e92:	2d 76       	sub	r6,-41
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	8f 04       	st.w	r7[0x0],r4
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	8e 00       	ld.sh	r0,r7[0x0]

80002e9c <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
80002e9c:	eb cd 40 80 	pushm	r7,lr
80002ea0:	1a 97       	mov	r7,sp
80002ea2:	20 4d       	sub	sp,16
80002ea4:	ef 4c ff f8 	st.w	r7[-8],r12
80002ea8:	ef 4b ff f4 	st.w	r7[-12],r11
80002eac:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002eb0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002eb4:	a5 98       	lsr	r8,0x5
80002eb6:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80002eba:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002ebe:	4a 78       	lddpc	r8,80002f58 <INTC_register_interrupt+0xbc>
80002ec0:	a1 79       	lsl	r9,0x1
80002ec2:	2f f9       	sub	r9,-1
80002ec4:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002ec8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ecc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002ed0:	a3 68       	lsl	r8,0x2
80002ed2:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80002ed6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eda:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80002edc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ee0:	58 08       	cp.w	r8,0
80002ee2:	c0 c1       	brne	80002efa <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002ee4:	fe 78 08 00 	mov	r8,-63488
80002ee8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002eec:	49 cb       	lddpc	r11,80002f5c <INTC_register_interrupt+0xc0>
80002eee:	49 da       	lddpc	r10,80002f60 <INTC_register_interrupt+0xc4>
80002ef0:	f6 0a 01 0a 	sub	r10,r11,r10
80002ef4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002ef8:	c2 d8       	rjmp	80002f52 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80002efa:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002efe:	58 18       	cp.w	r8,1
80002f00:	c0 d1       	brne	80002f1a <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002f02:	fe 78 08 00 	mov	r8,-63488
80002f06:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002f0a:	49 7b       	lddpc	r11,80002f64 <INTC_register_interrupt+0xc8>
80002f0c:	49 5a       	lddpc	r10,80002f60 <INTC_register_interrupt+0xc4>
80002f0e:	f6 0a 01 0a 	sub	r10,r11,r10
80002f12:	bf aa       	sbr	r10,0x1e
80002f14:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002f18:	c1 d8       	rjmp	80002f52 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80002f1a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002f1e:	58 28       	cp.w	r8,2
80002f20:	c0 d1       	brne	80002f3a <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80002f22:	fe 78 08 00 	mov	r8,-63488
80002f26:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002f2a:	49 0b       	lddpc	r11,80002f68 <INTC_register_interrupt+0xcc>
80002f2c:	48 da       	lddpc	r10,80002f60 <INTC_register_interrupt+0xc4>
80002f2e:	f6 0a 01 0a 	sub	r10,r11,r10
80002f32:	bf ba       	sbr	r10,0x1f
80002f34:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002f38:	c0 d8       	rjmp	80002f52 <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80002f3a:	fe 78 08 00 	mov	r8,-63488
80002f3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002f42:	48 bb       	lddpc	r11,80002f6c <INTC_register_interrupt+0xd0>
80002f44:	48 7a       	lddpc	r10,80002f60 <INTC_register_interrupt+0xc4>
80002f46:	f6 0a 01 0a 	sub	r10,r11,r10
80002f4a:	ea 1a c0 00 	orh	r10,0xc000
80002f4e:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
80002f52:	2f cd       	sub	sp,-16
80002f54:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	90 20       	ld.sh	r0,r8[0x4]
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	8f 04       	st.w	r7[0x0],r4
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	8e 00       	ld.sh	r0,r7[0x0]
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	8f 12       	st.w	r7[0x4],r2
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	8f 20       	st.w	r7[0x8],r0
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	8f 2e       	st.w	r7[0x8],lr

80002f70 <usart_read_char>:
  return USART_SUCCESS;
}


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80002f70:	eb cd 40 80 	pushm	r7,lr
80002f74:	1a 97       	mov	r7,sp
80002f76:	20 3d       	sub	sp,12
80002f78:	ef 4c ff f8 	st.w	r7[-8],r12
80002f7c:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80002f80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f84:	70 58       	ld.w	r8,r8[0x14]
80002f86:	e2 18 00 e0 	andl	r8,0xe0,COH
80002f8a:	c0 30       	breq	80002f90 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80002f8c:	30 48       	mov	r8,4
80002f8e:	c1 68       	rjmp	80002fba <usart_read_char+0x4a>
80002f90:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f94:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80002f98:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f9c:	70 58       	ld.w	r8,r8[0x14]
80002f9e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80002fa2:	c0 b0       	breq	80002fb8 <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80002fa4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002fa8:	70 68       	ld.w	r8,r8[0x18]
80002faa:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002fae:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002fb2:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80002fb4:	30 08       	mov	r8,0
80002fb6:	c0 28       	rjmp	80002fba <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80002fb8:	30 38       	mov	r8,3
}
80002fba:	10 9c       	mov	r12,r8
80002fbc:	2f dd       	sub	sp,-12
80002fbe:	e3 cd 80 80 	ldm	sp++,r7,pc

80002fc2 <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80002fc2:	eb cd 40 80 	pushm	r7,lr
80002fc6:	1a 97       	mov	r7,sp
80002fc8:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80002fca:	e1 b8 00 00 	mfsr	r8,0x0
80002fce:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80002fd2:	d3 03       	ssrf	0x10

	return flags;
80002fd4:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80002fd8:	10 9c       	mov	r12,r8
80002fda:	2f fd       	sub	sp,-4
80002fdc:	e3 cd 80 80 	ldm	sp++,r7,pc

80002fe0 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80002fe0:	eb cd 40 80 	pushm	r7,lr
80002fe4:	1a 97       	mov	r7,sp
80002fe6:	20 1d       	sub	sp,4
80002fe8:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80002fec:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ff0:	e6 18 00 01 	andh	r8,0x1,COH
80002ff4:	5f 08       	sreq	r8
80002ff6:	5c 58       	castu.b	r8
}
80002ff8:	10 9c       	mov	r12,r8
80002ffa:	2f fd       	sub	sp,-4
80002ffc:	e3 cd 80 80 	ldm	sp++,r7,pc

80003000 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80003000:	eb cd 40 80 	pushm	r7,lr
80003004:	1a 97       	mov	r7,sp
80003006:	20 1d       	sub	sp,4
80003008:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000300c:	ee fc ff fc 	ld.w	r12,r7[-4]
80003010:	f0 1f 00 05 	mcall	80003024 <cpu_irq_restore+0x24>
80003014:	18 98       	mov	r8,r12
80003016:	58 08       	cp.w	r8,0
80003018:	c0 20       	breq	8000301c <cpu_irq_restore+0x1c>
      cpu_irq_enable();
8000301a:	d5 03       	csrf	0x10
   }

	barrier();
}
8000301c:	2f fd       	sub	sp,-4
8000301e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003022:	00 00       	add	r0,r0
80003024:	80 00       	ld.sh	r0,r0[0x0]
80003026:	2f e0       	sub	r0,-2

80003028 <sleepmgr_lock_mode>:
 * not put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to lock.
 */
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
80003028:	eb cd 40 80 	pushm	r7,lr
8000302c:	1a 97       	mov	r7,sp
8000302e:	20 2d       	sub	sp,8
80003030:	ef 4c ff f8 	st.w	r7[-8],r12
	irqflags_t flags;

	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();
80003034:	f0 1f 00 0b 	mcall	80003060 <sleepmgr_lock_mode+0x38>
80003038:	18 98       	mov	r8,r12
8000303a:	ef 48 ff fc 	st.w	r7[-4],r8

	++sleepmgr_locks[mode];
8000303e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003042:	48 99       	lddpc	r9,80003064 <sleepmgr_lock_mode+0x3c>
80003044:	f2 08 07 09 	ld.ub	r9,r9[r8]
80003048:	2f f9       	sub	r9,-1
8000304a:	5c 59       	castu.b	r9
8000304c:	48 6a       	lddpc	r10,80003064 <sleepmgr_lock_mode+0x3c>
8000304e:	f4 08 0b 09 	st.b	r10[r8],r9

	// Leave the critical section
	cpu_irq_restore(flags);
80003052:	ee fc ff fc 	ld.w	r12,r7[-4]
80003056:	f0 1f 00 05 	mcall	80003068 <sleepmgr_lock_mode+0x40>
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
8000305a:	2f ed       	sub	sp,-8
8000305c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003060:	80 00       	ld.sh	r0,r0[0x0]
80003062:	2f c2       	sub	r2,-4
80003064:	00 00       	add	r0,r0
80003066:	46 60       	lddsp	r0,sp[0x198]
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	30 00       	mov	r0,0

8000306c <sleepmgr_unlock_mode>:
 * manager can put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to unlock.
 */
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
8000306c:	eb cd 40 80 	pushm	r7,lr
80003070:	1a 97       	mov	r7,sp
80003072:	20 2d       	sub	sp,8
80003074:	ef 4c ff f8 	st.w	r7[-8],r12
	irqflags_t flags;

	Assert(sleepmgr_locks[mode]);

	// Enter a critical section
	flags = cpu_irq_save();
80003078:	f0 1f 00 0b 	mcall	800030a4 <sleepmgr_unlock_mode+0x38>
8000307c:	18 98       	mov	r8,r12
8000307e:	ef 48 ff fc 	st.w	r7[-4],r8

	--sleepmgr_locks[mode];
80003082:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003086:	48 99       	lddpc	r9,800030a8 <sleepmgr_unlock_mode+0x3c>
80003088:	f2 08 07 09 	ld.ub	r9,r9[r8]
8000308c:	20 19       	sub	r9,1
8000308e:	5c 59       	castu.b	r9
80003090:	48 6a       	lddpc	r10,800030a8 <sleepmgr_unlock_mode+0x3c>
80003092:	f4 08 0b 09 	st.b	r10[r8],r9

	// Leave the critical section
	cpu_irq_restore(flags);
80003096:	ee fc ff fc 	ld.w	r12,r7[-4]
8000309a:	f0 1f 00 05 	mcall	800030ac <sleepmgr_unlock_mode+0x40>
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
8000309e:	2f ed       	sub	sp,-8
800030a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	2f c2       	sub	r2,-4
800030a8:	00 00       	add	r0,r0
800030aa:	46 60       	lddsp	r0,sp[0x198]
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	30 00       	mov	r0,0

800030b0 <udd_sleep_mode>:
/*! \brief Authorize or not the CPU powerdown mode
 *
 * \param b_enable   true to authorize powerdown mode
 */
static void udd_sleep_mode(bool b_idle)
{
800030b0:	eb cd 40 80 	pushm	r7,lr
800030b4:	1a 97       	mov	r7,sp
800030b6:	20 1d       	sub	sp,4
800030b8:	18 98       	mov	r8,r12
800030ba:	ef 68 ff fc 	st.b	r7[-4],r8
	if (!b_idle && udd_b_idle) {
800030be:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800030c2:	ec 18 00 01 	eorl	r8,0x1
800030c6:	5c 58       	castu.b	r8
800030c8:	c0 80       	breq	800030d8 <udd_sleep_mode+0x28>
800030ca:	48 f8       	lddpc	r8,80003104 <udd_sleep_mode+0x54>
800030cc:	11 88       	ld.ub	r8,r8[0x0]
800030ce:	58 08       	cp.w	r8,0
800030d0:	c0 40       	breq	800030d8 <udd_sleep_mode+0x28>
		sleepmgr_unlock_mode(USBB_SLEEP_MODE_USB_IDLE);
800030d2:	30 1c       	mov	r12,1
800030d4:	f0 1f 00 0d 	mcall	80003108 <udd_sleep_mode+0x58>
	}
	if (b_idle && !udd_b_idle) {
800030d8:	ef 39 ff fc 	ld.ub	r9,r7[-4]
800030dc:	30 08       	mov	r8,0
800030de:	f0 09 18 00 	cp.b	r9,r8
800030e2:	c0 a0       	breq	800030f6 <udd_sleep_mode+0x46>
800030e4:	48 88       	lddpc	r8,80003104 <udd_sleep_mode+0x54>
800030e6:	11 88       	ld.ub	r8,r8[0x0]
800030e8:	ec 18 00 01 	eorl	r8,0x1
800030ec:	5c 58       	castu.b	r8
800030ee:	c0 40       	breq	800030f6 <udd_sleep_mode+0x46>
		sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_IDLE);
800030f0:	30 1c       	mov	r12,1
800030f2:	f0 1f 00 07 	mcall	8000310c <udd_sleep_mode+0x5c>
	}
	udd_b_idle = b_idle;
800030f6:	48 49       	lddpc	r9,80003104 <udd_sleep_mode+0x54>
800030f8:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800030fc:	b2 88       	st.b	r9[0x0],r8
}
800030fe:	2f fd       	sub	sp,-4
80003100:	e3 cd 80 80 	ldm	sp++,r7,pc
80003104:	00 00       	add	r0,r0
80003106:	01 90       	ld.ub	r0,r0[0x1]
80003108:	80 00       	ld.sh	r0,r0[0x0]
8000310a:	30 6c       	mov	r12,6
8000310c:	80 00       	ld.sh	r0,r0[0x0]
8000310e:	30 28       	mov	r8,2

80003110 <udd_interrupt>:
ISR_FREERTOS(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#  else
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#  endif
#endif
{
80003110:	eb cd 40 80 	pushm	r7,lr
80003114:	1a 97       	mov	r7,sp
	if (Is_udd_sof()) {
80003116:	fe 68 00 04 	mov	r8,-131068
8000311a:	70 08       	ld.w	r8,r8[0x0]
8000311c:	e2 18 00 04 	andl	r8,0x4,COH
80003120:	c1 10       	breq	80003142 <udd_interrupt+0x32>
		udd_ack_sof();
80003122:	fe 68 00 08 	mov	r8,-131064
80003126:	30 49       	mov	r9,4
80003128:	91 09       	st.w	r8[0x0],r9
		if (Is_udd_full_speed_mode()) {
8000312a:	fe 68 08 04 	mov	r8,-129020
8000312e:	70 08       	ld.w	r8,r8[0x0]
80003130:	e2 18 30 00 	andl	r8,0x3000,COH
80003134:	ad 88       	lsr	r8,0xc
80003136:	c0 31       	brne	8000313c <udd_interrupt+0x2c>
			udc_sof_notify();
80003138:	f0 1f 00 5d 	mcall	800032ac <udd_interrupt+0x19c>
		}
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
8000313c:	f0 1f 00 5d 	mcall	800032b0 <udd_interrupt+0x1a0>
#endif
		goto udd_interrupt_end;
80003140:	ca e8       	rjmp	8000329c <udd_interrupt+0x18c>
	}
	if (Is_udd_msof()) {
80003142:	fe 68 00 04 	mov	r8,-131068
80003146:	70 08       	ld.w	r8,r8[0x0]
80003148:	e2 18 00 02 	andl	r8,0x2,COH
8000314c:	c0 80       	breq	8000315c <udd_interrupt+0x4c>
		udd_ack_msof();
8000314e:	fe 68 00 08 	mov	r8,-131064
80003152:	30 29       	mov	r9,2
80003154:	91 09       	st.w	r8[0x0],r9
		udc_sof_notify();
80003156:	f0 1f 00 56 	mcall	800032ac <udd_interrupt+0x19c>
		goto udd_interrupt_end;
8000315a:	ca 18       	rjmp	8000329c <udd_interrupt+0x18c>
	}

	if (udd_ctrl_interrupt())
8000315c:	f0 1f 00 56 	mcall	800032b4 <udd_interrupt+0x1a4>
80003160:	18 98       	mov	r8,r12
80003162:	58 08       	cp.w	r8,0
80003164:	e0 81 00 99 	brne	80003296 <udd_interrupt+0x186>
		goto udd_interrupt_end; // Interrupt acked by control endpoint managed

#if (0 != USB_DEVICE_MAX_EP)
	if (udd_ep_interrupt())
80003168:	f0 1f 00 54 	mcall	800032b8 <udd_interrupt+0x1a8>
8000316c:	18 98       	mov	r8,r12
8000316e:	58 08       	cp.w	r8,0
80003170:	e0 81 00 95 	brne	8000329a <udd_interrupt+0x18a>
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
80003174:	fe 68 00 04 	mov	r8,-131068
80003178:	70 08       	ld.w	r8,r8[0x0]
8000317a:	e2 18 00 08 	andl	r8,0x8,COH
8000317e:	c0 e0       	breq	8000319a <udd_interrupt+0x8a>
		udd_ack_reset();
80003180:	fe 68 00 08 	mov	r8,-131064
80003184:	30 89       	mov	r9,8
80003186:	91 09       	st.w	r8[0x0],r9
		// Abort all jobs on-going
#if (USB_DEVICE_MAX_EP != 0)
		udd_ep_job_table_kill();
80003188:	f0 1f 00 4d 	mcall	800032bc <udd_interrupt+0x1ac>
#endif
		// Reset USB Device Stack Core
		udc_reset();
8000318c:	f0 1f 00 4d 	mcall	800032c0 <udd_interrupt+0x1b0>
		// Reset endpoint control
		udd_reset_ep_ctrl();
80003190:	f0 1f 00 4d 	mcall	800032c4 <udd_interrupt+0x1b4>
		// Reset endpoint control management
		udd_ctrl_init();
80003194:	f0 1f 00 4d 	mcall	800032c8 <udd_interrupt+0x1b8>
		goto udd_interrupt_end;
80003198:	c8 28       	rjmp	8000329c <udd_interrupt+0x18c>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
8000319a:	fe 68 00 10 	mov	r8,-131056
8000319e:	70 08       	ld.w	r8,r8[0x0]
800031a0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800031a4:	5c 58       	castu.b	r8
800031a6:	c2 40       	breq	800031ee <udd_interrupt+0xde>
800031a8:	fe 68 00 04 	mov	r8,-131068
800031ac:	70 08       	ld.w	r8,r8[0x0]
800031ae:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800031b2:	5c 58       	castu.b	r8
800031b4:	c1 d0       	breq	800031ee <udd_interrupt+0xde>
		otg_unfreeze_clock();
800031b6:	fe 68 08 00 	mov	r8,-129024
800031ba:	fe 69 08 00 	mov	r9,-129024
800031be:	72 09       	ld.w	r9,r9[0x0]
800031c0:	af c9       	cbr	r9,0xe
800031c2:	91 09       	st.w	r8[0x0],r9
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
800031c4:	fe 68 00 14 	mov	r8,-131052
800031c8:	30 19       	mov	r9,1
800031ca:	91 09       	st.w	r8[0x0],r9
		udd_enable_wake_up_interrupt();
800031cc:	fe 68 00 18 	mov	r8,-131048
800031d0:	31 09       	mov	r9,16
800031d2:	91 09       	st.w	r8[0x0],r9
		otg_freeze_clock(); // Mandatory to exit of sleep mode after a wakeup event
800031d4:	fe 68 08 00 	mov	r8,-129024
800031d8:	fe 69 08 00 	mov	r9,-129024
800031dc:	72 09       	ld.w	r9,r9[0x0]
800031de:	af a9       	sbr	r9,0xe
800031e0:	91 09       	st.w	r8[0x0],r9
		udd_sleep_mode(false); // Enter in SUSPEND mode
800031e2:	30 0c       	mov	r12,0
800031e4:	f0 1f 00 3a 	mcall	800032cc <udd_interrupt+0x1bc>
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
800031e8:	f0 1f 00 3a 	mcall	800032d0 <udd_interrupt+0x1c0>
#endif
		goto udd_interrupt_end;
800031ec:	c5 88       	rjmp	8000329c <udd_interrupt+0x18c>
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
800031ee:	fe 68 00 10 	mov	r8,-131056
800031f2:	70 08       	ld.w	r8,r8[0x0]
800031f4:	e2 18 00 10 	andl	r8,0x10,COH
800031f8:	c2 20       	breq	8000323c <udd_interrupt+0x12c>
800031fa:	fe 68 00 04 	mov	r8,-131068
800031fe:	70 08       	ld.w	r8,r8[0x0]
80003200:	e2 18 00 10 	andl	r8,0x10,COH
80003204:	c1 c0       	breq	8000323c <udd_interrupt+0x12c>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
80003206:	fe 68 08 00 	mov	r8,-129024
8000320a:	fe 69 08 00 	mov	r9,-129024
8000320e:	72 09       	ld.w	r9,r9[0x0]
80003210:	af c9       	cbr	r9,0xe
80003212:	91 09       	st.w	r8[0x0],r9

		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_otg_clock_usable() );
80003214:	fe 68 08 04 	mov	r8,-129020
80003218:	70 08       	ld.w	r8,r8[0x0]
8000321a:	e2 18 40 00 	andl	r8,0x4000,COH
8000321e:	cf b0       	breq	80003214 <udd_interrupt+0x104>

		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
80003220:	fe 68 00 14 	mov	r8,-131052
80003224:	31 09       	mov	r9,16
80003226:	91 09       	st.w	r8[0x0],r9
		udd_enable_suspend_interrupt();
80003228:	fe 68 00 18 	mov	r8,-131048
8000322c:	30 19       	mov	r9,1
8000322e:	91 09       	st.w	r8[0x0],r9
		udd_sleep_mode(true); // Enter in IDLE mode
80003230:	30 1c       	mov	r12,1
80003232:	f0 1f 00 27 	mcall	800032cc <udd_interrupt+0x1bc>
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
80003236:	f0 1f 00 28 	mcall	800032d4 <udd_interrupt+0x1c4>
#endif
		goto udd_interrupt_end;
8000323a:	c3 18       	rjmp	8000329c <udd_interrupt+0x18c>
	}

	if (Is_otg_vbus_transition()) {
8000323c:	fe 68 08 04 	mov	r8,-129020
80003240:	70 08       	ld.w	r8,r8[0x0]
80003242:	e2 18 00 02 	andl	r8,0x2,COH
80003246:	c2 b0       	breq	8000329c <udd_interrupt+0x18c>
		// Ack Vbus transition and send status to high level
		otg_unfreeze_clock();
80003248:	fe 68 08 00 	mov	r8,-129024
8000324c:	fe 69 08 00 	mov	r9,-129024
80003250:	72 09       	ld.w	r9,r9[0x0]
80003252:	af c9       	cbr	r9,0xe
80003254:	91 09       	st.w	r8[0x0],r9
		otg_ack_vbus_transition();
80003256:	fe 68 08 08 	mov	r8,-129016
8000325a:	30 29       	mov	r9,2
8000325c:	91 09       	st.w	r8[0x0],r9
		otg_freeze_clock();
8000325e:	fe 68 08 00 	mov	r8,-129024
80003262:	fe 69 08 00 	mov	r9,-129024
80003266:	72 09       	ld.w	r9,r9[0x0]
80003268:	af a9       	sbr	r9,0xe
8000326a:	91 09       	st.w	r8[0x0],r9
#ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
		if (Is_otg_vbus_high()) {
8000326c:	fe 68 08 04 	mov	r8,-129020
80003270:	70 08       	ld.w	r8,r8[0x0]
80003272:	e2 18 08 00 	andl	r8,0x800,COH
80003276:	c0 40       	breq	8000327e <udd_interrupt+0x16e>
			udd_attach();
80003278:	f0 1f 00 18 	mcall	800032d8 <udd_interrupt+0x1c8>
8000327c:	c0 38       	rjmp	80003282 <udd_interrupt+0x172>
		} else {
			udd_detach();
8000327e:	f0 1f 00 18 	mcall	800032dc <udd_interrupt+0x1cc>
		}
#endif
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_otg_vbus_high());
80003282:	fe 68 08 04 	mov	r8,-129020
80003286:	70 08       	ld.w	r8,r8[0x0]
80003288:	e2 18 08 00 	andl	r8,0x800,COH
8000328c:	5f 18       	srne	r8
8000328e:	10 9c       	mov	r12,r8
80003290:	f0 1f 00 14 	mcall	800032e0 <udd_interrupt+0x1d0>
80003294:	c0 48       	rjmp	8000329c <udd_interrupt+0x18c>
		udc_sof_notify();
		goto udd_interrupt_end;
	}

	if (udd_ctrl_interrupt())
		goto udd_interrupt_end; // Interrupt acked by control endpoint managed
80003296:	d7 03       	nop
80003298:	c0 28       	rjmp	8000329c <udd_interrupt+0x18c>

#if (0 != USB_DEVICE_MAX_EP)
	if (udd_ep_interrupt())
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
8000329a:	d7 03       	nop
		UDC_VBUS_EVENT(Is_otg_vbus_high());
#endif
		goto udd_interrupt_end;
	}
udd_interrupt_end:
	otg_data_memory_barrier();
8000329c:	fe 68 00 00 	mov	r8,-131072
800032a0:	f0 f8 08 18 	ld.w	r8,r8[2072]
	// consider that exiting from the USB interrupt will require a context switch.
	return pdTRUE;
#else
	return;
#endif
}
800032a4:	e3 cd 40 80 	ldm	sp++,r7,lr
800032a8:	d6 03       	rete
800032aa:	00 00       	add	r0,r0
800032ac:	80 00       	ld.sh	r0,r0[0x0]
800032ae:	69 b4       	ld.w	r4,r4[0x6c]
800032b0:	80 00       	ld.sh	r0,r0[0x0]
800032b2:	75 c4       	ld.w	r4,r10[0x70]
800032b4:	80 00       	ld.sh	r0,r0[0x0]
800032b6:	45 7c       	lddsp	r12,sp[0x15c]
800032b8:	80 00       	ld.sh	r0,r0[0x0]
800032ba:	4a 30       	lddpc	r0,80003344 <udd_enable+0x60>
800032bc:	80 00       	ld.sh	r0,r0[0x0]
800032be:	46 b0       	lddsp	r0,sp[0x1ac]
800032c0:	80 00       	ld.sh	r0,r0[0x0]
800032c2:	69 54       	ld.w	r4,r4[0x54]
800032c4:	80 00       	ld.sh	r0,r0[0x0]
800032c6:	3d f8       	mov	r8,-33
800032c8:	80 00       	ld.sh	r0,r0[0x0]
800032ca:	3e dc       	mov	r12,-19
800032cc:	80 00       	ld.sh	r0,r0[0x0]
800032ce:	30 b0       	mov	r0,11
800032d0:	80 00       	ld.sh	r0,r0[0x0]
800032d2:	75 b0       	ld.w	r0,r10[0x6c]
800032d4:	80 00       	ld.sh	r0,r0[0x0]
800032d6:	75 ba       	ld.w	r10,r10[0x6c]
800032d8:	80 00       	ld.sh	r0,r0[0x0]
800032da:	34 04       	mov	r4,64
800032dc:	80 00       	ld.sh	r0,r0[0x0]
800032de:	34 b4       	mov	r4,75
800032e0:	80 00       	ld.sh	r0,r0[0x0]
800032e2:	76 48       	ld.w	r8,r11[0x10]

800032e4 <udd_enable>:
	return true;
}


void udd_enable(void)
{
800032e4:	eb cd 40 80 	pushm	r7,lr
800032e8:	1a 97       	mov	r7,sp
800032ea:	20 2d       	sub	sp,8
	irqflags_t flags;

	flags = cpu_irq_save();
800032ec:	f0 1f 00 3e 	mcall	800033e4 <udd_enable+0x100>
800032f0:	18 98       	mov	r8,r12
800032f2:	ef 48 ff f8 	st.w	r7[-8],r8
		cpu_irq_restore(flags);
		return;
	}
#else
	//* SINGLE DEVICE MODE INITIALIZATION
	sysclk_enable_usb();
800032f6:	f0 1f 00 3d 	mcall	800033e8 <udd_enable+0x104>

	// Here, only the device mode is possible, then link USBB interrupt to UDD interrupt
	irq_register_handler(
800032fa:	30 0a       	mov	r10,0
800032fc:	e0 6b 02 20 	mov	r11,544
80003300:	4b bc       	lddpc	r12,800033ec <udd_enable+0x108>
80003302:	f0 1f 00 3c 	mcall	800033f0 <udd_enable+0x10c>
80003306:	30 18       	mov	r8,1
80003308:	ef 48 ff fc 	st.w	r7[-4],r8
 *  AVR32_PM_AWEN_xxxxWEN_MASK in the part-specific header file under
 *  "toolchain folder"/avr32/inc(lude)/avr32/)
 */
__always_inline static void pm_asyn_wake_up_enable(unsigned long awen_mask)
{
  AVR32_PM.awen |= awen_mask;
8000330c:	fe 78 0c 00 	mov	r8,-62464
80003310:	fe 79 0c 00 	mov	r9,-62464
80003314:	f2 fa 01 44 	ld.w	r10,r9[324]
80003318:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000331c:	f5 e9 10 09 	or	r9,r10,r9
80003320:	f1 49 01 44 	st.w	r8[324],r9
		cpu_irq_restore(flags);
		return; // Device is not the current mode
	}
# else
	// ID pin not used then force device mode
	otg_disable_id_pin();
80003324:	fe 68 08 00 	mov	r8,-129024
80003328:	fe 69 08 00 	mov	r9,-129024
8000332c:	72 09       	ld.w	r9,r9[0x0]
8000332e:	b9 c9       	cbr	r9,0x18
80003330:	91 09       	st.w	r8[0x0],r9
	otg_force_device_mode();
80003332:	fe 68 08 00 	mov	r8,-129024
80003336:	fe 69 08 00 	mov	r9,-129024
8000333a:	72 09       	ld.w	r9,r9[0x0]
8000333c:	b9 b9       	sbr	r9,0x19
8000333e:	91 09       	st.w	r8[0x0],r9
# endif

	// Enable USB hardware
	otg_enable_pad();
80003340:	fe 68 08 00 	mov	r8,-129024
80003344:	fe 69 08 00 	mov	r9,-129024
80003348:	72 09       	ld.w	r9,r9[0x0]
8000334a:	ad a9       	sbr	r9,0xc
8000334c:	91 09       	st.w	r8[0x0],r9
	otg_enable();
8000334e:	fe 68 08 00 	mov	r8,-129024
80003352:	fe 69 08 00 	mov	r9,-129024
80003356:	72 09       	ld.w	r9,r9[0x0]
80003358:	af b9       	sbr	r9,0xf
8000335a:	91 09       	st.w	r8[0x0],r9
	otg_unfreeze_clock();
8000335c:	fe 68 08 00 	mov	r8,-129024
80003360:	fe 69 08 00 	mov	r9,-129024
80003364:	72 09       	ld.w	r9,r9[0x0]
80003366:	af c9       	cbr	r9,0xe
80003368:	91 09       	st.w	r8[0x0],r9
	(void)Is_otg_clock_frozen();
8000336a:	fe 68 08 00 	mov	r8,-129024
8000336e:	70 08       	ld.w	r8,r8[0x0]

	// Reset internal variables
#if (0!=USB_DEVICE_MAX_EP)
	udd_ep_job_table_reset();
80003370:	f0 1f 00 21 	mcall	800033f4 <udd_enable+0x110>

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
80003374:	fe 68 00 00 	mov	r8,-131072
80003378:	fe 69 00 00 	mov	r9,-131072
8000337c:	72 09       	ld.w	r9,r9[0x0]
8000337e:	ad c9       	cbr	r9,0xc
80003380:	91 09       	st.w	r8[0x0],r9
#  ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
#  else
	udd_high_speed_disable();
80003382:	fe 68 00 00 	mov	r8,-131072
80003386:	fe 69 00 00 	mov	r9,-131072
8000338a:	72 09       	ld.w	r9,r9[0x0]
8000338c:	e8 19 0c 00 	orl	r9,0xc00
80003390:	91 09       	st.w	r8[0x0],r9
#  endif
#endif
	otg_ack_vbus_transition();
80003392:	fe 68 08 08 	mov	r8,-129016
80003396:	30 29       	mov	r9,2
80003398:	91 09       	st.w	r8[0x0],r9
	// Force Vbus interrupt in case of Vbus always with a high level
	// This is possible with a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
8000339a:	fe 68 08 04 	mov	r8,-129020
8000339e:	70 08       	ld.w	r8,r8[0x0]
800033a0:	e2 18 08 00 	andl	r8,0x800,COH
800033a4:	c0 50       	breq	800033ae <udd_enable+0xca>
		otg_raise_vbus_transition();
800033a6:	fe 68 08 0c 	mov	r8,-129012
800033aa:	30 29       	mov	r9,2
800033ac:	91 09       	st.w	r8[0x0],r9
	}
	otg_enable_vbus_interrupt();
800033ae:	fe 68 08 00 	mov	r8,-129024
800033b2:	fe 69 08 00 	mov	r9,-129024
800033b6:	72 09       	ld.w	r9,r9[0x0]
800033b8:	a1 b9       	sbr	r9,0x1
800033ba:	91 09       	st.w	r8[0x0],r9
	otg_freeze_clock();
800033bc:	fe 68 08 00 	mov	r8,-129024
800033c0:	fe 69 08 00 	mov	r9,-129024
800033c4:	72 09       	ld.w	r9,r9[0x0]
800033c6:	af a9       	sbr	r9,0xe
800033c8:	91 09       	st.w	r8[0x0],r9

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
800033ca:	48 c9       	lddpc	r9,800033f8 <udd_enable+0x114>
800033cc:	30 08       	mov	r8,0
800033ce:	b2 88       	st.b	r9[0x0],r8
	sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_SUSPEND);
800033d0:	30 3c       	mov	r12,3
800033d2:	f0 1f 00 0b 	mcall	800033fc <udd_enable+0x118>
#endif

	cpu_irq_restore(flags);
800033d6:	ee fc ff f8 	ld.w	r12,r7[-8]
800033da:	f0 1f 00 0a 	mcall	80003400 <udd_enable+0x11c>
}
800033de:	2f ed       	sub	sp,-8
800033e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800033e4:	80 00       	ld.sh	r0,r0[0x0]
800033e6:	2f c2       	sub	r2,-4
800033e8:	80 00       	ld.sh	r0,r0[0x0]
800033ea:	54 10       	stdsp	sp[0x104],r0
800033ec:	80 00       	ld.sh	r0,r0[0x0]
800033ee:	31 10       	mov	r0,17
800033f0:	80 00       	ld.sh	r0,r0[0x0]
800033f2:	2e 9c       	sub	r12,-23
800033f4:	80 00       	ld.sh	r0,r0[0x0]
800033f6:	46 44       	lddsp	r4,sp[0x190]
800033f8:	00 00       	add	r0,r0
800033fa:	01 90       	ld.ub	r0,r0[0x1]
800033fc:	80 00       	ld.sh	r0,r0[0x0]
800033fe:	30 28       	mov	r8,2
80003400:	80 00       	ld.sh	r0,r0[0x0]
80003402:	30 00       	mov	r0,0

80003404 <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
80003404:	eb cd 40 80 	pushm	r7,lr
80003408:	1a 97       	mov	r7,sp
8000340a:	20 1d       	sub	sp,4
	irqflags_t flags;
	flags = cpu_irq_save();
8000340c:	f0 1f 00 27 	mcall	800034a8 <udd_attach+0xa4>
80003410:	18 98       	mov	r8,r12
80003412:	ef 48 ff fc 	st.w	r7[-4],r8

	// At startup the USB bus state is unknown,
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
80003416:	30 1c       	mov	r12,1
80003418:	f0 1f 00 25 	mcall	800034ac <udd_attach+0xa8>
	otg_unfreeze_clock();
8000341c:	fe 68 08 00 	mov	r8,-129024
80003420:	fe 69 08 00 	mov	r9,-129024
80003424:	72 09       	ld.w	r9,r9[0x0]
80003426:	af c9       	cbr	r9,0xe
80003428:	91 09       	st.w	r8[0x0],r9
	while( !Is_otg_clock_usable() );
8000342a:	fe 68 08 04 	mov	r8,-129020
8000342e:	70 08       	ld.w	r8,r8[0x0]
80003430:	e2 18 40 00 	andl	r8,0x4000,COH
80003434:	cf b0       	breq	8000342a <udd_attach+0x26>

	// Authorize attach if Vbus is present
	udd_attach_device();
80003436:	fe 68 00 00 	mov	r8,-131072
8000343a:	fe 69 00 00 	mov	r9,-131072
8000343e:	72 09       	ld.w	r9,r9[0x0]
80003440:	a9 c9       	cbr	r9,0x8
80003442:	91 09       	st.w	r8[0x0],r9

	// Enable USB line events
	udd_enable_reset_interrupt();
80003444:	fe 68 00 18 	mov	r8,-131048
80003448:	30 89       	mov	r9,8
8000344a:	91 09       	st.w	r8[0x0],r9
	udd_enable_suspend_interrupt();
8000344c:	fe 68 00 18 	mov	r8,-131048
80003450:	30 19       	mov	r9,1
80003452:	91 09       	st.w	r8[0x0],r9
	udd_enable_wake_up_interrupt();
80003454:	fe 68 00 18 	mov	r8,-131048
80003458:	31 09       	mov	r9,16
8000345a:	91 09       	st.w	r8[0x0],r9
	udd_enable_sof_interrupt();
8000345c:	fe 68 00 18 	mov	r8,-131048
80003460:	30 49       	mov	r9,4
80003462:	91 09       	st.w	r8[0x0],r9
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
#endif
	// Reset following interrupts flag
	udd_ack_reset();
80003464:	fe 68 00 08 	mov	r8,-131064
80003468:	30 89       	mov	r9,8
8000346a:	91 09       	st.w	r8[0x0],r9
	udd_ack_sof();
8000346c:	fe 68 00 08 	mov	r8,-131064
80003470:	30 49       	mov	r9,4
80003472:	91 09       	st.w	r8[0x0],r9
	udd_ack_msof();
80003474:	fe 68 00 08 	mov	r8,-131064
80003478:	30 29       	mov	r9,2
8000347a:	91 09       	st.w	r8[0x0],r9
#if UC3A3
	// With UTMI, the first suspend is detected but must be cleared to reoccur interrupt
	udd_ack_suspend();
#else
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
8000347c:	fe 68 00 0c 	mov	r8,-131060
80003480:	30 19       	mov	r9,1
80003482:	91 09       	st.w	r8[0x0],r9
#endif
	udd_ack_wake_up();
80003484:	fe 68 00 08 	mov	r8,-131064
80003488:	31 09       	mov	r9,16
8000348a:	91 09       	st.w	r8[0x0],r9
	otg_freeze_clock();
8000348c:	fe 68 08 00 	mov	r8,-129024
80003490:	fe 69 08 00 	mov	r9,-129024
80003494:	72 09       	ld.w	r9,r9[0x0]
80003496:	af a9       	sbr	r9,0xe
80003498:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
8000349a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000349e:	f0 1f 00 05 	mcall	800034b0 <udd_attach+0xac>
}
800034a2:	2f fd       	sub	sp,-4
800034a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800034a8:	80 00       	ld.sh	r0,r0[0x0]
800034aa:	2f c2       	sub	r2,-4
800034ac:	80 00       	ld.sh	r0,r0[0x0]
800034ae:	30 b0       	mov	r0,11
800034b0:	80 00       	ld.sh	r0,r0[0x0]
800034b2:	30 00       	mov	r0,0

800034b4 <udd_detach>:


void udd_detach(void)
{
800034b4:	eb cd 40 80 	pushm	r7,lr
800034b8:	1a 97       	mov	r7,sp
	otg_unfreeze_clock();
800034ba:	fe 68 08 00 	mov	r8,-129024
800034be:	fe 69 08 00 	mov	r9,-129024
800034c2:	72 09       	ld.w	r9,r9[0x0]
800034c4:	af c9       	cbr	r9,0xe
800034c6:	91 09       	st.w	r8[0x0],r9

	// Detach device from the bus
	udd_detach_device();
800034c8:	fe 68 00 00 	mov	r8,-131072
800034cc:	fe 69 00 00 	mov	r9,-131072
800034d0:	72 09       	ld.w	r9,r9[0x0]
800034d2:	a9 a9       	sbr	r9,0x8
800034d4:	91 09       	st.w	r8[0x0],r9
	otg_freeze_clock();
800034d6:	fe 68 08 00 	mov	r8,-129024
800034da:	fe 69 08 00 	mov	r9,-129024
800034de:	72 09       	ld.w	r9,r9[0x0]
800034e0:	af a9       	sbr	r9,0xe
800034e2:	91 09       	st.w	r8[0x0],r9
	udd_sleep_mode(false);
800034e4:	30 0c       	mov	r12,0
800034e6:	f0 1f 00 03 	mcall	800034f0 <udd_detach+0x3c>
}
800034ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800034ee:	00 00       	add	r0,r0
800034f0:	80 00       	ld.sh	r0,r0[0x0]
800034f2:	30 b0       	mov	r0,11

800034f4 <udd_is_high_speed>:


bool udd_is_high_speed(void)
{
800034f4:	eb cd 40 80 	pushm	r7,lr
800034f8:	1a 97       	mov	r7,sp
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
#else
	return false;
800034fa:	30 08       	mov	r8,0
#endif
}
800034fc:	10 9c       	mov	r12,r8
800034fe:	e3 cd 80 80 	ldm	sp++,r7,pc

80003502 <udd_set_address>:


void udd_set_address(uint8_t address)
{
80003502:	eb cd 40 80 	pushm	r7,lr
80003506:	1a 97       	mov	r7,sp
80003508:	20 1d       	sub	sp,4
8000350a:	18 98       	mov	r8,r12
8000350c:	ef 68 ff fc 	st.b	r7[-4],r8
	udd_disable_address();
80003510:	fe 68 00 00 	mov	r8,-131072
80003514:	fe 69 00 00 	mov	r9,-131072
80003518:	72 09       	ld.w	r9,r9[0x0]
8000351a:	a7 d9       	cbr	r9,0x7
8000351c:	91 09       	st.w	r8[0x0],r9
	udd_configure_address(address);
8000351e:	fe 68 00 00 	mov	r8,-131072
80003522:	fe 69 00 00 	mov	r9,-131072
80003526:	72 09       	ld.w	r9,r9[0x0]
80003528:	12 9a       	mov	r10,r9
8000352a:	e0 1a ff 80 	andl	r10,0xff80
8000352e:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80003532:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
80003536:	f5 e9 10 09 	or	r9,r10,r9
8000353a:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
8000353c:	fe 68 00 00 	mov	r8,-131072
80003540:	fe 69 00 00 	mov	r9,-131072
80003544:	72 09       	ld.w	r9,r9[0x0]
80003546:	a7 b9       	sbr	r9,0x7
80003548:	91 09       	st.w	r8[0x0],r9
}
8000354a:	2f fd       	sub	sp,-4
8000354c:	e3 cd 80 80 	ldm	sp++,r7,pc

80003550 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
80003550:	eb cd 40 80 	pushm	r7,lr
80003554:	1a 97       	mov	r7,sp
	return udd_get_configured_address();
80003556:	fe 68 00 00 	mov	r8,-131072
8000355a:	70 08       	ld.w	r8,r8[0x0]
8000355c:	5c 58       	castu.b	r8
8000355e:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
}
80003562:	10 9c       	mov	r12,r8
80003564:	e3 cd 80 80 	ldm	sp++,r7,pc

80003568 <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
80003568:	eb cd 40 80 	pushm	r7,lr
8000356c:	1a 97       	mov	r7,sp
	return udd_frame_number();
8000356e:	fe 68 00 20 	mov	r8,-131040
80003572:	70 08       	ld.w	r8,r8[0x0]
80003574:	e2 18 3f f8 	andl	r8,0x3ff8,COH
80003578:	a3 98       	lsr	r8,0x3
8000357a:	5c 88       	casts.h	r8
}
8000357c:	10 9c       	mov	r12,r8
8000357e:	e3 cd 80 80 	ldm	sp++,r7,pc

80003582 <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
80003582:	eb cd 40 80 	pushm	r7,lr
80003586:	1a 97       	mov	r7,sp
	return udd_micro_frame_number();
80003588:	fe 68 00 00 	mov	r8,-131072
8000358c:	70 88       	ld.w	r8,r8[0x20]
8000358e:	5c 88       	casts.h	r8
80003590:	5c 88       	casts.h	r8
80003592:	f1 d8 c0 0e 	bfextu	r8,r8,0x0,0xe
}
80003596:	10 9c       	mov	r12,r8
80003598:	e3 cd 80 80 	ldm	sp++,r7,pc

8000359c <udd_set_setup_payload>:
	}
}


void udd_set_setup_payload( uint8_t *payload, uint16_t payload_size )
{
8000359c:	eb cd 40 80 	pushm	r7,lr
800035a0:	1a 97       	mov	r7,sp
800035a2:	20 2d       	sub	sp,8
800035a4:	ef 4c ff fc 	st.w	r7[-4],r12
800035a8:	16 98       	mov	r8,r11
800035aa:	ef 58 ff f8 	st.h	r7[-8],r8
	udd_g_ctrlreq.payload = payload;
800035ae:	48 68       	lddpc	r8,800035c4 <udd_set_setup_payload+0x28>
800035b0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800035b4:	91 29       	st.w	r8[0x8],r9
	udd_g_ctrlreq.payload_size = payload_size;
800035b6:	48 49       	lddpc	r9,800035c4 <udd_set_setup_payload+0x28>
800035b8:	ef 08 ff f8 	ld.sh	r8,r7[-8]
800035bc:	b2 68       	st.h	r9[0xc],r8
}
800035be:	2f ed       	sub	sp,-8
800035c0:	e3 cd 80 80 	ldm	sp++,r7,pc
800035c4:	00 00       	add	r0,r0
800035c6:	46 48       	lddsp	r8,sp[0x190]

800035c8 <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
800035c8:	eb cd 40 80 	pushm	r7,lr
800035cc:	1a 97       	mov	r7,sp
800035ce:	20 dd       	sub	sp,52
800035d0:	16 99       	mov	r9,r11
800035d2:	14 98       	mov	r8,r10
800035d4:	18 9a       	mov	r10,r12
800035d6:	ef 6a ff d4 	st.b	r7[-44],r10
800035da:	ef 69 ff d0 	st.b	r7[-48],r9
800035de:	ef 58 ff cc 	st.h	r7[-52],r8
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
800035e2:	ef 38 ff d4 	ld.ub	r8,r7[-44]
800035e6:	a7 98       	lsr	r8,0x7
800035e8:	ef 68 ff db 	st.b	r7[-37],r8
	ep = ep & USB_EP_ADDR_MASK;
800035ec:	ef 38 ff d4 	ld.ub	r8,r7[-44]
800035f0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800035f4:	ef 68 ff d4 	st.b	r7[-44],r8

	if (ep > USB_DEVICE_MAX_EP) {
800035f8:	ef 39 ff d4 	ld.ub	r9,r7[-44]
800035fc:	30 38       	mov	r8,3
800035fe:	f0 09 18 00 	cp.b	r9,r8
80003602:	e0 88 00 04 	brls	8000360a <udd_ep_alloc+0x42>
		return false;
80003606:	30 08       	mov	r8,0
80003608:	c7 f9       	rjmp	80003906 <udd_ep_alloc+0x33e>
	}
	if (Is_udd_endpoint_enabled(ep)) {
8000360a:	fe 68 00 00 	mov	r8,-131072
8000360e:	70 79       	ld.w	r9,r8[0x1c]
80003610:	ef 38 ff d4 	ld.ub	r8,r7[-44]
80003614:	30 1a       	mov	r10,1
80003616:	f4 08 09 48 	lsl	r8,r10,r8
8000361a:	f3 e8 00 08 	and	r8,r9,r8
8000361e:	c0 30       	breq	80003624 <udd_ep_alloc+0x5c>
		return false;
80003620:	30 08       	mov	r8,0
80003622:	c7 29       	rjmp	80003906 <udd_ep_alloc+0x33e>
	}

	// Bank choice
	switch(bmAttributes&USB_EP_TYPE_MASK) {
80003624:	ef 38 ff d0 	ld.ub	r8,r7[-48]
80003628:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
8000362c:	58 28       	cp.w	r8,2
8000362e:	c0 d0       	breq	80003648 <udd_ep_alloc+0x80>
80003630:	58 38       	cp.w	r8,3
80003632:	c0 70       	breq	80003640 <udd_ep_alloc+0x78>
80003634:	58 18       	cp.w	r8,1
80003636:	c0 d1       	brne	80003650 <udd_ep_alloc+0x88>
	case USB_EP_TYPE_ISOCHRONOUS:
		bank = UDD_ISOCHRONOUS_NB_BANK(ep);
80003638:	30 28       	mov	r8,2
8000363a:	ef 68 ff de 	st.b	r7[-34],r8
		break;
8000363e:	c0 b8       	rjmp	80003654 <udd_ep_alloc+0x8c>
	case USB_EP_TYPE_INTERRUPT:
		bank = UDD_INTERRUPT_NB_BANK(ep);
80003640:	30 18       	mov	r8,1
80003642:	ef 68 ff de 	st.b	r7[-34],r8
		break;
80003646:	c0 78       	rjmp	80003654 <udd_ep_alloc+0x8c>
	case USB_EP_TYPE_BULK:
		bank = UDD_BULK_NB_BANK(ep);
80003648:	30 28       	mov	r8,2
8000364a:	ef 68 ff de 	st.b	r7[-34],r8
		break;
8000364e:	c0 38       	rjmp	80003654 <udd_ep_alloc+0x8c>
	default:
		Assert(false);
		return false;
80003650:	30 08       	mov	r8,0
80003652:	c5 a9       	rjmp	80003906 <udd_ep_alloc+0x33e>
	}
	switch(bank) {
80003654:	ef 38 ff de 	ld.ub	r8,r7[-34]
80003658:	58 28       	cp.w	r8,2
8000365a:	c0 90       	breq	8000366c <udd_ep_alloc+0xa4>
8000365c:	58 38       	cp.w	r8,3
8000365e:	c0 b0       	breq	80003674 <udd_ep_alloc+0xac>
80003660:	58 18       	cp.w	r8,1
80003662:	c0 d1       	brne	8000367c <udd_ep_alloc+0xb4>
	case 1:
		bank = AVR32_USBB_UECFG0_EPBK_SINGLE;
80003664:	30 08       	mov	r8,0
80003666:	ef 68 ff de 	st.b	r7[-34],r8
		break;
8000366a:	c0 b8       	rjmp	80003680 <udd_ep_alloc+0xb8>
	case 2:
		bank = AVR32_USBB_UECFG0_EPBK_DOUBLE;
8000366c:	30 18       	mov	r8,1
8000366e:	ef 68 ff de 	st.b	r7[-34],r8
		break;
80003672:	c0 78       	rjmp	80003680 <udd_ep_alloc+0xb8>
	case 3:
		bank = AVR32_USBB_UECFG0_EPBK_TRIPLE;
80003674:	30 28       	mov	r8,2
80003676:	ef 68 ff de 	st.b	r7[-34],r8
		break;
8000367a:	c0 38       	rjmp	80003680 <udd_ep_alloc+0xb8>
	default:
		Assert(false);
		return false;
8000367c:	30 08       	mov	r8,0
8000367e:	c4 49       	rjmp	80003906 <udd_ep_alloc+0x33e>
	Assert(MaxEndpointSize < 1024);
	Assert((MaxEndpointSize == 1023) || !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);

	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
80003680:	ef 38 ff d4 	ld.ub	r8,r7[-44]
80003684:	a3 68       	lsl	r8,0x2
80003686:	e0 38 ff 00 	sub	r8,130816
8000368a:	ef 39 ff d4 	ld.ub	r9,r7[-44]
8000368e:	a3 69       	lsl	r9,0x2
80003690:	e0 39 ff 00 	sub	r9,130816
80003694:	72 09       	ld.w	r9,r9[0x0]
80003696:	12 9a       	mov	r10,r9
80003698:	e0 1a e6 83 	andl	r10,0xe683
8000369c:	ef 39 ff d0 	ld.ub	r9,r7[-48]
800036a0:	ab 79       	lsl	r9,0xb
800036a2:	12 9b       	mov	r11,r9
800036a4:	e2 1b 18 00 	andl	r11,0x1800,COH
800036a8:	ef 39 ff db 	ld.ub	r9,r7[-37]
800036ac:	a9 69       	lsl	r9,0x8
800036ae:	e2 19 01 00 	andl	r9,0x100,COH
800036b2:	12 4b       	or	r11,r9
800036b4:	ef 19 ff cc 	ld.uh	r9,r7[-52]
800036b8:	ef 49 ff f0 	st.w	r7[-16],r9
800036bc:	30 89       	mov	r9,8
800036be:	ef 49 ff f4 	st.w	r7[-12],r9
800036c2:	ee f9 ff f0 	ld.w	r9,r7[-16]
800036c6:	ee fc ff f4 	ld.w	r12,r7[-12]
800036ca:	f2 0c 0c 49 	max	r9,r9,r12
800036ce:	ef 49 ff ec 	st.w	r7[-20],r9
800036d2:	ee f9 ff ec 	ld.w	r9,r7[-20]
800036d6:	ef 49 ff e4 	st.w	r7[-28],r9
800036da:	e0 69 04 00 	mov	r9,1024
800036de:	ef 49 ff e8 	st.w	r7[-24],r9
800036e2:	ee f9 ff e4 	ld.w	r9,r7[-28]
800036e6:	ee fc ff e8 	ld.w	r12,r7[-24]
800036ea:	f2 0c 0d 49 	min	r9,r9,r12
800036ee:	ef 49 ff e0 	st.w	r7[-32],r9
800036f2:	ee f9 ff e0 	ld.w	r9,r7[-32]
800036f6:	a1 79       	lsl	r9,0x1
800036f8:	20 19       	sub	r9,1
800036fa:	f2 09 12 00 	clz	r9,r9
800036fe:	f2 09 11 1c 	rsub	r9,r9,28
80003702:	a5 69       	lsl	r9,0x4
80003704:	12 4b       	or	r11,r9
80003706:	ef 39 ff de 	ld.ub	r9,r7[-34]
8000370a:	a3 69       	lsl	r9,0x2
8000370c:	e2 19 00 0c 	andl	r9,0xc,COH
80003710:	f7 e9 10 09 	or	r9,r11,r9
80003714:	e2 19 19 7c 	andl	r9,0x197c,COH
80003718:	f5 e9 10 09 	or	r9,r10,r9
8000371c:	91 09       	st.w	r8[0x0],r9
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
8000371e:	ef 38 ff d4 	ld.ub	r8,r7[-44]
80003722:	30 19       	mov	r9,1
80003724:	f2 08 09 48 	lsl	r8,r9,r8
80003728:	ef 58 ff dc 	st.h	r7[-36],r8

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
8000372c:	30 38       	mov	r8,3
8000372e:	ef 68 ff df 	st.b	r7[-33],r8
80003732:	c3 a8       	rjmp	800037a6 <udd_ep_alloc+0x1de>
		if (Is_udd_endpoint_enabled(i)) {
80003734:	fe 68 00 00 	mov	r8,-131072
80003738:	70 79       	ld.w	r9,r8[0x1c]
8000373a:	ef 38 ff df 	ld.ub	r8,r7[-33]
8000373e:	30 1a       	mov	r10,1
80003740:	f4 08 09 48 	lsl	r8,r10,r8
80003744:	f3 e8 00 08 	and	r8,r9,r8
80003748:	c2 a0       	breq	8000379c <udd_ep_alloc+0x1d4>
			ep_allocated |= 1 << i;
8000374a:	ef 38 ff df 	ld.ub	r8,r7[-33]
8000374e:	30 19       	mov	r9,1
80003750:	f2 08 09 48 	lsl	r8,r9,r8
80003754:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80003758:	ef 08 ff dc 	ld.sh	r8,r7[-36]
8000375c:	f3 e8 10 08 	or	r8,r9,r8
80003760:	5c 88       	casts.h	r8
80003762:	ef 58 ff dc 	st.h	r7[-36],r8
			udd_disable_endpoint(i);
80003766:	fe 68 00 00 	mov	r8,-131072
8000376a:	fe 69 00 00 	mov	r9,-131072
8000376e:	72 7a       	ld.w	r10,r9[0x1c]
80003770:	ef 39 ff df 	ld.ub	r9,r7[-33]
80003774:	30 1b       	mov	r11,1
80003776:	f6 09 09 49 	lsl	r9,r11,r9
8000377a:	5c d9       	com	r9
8000377c:	f5 e9 00 09 	and	r9,r10,r9
80003780:	91 79       	st.w	r8[0x1c],r9
			udd_unallocate_memory(i);
80003782:	ef 38 ff df 	ld.ub	r8,r7[-33]
80003786:	a3 68       	lsl	r8,0x2
80003788:	e0 38 ff 00 	sub	r8,130816
8000378c:	ef 39 ff df 	ld.ub	r9,r7[-33]
80003790:	a3 69       	lsl	r9,0x2
80003792:	e0 39 ff 00 	sub	r9,130816
80003796:	72 09       	ld.w	r9,r9[0x0]
80003798:	a1 d9       	cbr	r9,0x1
8000379a:	91 09       	st.w	r8[0x0],r9
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
8000379c:	ef 38 ff df 	ld.ub	r8,r7[-33]
800037a0:	20 18       	sub	r8,1
800037a2:	ef 68 ff df 	st.b	r7[-33],r8
800037a6:	ef 39 ff df 	ld.ub	r9,r7[-33]
800037aa:	ef 38 ff d4 	ld.ub	r8,r7[-44]
800037ae:	f0 09 18 00 	cp.b	r9,r8
800037b2:	fe 9b ff c1 	brhi	80003734 <udd_ep_alloc+0x16c>
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
800037b6:	ef 38 ff d4 	ld.ub	r8,r7[-44]
800037ba:	ef 68 ff df 	st.b	r7[-33],r8
800037be:	c9 c8       	rjmp	800038f6 <udd_ep_alloc+0x32e>
		if (ep_allocated & (1 << i)) {
800037c0:	ef 19 ff dc 	ld.uh	r9,r7[-36]
800037c4:	ef 38 ff df 	ld.ub	r8,r7[-33]
800037c8:	f2 08 08 48 	asr	r8,r9,r8
800037cc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800037d0:	5c 58       	castu.b	r8
800037d2:	e0 80 00 8d 	breq	800038ec <udd_ep_alloc+0x324>
			udd_ep_job_t *ptr_job = &udd_ep_job[i - 1];
800037d6:	ef 38 ff df 	ld.ub	r8,r7[-33]
800037da:	f0 c9 00 01 	sub	r9,r8,1
800037de:	12 98       	mov	r8,r9
800037e0:	a3 68       	lsl	r8,0x2
800037e2:	12 08       	add	r8,r9
800037e4:	a3 68       	lsl	r8,0x2
800037e6:	10 99       	mov	r9,r8
800037e8:	4c a8       	lddpc	r8,80003910 <udd_ep_alloc+0x348>
800037ea:	f2 08 00 08 	add	r8,r9,r8
800037ee:	ef 48 ff f8 	st.w	r7[-8],r8
			bool b_restart = ptr_job->busy;
800037f2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800037f6:	70 08       	ld.w	r8,r8[0x0]
800037f8:	e6 18 80 00 	andh	r8,0x8000,COH
800037fc:	5f 18       	srne	r8
800037fe:	ef 68 ff ff 	st.b	r7[-1],r8
			ptr_job->busy = false;
80003802:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003806:	72 08       	ld.w	r8,r9[0x0]
80003808:	30 0a       	mov	r10,0
8000380a:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
8000380e:	93 08       	st.w	r9[0x0],r8

			udd_allocate_memory(i);
80003810:	ef 38 ff df 	ld.ub	r8,r7[-33]
80003814:	a3 68       	lsl	r8,0x2
80003816:	e0 38 ff 00 	sub	r8,130816
8000381a:	ef 39 ff df 	ld.ub	r9,r7[-33]
8000381e:	a3 69       	lsl	r9,0x2
80003820:	e0 39 ff 00 	sub	r9,130816
80003824:	72 09       	ld.w	r9,r9[0x0]
80003826:	a1 b9       	sbr	r9,0x1
80003828:	91 09       	st.w	r8[0x0],r9
			udd_enable_endpoint(i);
8000382a:	fe 68 00 00 	mov	r8,-131072
8000382e:	fe 69 00 00 	mov	r9,-131072
80003832:	72 7a       	ld.w	r10,r9[0x1c]
80003834:	ef 39 ff df 	ld.ub	r9,r7[-33]
80003838:	30 1b       	mov	r11,1
8000383a:	f6 09 09 49 	lsl	r9,r11,r9
8000383e:	f5 e9 10 09 	or	r9,r10,r9
80003842:	91 79       	st.w	r8[0x1c],r9
			if (!Is_udd_endpoint_configured(i)) {
80003844:	ef 38 ff df 	ld.ub	r8,r7[-33]
80003848:	a3 68       	lsl	r8,0x2
8000384a:	e0 38 fe d0 	sub	r8,130768
8000384e:	70 08       	ld.w	r8,r8[0x0]
80003850:	e6 18 00 04 	andh	r8,0x4,COH
80003854:	c2 61       	brne	800038a0 <udd_ep_alloc+0x2d8>
				if (NULL == ptr_job->call_trans) {
80003856:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000385a:	70 48       	ld.w	r8,r8[0x10]
8000385c:	58 08       	cp.w	r8,0
8000385e:	c0 31       	brne	80003864 <udd_ep_alloc+0x29c>
					return false;
80003860:	30 08       	mov	r8,0
80003862:	c5 28       	rjmp	80003906 <udd_ep_alloc+0x33e>
				}
				if (Is_udd_endpoint_in(i)) {
80003864:	ef 38 ff df 	ld.ub	r8,r7[-33]
80003868:	a3 68       	lsl	r8,0x2
8000386a:	e0 38 ff 00 	sub	r8,130816
8000386e:	70 08       	ld.w	r8,r8[0x0]
80003870:	e2 18 01 00 	andl	r8,0x100,COH
80003874:	c0 90       	breq	80003886 <udd_ep_alloc+0x2be>
					i |= USB_EP_DIR_IN;
80003876:	ef 38 ff df 	ld.ub	r8,r7[-33]
8000387a:	ea 18 ff ff 	orh	r8,0xffff
8000387e:	e8 18 ff 80 	orl	r8,0xff80
80003882:	ef 68 ff df 	st.b	r7[-33],r8
				}				
				ptr_job->call_trans(UDD_EP_TRANSFER_ABORT,
80003886:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000388a:	70 48       	ld.w	r8,r8[0x10]
8000388c:	ef 3a ff df 	ld.ub	r10,r7[-33]
80003890:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003894:	72 29       	ld.w	r9,r9[0x8]
80003896:	12 9b       	mov	r11,r9
80003898:	30 1c       	mov	r12,1
8000389a:	5d 18       	icall	r8
						ptr_job->buf_size, i);
				return false;
8000389c:	30 08       	mov	r8,0
8000389e:	c3 48       	rjmp	80003906 <udd_ep_alloc+0x33e>
			}
			udd_enable_endpoint_bank_autoswitch(i);
800038a0:	ef 38 ff df 	ld.ub	r8,r7[-33]
800038a4:	a3 68       	lsl	r8,0x2
800038a6:	e0 38 ff 00 	sub	r8,130816
800038aa:	ef 39 ff df 	ld.ub	r9,r7[-33]
800038ae:	a3 69       	lsl	r9,0x2
800038b0:	e0 39 ff 00 	sub	r9,130816
800038b4:	72 09       	ld.w	r9,r9[0x0]
800038b6:	a9 b9       	sbr	r9,0x9
800038b8:	91 09       	st.w	r8[0x0],r9
			if (b_restart) {
800038ba:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800038be:	30 08       	mov	r8,0
800038c0:	f0 09 18 00 	cp.b	r9,r8
800038c4:	c1 40       	breq	800038ec <udd_ep_alloc+0x324>
				// Re-run the job
				udd_ep_run(i, ptr_job->b_shortpacket,
800038c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038ca:	70 48       	ld.w	r8,r8[0x10]
800038cc:	ee f9 ff f8 	ld.w	r9,r7[-8]
800038d0:	72 29       	ld.w	r9,r9[0x8]
800038d2:	ee fa ff f8 	ld.w	r10,r7[-8]
800038d6:	74 1a       	ld.w	r10,r10[0x4]
800038d8:	ee fb ff f8 	ld.w	r11,r7[-8]
800038dc:	76 0b       	ld.w	r11,r11[0x0]
800038de:	e6 1b 40 00 	andh	r11,0x4000,COH
800038e2:	5f 1b       	srne	r11
800038e4:	ef 3c ff df 	ld.ub	r12,r7[-33]
800038e8:	f0 1f 00 0b 	mcall	80003914 <udd_ep_alloc+0x34c>
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
800038ec:	ef 38 ff df 	ld.ub	r8,r7[-33]
800038f0:	2f f8       	sub	r8,-1
800038f2:	ef 68 ff df 	st.b	r7[-33],r8
800038f6:	ef 39 ff df 	ld.ub	r9,r7[-33]
800038fa:	30 38       	mov	r8,3
800038fc:	f0 09 18 00 	cp.b	r9,r8
80003900:	fe 98 ff 60 	brls	800037c0 <udd_ep_alloc+0x1f8>
						ptr_job->buf_size,
						ptr_job->call_trans);
			}
		}
	}
	return true;
80003904:	30 18       	mov	r8,1
}
80003906:	10 9c       	mov	r12,r8
80003908:	2f 3d       	sub	sp,-52
8000390a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000390e:	00 00       	add	r0,r0
80003910:	00 00       	add	r0,r0
80003912:	01 9c       	ld.ub	r12,r0[0x1]
80003914:	80 00       	ld.sh	r0,r0[0x0]
80003916:	3c 38       	mov	r8,-61

80003918 <udd_ep_free>:


void udd_ep_free(udd_ep_id_t ep)
{
80003918:	eb cd 40 80 	pushm	r7,lr
8000391c:	1a 97       	mov	r7,sp
8000391e:	20 2d       	sub	sp,8
80003920:	18 98       	mov	r8,r12
80003922:	ef 68 ff f8 	st.b	r7[-8],r8
	uint8_t index = ep & USB_EP_ADDR_MASK;
80003926:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000392a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
8000392e:	ef 68 ff ff 	st.b	r7[-1],r8

	if (USB_DEVICE_MAX_EP < index) {
80003932:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003936:	30 38       	mov	r8,3
80003938:	f0 09 18 00 	cp.b	r9,r8
8000393c:	e0 8b 00 33 	brhi	800039a2 <udd_ep_free+0x8a>
		return;
	}
	udd_disable_endpoint(index);
80003940:	fe 68 00 00 	mov	r8,-131072
80003944:	fe 69 00 00 	mov	r9,-131072
80003948:	72 7a       	ld.w	r10,r9[0x1c]
8000394a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000394e:	30 1b       	mov	r11,1
80003950:	f6 09 09 49 	lsl	r9,r11,r9
80003954:	5c d9       	com	r9
80003956:	f5 e9 00 09 	and	r9,r10,r9
8000395a:	91 79       	st.w	r8[0x1c],r9
	udd_unallocate_memory(index);
8000395c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003960:	a3 68       	lsl	r8,0x2
80003962:	e0 38 ff 00 	sub	r8,130816
80003966:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000396a:	a3 69       	lsl	r9,0x2
8000396c:	e0 39 ff 00 	sub	r9,130816
80003970:	72 09       	ld.w	r9,r9[0x0]
80003972:	a1 d9       	cbr	r9,0x1
80003974:	91 09       	st.w	r8[0x0],r9
	udd_ep_abort_job(ep);
80003976:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000397a:	10 9c       	mov	r12,r8
8000397c:	f0 1f 00 0c 	mcall	800039ac <udd_ep_free+0x94>
	udd_ep_job[index - 1].stall_requested = false;
80003980:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003984:	f0 c9 00 01 	sub	r9,r8,1
80003988:	48 aa       	lddpc	r10,800039b0 <udd_ep_free+0x98>
8000398a:	12 98       	mov	r8,r9
8000398c:	a3 68       	lsl	r8,0x2
8000398e:	12 08       	add	r8,r9
80003990:	a3 68       	lsl	r8,0x2
80003992:	f4 08 00 09 	add	r9,r10,r8
80003996:	72 08       	ld.w	r8,r9[0x0]
80003998:	30 0a       	mov	r10,0
8000399a:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
8000399e:	93 08       	st.w	r9[0x0],r8
800039a0:	c0 28       	rjmp	800039a4 <udd_ep_free+0x8c>
void udd_ep_free(udd_ep_id_t ep)
{
	uint8_t index = ep & USB_EP_ADDR_MASK;

	if (USB_DEVICE_MAX_EP < index) {
		return;
800039a2:	d7 03       	nop
	}
	udd_disable_endpoint(index);
	udd_unallocate_memory(index);
	udd_ep_abort_job(ep);
	udd_ep_job[index - 1].stall_requested = false;
}
800039a4:	2f ed       	sub	sp,-8
800039a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800039aa:	00 00       	add	r0,r0
800039ac:	80 00       	ld.sh	r0,r0[0x0]
800039ae:	47 0c       	lddsp	r12,sp[0x1c0]
800039b0:	00 00       	add	r0,r0
800039b2:	01 9c       	ld.ub	r12,r0[0x1]

800039b4 <udd_ep_is_halted>:


bool udd_ep_is_halted(udd_ep_id_t ep)
{
800039b4:	eb cd 40 80 	pushm	r7,lr
800039b8:	1a 97       	mov	r7,sp
800039ba:	20 1d       	sub	sp,4
800039bc:	18 98       	mov	r8,r12
800039be:	ef 68 ff fc 	st.b	r7[-4],r8
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
800039c2:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800039c6:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800039ca:	a3 68       	lsl	r8,0x2
800039cc:	e0 38 fe 40 	sub	r8,130624
800039d0:	70 08       	ld.w	r8,r8[0x0]
800039d2:	e6 18 00 08 	andh	r8,0x8,COH
800039d6:	5f 18       	srne	r8
800039d8:	5c 58       	castu.b	r8
}
800039da:	10 9c       	mov	r12,r8
800039dc:	2f fd       	sub	sp,-4
800039de:	e3 cd 80 80 	ldm	sp++,r7,pc
800039e2:	d7 03       	nop

800039e4 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
800039e4:	eb cd 40 80 	pushm	r7,lr
800039e8:	1a 97       	mov	r7,sp
800039ea:	20 3d       	sub	sp,12
800039ec:	18 98       	mov	r8,r12
800039ee:	ef 68 ff f4 	st.b	r7[-12],r8
	udd_ep_job_t *ptr_job;
	uint8_t index = ep & USB_EP_ADDR_MASK;
800039f2:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800039f6:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
800039fa:	ef 68 ff ff 	st.b	r7[-1],r8

	if (USB_DEVICE_MAX_EP < index) {
800039fe:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003a02:	30 38       	mov	r8,3
80003a04:	f0 09 18 00 	cp.b	r9,r8
80003a08:	e0 88 00 04 	brls	80003a10 <udd_ep_set_halt+0x2c>
		return false;
80003a0c:	30 08       	mov	r8,0
80003a0e:	c6 f8       	rjmp	80003aec <udd_ep_set_halt+0x108>
	}

	ptr_job = &udd_ep_job[index - 1];
80003a10:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003a14:	f0 c9 00 01 	sub	r9,r8,1
80003a18:	12 98       	mov	r8,r9
80003a1a:	a3 68       	lsl	r8,0x2
80003a1c:	12 08       	add	r8,r9
80003a1e:	a3 68       	lsl	r8,0x2
80003a20:	10 99       	mov	r9,r8
80003a22:	4b 58       	lddpc	r8,80003af4 <udd_ep_set_halt+0x110>
80003a24:	f2 08 00 08 	add	r8,r9,r8
80003a28:	ef 48 ff f8 	st.w	r7[-8],r8

	if (Is_udd_endpoint_stall_requested(index) // Endpoint stalled
80003a2c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003a30:	a3 68       	lsl	r8,0x2
80003a32:	e0 38 fe 40 	sub	r8,130624
80003a36:	70 08       	ld.w	r8,r8[0x0]
80003a38:	e6 18 00 08 	andh	r8,0x8,COH
80003a3c:	c0 71       	brne	80003a4a <udd_ep_set_halt+0x66>
			|| ptr_job->stall_requested) { // Endpoint stall is requested
80003a3e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a42:	70 08       	ld.w	r8,r8[0x0]
80003a44:	e6 18 20 00 	andh	r8,0x2000,COH
		return false;
	}

	ptr_job = &udd_ep_job[index - 1];

	if (Is_udd_endpoint_stall_requested(index) // Endpoint stalled
80003a48:	c0 30       	breq	80003a4e <udd_ep_set_halt+0x6a>
			|| ptr_job->stall_requested) { // Endpoint stall is requested
		return true; // Already STALL
80003a4a:	30 18       	mov	r8,1
80003a4c:	c5 08       	rjmp	80003aec <udd_ep_set_halt+0x108>
	}

	if (ptr_job->busy == true) {
80003a4e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a52:	70 08       	ld.w	r8,r8[0x0]
80003a54:	e6 18 80 00 	andh	r8,0x8000,COH
80003a58:	c0 30       	breq	80003a5e <udd_ep_set_halt+0x7a>
		return false; // Job on going, stall impossible
80003a5a:	30 08       	mov	r8,0
80003a5c:	c4 88       	rjmp	80003aec <udd_ep_set_halt+0x108>
	}

	if ((ep & USB_EP_DIR_IN) && (0 != udd_nb_busy_bank(index))) {
80003a5e:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003a62:	30 08       	mov	r8,0
80003a64:	f0 09 18 00 	cp.b	r9,r8
80003a68:	c2 54       	brge	80003ab2 <udd_ep_set_halt+0xce>
80003a6a:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003a6e:	a3 68       	lsl	r8,0x2
80003a70:	e0 38 fe d0 	sub	r8,130768
80003a74:	70 08       	ld.w	r8,r8[0x0]
80003a76:	e2 18 30 00 	andl	r8,0x3000,COH
80003a7a:	ad 88       	lsr	r8,0xc
80003a7c:	c1 b0       	breq	80003ab2 <udd_ep_set_halt+0xce>
			// Delay the stall after the end of IN transfer on USB line
			ptr_job->stall_requested = true;
80003a7e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003a82:	72 08       	ld.w	r8,r9[0x0]
80003a84:	30 1a       	mov	r10,1
80003a86:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
80003a8a:	93 08       	st.w	r9[0x0],r8
			udd_enable_bank_interrupt(index);
80003a8c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003a90:	a3 68       	lsl	r8,0x2
80003a92:	e0 38 fe 10 	sub	r8,130576
80003a96:	e0 69 10 00 	mov	r9,4096
80003a9a:	91 09       	st.w	r8[0x0],r9
			udd_enable_endpoint_interrupt(index);
80003a9c:	fe 68 00 00 	mov	r8,-131072
80003aa0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003aa4:	e0 6a 10 00 	mov	r10,4096
80003aa8:	f4 09 09 49 	lsl	r9,r10,r9
80003aac:	91 69       	st.w	r8[0x18],r9
			return true;
80003aae:	30 18       	mov	r8,1
80003ab0:	c1 e8       	rjmp	80003aec <udd_ep_set_halt+0x108>
	}
	
	// Stall endpoint immediately
	udd_disable_endpoint_bank_autoswitch(index);
80003ab2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003ab6:	a3 68       	lsl	r8,0x2
80003ab8:	e0 38 ff 00 	sub	r8,130816
80003abc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003ac0:	a3 69       	lsl	r9,0x2
80003ac2:	e0 39 ff 00 	sub	r9,130816
80003ac6:	72 09       	ld.w	r9,r9[0x0]
80003ac8:	a9 d9       	cbr	r9,0x9
80003aca:	91 09       	st.w	r8[0x0],r9
	udd_ack_stall(index);
80003acc:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003ad0:	a3 68       	lsl	r8,0x2
80003ad2:	e0 38 fe a0 	sub	r8,130720
80003ad6:	34 09       	mov	r9,64
80003ad8:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(index);
80003ada:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003ade:	a3 68       	lsl	r8,0x2
80003ae0:	e0 38 fe 10 	sub	r8,130576
80003ae4:	e8 69 00 00 	mov	r9,524288
80003ae8:	91 09       	st.w	r8[0x0],r9
	return true;
80003aea:	30 18       	mov	r8,1
}
80003aec:	10 9c       	mov	r12,r8
80003aee:	2f dd       	sub	sp,-12
80003af0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003af4:	00 00       	add	r0,r0
80003af6:	01 9c       	ld.ub	r12,r0[0x1]

80003af8 <udd_ep_clear_halt>:


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
80003af8:	eb cd 40 80 	pushm	r7,lr
80003afc:	1a 97       	mov	r7,sp
80003afe:	20 3d       	sub	sp,12
80003b00:	18 98       	mov	r8,r12
80003b02:	ef 68 ff f4 	st.b	r7[-12],r8
	bool b_stall_cleared = false;
80003b06:	30 08       	mov	r8,0
80003b08:	ef 68 ff fb 	st.b	r7[-5],r8
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
80003b0c:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b10:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003b14:	ef 68 ff f4 	st.b	r7[-12],r8
	if (USB_DEVICE_MAX_EP < ep)
80003b18:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003b1c:	30 38       	mov	r8,3
80003b1e:	f0 09 18 00 	cp.b	r9,r8
80003b22:	e0 88 00 04 	brls	80003b2a <udd_ep_clear_halt+0x32>
		return false;
80003b26:	30 08       	mov	r8,0
80003b28:	c8 18       	rjmp	80003c2a <udd_ep_clear_halt+0x132>
	ptr_job = &udd_ep_job[ep - 1];
80003b2a:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b2e:	f0 c9 00 01 	sub	r9,r8,1
80003b32:	12 98       	mov	r8,r9
80003b34:	a3 68       	lsl	r8,0x2
80003b36:	12 08       	add	r8,r9
80003b38:	a3 68       	lsl	r8,0x2
80003b3a:	10 99       	mov	r9,r8
80003b3c:	4b e8       	lddpc	r8,80003c34 <udd_ep_clear_halt+0x13c>
80003b3e:	f2 08 00 08 	add	r8,r9,r8
80003b42:	ef 48 ff fc 	st.w	r7[-4],r8

	if (ptr_job->stall_requested) {
80003b46:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b4a:	70 08       	ld.w	r8,r8[0x0]
80003b4c:	e6 18 20 00 	andh	r8,0x2000,COH
80003b50:	c1 c0       	breq	80003b88 <udd_ep_clear_halt+0x90>
		// Endpoint stall has been requested but not done
		// Remove stall request
		ptr_job->stall_requested = false;
80003b52:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003b56:	72 08       	ld.w	r8,r9[0x0]
80003b58:	30 0a       	mov	r10,0
80003b5a:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
80003b5e:	93 08       	st.w	r9[0x0],r8
		udd_disable_bank_interrupt(ep);
80003b60:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b64:	a3 68       	lsl	r8,0x2
80003b66:	e0 38 fd e0 	sub	r8,130528
80003b6a:	e0 69 10 00 	mov	r9,4096
80003b6e:	91 09       	st.w	r8[0x0],r9
		udd_disable_endpoint_interrupt(ep);
80003b70:	fe 68 00 00 	mov	r8,-131072
80003b74:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003b78:	e0 6a 10 00 	mov	r10,4096
80003b7c:	f4 09 09 49 	lsl	r9,r10,r9
80003b80:	91 59       	st.w	r8[0x14],r9
		b_stall_cleared = true;
80003b82:	30 18       	mov	r8,1
80003b84:	ef 68 ff fb 	st.b	r7[-5],r8
	}
	if (Is_udd_endpoint_stall_requested(ep)) { 
80003b88:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b8c:	a3 68       	lsl	r8,0x2
80003b8e:	e0 38 fe 40 	sub	r8,130624
80003b92:	70 08       	ld.w	r8,r8[0x0]
80003b94:	e6 18 00 08 	andh	r8,0x8,COH
80003b98:	c3 10       	breq	80003bfa <udd_ep_clear_halt+0x102>
		if (Is_udd_stall(ep)) {
80003b9a:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b9e:	a3 68       	lsl	r8,0x2
80003ba0:	e0 38 fe d0 	sub	r8,130768
80003ba4:	70 08       	ld.w	r8,r8[0x0]
80003ba6:	e2 18 00 40 	andl	r8,0x40,COH
80003baa:	c1 00       	breq	80003bca <udd_ep_clear_halt+0xd2>
			udd_ack_stall(ep);
80003bac:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003bb0:	a3 68       	lsl	r8,0x2
80003bb2:	e0 38 fe a0 	sub	r8,130720
80003bb6:	34 09       	mov	r9,64
80003bb8:	91 09       	st.w	r8[0x0],r9
			// A packet has been stalled
			// then reset datatoggle
			udd_reset_data_toggle(ep);
80003bba:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003bbe:	a3 68       	lsl	r8,0x2
80003bc0:	e0 38 fe 10 	sub	r8,130576
80003bc4:	e4 69 00 00 	mov	r9,262144
80003bc8:	91 09       	st.w	r8[0x0],r9
		}
		// Disable stall
		udd_disable_stall_handshake(ep);
80003bca:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003bce:	a3 68       	lsl	r8,0x2
80003bd0:	e0 38 fd e0 	sub	r8,130528
80003bd4:	e8 69 00 00 	mov	r9,524288
80003bd8:	91 09       	st.w	r8[0x0],r9
		udd_enable_endpoint_bank_autoswitch(ep);
80003bda:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003bde:	a3 68       	lsl	r8,0x2
80003be0:	e0 38 ff 00 	sub	r8,130816
80003be4:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003be8:	a3 69       	lsl	r9,0x2
80003bea:	e0 39 ff 00 	sub	r9,130816
80003bee:	72 09       	ld.w	r9,r9[0x0]
80003bf0:	a9 b9       	sbr	r9,0x9
80003bf2:	91 09       	st.w	r8[0x0],r9
		b_stall_cleared = true;
80003bf4:	30 18       	mov	r8,1
80003bf6:	ef 68 ff fb 	st.b	r7[-5],r8
	}
	if (b_stall_cleared) {
80003bfa:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003bfe:	30 08       	mov	r8,0
80003c00:	f0 09 18 00 	cp.b	r9,r8
80003c04:	c1 20       	breq	80003c28 <udd_ep_clear_halt+0x130>
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
80003c06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c0a:	70 08       	ld.w	r8,r8[0x0]
80003c0c:	e6 18 80 00 	andh	r8,0x8000,COH
80003c10:	c0 c0       	breq	80003c28 <udd_ep_clear_halt+0x130>
			ptr_job->busy = false;
80003c12:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003c16:	72 08       	ld.w	r8,r9[0x0]
80003c18:	30 0a       	mov	r10,0
80003c1a:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80003c1e:	93 08       	st.w	r9[0x0],r8
			ptr_job->call_nohalt();
80003c20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c24:	70 48       	ld.w	r8,r8[0x10]
80003c26:	5d 18       	icall	r8
		}
	}
	return true;
80003c28:	30 18       	mov	r8,1
}
80003c2a:	10 9c       	mov	r12,r8
80003c2c:	2f dd       	sub	sp,-12
80003c2e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c32:	00 00       	add	r0,r0
80003c34:	00 00       	add	r0,r0
80003c36:	01 9c       	ld.ub	r12,r0[0x1]

80003c38 <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
80003c38:	eb cd 40 80 	pushm	r7,lr
80003c3c:	1a 97       	mov	r7,sp
80003c3e:	20 7d       	sub	sp,28
80003c40:	ef 4a ff ec 	st.w	r7[-20],r10
80003c44:	ef 49 ff e8 	st.w	r7[-24],r9
80003c48:	ef 48 ff e4 	st.w	r7[-28],r8
80003c4c:	18 98       	mov	r8,r12
80003c4e:	ef 68 ff f4 	st.b	r7[-12],r8
80003c52:	16 98       	mov	r8,r11
80003c54:	ef 68 ff f0 	st.b	r7[-16],r8
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	ep &= USB_EP_ADDR_MASK;
80003c58:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003c5c:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003c60:	ef 68 ff f4 	st.b	r7[-12],r8
	if (USB_DEVICE_MAX_EP < ep) {
80003c64:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003c68:	30 38       	mov	r8,3
80003c6a:	f0 09 18 00 	cp.b	r9,r8
80003c6e:	e0 88 00 04 	brls	80003c76 <udd_ep_run+0x3e>
		return false;
80003c72:	30 08       	mov	r8,0
80003c74:	c6 88       	rjmp	80003d44 <udd_ep_run+0x10c>
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
80003c76:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003c7a:	f0 c9 00 01 	sub	r9,r8,1
80003c7e:	12 98       	mov	r8,r9
80003c80:	a3 68       	lsl	r8,0x2
80003c82:	12 08       	add	r8,r9
80003c84:	a3 68       	lsl	r8,0x2
80003c86:	10 99       	mov	r9,r8
80003c88:	4b 18       	lddpc	r8,80003d4c <udd_ep_run+0x114>
80003c8a:	f2 08 00 08 	add	r8,r9,r8
80003c8e:	ef 48 ff f8 	st.w	r7[-8],r8

	if ((!Is_udd_endpoint_enabled(ep))
80003c92:	fe 68 00 00 	mov	r8,-131072
80003c96:	70 79       	ld.w	r9,r8[0x1c]
80003c98:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003c9c:	30 1a       	mov	r10,1
80003c9e:	f4 08 09 48 	lsl	r8,r10,r8
80003ca2:	f3 e8 00 08 	and	r8,r9,r8
80003ca6:	c1 00       	breq	80003cc6 <udd_ep_run+0x8e>
			|| Is_udd_endpoint_stall_requested(ep)
80003ca8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003cac:	a3 68       	lsl	r8,0x2
80003cae:	e0 38 fe 40 	sub	r8,130624
80003cb2:	70 08       	ld.w	r8,r8[0x0]
80003cb4:	e6 18 00 08 	andh	r8,0x8,COH
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80003cb8:	c0 71       	brne	80003cc6 <udd_ep_run+0x8e>
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested) {
80003cba:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cbe:	70 08       	ld.w	r8,r8[0x0]
80003cc0:	e6 18 20 00 	andh	r8,0x2000,COH
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80003cc4:	c0 30       	breq	80003cca <udd_ep_run+0x92>
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested) {
		return false; // Endpoint is halted
80003cc6:	30 08       	mov	r8,0
80003cc8:	c3 e8       	rjmp	80003d44 <udd_ep_run+0x10c>
	}

	flags = cpu_irq_save();
80003cca:	f0 1f 00 22 	mcall	80003d50 <udd_ep_run+0x118>
80003cce:	18 98       	mov	r8,r12
80003cd0:	ef 48 ff fc 	st.w	r7[-4],r8
	if (ptr_job->busy == true) {
80003cd4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003cd8:	70 08       	ld.w	r8,r8[0x0]
80003cda:	e6 18 80 00 	andh	r8,0x8000,COH
80003cde:	c0 70       	breq	80003cec <udd_ep_run+0xb4>
		cpu_irq_restore(flags);
80003ce0:	ee fc ff fc 	ld.w	r12,r7[-4]
80003ce4:	f0 1f 00 1c 	mcall	80003d54 <udd_ep_run+0x11c>
		return false; // Job already on going
80003ce8:	30 08       	mov	r8,0
80003cea:	c2 d8       	rjmp	80003d44 <udd_ep_run+0x10c>
	}
	ptr_job->busy = true;
80003cec:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003cf0:	72 08       	ld.w	r8,r9[0x0]
80003cf2:	30 1a       	mov	r10,1
80003cf4:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80003cf8:	93 08       	st.w	r9[0x0],r8
	cpu_irq_restore(flags);
80003cfa:	ee fc ff fc 	ld.w	r12,r7[-4]
80003cfe:	f0 1f 00 16 	mcall	80003d54 <udd_ep_run+0x11c>

	// No job running. Let's setup a new one.
	//
	ptr_job->buf = buf;
80003d02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d06:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003d0a:	91 19       	st.w	r8[0x4],r9
	ptr_job->buf_size = buf_size;
80003d0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d10:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003d14:	91 29       	st.w	r8[0x8],r9
	ptr_job->nb_trans = 0;
80003d16:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d1a:	30 09       	mov	r9,0
80003d1c:	91 39       	st.w	r8[0xc],r9
	ptr_job->call_trans = callback;
80003d1e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d22:	ee f9 ff e4 	ld.w	r9,r7[-28]
80003d26:	91 49       	st.w	r8[0x10],r9
	ptr_job->b_shortpacket = b_shortpacket;
80003d28:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003d2c:	72 08       	ld.w	r8,r9[0x0]
80003d2e:	ef 3a ff f0 	ld.ub	r10,r7[-16]
80003d32:	f1 da d3 c1 	bfins	r8,r10,0x1e,0x1
80003d36:	93 08       	st.w	r9[0x0],r8


	// Request first transfer
	udd_ep_trans_done(ep);
80003d38:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003d3c:	10 9c       	mov	r12,r8
80003d3e:	f0 1f 00 07 	mcall	80003d58 <udd_ep_run+0x120>
	return true;
80003d42:	30 18       	mov	r8,1
}
80003d44:	10 9c       	mov	r12,r8
80003d46:	2f 9d       	sub	sp,-28
80003d48:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d4c:	00 00       	add	r0,r0
80003d4e:	01 9c       	ld.ub	r12,r0[0x1]
80003d50:	80 00       	ld.sh	r0,r0[0x0]
80003d52:	2f c2       	sub	r2,-4
80003d54:	80 00       	ld.sh	r0,r0[0x0]
80003d56:	30 00       	mov	r0,0
80003d58:	80 00       	ld.sh	r0,r0[0x0]
80003d5a:	47 dc       	lddsp	r12,sp[0x1f4]

80003d5c <udd_ep_abort>:


void udd_ep_abort(udd_ep_id_t ep)
{
80003d5c:	eb cd 40 80 	pushm	r7,lr
80003d60:	1a 97       	mov	r7,sp
80003d62:	20 2d       	sub	sp,8
80003d64:	18 98       	mov	r8,r12
80003d66:	ef 68 ff f8 	st.b	r7[-8],r8
	uint8_t index = ep & USB_EP_ADDR_MASK;
80003d6a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003d6e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003d72:	ef 68 ff ff 	st.b	r7[-1],r8

	// Stop DMA transfer
	udd_disable_endpoint_dma_interrupt(index);
80003d76:	fe 68 00 00 	mov	r8,-131072
80003d7a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003d7e:	20 19       	sub	r9,1
80003d80:	30 0a       	mov	r10,0
80003d82:	ea 1a 02 00 	orh	r10,0x200
80003d86:	f4 09 09 49 	lsl	r9,r10,r9
80003d8a:	91 59       	st.w	r8[0x14],r9
	udd_endpoint_dma_set_control(index, 0);
80003d8c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003d90:	a5 68       	lsl	r8,0x4
80003d92:	e0 38 fd 00 	sub	r8,130304
80003d96:	30 09       	mov	r9,0
80003d98:	91 29       	st.w	r8[0x8],r9
	// Kill banks
	udd_disable_endpoint_interrupt(index);
80003d9a:	fe 68 00 00 	mov	r8,-131072
80003d9e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003da2:	e0 6a 10 00 	mov	r10,4096
80003da6:	f4 09 09 49 	lsl	r9,r10,r9
80003daa:	91 59       	st.w	r8[0x14],r9
	while (udd_nb_busy_bank(index)) {
80003dac:	c1 28       	rjmp	80003dd0 <udd_ep_abort+0x74>
		udd_kill_last_in_bank(index);
80003dae:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003db2:	a3 68       	lsl	r8,0x2
80003db4:	e0 38 fe 10 	sub	r8,130576
80003db8:	e0 69 20 00 	mov	r9,8192
80003dbc:	91 09       	st.w	r8[0x0],r9
		while(Is_udd_killing_last_in_bank(index));
80003dbe:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003dc2:	a3 68       	lsl	r8,0x2
80003dc4:	e0 38 fe 40 	sub	r8,130624
80003dc8:	70 08       	ld.w	r8,r8[0x0]
80003dca:	e2 18 20 00 	andl	r8,0x2000,COH
80003dce:	cf 81       	brne	80003dbe <udd_ep_abort+0x62>
	// Stop DMA transfer
	udd_disable_endpoint_dma_interrupt(index);
	udd_endpoint_dma_set_control(index, 0);
	// Kill banks
	udd_disable_endpoint_interrupt(index);
	while (udd_nb_busy_bank(index)) {
80003dd0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003dd4:	a3 68       	lsl	r8,0x2
80003dd6:	e0 38 fe d0 	sub	r8,130768
80003dda:	70 08       	ld.w	r8,r8[0x0]
80003ddc:	e2 18 30 00 	andl	r8,0x3000,COH
80003de0:	ad 88       	lsr	r8,0xc
80003de2:	ce 61       	brne	80003dae <udd_ep_abort+0x52>
		udd_kill_last_in_bank(index);
		while(Is_udd_killing_last_in_bank(index));
	}
	udd_ep_abort_job(ep);
80003de4:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003de8:	10 9c       	mov	r12,r8
80003dea:	f0 1f 00 03 	mcall	80003df4 <udd_ep_abort+0x98>
}
80003dee:	2f ed       	sub	sp,-8
80003df0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003df4:	80 00       	ld.sh	r0,r0[0x0]
80003df6:	47 0c       	lddsp	r12,sp[0x1c0]

80003df8 <udd_reset_ep_ctrl>:

//--------------------------------------------------------
//--- INTERNAL ROUTINES TO MANAGED THE CONTROL ENDPOINT

static void udd_reset_ep_ctrl(void)
{
80003df8:	eb cd 40 80 	pushm	r7,lr
80003dfc:	1a 97       	mov	r7,sp
80003dfe:	20 7d       	sub	sp,28
	irqflags_t flags;

	// Reset USB address to 0
	udd_configure_address(0);
80003e00:	fe 68 00 00 	mov	r8,-131072
80003e04:	fe 69 00 00 	mov	r9,-131072
80003e08:	72 09       	ld.w	r9,r9[0x0]
80003e0a:	e0 19 ff 80 	andl	r9,0xff80
80003e0e:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
80003e10:	fe 68 00 00 	mov	r8,-131072
80003e14:	fe 69 00 00 	mov	r9,-131072
80003e18:	72 09       	ld.w	r9,r9[0x0]
80003e1a:	a7 b9       	sbr	r9,0x7
80003e1c:	91 09       	st.w	r8[0x0],r9

	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
80003e1e:	fe 68 01 00 	mov	r8,-130816
80003e22:	fe 69 01 00 	mov	r9,-130816
80003e26:	72 09       	ld.w	r9,r9[0x0]
80003e28:	12 9a       	mov	r10,r9
80003e2a:	e0 1a e6 83 	andl	r10,0xe683
80003e2e:	34 09       	mov	r9,64
80003e30:	ef 49 ff f8 	st.w	r7[-8],r9
80003e34:	30 89       	mov	r9,8
80003e36:	ef 49 ff fc 	st.w	r7[-4],r9
80003e3a:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003e3e:	ee fb ff fc 	ld.w	r11,r7[-4]
80003e42:	f2 0b 0c 49 	max	r9,r9,r11
80003e46:	ef 49 ff f4 	st.w	r7[-12],r9
80003e4a:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003e4e:	ef 49 ff ec 	st.w	r7[-20],r9
80003e52:	e0 69 04 00 	mov	r9,1024
80003e56:	ef 49 ff f0 	st.w	r7[-16],r9
80003e5a:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003e5e:	ee fb ff f0 	ld.w	r11,r7[-16]
80003e62:	f2 0b 0d 49 	min	r9,r9,r11
80003e66:	ef 49 ff e8 	st.w	r7[-24],r9
80003e6a:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003e6e:	a1 79       	lsl	r9,0x1
80003e70:	20 19       	sub	r9,1
80003e72:	f2 09 12 00 	clz	r9,r9
80003e76:	f2 09 11 1c 	rsub	r9,r9,28
80003e7a:	a5 69       	lsl	r9,0x4
80003e7c:	e2 19 19 7c 	andl	r9,0x197c,COH
80003e80:	f5 e9 10 09 	or	r9,r10,r9
80003e84:	91 09       	st.w	r8[0x0],r9
			USB_EP_TYPE_CONTROL,
			0,
			USB_DEVICE_EP_CTRL_SIZE, AVR32_USBB_UECFG0_EPBK_SINGLE);

	udd_allocate_memory(0);
80003e86:	fe 68 01 00 	mov	r8,-130816
80003e8a:	fe 69 01 00 	mov	r9,-130816
80003e8e:	72 09       	ld.w	r9,r9[0x0]
80003e90:	a1 b9       	sbr	r9,0x1
80003e92:	91 09       	st.w	r8[0x0],r9
	udd_enable_endpoint(0);
80003e94:	fe 68 00 00 	mov	r8,-131072
80003e98:	fe 69 00 00 	mov	r9,-131072
80003e9c:	72 79       	ld.w	r9,r9[0x1c]
80003e9e:	a1 a9       	sbr	r9,0x0
80003ea0:	91 79       	st.w	r8[0x1c],r9
	flags = cpu_irq_save();
80003ea2:	f0 1f 00 0d 	mcall	80003ed4 <udd_reset_ep_ctrl+0xdc>
80003ea6:	18 98       	mov	r8,r12
80003ea8:	ef 48 ff e4 	st.w	r7[-28],r8
	udd_enable_setup_received_interrupt(0);
80003eac:	fe 68 01 f0 	mov	r8,-130576
80003eb0:	30 49       	mov	r9,4
80003eb2:	91 09       	st.w	r8[0x0],r9
	udd_enable_out_received_interrupt(0);
80003eb4:	fe 68 01 f0 	mov	r8,-130576
80003eb8:	30 29       	mov	r9,2
80003eba:	91 09       	st.w	r8[0x0],r9
	udd_enable_endpoint_interrupt(0);
80003ebc:	fe 68 00 00 	mov	r8,-131072
80003ec0:	e0 69 10 00 	mov	r9,4096
80003ec4:	91 69       	st.w	r8[0x18],r9
	cpu_irq_restore(flags);
80003ec6:	ee fc ff e4 	ld.w	r12,r7[-28]
80003eca:	f0 1f 00 04 	mcall	80003ed8 <udd_reset_ep_ctrl+0xe0>
}
80003ece:	2f 9d       	sub	sp,-28
80003ed0:	e3 cd 80 80 	ldm	sp++,r7,pc
80003ed4:	80 00       	ld.sh	r0,r0[0x0]
80003ed6:	2f c2       	sub	r2,-4
80003ed8:	80 00       	ld.sh	r0,r0[0x0]
80003eda:	30 00       	mov	r0,0

80003edc <udd_ctrl_init>:

static void udd_ctrl_init(void)
{
80003edc:	eb cd 40 80 	pushm	r7,lr
80003ee0:	1a 97       	mov	r7,sp
80003ee2:	20 1d       	sub	sp,4
	irqflags_t flags;
	flags = cpu_irq_save();
80003ee4:	f0 1f 00 10 	mcall	80003f24 <udd_ctrl_init+0x48>
80003ee8:	18 98       	mov	r8,r12
80003eea:	ef 48 ff fc 	st.w	r7[-4],r8
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI),
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
80003eee:	fe 68 02 20 	mov	r8,-130528
80003ef2:	30 19       	mov	r9,1
80003ef4:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
80003ef6:	ee fc ff fc 	ld.w	r12,r7[-4]
80003efa:	f0 1f 00 0c 	mcall	80003f28 <udd_ctrl_init+0x4c>

	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
80003efe:	fe 68 01 60 	mov	r8,-130720
80003f02:	30 29       	mov	r9,2
80003f04:	91 09       	st.w	r8[0x0],r9

	udd_g_ctrlreq.callback = NULL;
80003f06:	48 a8       	lddpc	r8,80003f2c <udd_ctrl_init+0x50>
80003f08:	30 09       	mov	r9,0
80003f0a:	91 49       	st.w	r8[0x10],r9
	udd_g_ctrlreq.over_under_run = NULL;
80003f0c:	48 88       	lddpc	r8,80003f2c <udd_ctrl_init+0x50>
80003f0e:	30 09       	mov	r9,0
80003f10:	91 59       	st.w	r8[0x14],r9
	udd_g_ctrlreq.payload_size = 0;
80003f12:	48 79       	lddpc	r9,80003f2c <udd_ctrl_init+0x50>
80003f14:	30 08       	mov	r8,0
80003f16:	b2 68       	st.h	r9[0xc],r8
	udd_ep_control_state = UDD_EPCTRL_SETUP;
80003f18:	48 68       	lddpc	r8,80003f30 <udd_ctrl_init+0x54>
80003f1a:	30 09       	mov	r9,0
80003f1c:	91 09       	st.w	r8[0x0],r9
}
80003f1e:	2f fd       	sub	sp,-4
80003f20:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f24:	80 00       	ld.sh	r0,r0[0x0]
80003f26:	2f c2       	sub	r2,-4
80003f28:	80 00       	ld.sh	r0,r0[0x0]
80003f2a:	30 00       	mov	r0,0
80003f2c:	00 00       	add	r0,r0
80003f2e:	46 48       	lddsp	r8,sp[0x190]
80003f30:	00 00       	add	r0,r0
80003f32:	01 94       	ld.ub	r4,r0[0x1]

80003f34 <udd_ctrl_setup_received>:


static void udd_ctrl_setup_received(void)
{
80003f34:	eb cd 40 80 	pushm	r7,lr
80003f38:	1a 97       	mov	r7,sp
80003f3a:	20 3d       	sub	sp,12
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
80003f3c:	4c c8       	lddpc	r8,8000406c <udd_ctrl_setup_received+0x138>
80003f3e:	70 08       	ld.w	r8,r8[0x0]
80003f40:	58 08       	cp.w	r8,0
80003f42:	c0 50       	breq	80003f4c <udd_ctrl_setup_received+0x18>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
80003f44:	f0 1f 00 4b 	mcall	80004070 <udd_ctrl_setup_received+0x13c>

		// Reinitializes control endpoint management
		udd_ctrl_init();
80003f48:	f0 1f 00 4b 	mcall	80004074 <udd_ctrl_setup_received+0x140>
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
80003f4c:	fe 68 01 30 	mov	r8,-130768
80003f50:	70 08       	ld.w	r8,r8[0x0]
80003f52:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80003f56:	b5 88       	lsr	r8,0x14
80003f58:	58 88       	cp.w	r8,8
80003f5a:	c0 80       	breq	80003f6a <udd_ctrl_setup_received+0x36>
		udd_ctrl_stall_data();
80003f5c:	f0 1f 00 47 	mcall	80004078 <udd_ctrl_setup_received+0x144>
		udd_ack_setup_received(0);
80003f60:	fe 68 01 60 	mov	r8,-130720
80003f64:	30 49       	mov	r9,4
80003f66:	91 09       	st.w	r8[0x0],r9
		return; // Error data number doesn't correspond to SETUP packet
80003f68:	c7 e8       	rjmp	80004064 <udd_ctrl_setup_received+0x130>
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
80003f6a:	30 08       	mov	r8,0
80003f6c:	ea 18 d0 00 	orh	r8,0xd000
80003f70:	ef 48 ff fc 	st.w	r7[-4],r8
	for (i = 0; i < 8; i++) {
80003f74:	30 08       	mov	r8,0
80003f76:	ef 68 ff fb 	st.b	r7[-5],r8
80003f7a:	c1 38       	rjmp	80003fa0 <udd_ctrl_setup_received+0x6c>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
80003f7c:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003f80:	4b f8       	lddpc	r8,8000407c <udd_ctrl_setup_received+0x148>
80003f82:	10 09       	add	r9,r8
80003f84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f88:	11 88       	ld.ub	r8,r8[0x0]
80003f8a:	b2 88       	st.b	r9[0x0],r8
80003f8c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003f90:	2f f8       	sub	r8,-1
80003f92:	ef 48 ff fc 	st.w	r7[-4],r8
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return; // Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
80003f96:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003f9a:	2f f8       	sub	r8,-1
80003f9c:	ef 68 ff fb 	st.b	r7[-5],r8
80003fa0:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003fa4:	30 78       	mov	r8,7
80003fa6:	f0 09 18 00 	cp.b	r9,r8
80003faa:	fe 98 ff e9 	brls	80003f7c <udd_ctrl_setup_received+0x48>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
80003fae:	4b 48       	lddpc	r8,8000407c <udd_ctrl_setup_received+0x148>
80003fb0:	90 18       	ld.sh	r8,r8[0x2]
80003fb2:	5c 88       	casts.h	r8
80003fb4:	5c c8       	swap.bh	r8
80003fb6:	5c 88       	casts.h	r8
80003fb8:	4b 19       	lddpc	r9,8000407c <udd_ctrl_setup_received+0x148>
80003fba:	b2 18       	st.h	r9[0x2],r8
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
80003fbc:	4b 08       	lddpc	r8,8000407c <udd_ctrl_setup_received+0x148>
80003fbe:	90 28       	ld.sh	r8,r8[0x4]
80003fc0:	5c 88       	casts.h	r8
80003fc2:	5c c8       	swap.bh	r8
80003fc4:	5c 88       	casts.h	r8
80003fc6:	4a e9       	lddpc	r9,8000407c <udd_ctrl_setup_received+0x148>
80003fc8:	b2 28       	st.h	r9[0x4],r8
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
80003fca:	4a d8       	lddpc	r8,8000407c <udd_ctrl_setup_received+0x148>
80003fcc:	90 38       	ld.sh	r8,r8[0x6]
80003fce:	5c 88       	casts.h	r8
80003fd0:	5c c8       	swap.bh	r8
80003fd2:	5c 88       	casts.h	r8
80003fd4:	4a a9       	lddpc	r9,8000407c <udd_ctrl_setup_received+0x148>
80003fd6:	b2 38       	st.h	r9[0x6],r8

	// Decode setup request
	if (udc_process_setup() == false) {
80003fd8:	f0 1f 00 2a 	mcall	80004080 <udd_ctrl_setup_received+0x14c>
80003fdc:	18 98       	mov	r8,r12
80003fde:	ec 18 00 01 	eorl	r8,0x1
80003fe2:	5c 58       	castu.b	r8
80003fe4:	c0 80       	breq	80003ff4 <udd_ctrl_setup_received+0xc0>
		// Setup request unknown then stall it
		udd_ctrl_stall_data();
80003fe6:	f0 1f 00 25 	mcall	80004078 <udd_ctrl_setup_received+0x144>
		udd_ack_setup_received(0);
80003fea:	fe 68 01 60 	mov	r8,-130720
80003fee:	30 49       	mov	r9,4
80003ff0:	91 09       	st.w	r8[0x0],r9
		return;
80003ff2:	c3 98       	rjmp	80004064 <udd_ctrl_setup_received+0x130>
	}
	udd_ack_setup_received(0);
80003ff4:	fe 68 01 60 	mov	r8,-130720
80003ff8:	30 49       	mov	r9,4
80003ffa:	91 09       	st.w	r8[0x0],r9

	if (Udd_setup_is_in()) {
80003ffc:	4a 08       	lddpc	r8,8000407c <udd_ctrl_setup_received+0x148>
80003ffe:	11 88       	ld.ub	r8,r8[0x0]
80004000:	10 99       	mov	r9,r8
80004002:	30 08       	mov	r8,0
80004004:	f0 09 18 00 	cp.b	r9,r8
80004008:	c0 d4       	brge	80004022 <udd_ctrl_setup_received+0xee>
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
8000400a:	49 f9       	lddpc	r9,80004084 <udd_ctrl_setup_received+0x150>
8000400c:	30 08       	mov	r8,0
8000400e:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80004010:	49 e9       	lddpc	r9,80004088 <udd_ctrl_setup_received+0x154>
80004012:	30 08       	mov	r8,0
80004014:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
80004016:	49 68       	lddpc	r8,8000406c <udd_ctrl_setup_received+0x138>
80004018:	30 29       	mov	r9,2
8000401a:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_in_sent(); // Send first data transfer
8000401c:	f0 1f 00 1c 	mcall	8000408c <udd_ctrl_setup_received+0x158>
80004020:	c2 28       	rjmp	80004064 <udd_ctrl_setup_received+0x130>
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
80004022:	49 78       	lddpc	r8,8000407c <udd_ctrl_setup_received+0x148>
80004024:	90 38       	ld.sh	r8,r8[0x6]
80004026:	58 08       	cp.w	r8,0
80004028:	c0 41       	brne	80004030 <udd_ctrl_setup_received+0xfc>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
8000402a:	f0 1f 00 1a 	mcall	80004090 <udd_ctrl_setup_received+0x15c>
			return;
8000402e:	c1 b8       	rjmp	80004064 <udd_ctrl_setup_received+0x130>
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80004030:	49 59       	lddpc	r9,80004084 <udd_ctrl_setup_received+0x150>
80004032:	30 08       	mov	r8,0
80004034:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80004036:	49 59       	lddpc	r9,80004088 <udd_ctrl_setup_received+0x154>
80004038:	30 08       	mov	r8,0
8000403a:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
8000403c:	48 c8       	lddpc	r8,8000406c <udd_ctrl_setup_received+0x138>
8000403e:	30 19       	mov	r9,1
80004040:	91 09       	st.w	r8[0x0],r9
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
80004042:	fe 68 01 60 	mov	r8,-130720
80004046:	31 09       	mov	r9,16
80004048:	91 09       	st.w	r8[0x0],r9
		flags = cpu_irq_save();
8000404a:	f0 1f 00 13 	mcall	80004094 <udd_ctrl_setup_received+0x160>
8000404e:	18 98       	mov	r8,r12
80004050:	ef 48 ff f4 	st.w	r7[-12],r8
		udd_enable_nak_in_interrupt(0);
80004054:	fe 68 01 f0 	mov	r8,-130576
80004058:	31 09       	mov	r9,16
8000405a:	91 09       	st.w	r8[0x0],r9
		cpu_irq_restore(flags);
8000405c:	ee fc ff f4 	ld.w	r12,r7[-12]
80004060:	f0 1f 00 0e 	mcall	80004098 <udd_ctrl_setup_received+0x164>
	}
}
80004064:	2f dd       	sub	sp,-12
80004066:	e3 cd 80 80 	ldm	sp++,r7,pc
8000406a:	00 00       	add	r0,r0
8000406c:	00 00       	add	r0,r0
8000406e:	01 94       	ld.ub	r4,r0[0x1]
80004070:	80 00       	ld.sh	r0,r0[0x0]
80004072:	45 60       	lddsp	r0,sp[0x158]
80004074:	80 00       	ld.sh	r0,r0[0x0]
80004076:	3e dc       	mov	r12,-19
80004078:	80 00       	ld.sh	r0,r0[0x0]
8000407a:	44 a8       	lddsp	r8,sp[0x128]
8000407c:	00 00       	add	r0,r0
8000407e:	46 48       	lddsp	r8,sp[0x190]
80004080:	80 00       	ld.sh	r0,r0[0x0]
80004082:	72 a0       	ld.w	r0,r9[0x28]
80004084:	00 00       	add	r0,r0
80004086:	01 98       	ld.ub	r8,r0[0x1]
80004088:	00 00       	add	r0,r0
8000408a:	01 9a       	ld.ub	r10,r0[0x1]
8000408c:	80 00       	ld.sh	r0,r0[0x0]
8000408e:	40 9c       	lddsp	r12,sp[0x24]
80004090:	80 00       	ld.sh	r0,r0[0x0]
80004092:	44 c8       	lddsp	r8,sp[0x130]
80004094:	80 00       	ld.sh	r0,r0[0x0]
80004096:	2f c2       	sub	r2,-4
80004098:	80 00       	ld.sh	r0,r0[0x0]
8000409a:	30 00       	mov	r0,0

8000409c <udd_ctrl_in_sent>:


static void udd_ctrl_in_sent(void)
{
8000409c:	eb cd 40 80 	pushm	r7,lr
800040a0:	1a 97       	mov	r7,sp
800040a2:	20 4d       	sub	sp,16
	uint16_t nb_remain;
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
800040a4:	f0 1f 00 5c 	mcall	80004214 <udd_ctrl_in_sent+0x178>
800040a8:	18 98       	mov	r8,r12
800040aa:	ef 48 ff fc 	st.w	r7[-4],r8
	udd_disable_in_send_interrupt(0);
800040ae:	fe 68 02 20 	mov	r8,-130528
800040b2:	30 19       	mov	r9,1
800040b4:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
800040b6:	ee fc ff fc 	ld.w	r12,r7[-4]
800040ba:	f0 1f 00 58 	mcall	80004218 <udd_ctrl_in_sent+0x17c>

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
800040be:	4d 88       	lddpc	r8,8000421c <udd_ctrl_in_sent+0x180>
800040c0:	70 08       	ld.w	r8,r8[0x0]
800040c2:	58 38       	cp.w	r8,3
800040c4:	c0 61       	brne	800040d0 <udd_ctrl_in_sent+0x34>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
800040c6:	f0 1f 00 57 	mcall	80004220 <udd_ctrl_in_sent+0x184>
		// Reinitializes control endpoint management
		udd_ctrl_init();
800040ca:	f0 1f 00 57 	mcall	80004224 <udd_ctrl_in_sent+0x188>
		return;
800040ce:	ca 08       	rjmp	8000420e <udd_ctrl_in_sent+0x172>
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
800040d0:	4d 68       	lddpc	r8,80004228 <udd_ctrl_in_sent+0x18c>
800040d2:	90 69       	ld.sh	r9,r8[0xc]
800040d4:	4d 68       	lddpc	r8,8000422c <udd_ctrl_in_sent+0x190>
800040d6:	90 08       	ld.sh	r8,r8[0x0]
800040d8:	10 19       	sub	r9,r8
800040da:	ef 59 ff f0 	st.h	r7[-16],r9
	if (0 == nb_remain) {
800040de:	ef 09 ff f0 	ld.sh	r9,r7[-16]
800040e2:	30 08       	mov	r8,0
800040e4:	f0 09 19 00 	cp.h	r9,r8
800040e8:	c2 b1       	brne	8000413e <udd_ctrl_in_sent+0xa2>
		// All content of current buffer payload are sent
		// Update number of total data sending by previous payload buffer
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
800040ea:	4d 28       	lddpc	r8,80004230 <udd_ctrl_in_sent+0x194>
800040ec:	90 09       	ld.sh	r9,r8[0x0]
800040ee:	4d 08       	lddpc	r8,8000422c <udd_ctrl_in_sent+0x190>
800040f0:	90 08       	ld.sh	r8,r8[0x0]
800040f2:	f2 08 00 08 	add	r8,r9,r8
800040f6:	5c 88       	casts.h	r8
800040f8:	4c e9       	lddpc	r9,80004230 <udd_ctrl_in_sent+0x194>
800040fa:	b2 08       	st.h	r9[0x0],r8
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans)
800040fc:	4c b8       	lddpc	r8,80004228 <udd_ctrl_in_sent+0x18c>
800040fe:	90 39       	ld.sh	r9,r8[0x6]
80004100:	4c c8       	lddpc	r8,80004230 <udd_ctrl_in_sent+0x194>
80004102:	90 08       	ld.sh	r8,r8[0x0]
80004104:	f0 09 19 00 	cp.h	r9,r8
80004108:	c0 50       	breq	80004112 <udd_ctrl_in_sent+0x76>
8000410a:	4c b8       	lddpc	r8,80004234 <udd_ctrl_in_sent+0x198>
8000410c:	11 88       	ld.ub	r8,r8[0x0]
8000410e:	58 08       	cp.w	r8,0
80004110:	c0 40       	breq	80004118 <udd_ctrl_in_sent+0x7c>
					|| b_shortpacket) {
			// All data requested are transfered or a short packet has been sent
			// then it is the end of data phase.
			// Generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
80004112:	f0 1f 00 4a 	mcall	80004238 <udd_ctrl_in_sent+0x19c>
			return;
80004116:	c7 c8       	rjmp	8000420e <udd_ctrl_in_sent+0x172>
		}
		// Need of new buffer because the data phase is not complete
		if ((!udd_g_ctrlreq.over_under_run)
80004118:	4c 48       	lddpc	r8,80004228 <udd_ctrl_in_sent+0x18c>
8000411a:	70 58       	ld.w	r8,r8[0x14]
8000411c:	58 08       	cp.w	r8,0
8000411e:	c1 00       	breq	8000413e <udd_ctrl_in_sent+0xa2>
80004120:	4c 28       	lddpc	r8,80004228 <udd_ctrl_in_sent+0x18c>
80004122:	70 58       	ld.w	r8,r8[0x14]
80004124:	5d 18       	icall	r8
80004126:	18 98       	mov	r8,r12
80004128:	ec 18 00 01 	eorl	r8,0x1
8000412c:	5c 58       	castu.b	r8
8000412e:	c0 81       	brne	8000413e <udd_ctrl_in_sent+0xa2>
				|| (!udd_g_ctrlreq.over_under_run())) {
			// Underrun then send zlp on IN
			// Here nb_remain=0 and allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			udd_ctrl_payload_nb_trans = 0;
80004130:	4b f9       	lddpc	r9,8000422c <udd_ctrl_in_sent+0x190>
80004132:	30 08       	mov	r8,0
80004134:	b2 08       	st.h	r9[0x0],r8
			nb_remain = udd_g_ctrlreq.payload_size;
80004136:	4b d8       	lddpc	r8,80004228 <udd_ctrl_in_sent+0x18c>
80004138:	90 68       	ld.sh	r8,r8[0xc]
8000413a:	ef 58 ff f0 	st.h	r7[-16],r8
		}
	}
	// Continue transfer and send next data
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
8000413e:	ef 09 ff f0 	ld.sh	r9,r7[-16]
80004142:	33 f8       	mov	r8,63
80004144:	f0 09 19 00 	cp.h	r9,r8
80004148:	e0 88 00 09 	brls	8000415a <udd_ctrl_in_sent+0xbe>
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
8000414c:	34 08       	mov	r8,64
8000414e:	ef 58 ff f0 	st.h	r7[-16],r8
		b_shortpacket = false;
80004152:	4b 99       	lddpc	r9,80004234 <udd_ctrl_in_sent+0x198>
80004154:	30 08       	mov	r8,0
80004156:	b2 88       	st.b	r9[0x0],r8
80004158:	c0 48       	rjmp	80004160 <udd_ctrl_in_sent+0xc4>
	} else {
		b_shortpacket = true;
8000415a:	4b 79       	lddpc	r9,80004234 <udd_ctrl_in_sent+0x198>
8000415c:	30 18       	mov	r8,1
8000415e:	b2 88       	st.b	r9[0x0],r8
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
80004160:	30 08       	mov	r8,0
80004162:	ea 18 d0 00 	orh	r8,0xd000
80004166:	ef 48 ff f4 	st.w	r7[-12],r8
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
8000416a:	4b 08       	lddpc	r8,80004228 <udd_ctrl_in_sent+0x18c>
8000416c:	70 29       	ld.w	r9,r8[0x8]
8000416e:	4b 08       	lddpc	r8,8000422c <udd_ctrl_in_sent+0x190>
80004170:	90 08       	ld.sh	r8,r8[0x0]
80004172:	5c 78       	castu.h	r8
80004174:	f2 08 00 08 	add	r8,r9,r8
80004178:	ef 48 ff f8 	st.w	r7[-8],r8
	// The IN data don't must be written in endpoint 0 DPRAM during
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write
	// and if no OUT ZLP is received the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
8000417c:	f0 1f 00 26 	mcall	80004214 <udd_ctrl_in_sent+0x178>
80004180:	18 98       	mov	r8,r12
80004182:	ef 48 ff fc 	st.w	r7[-4],r8
	if (Is_udd_out_received(0)) {
80004186:	fe 68 01 30 	mov	r8,-130768
8000418a:	70 08       	ld.w	r8,r8[0x0]
8000418c:	e2 18 00 02 	andl	r8,0x2,COH
80004190:	c0 90       	breq	800041a2 <udd_ctrl_in_sent+0x106>
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
80004192:	ee fc ff fc 	ld.w	r12,r7[-4]
80004196:	f0 1f 00 21 	mcall	80004218 <udd_ctrl_in_sent+0x17c>
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
8000419a:	4a 18       	lddpc	r8,8000421c <udd_ctrl_in_sent+0x180>
8000419c:	30 49       	mov	r9,4
8000419e:	91 09       	st.w	r8[0x0],r9
		return; // Exit of IN DATA phase
800041a0:	c3 78       	rjmp	8000420e <udd_ctrl_in_sent+0x172>
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
800041a2:	30 08       	mov	r8,0
800041a4:	ef 68 ff f3 	st.b	r7[-13],r8
800041a8:	c1 68       	rjmp	800041d4 <udd_ctrl_in_sent+0x138>
		*ptr_dest++ = *ptr_src++;
800041aa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041ae:	11 88       	ld.ub	r8,r8[0x0]
800041b0:	ee f9 ff f4 	ld.w	r9,r7[-12]
800041b4:	b2 88       	st.b	r9[0x0],r8
800041b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041ba:	2f f8       	sub	r8,-1
800041bc:	ef 48 ff f4 	st.w	r7[-12],r8
800041c0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041c4:	2f f8       	sub	r8,-1
800041c6:	ef 48 ff f8 	st.w	r7[-8],r8
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return; // Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
800041ca:	ef 38 ff f3 	ld.ub	r8,r7[-13]
800041ce:	2f f8       	sub	r8,-1
800041d0:	ef 68 ff f3 	st.b	r7[-13],r8
800041d4:	ef 38 ff f3 	ld.ub	r8,r7[-13]
800041d8:	ef 09 ff f0 	ld.sh	r9,r7[-16]
800041dc:	f0 09 19 00 	cp.h	r9,r8
800041e0:	fe 9b ff e5 	brhi	800041aa <udd_ctrl_in_sent+0x10e>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_remain;
800041e4:	49 28       	lddpc	r8,8000422c <udd_ctrl_in_sent+0x190>
800041e6:	90 08       	ld.sh	r8,r8[0x0]
800041e8:	ef 09 ff f0 	ld.sh	r9,r7[-16]
800041ec:	f2 08 00 08 	add	r8,r9,r8
800041f0:	5c 88       	casts.h	r8
800041f2:	48 f9       	lddpc	r9,8000422c <udd_ctrl_in_sent+0x190>
800041f4:	b2 08       	st.h	r9[0x0],r8

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
800041f6:	fe 68 01 60 	mov	r8,-130720
800041fa:	30 19       	mov	r9,1
800041fc:	91 09       	st.w	r8[0x0],r9
	udd_enable_in_send_interrupt(0);
800041fe:	fe 68 01 f0 	mov	r8,-130576
80004202:	30 19       	mov	r9,1
80004204:	91 09       	st.w	r8[0x0],r9
	// In case of abort of DATA IN phase, no need to enable nak OUT interrupt
	// because OUT endpoint is already free and ZLP OUT accepted.
	cpu_irq_restore(flags);
80004206:	ee fc ff fc 	ld.w	r12,r7[-4]
8000420a:	f0 1f 00 04 	mcall	80004218 <udd_ctrl_in_sent+0x17c>
}
8000420e:	2f cd       	sub	sp,-16
80004210:	e3 cd 80 80 	ldm	sp++,r7,pc
80004214:	80 00       	ld.sh	r0,r0[0x0]
80004216:	2f c2       	sub	r2,-4
80004218:	80 00       	ld.sh	r0,r0[0x0]
8000421a:	30 00       	mov	r0,0
8000421c:	00 00       	add	r0,r0
8000421e:	01 94       	ld.ub	r4,r0[0x1]
80004220:	80 00       	ld.sh	r0,r0[0x0]
80004222:	45 60       	lddsp	r0,sp[0x158]
80004224:	80 00       	ld.sh	r0,r0[0x0]
80004226:	3e dc       	mov	r12,-19
80004228:	00 00       	add	r0,r0
8000422a:	46 48       	lddsp	r8,sp[0x190]
8000422c:	00 00       	add	r0,r0
8000422e:	01 9a       	ld.ub	r10,r0[0x1]
80004230:	00 00       	add	r0,r0
80004232:	01 98       	ld.ub	r8,r0[0x1]
80004234:	00 00       	add	r0,r0
80004236:	01 d8       	ld.ub	r8,r0[0x5]
80004238:	80 00       	ld.sh	r0,r0[0x0]
8000423a:	45 1c       	lddsp	r12,sp[0x144]

8000423c <udd_ctrl_out_received>:


static void udd_ctrl_out_received(void)
{
8000423c:	eb cd 40 80 	pushm	r7,lr
80004240:	1a 97       	mov	r7,sp
80004242:	20 4d       	sub	sp,16
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
80004244:	4f 18       	lddpc	r8,80004408 <udd_ctrl_out_received+0x1cc>
80004246:	70 08       	ld.w	r8,r8[0x0]
80004248:	58 18       	cp.w	r8,1
8000424a:	c1 10       	breq	8000426c <udd_ctrl_out_received+0x30>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
8000424c:	4e f8       	lddpc	r8,80004408 <udd_ctrl_out_received+0x1cc>
8000424e:	70 08       	ld.w	r8,r8[0x0]
80004250:	58 28       	cp.w	r8,2
80004252:	c0 50       	breq	8000425c <udd_ctrl_out_received+0x20>
				|| (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP ==
80004254:	4e d8       	lddpc	r8,80004408 <udd_ctrl_out_received+0x1cc>
80004256:	70 08       	ld.w	r8,r8[0x0]
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
80004258:	58 48       	cp.w	r8,4
8000425a:	c0 41       	brne	80004262 <udd_ctrl_out_received+0x26>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quickly,
			// - or ZLP OUT received normally.
			udd_ctrl_endofrequest();
8000425c:	f0 1f 00 6c 	mcall	8000440c <udd_ctrl_out_received+0x1d0>
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
80004260:	c0 38       	rjmp	80004266 <udd_ctrl_out_received+0x2a>
			// - or last Data IN Phase hidden by ZLP OUT sending quickly,
			// - or ZLP OUT received normally.
			udd_ctrl_endofrequest();
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
80004262:	f0 1f 00 6c 	mcall	80004410 <udd_ctrl_out_received+0x1d4>
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
80004266:	f0 1f 00 6c 	mcall	80004414 <udd_ctrl_out_received+0x1d8>
		return;
8000426a:	cc c8       	rjmp	80004402 <udd_ctrl_out_received+0x1c6>
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
8000426c:	fe 68 01 30 	mov	r8,-130768
80004270:	70 08       	ld.w	r8,r8[0x0]
80004272:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80004276:	b5 88       	lsr	r8,0x14
80004278:	ef 58 ff f6 	st.h	r7[-10],r8
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
8000427c:	4e 78       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
8000427e:	90 68       	ld.sh	r8,r8[0xc]
80004280:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80004284:	4e 68       	lddpc	r8,8000441c <udd_ctrl_out_received+0x1e0>
80004286:	90 08       	ld.sh	r8,r8[0x0]
80004288:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
8000428c:	ef 18 ff f6 	ld.uh	r8,r7[-10]
80004290:	f4 08 00 08 	add	r8,r10,r8
80004294:	10 39       	cp.w	r9,r8
80004296:	c0 84       	brge	800042a6 <udd_ctrl_out_received+0x6a>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
80004298:	4e 08       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
8000429a:	90 69       	ld.sh	r9,r8[0xc]
8000429c:	4e 08       	lddpc	r8,8000441c <udd_ctrl_out_received+0x1e0>
8000429e:	90 08       	ld.sh	r8,r8[0x0]
800042a0:	10 19       	sub	r9,r8
800042a2:	ef 59 ff f6 	st.h	r7[-10],r9
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
800042a6:	30 08       	mov	r8,0
800042a8:	ea 18 d0 00 	orh	r8,0xd000
800042ac:	ef 48 ff f8 	st.w	r7[-8],r8
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
800042b0:	4d a8       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
800042b2:	70 29       	ld.w	r9,r8[0x8]
800042b4:	4d a8       	lddpc	r8,8000441c <udd_ctrl_out_received+0x1e0>
800042b6:	90 08       	ld.sh	r8,r8[0x0]
800042b8:	5c 78       	castu.h	r8
800042ba:	f2 08 00 08 	add	r8,r9,r8
800042be:	ef 48 ff fc 	st.w	r7[-4],r8
	for (i = 0; i < nb_data; i++) {
800042c2:	30 08       	mov	r8,0
800042c4:	ef 68 ff f5 	st.b	r7[-11],r8
800042c8:	c1 68       	rjmp	800042f4 <udd_ctrl_out_received+0xb8>
		*ptr_dest++ = *ptr_src++;
800042ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042ce:	11 88       	ld.ub	r8,r8[0x0]
800042d0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800042d4:	b2 88       	st.b	r9[0x0],r8
800042d6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800042da:	2f f8       	sub	r8,-1
800042dc:	ef 48 ff fc 	st.w	r7[-4],r8
800042e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800042e4:	2f f8       	sub	r8,-1
800042e6:	ef 48 ff f8 	st.w	r7[-8],r8
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
800042ea:	ef 38 ff f5 	ld.ub	r8,r7[-11]
800042ee:	2f f8       	sub	r8,-1
800042f0:	ef 68 ff f5 	st.b	r7[-11],r8
800042f4:	ef 38 ff f5 	ld.ub	r8,r7[-11]
800042f8:	ef 09 ff f6 	ld.sh	r9,r7[-10]
800042fc:	f0 09 19 00 	cp.h	r9,r8
80004300:	fe 9b ff e5 	brhi	800042ca <udd_ctrl_out_received+0x8e>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80004304:	4c 68       	lddpc	r8,8000441c <udd_ctrl_out_received+0x1e0>
80004306:	90 08       	ld.sh	r8,r8[0x0]
80004308:	ef 09 ff f6 	ld.sh	r9,r7[-10]
8000430c:	f2 08 00 08 	add	r8,r9,r8
80004310:	5c 88       	casts.h	r8
80004312:	4c 39       	lddpc	r9,8000441c <udd_ctrl_out_received+0x1e0>
80004314:	b2 08       	st.h	r9[0x0],r8

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
80004316:	ef 09 ff f6 	ld.sh	r9,r7[-10]
8000431a:	34 08       	mov	r8,64
8000431c:	f0 09 19 00 	cp.h	r9,r8
80004320:	c1 11       	brne	80004342 <udd_ctrl_out_received+0x106>
			|| (udd_g_ctrlreq.req.wLength <=
80004322:	4b e8       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
80004324:	90 38       	ld.sh	r8,r8[0x6]
80004326:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
					(udd_ctrl_prev_payload_nb_trans +
8000432a:	4b e8       	lddpc	r8,80004420 <udd_ctrl_out_received+0x1e4>
8000432c:	90 08       	ld.sh	r8,r8[0x0]
8000432e:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80004332:	4b b8       	lddpc	r8,8000441c <udd_ctrl_out_received+0x1e0>
80004334:	90 08       	ld.sh	r8,r8[0x0]
80004336:	5c 78       	castu.h	r8
80004338:	f4 08 00 08 	add	r8,r10,r8
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
8000433c:	10 39       	cp.w	r9,r8
8000433e:	e0 89 00 20 	brgt	8000437e <udd_ctrl_out_received+0x142>
							udd_ctrl_payload_nb_trans)))
	{
		// End of reception because it is a short packet
		// Before send ZLP, call intermediate callback
		// in case of data receive generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
80004342:	4b 78       	lddpc	r8,8000441c <udd_ctrl_out_received+0x1e0>
80004344:	90 08       	ld.sh	r8,r8[0x0]
80004346:	4b 59       	lddpc	r9,80004418 <udd_ctrl_out_received+0x1dc>
80004348:	b2 68       	st.h	r9[0xc],r8
		if (NULL != udd_g_ctrlreq.over_under_run) {
8000434a:	4b 48       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
8000434c:	70 58       	ld.w	r8,r8[0x14]
8000434e:	58 08       	cp.w	r8,0
80004350:	c1 00       	breq	80004370 <udd_ctrl_out_received+0x134>
			if (!udd_g_ctrlreq.over_under_run()) {
80004352:	4b 28       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
80004354:	70 58       	ld.w	r8,r8[0x14]
80004356:	5d 18       	icall	r8
80004358:	18 98       	mov	r8,r12
8000435a:	ec 18 00 01 	eorl	r8,0x1
8000435e:	5c 58       	castu.b	r8
80004360:	c0 80       	breq	80004370 <udd_ctrl_out_received+0x134>
				// Stall ZLP
				udd_ctrl_stall_data();
80004362:	f0 1f 00 2c 	mcall	80004410 <udd_ctrl_out_received+0x1d4>
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
80004366:	fe 68 01 60 	mov	r8,-130720
8000436a:	30 29       	mov	r9,2
8000436c:	91 09       	st.w	r8[0x0],r9
				return;
8000436e:	c4 a8       	rjmp	80004402 <udd_ctrl_out_received+0x1c6>
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
80004370:	fe 68 01 60 	mov	r8,-130720
80004374:	30 29       	mov	r9,2
80004376:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_send_zlp_in();
80004378:	f0 1f 00 2b 	mcall	80004424 <udd_ctrl_out_received+0x1e8>
		return;
8000437c:	c4 38       	rjmp	80004402 <udd_ctrl_out_received+0x1c6>
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
8000437e:	4a 78       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
80004380:	90 69       	ld.sh	r9,r8[0xc]
80004382:	4a 78       	lddpc	r8,8000441c <udd_ctrl_out_received+0x1e0>
80004384:	90 08       	ld.sh	r8,r8[0x0]
80004386:	f0 09 19 00 	cp.h	r9,r8
8000438a:	c2 71       	brne	800043d8 <udd_ctrl_out_received+0x19c>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
8000438c:	4a 38       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
8000438e:	70 58       	ld.w	r8,r8[0x14]
80004390:	58 08       	cp.w	r8,0
80004392:	c0 81       	brne	800043a2 <udd_ctrl_out_received+0x166>
			// No callback available to request a new payload buffer
			udd_ctrl_stall_data();
80004394:	f0 1f 00 1f 	mcall	80004410 <udd_ctrl_out_received+0x1d4>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
80004398:	fe 68 01 60 	mov	r8,-130720
8000439c:	30 29       	mov	r9,2
8000439e:	91 09       	st.w	r8[0x0],r9
			return;
800043a0:	c3 18       	rjmp	80004402 <udd_ctrl_out_received+0x1c6>
		}
		if (!udd_g_ctrlreq.over_under_run()) {
800043a2:	49 e8       	lddpc	r8,80004418 <udd_ctrl_out_received+0x1dc>
800043a4:	70 58       	ld.w	r8,r8[0x14]
800043a6:	5d 18       	icall	r8
800043a8:	18 98       	mov	r8,r12
800043aa:	ec 18 00 01 	eorl	r8,0x1
800043ae:	5c 58       	castu.b	r8
800043b0:	c0 80       	breq	800043c0 <udd_ctrl_out_received+0x184>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
800043b2:	f0 1f 00 18 	mcall	80004410 <udd_ctrl_out_received+0x1d4>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
800043b6:	fe 68 01 60 	mov	r8,-130720
800043ba:	30 29       	mov	r9,2
800043bc:	91 09       	st.w	r8[0x0],r9
			return;
800043be:	c2 28       	rjmp	80004402 <udd_ctrl_out_received+0x1c6>
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
800043c0:	49 88       	lddpc	r8,80004420 <udd_ctrl_out_received+0x1e4>
800043c2:	90 09       	ld.sh	r9,r8[0x0]
800043c4:	49 68       	lddpc	r8,8000441c <udd_ctrl_out_received+0x1e0>
800043c6:	90 08       	ld.sh	r8,r8[0x0]
800043c8:	f2 08 00 08 	add	r8,r9,r8
800043cc:	5c 88       	casts.h	r8
800043ce:	49 59       	lddpc	r9,80004420 <udd_ctrl_out_received+0x1e4>
800043d0:	b2 08       	st.h	r9[0x0],r8
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
800043d2:	49 39       	lddpc	r9,8000441c <udd_ctrl_out_received+0x1e0>
800043d4:	30 08       	mov	r8,0
800043d6:	b2 08       	st.h	r9[0x0],r8
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
800043d8:	fe 68 01 60 	mov	r8,-130720
800043dc:	30 29       	mov	r9,2
800043de:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
800043e0:	fe 68 01 60 	mov	r8,-130720
800043e4:	31 09       	mov	r9,16
800043e6:	91 09       	st.w	r8[0x0],r9
	flags = cpu_irq_save();
800043e8:	f0 1f 00 10 	mcall	80004428 <udd_ctrl_out_received+0x1ec>
800043ec:	18 98       	mov	r8,r12
800043ee:	ef 48 ff f0 	st.w	r7[-16],r8
	udd_enable_nak_in_interrupt(0);
800043f2:	fe 68 01 f0 	mov	r8,-130576
800043f6:	31 09       	mov	r9,16
800043f8:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
800043fa:	ee fc ff f0 	ld.w	r12,r7[-16]
800043fe:	f0 1f 00 0c 	mcall	8000442c <udd_ctrl_out_received+0x1f0>
}
80004402:	2f cd       	sub	sp,-16
80004404:	e3 cd 80 80 	ldm	sp++,r7,pc
80004408:	00 00       	add	r0,r0
8000440a:	01 94       	ld.ub	r4,r0[0x1]
8000440c:	80 00       	ld.sh	r0,r0[0x0]
8000440e:	45 60       	lddsp	r0,sp[0x158]
80004410:	80 00       	ld.sh	r0,r0[0x0]
80004412:	44 a8       	lddsp	r8,sp[0x128]
80004414:	80 00       	ld.sh	r0,r0[0x0]
80004416:	3e dc       	mov	r12,-19
80004418:	00 00       	add	r0,r0
8000441a:	46 48       	lddsp	r8,sp[0x190]
8000441c:	00 00       	add	r0,r0
8000441e:	01 9a       	ld.ub	r10,r0[0x1]
80004420:	00 00       	add	r0,r0
80004422:	01 98       	ld.ub	r8,r0[0x1]
80004424:	80 00       	ld.sh	r0,r0[0x0]
80004426:	44 c8       	lddsp	r8,sp[0x130]
80004428:	80 00       	ld.sh	r0,r0[0x0]
8000442a:	2f c2       	sub	r2,-4
8000442c:	80 00       	ld.sh	r0,r0[0x0]
8000442e:	30 00       	mov	r0,0

80004430 <udd_ctrl_underflow>:


static void udd_ctrl_underflow(void)
{
80004430:	eb cd 40 80 	pushm	r7,lr
80004434:	1a 97       	mov	r7,sp
	if (Is_udd_out_received(0))
80004436:	fe 68 01 30 	mov	r8,-130768
8000443a:	70 08       	ld.w	r8,r8[0x0]
8000443c:	e2 18 00 02 	andl	r8,0x2,COH
80004440:	c1 21       	brne	80004464 <udd_ctrl_underflow+0x34>
		return; // underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
80004442:	48 b8       	lddpc	r8,8000446c <udd_ctrl_underflow+0x3c>
80004444:	70 08       	ld.w	r8,r8[0x0]
80004446:	58 18       	cp.w	r8,1
80004448:	c0 41       	brne	80004450 <udd_ctrl_underflow+0x20>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
8000444a:	f0 1f 00 0a 	mcall	80004470 <udd_ctrl_underflow+0x40>
8000444e:	c0 c8       	rjmp	80004466 <udd_ctrl_underflow+0x36>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
80004450:	48 78       	lddpc	r8,8000446c <udd_ctrl_underflow+0x3c>
80004452:	70 08       	ld.w	r8,r8[0x0]
80004454:	58 48       	cp.w	r8,4
80004456:	c0 81       	brne	80004466 <udd_ctrl_underflow+0x36>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
80004458:	fe 68 01 f0 	mov	r8,-130576
8000445c:	e8 69 00 00 	mov	r9,524288
80004460:	91 09       	st.w	r8[0x0],r9
80004462:	c0 28       	rjmp	80004466 <udd_ctrl_underflow+0x36>


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
		return; // underflow ignored if OUT data is received
80004464:	d7 03       	nop
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
	}
}
80004466:	e3 cd 80 80 	ldm	sp++,r7,pc
8000446a:	00 00       	add	r0,r0
8000446c:	00 00       	add	r0,r0
8000446e:	01 94       	ld.ub	r4,r0[0x1]
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	44 c8       	lddsp	r8,sp[0x130]

80004474 <udd_ctrl_overflow>:


static void udd_ctrl_overflow(void)
{
80004474:	eb cd 40 80 	pushm	r7,lr
80004478:	1a 97       	mov	r7,sp
	if (Is_udd_in_send(0))
8000447a:	fe 68 01 30 	mov	r8,-130768
8000447e:	70 08       	ld.w	r8,r8[0x0]
80004480:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004484:	5c 58       	castu.b	r8
80004486:	c0 b1       	brne	8000449c <udd_ctrl_overflow+0x28>
		return; // overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80004488:	48 78       	lddpc	r8,800044a4 <udd_ctrl_overflow+0x30>
8000448a:	70 08       	ld.w	r8,r8[0x0]
8000448c:	58 38       	cp.w	r8,3
8000448e:	c0 81       	brne	8000449e <udd_ctrl_overflow+0x2a>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
80004490:	fe 68 01 f0 	mov	r8,-130576
80004494:	e8 69 00 00 	mov	r9,524288
80004498:	91 09       	st.w	r8[0x0],r9
8000449a:	c0 28       	rjmp	8000449e <udd_ctrl_overflow+0x2a>


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
		return; // overflow ignored if IN data is received
8000449c:	d7 03       	nop
	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
	}
}
8000449e:	e3 cd 80 80 	ldm	sp++,r7,pc
800044a2:	00 00       	add	r0,r0
800044a4:	00 00       	add	r0,r0
800044a6:	01 94       	ld.ub	r4,r0[0x1]

800044a8 <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
800044a8:	eb cd 40 80 	pushm	r7,lr
800044ac:	1a 97       	mov	r7,sp
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
800044ae:	48 68       	lddpc	r8,800044c4 <udd_ctrl_stall_data+0x1c>
800044b0:	30 59       	mov	r9,5
800044b2:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(0);
800044b4:	fe 68 01 f0 	mov	r8,-130576
800044b8:	e8 69 00 00 	mov	r9,524288
800044bc:	91 09       	st.w	r8[0x0],r9
}
800044be:	e3 cd 80 80 	ldm	sp++,r7,pc
800044c2:	00 00       	add	r0,r0
800044c4:	00 00       	add	r0,r0
800044c6:	01 94       	ld.ub	r4,r0[0x1]

800044c8 <udd_ctrl_send_zlp_in>:


static void udd_ctrl_send_zlp_in(void)
{
800044c8:	eb cd 40 80 	pushm	r7,lr
800044cc:	1a 97       	mov	r7,sp
800044ce:	20 1d       	sub	sp,4
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
800044d0:	49 08       	lddpc	r8,80004510 <udd_ctrl_send_zlp_in+0x48>
800044d2:	30 39       	mov	r9,3
800044d4:	91 09       	st.w	r8[0x0],r9

	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
800044d6:	f0 1f 00 10 	mcall	80004514 <udd_ctrl_send_zlp_in+0x4c>
800044da:	18 98       	mov	r8,r12
800044dc:	ef 48 ff fc 	st.w	r7[-4],r8
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
800044e0:	fe 68 01 60 	mov	r8,-130720
800044e4:	30 19       	mov	r9,1
800044e6:	91 09       	st.w	r8[0x0],r9
	udd_enable_in_send_interrupt(0);
800044e8:	fe 68 01 f0 	mov	r8,-130576
800044ec:	30 19       	mov	r9,1
800044ee:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
800044f0:	fe 68 01 60 	mov	r8,-130720
800044f4:	30 89       	mov	r9,8
800044f6:	91 09       	st.w	r8[0x0],r9
	udd_enable_nak_out_interrupt(0);
800044f8:	fe 68 01 f0 	mov	r8,-130576
800044fc:	30 89       	mov	r9,8
800044fe:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
80004500:	ee fc ff fc 	ld.w	r12,r7[-4]
80004504:	f0 1f 00 05 	mcall	80004518 <udd_ctrl_send_zlp_in+0x50>
}
80004508:	2f fd       	sub	sp,-4
8000450a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000450e:	00 00       	add	r0,r0
80004510:	00 00       	add	r0,r0
80004512:	01 94       	ld.ub	r4,r0[0x1]
80004514:	80 00       	ld.sh	r0,r0[0x0]
80004516:	2f c2       	sub	r2,-4
80004518:	80 00       	ld.sh	r0,r0[0x0]
8000451a:	30 00       	mov	r0,0

8000451c <udd_ctrl_send_zlp_out>:


static void udd_ctrl_send_zlp_out(void)
{
8000451c:	eb cd 40 80 	pushm	r7,lr
80004520:	1a 97       	mov	r7,sp
80004522:	20 1d       	sub	sp,4
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
80004524:	48 c8       	lddpc	r8,80004554 <udd_ctrl_send_zlp_out+0x38>
80004526:	30 49       	mov	r9,4
80004528:	91 09       	st.w	r8[0x0],r9
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
8000452a:	f0 1f 00 0c 	mcall	80004558 <udd_ctrl_send_zlp_out+0x3c>
8000452e:	18 98       	mov	r8,r12
80004530:	ef 48 ff fc 	st.w	r7[-4],r8
	udd_ack_nak_in(0);
80004534:	fe 68 01 60 	mov	r8,-130720
80004538:	31 09       	mov	r9,16
8000453a:	91 09       	st.w	r8[0x0],r9
	udd_enable_nak_in_interrupt(0);
8000453c:	fe 68 01 f0 	mov	r8,-130576
80004540:	31 09       	mov	r9,16
80004542:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
80004544:	ee fc ff fc 	ld.w	r12,r7[-4]
80004548:	f0 1f 00 05 	mcall	8000455c <udd_ctrl_send_zlp_out+0x40>
}
8000454c:	2f fd       	sub	sp,-4
8000454e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004552:	00 00       	add	r0,r0
80004554:	00 00       	add	r0,r0
80004556:	01 94       	ld.ub	r4,r0[0x1]
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	2f c2       	sub	r2,-4
8000455c:	80 00       	ld.sh	r0,r0[0x0]
8000455e:	30 00       	mov	r0,0

80004560 <udd_ctrl_endofrequest>:


static void udd_ctrl_endofrequest(void)
{
80004560:	eb cd 40 80 	pushm	r7,lr
80004564:	1a 97       	mov	r7,sp
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
80004566:	48 58       	lddpc	r8,80004578 <udd_ctrl_endofrequest+0x18>
80004568:	70 48       	ld.w	r8,r8[0x10]
8000456a:	58 08       	cp.w	r8,0
8000456c:	c0 40       	breq	80004574 <udd_ctrl_endofrequest+0x14>
		udd_g_ctrlreq.callback();
8000456e:	48 38       	lddpc	r8,80004578 <udd_ctrl_endofrequest+0x18>
80004570:	70 48       	ld.w	r8,r8[0x10]
80004572:	5d 18       	icall	r8
	}
}
80004574:	e3 cd 80 80 	ldm	sp++,r7,pc
80004578:	00 00       	add	r0,r0
8000457a:	46 48       	lddsp	r8,sp[0x190]

8000457c <udd_ctrl_interrupt>:


static bool udd_ctrl_interrupt(void)
{
8000457c:	eb cd 40 80 	pushm	r7,lr
80004580:	1a 97       	mov	r7,sp

	if (!Is_udd_endpoint_interrupt(0))
80004582:	fe 68 00 00 	mov	r8,-131072
80004586:	70 18       	ld.w	r8,r8[0x4]
80004588:	e2 18 10 00 	andl	r8,0x1000,COH
8000458c:	c0 31       	brne	80004592 <udd_ctrl_interrupt+0x16>
		return false; // No interrupt events on control endpoint
8000458e:	30 08       	mov	r8,0
80004590:	c4 c8       	rjmp	80004628 <udd_ctrl_interrupt+0xac>

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
80004592:	fe 68 02 20 	mov	r8,-130528
80004596:	31 09       	mov	r9,16
80004598:	91 09       	st.w	r8[0x0],r9
	udd_disable_nak_out_interrupt(0);
8000459a:	fe 68 02 20 	mov	r8,-130528
8000459e:	30 89       	mov	r9,8
800045a0:	91 09       	st.w	r8[0x0],r9


	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
800045a2:	fe 68 01 30 	mov	r8,-130768
800045a6:	70 08       	ld.w	r8,r8[0x0]
800045a8:	e2 18 00 04 	andl	r8,0x4,COH
800045ac:	c0 50       	breq	800045b6 <udd_ctrl_interrupt+0x3a>
		// SETUP packet received
		udd_ctrl_setup_received();
800045ae:	f0 1f 00 21 	mcall	80004630 <udd_ctrl_interrupt+0xb4>
		return true;
800045b2:	30 18       	mov	r8,1
800045b4:	c3 a8       	rjmp	80004628 <udd_ctrl_interrupt+0xac>
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
800045b6:	fe 68 01 30 	mov	r8,-130768
800045ba:	70 08       	ld.w	r8,r8[0x0]
800045bc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800045c0:	5c 58       	castu.b	r8
800045c2:	c0 c0       	breq	800045da <udd_ctrl_interrupt+0x5e>
800045c4:	fe 68 01 c0 	mov	r8,-130624
800045c8:	70 08       	ld.w	r8,r8[0x0]
800045ca:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800045ce:	5c 58       	castu.b	r8
800045d0:	c0 50       	breq	800045da <udd_ctrl_interrupt+0x5e>
		// IN packet sent
		udd_ctrl_in_sent();
800045d2:	f0 1f 00 19 	mcall	80004634 <udd_ctrl_interrupt+0xb8>
		return true;
800045d6:	30 18       	mov	r8,1
800045d8:	c2 88       	rjmp	80004628 <udd_ctrl_interrupt+0xac>
	}
	if (Is_udd_out_received(0)) {
800045da:	fe 68 01 30 	mov	r8,-130768
800045de:	70 08       	ld.w	r8,r8[0x0]
800045e0:	e2 18 00 02 	andl	r8,0x2,COH
800045e4:	c0 50       	breq	800045ee <udd_ctrl_interrupt+0x72>
		// OUT packet received
		udd_ctrl_out_received();
800045e6:	f0 1f 00 15 	mcall	80004638 <udd_ctrl_interrupt+0xbc>
		return true;
800045ea:	30 18       	mov	r8,1
800045ec:	c1 e8       	rjmp	80004628 <udd_ctrl_interrupt+0xac>
	}
	if (Is_udd_nak_out(0)) {
800045ee:	fe 68 01 30 	mov	r8,-130768
800045f2:	70 08       	ld.w	r8,r8[0x0]
800045f4:	e2 18 00 08 	andl	r8,0x8,COH
800045f8:	c0 90       	breq	8000460a <udd_ctrl_interrupt+0x8e>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
800045fa:	fe 68 01 60 	mov	r8,-130720
800045fe:	30 89       	mov	r9,8
80004600:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_overflow();
80004602:	f0 1f 00 0f 	mcall	8000463c <udd_ctrl_interrupt+0xc0>
		return true;
80004606:	30 18       	mov	r8,1
80004608:	c1 08       	rjmp	80004628 <udd_ctrl_interrupt+0xac>
	}
	if (Is_udd_nak_in(0)) {
8000460a:	fe 68 01 30 	mov	r8,-130768
8000460e:	70 08       	ld.w	r8,r8[0x0]
80004610:	e2 18 00 10 	andl	r8,0x10,COH
80004614:	c0 90       	breq	80004626 <udd_ctrl_interrupt+0xaa>
		// Underflow on IN packet
		udd_ack_nak_in(0);
80004616:	fe 68 01 60 	mov	r8,-130720
8000461a:	31 09       	mov	r9,16
8000461c:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_underflow();
8000461e:	f0 1f 00 09 	mcall	80004640 <udd_ctrl_interrupt+0xc4>
		return true;
80004622:	30 18       	mov	r8,1
80004624:	c0 28       	rjmp	80004628 <udd_ctrl_interrupt+0xac>
	}
	return false;
80004626:	30 08       	mov	r8,0
}
80004628:	10 9c       	mov	r12,r8
8000462a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000462e:	00 00       	add	r0,r0
80004630:	80 00       	ld.sh	r0,r0[0x0]
80004632:	3f 34       	mov	r4,-13
80004634:	80 00       	ld.sh	r0,r0[0x0]
80004636:	40 9c       	lddsp	r12,sp[0x24]
80004638:	80 00       	ld.sh	r0,r0[0x0]
8000463a:	42 3c       	lddsp	r12,sp[0x8c]
8000463c:	80 00       	ld.sh	r0,r0[0x0]
8000463e:	44 74       	lddsp	r4,sp[0x11c]
80004640:	80 00       	ld.sh	r0,r0[0x0]
80004642:	44 30       	lddsp	r0,sp[0x10c]

80004644 <udd_ep_job_table_reset>:
//--- INTERNAL ROUTINES TO MANAGED THE BULK/INTERRUPT/ISOCHRONOUS ENDPOINTS

#if (0!=USB_DEVICE_MAX_EP)

static void udd_ep_job_table_reset(void)
{
80004644:	eb cd 40 80 	pushm	r7,lr
80004648:	1a 97       	mov	r7,sp
8000464a:	20 1d       	sub	sp,4
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
8000464c:	30 08       	mov	r8,0
8000464e:	ef 68 ff ff 	st.b	r7[-1],r8
80004652:	c2 28       	rjmp	80004696 <udd_ep_job_table_reset+0x52>
		udd_ep_job[i].busy = false;
80004654:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004658:	49 5a       	lddpc	r10,800046ac <udd_ep_job_table_reset+0x68>
8000465a:	12 98       	mov	r8,r9
8000465c:	a3 68       	lsl	r8,0x2
8000465e:	12 08       	add	r8,r9
80004660:	a3 68       	lsl	r8,0x2
80004662:	f4 08 00 09 	add	r9,r10,r8
80004666:	72 08       	ld.w	r8,r9[0x0]
80004668:	30 0a       	mov	r10,0
8000466a:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
8000466e:	93 08       	st.w	r9[0x0],r8
		udd_ep_job[i].stall_requested = false;
80004670:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004674:	48 ea       	lddpc	r10,800046ac <udd_ep_job_table_reset+0x68>
80004676:	12 98       	mov	r8,r9
80004678:	a3 68       	lsl	r8,0x2
8000467a:	12 08       	add	r8,r9
8000467c:	a3 68       	lsl	r8,0x2
8000467e:	f4 08 00 09 	add	r9,r10,r8
80004682:	72 08       	ld.w	r8,r9[0x0]
80004684:	30 0a       	mov	r10,0
80004686:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
8000468a:	93 08       	st.w	r9[0x0],r8
#if (0!=USB_DEVICE_MAX_EP)

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
8000468c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80004690:	2f f8       	sub	r8,-1
80004692:	ef 68 ff ff 	st.b	r7[-1],r8
80004696:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000469a:	30 28       	mov	r8,2
8000469c:	f0 09 18 00 	cp.b	r9,r8
800046a0:	fe 98 ff da 	brls	80004654 <udd_ep_job_table_reset+0x10>
		udd_ep_job[i].busy = false;
		udd_ep_job[i].stall_requested = false;
	}
}
800046a4:	2f fd       	sub	sp,-4
800046a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800046aa:	00 00       	add	r0,r0
800046ac:	00 00       	add	r0,r0
800046ae:	01 9c       	ld.ub	r12,r0[0x1]

800046b0 <udd_ep_job_table_kill>:


static void udd_ep_job_table_kill(void)
{
800046b0:	eb cd 40 80 	pushm	r7,lr
800046b4:	1a 97       	mov	r7,sp
800046b6:	20 1d       	sub	sp,4
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
800046b8:	30 08       	mov	r8,0
800046ba:	ef 68 ff ff 	st.b	r7[-1],r8
800046be:	c1 98       	rjmp	800046f0 <udd_ep_job_table_kill+0x40>
		udd_ep_finish_job(&udd_ep_job[i], true, i + 1);
800046c0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800046c4:	2f f8       	sub	r8,-1
800046c6:	5c 58       	castu.b	r8
800046c8:	10 9a       	mov	r10,r8
800046ca:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800046ce:	12 98       	mov	r8,r9
800046d0:	a3 68       	lsl	r8,0x2
800046d2:	12 08       	add	r8,r9
800046d4:	a3 68       	lsl	r8,0x2
800046d6:	10 99       	mov	r9,r8
800046d8:	48 b8       	lddpc	r8,80004704 <udd_ep_job_table_kill+0x54>
800046da:	f2 08 00 08 	add	r8,r9,r8
800046de:	30 1b       	mov	r11,1
800046e0:	10 9c       	mov	r12,r8
800046e2:	f0 1f 00 0a 	mcall	80004708 <udd_ep_job_table_kill+0x58>
static void udd_ep_job_table_kill(void)
{
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
800046e6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800046ea:	2f f8       	sub	r8,-1
800046ec:	ef 68 ff ff 	st.b	r7[-1],r8
800046f0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800046f4:	30 28       	mov	r8,2
800046f6:	f0 09 18 00 	cp.b	r9,r8
800046fa:	fe 98 ff e3 	brls	800046c0 <udd_ep_job_table_kill+0x10>
		udd_ep_finish_job(&udd_ep_job[i], true, i + 1);
	}
}
800046fe:	2f fd       	sub	sp,-4
80004700:	e3 cd 80 80 	ldm	sp++,r7,pc
80004704:	00 00       	add	r0,r0
80004706:	01 9c       	ld.ub	r12,r0[0x1]
80004708:	80 00       	ld.sh	r0,r0[0x0]
8000470a:	47 58       	lddsp	r8,sp[0x1d4]

8000470c <udd_ep_abort_job>:


static void udd_ep_abort_job(udd_ep_id_t ep)
{
8000470c:	eb cd 40 80 	pushm	r7,lr
80004710:	1a 97       	mov	r7,sp
80004712:	20 1d       	sub	sp,4
80004714:	18 98       	mov	r8,r12
80004716:	ef 68 ff fc 	st.b	r7[-4],r8
	ep &= USB_EP_ADDR_MASK;
8000471a:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000471e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80004722:	ef 68 ff fc 	st.b	r7[-4],r8

	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
80004726:	ef 3a ff fc 	ld.ub	r10,r7[-4]
8000472a:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000472e:	f0 c9 00 01 	sub	r9,r8,1
80004732:	12 98       	mov	r8,r9
80004734:	a3 68       	lsl	r8,0x2
80004736:	12 08       	add	r8,r9
80004738:	a3 68       	lsl	r8,0x2
8000473a:	10 99       	mov	r9,r8
8000473c:	48 58       	lddpc	r8,80004750 <udd_ep_abort_job+0x44>
8000473e:	f2 08 00 08 	add	r8,r9,r8
80004742:	30 1b       	mov	r11,1
80004744:	10 9c       	mov	r12,r8
80004746:	f0 1f 00 04 	mcall	80004754 <udd_ep_abort_job+0x48>
}
8000474a:	2f fd       	sub	sp,-4
8000474c:	e3 cd 80 80 	ldm	sp++,r7,pc
80004750:	00 00       	add	r0,r0
80004752:	01 9c       	ld.ub	r12,r0[0x1]
80004754:	80 00       	ld.sh	r0,r0[0x0]
80004756:	47 58       	lddsp	r8,sp[0x1d4]

80004758 <udd_ep_finish_job>:


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num)
{
80004758:	eb cd 40 80 	pushm	r7,lr
8000475c:	1a 97       	mov	r7,sp
8000475e:	20 3d       	sub	sp,12
80004760:	ef 4c ff fc 	st.w	r7[-4],r12
80004764:	16 99       	mov	r9,r11
80004766:	14 98       	mov	r8,r10
80004768:	ef 69 ff f8 	st.b	r7[-8],r9
8000476c:	ef 68 ff f4 	st.b	r7[-12],r8
	if (ptr_job->busy == false) {
80004770:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004774:	70 08       	ld.w	r8,r8[0x0]
80004776:	e6 18 80 00 	andh	r8,0x8000,COH
8000477a:	c2 b0       	breq	800047d0 <udd_ep_finish_job+0x78>
		return; // No on-going job
	}
	ptr_job->busy = false;
8000477c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004780:	72 08       	ld.w	r8,r9[0x0]
80004782:	30 0a       	mov	r10,0
80004784:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80004788:	93 08       	st.w	r9[0x0],r8
	if (NULL == ptr_job->call_trans) {
8000478a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000478e:	70 48       	ld.w	r8,r8[0x10]
80004790:	58 08       	cp.w	r8,0
80004792:	c2 10       	breq	800047d4 <udd_ep_finish_job+0x7c>
		return; // No callback linked to job
	}
	if (Is_udd_endpoint_in(ep_num)) {
80004794:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80004798:	a3 68       	lsl	r8,0x2
8000479a:	e0 38 ff 00 	sub	r8,130816
8000479e:	70 08       	ld.w	r8,r8[0x0]
800047a0:	e2 18 01 00 	andl	r8,0x100,COH
800047a4:	c0 90       	breq	800047b6 <udd_ep_finish_job+0x5e>
		ep_num |= USB_EP_DIR_IN;
800047a6:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800047aa:	ea 18 ff ff 	orh	r8,0xffff
800047ae:	e8 18 ff 80 	orl	r8,0xff80
800047b2:	ef 68 ff f4 	st.b	r7[-12],r8
	}
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
800047b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047ba:	70 48       	ld.w	r8,r8[0x10]
800047bc:	ef 3a ff f4 	ld.ub	r10,r7[-12]
800047c0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800047c4:	72 2b       	ld.w	r11,r9[0x8]
800047c6:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800047ca:	12 9c       	mov	r12,r9
800047cc:	5d 18       	icall	r8
800047ce:	c0 48       	rjmp	800047d6 <udd_ep_finish_job+0x7e>


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num)
{
	if (ptr_job->busy == false) {
		return; // No on-going job
800047d0:	d7 03       	nop
800047d2:	c0 28       	rjmp	800047d6 <udd_ep_finish_job+0x7e>
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_trans) {
		return; // No callback linked to job
800047d4:	d7 03       	nop
	if (Is_udd_endpoint_in(ep_num)) {
		ep_num |= USB_EP_DIR_IN;
	}
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
			UDD_EP_TRANSFER_OK, ptr_job->buf_size, ep_num);
}
800047d6:	2f dd       	sub	sp,-12
800047d8:	e3 cd 80 80 	ldm	sp++,r7,pc

800047dc <udd_ep_trans_done>:

static void udd_ep_trans_done(udd_ep_id_t ep)
{
800047dc:	eb cd 40 80 	pushm	r7,lr
800047e0:	1a 97       	mov	r7,sp
800047e2:	20 5d       	sub	sp,20
800047e4:	18 98       	mov	r8,r12
800047e6:	ef 68 ff ec 	st.b	r7[-20],r8
	uint32_t udd_dma_ctrl = 0;
800047ea:	30 08       	mov	r8,0
800047ec:	ef 48 ff f0 	st.w	r7[-16],r8
	udd_ep_job_t *ptr_job;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep - 1];
800047f0:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800047f4:	f0 c9 00 01 	sub	r9,r8,1
800047f8:	12 98       	mov	r8,r9
800047fa:	a3 68       	lsl	r8,0x2
800047fc:	12 08       	add	r8,r9
800047fe:	a3 68       	lsl	r8,0x2
80004800:	10 99       	mov	r9,r8
80004802:	fe f8 02 1e 	ld.w	r8,pc[542]
80004806:	f2 08 00 08 	add	r8,r9,r8
8000480a:	ef 48 ff f4 	st.w	r7[-12],r8

	if (!ptr_job->busy) {
8000480e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004812:	70 08       	ld.w	r8,r8[0x0]
80004814:	e6 18 80 00 	andh	r8,0x8000,COH
80004818:	e0 80 00 ff 	breq	80004a16 <udd_ep_trans_done+0x23a>
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
8000481c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004820:	70 39       	ld.w	r9,r8[0xc]
80004822:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004826:	70 28       	ld.w	r8,r8[0x8]
80004828:	10 39       	cp.w	r9,r8
8000482a:	e0 80 00 b6 	breq	80004996 <udd_ep_trans_done+0x1ba>
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
8000482e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004832:	70 29       	ld.w	r9,r8[0x8]
80004834:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004838:	70 38       	ld.w	r8,r8[0xc]
8000483a:	10 19       	sub	r9,r8
8000483c:	ef 49 ff f8 	st.w	r7[-8],r9

		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
80004840:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004844:	e0 58 00 00 	cp.w	r8,65536
80004848:	e0 88 00 0a 	brls	8000485c <udd_ep_trans_done+0x80>
			// The USB hardware support a maximum
			// transfer size of UDD_ENDPOINT_MAX_TRANS Bytes
			next_trans = UDD_ENDPOINT_MAX_TRANS;
8000484c:	e0 78 00 00 	mov	r8,65536
80004850:	ef 48 ff f8 	st.w	r7[-8],r8

			// Set 0 to transfer the maximum
			udd_dma_ctrl = (0 <<
80004854:	30 08       	mov	r8,0
80004856:	ef 48 ff f0 	st.w	r7[-16],r8
8000485a:	c0 68       	rjmp	80004866 <udd_ep_trans_done+0x8a>
					AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		} else {
			udd_dma_ctrl = (next_trans <<
8000485c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004860:	b1 68       	lsl	r8,0x10
80004862:	ef 48 ff f0 	st.w	r7[-16],r8
					AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		}
		if (Is_udd_endpoint_in(ep)) {
80004866:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000486a:	a3 68       	lsl	r8,0x2
8000486c:	e0 38 ff 00 	sub	r8,130816
80004870:	70 08       	ld.w	r8,r8[0x0]
80004872:	e2 18 01 00 	andl	r8,0x100,COH
80004876:	c2 10       	breq	800048b8 <udd_ep_trans_done+0xdc>
			if (0 != next_trans % udd_get_endpoint_size(ep)) {
80004878:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000487c:	a3 68       	lsl	r8,0x2
8000487e:	e0 38 ff 00 	sub	r8,130816
80004882:	70 08       	ld.w	r8,r8[0x0]
80004884:	e2 18 00 70 	andl	r8,0x70,COH
80004888:	a5 88       	lsr	r8,0x4
8000488a:	30 89       	mov	r9,8
8000488c:	f2 08 09 48 	lsl	r8,r9,r8
80004890:	20 18       	sub	r8,1
80004892:	10 99       	mov	r9,r8
80004894:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004898:	f3 e8 00 08 	and	r8,r9,r8
8000489c:	c3 00       	breq	800048fc <udd_ep_trans_done+0x120>
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_DMAEND_EN_MASK;
8000489e:	ee f8 ff f0 	ld.w	r8,r7[-16]
800048a2:	a3 b8       	sbr	r8,0x3
800048a4:	ef 48 ff f0 	st.w	r7[-16],r8
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
800048a8:	ee f9 ff f4 	ld.w	r9,r7[-12]
800048ac:	72 08       	ld.w	r8,r9[0x0]
800048ae:	30 0a       	mov	r10,0
800048b0:	f1 da d3 c1 	bfins	r8,r10,0x1e,0x1
800048b4:	93 08       	st.w	r9[0x0],r8
800048b6:	c2 38       	rjmp	800048fc <udd_ep_trans_done+0x120>
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != udd_get_endpoint_type(ep))
800048b8:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800048bc:	a3 68       	lsl	r8,0x2
800048be:	e0 38 ff 00 	sub	r8,130816
800048c2:	70 08       	ld.w	r8,r8[0x0]
800048c4:	e2 18 18 00 	andl	r8,0x1800,COH
800048c8:	ab 98       	lsr	r8,0xb
800048ca:	58 18       	cp.w	r8,1
800048cc:	c1 21       	brne	800048f0 <udd_ep_trans_done+0x114>
					|| (next_trans <= udd_get_endpoint_size(ep))) {
800048ce:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800048d2:	a3 68       	lsl	r8,0x2
800048d4:	e0 38 ff 00 	sub	r8,130816
800048d8:	70 08       	ld.w	r8,r8[0x0]
800048da:	e2 18 00 70 	andl	r8,0x70,COH
800048de:	a5 88       	lsr	r8,0x4
800048e0:	30 89       	mov	r9,8
800048e2:	f2 08 09 48 	lsl	r8,r9,r8
800048e6:	10 99       	mov	r9,r8
				udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != udd_get_endpoint_type(ep))
800048e8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048ec:	10 39       	cp.w	r9,r8
800048ee:	c0 73       	brcs	800048fc <udd_ep_trans_done+0x120>
					|| (next_trans <= udd_get_endpoint_size(ep))) {

				// Enable short packet reception
				udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOT_IRQ_EN_MASK
800048f0:	ee f8 ff f0 	ld.w	r8,r7[-16]
800048f4:	e8 18 00 14 	orl	r8,0x14
800048f8:	ef 48 ff f0 	st.w	r7[-16],r8
						| AVR32_USBB_UDDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		udd_endpoint_dma_set_addr(ep, (U32) &ptr_job->buf[ptr_job->nb_trans]);
800048fc:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004900:	a5 68       	lsl	r8,0x4
80004902:	e0 38 fd 00 	sub	r8,130304
80004906:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000490a:	72 1a       	ld.w	r10,r9[0x4]
8000490c:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004910:	72 39       	ld.w	r9,r9[0xc]
80004912:	f4 09 00 09 	add	r9,r10,r9
80004916:	91 19       	st.w	r8[0x4],r9
		udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
80004918:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000491c:	e8 18 00 21 	orl	r8,0x21
80004920:	ef 48 ff f0 	st.w	r7[-16],r8
				AVR32_USBB_UDDMA1_CONTROL_CH_EN_MASK;

		// Disable IRQs to have a short sequence
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
80004924:	f0 1f 00 40 	mcall	80004a24 <udd_ep_trans_done+0x248>
80004928:	18 98       	mov	r8,r12
8000492a:	ef 48 ff fc 	st.w	r7[-4],r8
		if ( !(udd_endpoint_dma_get_status(ep)
8000492e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004932:	a5 68       	lsl	r8,0x4
80004934:	e0 38 fd 00 	sub	r8,130304
80004938:	70 38       	ld.w	r8,r8[0xc]
8000493a:	e2 18 00 10 	andl	r8,0x10,COH
8000493e:	c2 21       	brne	80004982 <udd_ep_trans_done+0x1a6>
				& AVR32_USBB_UDDMA1_STATUS_EOT_STA_MASK)) {
			udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
80004940:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004944:	a5 68       	lsl	r8,0x4
80004946:	e0 38 fd 00 	sub	r8,130304
8000494a:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000494e:	91 29       	st.w	r8[0x8],r9
			ptr_job->nb_trans += next_trans;
80004950:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004954:	70 39       	ld.w	r9,r8[0xc]
80004956:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000495a:	10 09       	add	r9,r8
8000495c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004960:	91 39       	st.w	r8[0xc],r9
			udd_enable_endpoint_dma_interrupt(ep);
80004962:	fe 68 00 00 	mov	r8,-131072
80004966:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000496a:	20 19       	sub	r9,1
8000496c:	30 0a       	mov	r10,0
8000496e:	ea 1a 02 00 	orh	r10,0x200
80004972:	f4 09 09 49 	lsl	r9,r10,r9
80004976:	91 69       	st.w	r8[0x18],r9
			cpu_irq_restore(flags);
80004978:	ee fc ff fc 	ld.w	r12,r7[-4]
8000497c:	f0 1f 00 2b 	mcall	80004a28 <udd_ep_trans_done+0x24c>
			return;
80004980:	c4 c8       	rjmp	80004a18 <udd_ep_trans_done+0x23c>
		}
		cpu_irq_restore(flags);
80004982:	ee fc ff fc 	ld.w	r12,r7[-4]
80004986:	f0 1f 00 29 	mcall	80004a28 <udd_ep_trans_done+0x24c>

		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
8000498a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000498e:	70 39       	ld.w	r9,r8[0xc]
80004990:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004994:	91 29       	st.w	r8[0x8],r9
	}
	if (Is_udd_endpoint_in(ep)) {
80004996:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000499a:	a3 68       	lsl	r8,0x2
8000499c:	e0 38 ff 00 	sub	r8,130816
800049a0:	70 08       	ld.w	r8,r8[0x0]
800049a2:	e2 18 01 00 	andl	r8,0x100,COH
800049a6:	c2 f0       	breq	80004a04 <udd_ep_trans_done+0x228>
		if (ptr_job->b_shortpacket) {
800049a8:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049ac:	70 08       	ld.w	r8,r8[0x0]
800049ae:	e6 18 40 00 	andh	r8,0x4000,COH
800049b2:	c2 90       	breq	80004a04 <udd_ep_trans_done+0x228>
			// Need to send a ZLP (No possible with USB DMA)
			// enable interrupt to wait a free bank to sent ZLP
			udd_ack_in_send(ep);
800049b4:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800049b8:	a3 68       	lsl	r8,0x2
800049ba:	e0 38 fe a0 	sub	r8,130720
800049be:	30 19       	mov	r9,1
800049c0:	91 09       	st.w	r8[0x0],r9
			if (Is_udd_write_enabled(ep)) {
800049c2:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800049c6:	a3 68       	lsl	r8,0x2
800049c8:	e0 38 fe d0 	sub	r8,130768
800049cc:	70 08       	ld.w	r8,r8[0x0]
800049ce:	e6 18 00 01 	andh	r8,0x1,COH
800049d2:	c0 80       	breq	800049e2 <udd_ep_trans_done+0x206>
				// Force interrupt in case of ep already free
				udd_raise_in_send(ep);
800049d4:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800049d8:	a3 68       	lsl	r8,0x2
800049da:	e0 38 fe 70 	sub	r8,130672
800049de:	30 19       	mov	r9,1
800049e0:	91 09       	st.w	r8[0x0],r9
			}
			udd_enable_in_send_interrupt(ep);
800049e2:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800049e6:	a3 68       	lsl	r8,0x2
800049e8:	e0 38 fe 10 	sub	r8,130576
800049ec:	30 19       	mov	r9,1
800049ee:	91 09       	st.w	r8[0x0],r9
			udd_enable_endpoint_interrupt(ep);
800049f0:	fe 68 00 00 	mov	r8,-131072
800049f4:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800049f8:	e0 6a 10 00 	mov	r10,4096
800049fc:	f4 09 09 49 	lsl	r9,r10,r9
80004a00:	91 69       	st.w	r8[0x18],r9
			return;
80004a02:	c0 b8       	rjmp	80004a18 <udd_ep_trans_done+0x23c>
		}
	}
	// Call callback to signal end of transfer
	udd_ep_finish_job(ptr_job, false, ep);
80004a04:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004a08:	10 9a       	mov	r10,r8
80004a0a:	30 0b       	mov	r11,0
80004a0c:	ee fc ff f4 	ld.w	r12,r7[-12]
80004a10:	f0 1f 00 07 	mcall	80004a2c <udd_ep_trans_done+0x250>
80004a14:	c0 28       	rjmp	80004a18 <udd_ep_trans_done+0x23c>

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if (!ptr_job->busy) {
		return; // No job is running, then ignore it (system error)
80004a16:	d7 03       	nop
			return;
		}
	}
	// Call callback to signal end of transfer
	udd_ep_finish_job(ptr_job, false, ep);
}
80004a18:	2f bd       	sub	sp,-20
80004a1a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a1e:	00 00       	add	r0,r0
80004a20:	00 00       	add	r0,r0
80004a22:	01 9c       	ld.ub	r12,r0[0x1]
80004a24:	80 00       	ld.sh	r0,r0[0x0]
80004a26:	2f c2       	sub	r2,-4
80004a28:	80 00       	ld.sh	r0,r0[0x0]
80004a2a:	30 00       	mov	r0,0
80004a2c:	80 00       	ld.sh	r0,r0[0x0]
80004a2e:	47 58       	lddsp	r8,sp[0x1d4]

80004a30 <udd_ep_interrupt>:


static bool udd_ep_interrupt(void)
{
80004a30:	eb cd 40 80 	pushm	r7,lr
80004a34:	1a 97       	mov	r7,sp
80004a36:	20 3d       	sub	sp,12
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
80004a38:	30 18       	mov	r8,1
80004a3a:	ef 68 ff f7 	st.b	r7[-9],r8
80004a3e:	cf 48       	rjmp	80004c26 <udd_ep_interrupt+0x1f6>
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
80004a40:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004a44:	f0 c9 00 01 	sub	r9,r8,1
80004a48:	12 98       	mov	r8,r9
80004a4a:	a3 68       	lsl	r8,0x2
80004a4c:	12 08       	add	r8,r9
80004a4e:	a3 68       	lsl	r8,0x2
80004a50:	10 99       	mov	r9,r8
80004a52:	4f c8       	lddpc	r8,80004c40 <udd_ep_interrupt+0x210>
80004a54:	f2 08 00 08 	add	r8,r9,r8
80004a58:	ef 48 ff f8 	st.w	r7[-8],r8

		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80004a5c:	fe 68 00 00 	mov	r8,-131072
80004a60:	70 49       	ld.w	r9,r8[0x10]
80004a62:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004a66:	20 18       	sub	r8,1
80004a68:	30 0a       	mov	r10,0
80004a6a:	ea 1a 02 00 	orh	r10,0x200
80004a6e:	f4 08 09 48 	lsl	r8,r10,r8
80004a72:	f3 e8 00 08 	and	r8,r9,r8
80004a76:	c4 90       	breq	80004b08 <udd_ep_interrupt+0xd8>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
80004a78:	fe 68 00 00 	mov	r8,-131072
80004a7c:	70 19       	ld.w	r9,r8[0x4]
80004a7e:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004a82:	20 18       	sub	r8,1
80004a84:	30 0a       	mov	r10,0
80004a86:	ea 1a 02 00 	orh	r10,0x200
80004a8a:	f4 08 09 48 	lsl	r8,r10,r8
80004a8e:	f3 e8 00 08 	and	r8,r9,r8
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];

		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80004a92:	c3 b0       	breq	80004b08 <udd_ep_interrupt+0xd8>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
			uint32_t nb_remaining;
			if( udd_endpoint_dma_get_status(ep)
80004a94:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004a98:	a5 68       	lsl	r8,0x4
80004a9a:	e0 38 fd 00 	sub	r8,130304
80004a9e:	70 38       	ld.w	r8,r8[0xc]
80004aa0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004aa4:	5c 58       	castu.b	r8
80004aa6:	c0 30       	breq	80004aac <udd_ep_interrupt+0x7c>
					& AVR32_USBB_UDDMA1_STATUS_CH_EN_MASK) {
				return true; // Ignore EOT_STA interrupt
80004aa8:	30 18       	mov	r8,1
80004aaa:	cc 68       	rjmp	80004c36 <udd_ep_interrupt+0x206>
			}
			udd_disable_endpoint_dma_interrupt(ep);
80004aac:	fe 68 00 00 	mov	r8,-131072
80004ab0:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80004ab4:	20 19       	sub	r9,1
80004ab6:	30 0a       	mov	r10,0
80004ab8:	ea 1a 02 00 	orh	r10,0x200
80004abc:	f4 09 09 49 	lsl	r9,r10,r9
80004ac0:	91 59       	st.w	r8[0x14],r9
			// Save number of data no transfered
			nb_remaining = (udd_endpoint_dma_get_status(ep) &
80004ac2:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004ac6:	a5 68       	lsl	r8,0x4
80004ac8:	e0 38 fd 00 	sub	r8,130304
80004acc:	70 38       	ld.w	r8,r8[0xc]
80004ace:	b1 88       	lsr	r8,0x10
80004ad0:	ef 48 ff fc 	st.w	r7[-4],r8
					AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_MASK)
					>> AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_OFFSET;
			if (nb_remaining) {
80004ad4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ad8:	58 08       	cp.w	r8,0
80004ada:	c1 00       	breq	80004afa <udd_ep_interrupt+0xca>
				// Transfer no complete (short packet or ZLP) then:
				// Update number of data transfered
				ptr_job->nb_trans -= nb_remaining;
80004adc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ae0:	70 39       	ld.w	r9,r8[0xc]
80004ae2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ae6:	10 19       	sub	r9,r8
80004ae8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004aec:	91 39       	st.w	r8[0xc],r9
				// Set transfer complete to stop the transfer
				ptr_job->buf_size = ptr_job->nb_trans;
80004aee:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004af2:	70 39       	ld.w	r9,r8[0xc]
80004af4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004af8:	91 29       	st.w	r8[0x8],r9
			}
			udd_ep_trans_done(ep);
80004afa:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004afe:	10 9c       	mov	r12,r8
80004b00:	f0 1f 00 51 	mcall	80004c44 <udd_ep_interrupt+0x214>
			return true;
80004b04:	30 18       	mov	r8,1
80004b06:	c9 88       	rjmp	80004c36 <udd_ep_interrupt+0x206>
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80004b08:	fe 68 00 00 	mov	r8,-131072
80004b0c:	70 49       	ld.w	r9,r8[0x10]
80004b0e:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b12:	e0 6a 10 00 	mov	r10,4096
80004b16:	f4 08 09 48 	lsl	r8,r10,r8
80004b1a:	f3 e8 00 08 	and	r8,r9,r8
80004b1e:	c7 f0       	breq	80004c1c <udd_ep_interrupt+0x1ec>
			if (Is_udd_in_send_interrupt_enabled(ep) && Is_udd_in_send(ep)) {
80004b20:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b24:	a3 68       	lsl	r8,0x2
80004b26:	e0 38 fe 40 	sub	r8,130624
80004b2a:	70 08       	ld.w	r8,r8[0x0]
80004b2c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b30:	5c 58       	castu.b	r8
80004b32:	c2 b0       	breq	80004b88 <udd_ep_interrupt+0x158>
80004b34:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b38:	a3 68       	lsl	r8,0x2
80004b3a:	e0 38 fe d0 	sub	r8,130768
80004b3e:	70 08       	ld.w	r8,r8[0x0]
80004b40:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b44:	5c 58       	castu.b	r8
80004b46:	c2 10       	breq	80004b88 <udd_ep_interrupt+0x158>
				udd_disable_in_send_interrupt(ep);
80004b48:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b4c:	a3 68       	lsl	r8,0x2
80004b4e:	e0 38 fd e0 	sub	r8,130528
80004b52:	30 19       	mov	r9,1
80004b54:	91 09       	st.w	r8[0x0],r9
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
80004b56:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b5a:	a3 68       	lsl	r8,0x2
80004b5c:	e0 38 fe a0 	sub	r8,130720
80004b60:	30 19       	mov	r9,1
80004b62:	91 09       	st.w	r8[0x0],r9
				udd_ack_fifocon(ep);
80004b64:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b68:	a3 68       	lsl	r8,0x2
80004b6a:	e0 38 fd e0 	sub	r8,130528
80004b6e:	e0 69 40 00 	mov	r9,16384
80004b72:	91 09       	st.w	r8[0x0],r9
				udd_ep_finish_job(ptr_job, false, ep);
80004b74:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b78:	10 9a       	mov	r10,r8
80004b7a:	30 0b       	mov	r11,0
80004b7c:	ee fc ff f8 	ld.w	r12,r7[-8]
80004b80:	f0 1f 00 32 	mcall	80004c48 <udd_ep_interrupt+0x218>
				return true;
80004b84:	30 18       	mov	r8,1
80004b86:	c5 88       	rjmp	80004c36 <udd_ep_interrupt+0x206>
			}
			if (Is_udd_bank_interrupt_enabled(ep) && (0 == udd_nb_busy_bank(ep))) {
80004b88:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b8c:	a3 68       	lsl	r8,0x2
80004b8e:	e0 38 fe 40 	sub	r8,130624
80004b92:	70 08       	ld.w	r8,r8[0x0]
80004b94:	e2 18 10 00 	andl	r8,0x1000,COH
80004b98:	c4 20       	breq	80004c1c <udd_ep_interrupt+0x1ec>
80004b9a:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b9e:	a3 68       	lsl	r8,0x2
80004ba0:	e0 38 fe d0 	sub	r8,130768
80004ba4:	70 08       	ld.w	r8,r8[0x0]
80004ba6:	e2 18 30 00 	andl	r8,0x3000,COH
80004baa:	ad 88       	lsr	r8,0xc
80004bac:	c3 81       	brne	80004c1c <udd_ep_interrupt+0x1ec>
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
80004bae:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004bb2:	a3 68       	lsl	r8,0x2
80004bb4:	e0 38 fd e0 	sub	r8,130528
80004bb8:	e0 69 10 00 	mov	r9,4096
80004bbc:	91 09       	st.w	r8[0x0],r9
				udd_disable_endpoint_interrupt(ep);
80004bbe:	fe 68 00 00 	mov	r8,-131072
80004bc2:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80004bc6:	e0 6a 10 00 	mov	r10,4096
80004bca:	f4 09 09 49 	lsl	r9,r10,r9
80004bce:	91 59       	st.w	r8[0x14],r9

				Assert(ptr_job->stall_requested);
				// A stall has been requested during background transfer
				ptr_job->stall_requested = false;
80004bd0:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004bd4:	72 08       	ld.w	r8,r9[0x0]
80004bd6:	30 0a       	mov	r10,0
80004bd8:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
80004bdc:	93 08       	st.w	r9[0x0],r8
				udd_disable_endpoint_bank_autoswitch(ep);
80004bde:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004be2:	a3 68       	lsl	r8,0x2
80004be4:	e0 38 ff 00 	sub	r8,130816
80004be8:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80004bec:	a3 69       	lsl	r9,0x2
80004bee:	e0 39 ff 00 	sub	r9,130816
80004bf2:	72 09       	ld.w	r9,r9[0x0]
80004bf4:	a9 d9       	cbr	r9,0x9
80004bf6:	91 09       	st.w	r8[0x0],r9
				udd_enable_stall_handshake(ep);
80004bf8:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004bfc:	a3 68       	lsl	r8,0x2
80004bfe:	e0 38 fe 10 	sub	r8,130576
80004c02:	e8 69 00 00 	mov	r9,524288
80004c06:	91 09       	st.w	r8[0x0],r9
				udd_reset_data_toggle(ep);
80004c08:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004c0c:	a3 68       	lsl	r8,0x2
80004c0e:	e0 38 fe 10 	sub	r8,130576
80004c12:	e4 69 00 00 	mov	r9,262144
80004c16:	91 09       	st.w	r8[0x0],r9
				return true;
80004c18:	30 18       	mov	r8,1
80004c1a:	c0 e8       	rjmp	80004c36 <udd_ep_interrupt+0x206>
{
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
80004c1c:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004c20:	2f f8       	sub	r8,-1
80004c22:	ef 68 ff f7 	st.b	r7[-9],r8
80004c26:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80004c2a:	30 38       	mov	r8,3
80004c2c:	f0 09 18 00 	cp.b	r9,r8
80004c30:	fe 98 ff 08 	brls	80004a40 <udd_ep_interrupt+0x10>
				udd_reset_data_toggle(ep);
				return true;
			}
		}
	}
	return false;
80004c34:	30 08       	mov	r8,0
}
80004c36:	10 9c       	mov	r12,r8
80004c38:	2f dd       	sub	sp,-12
80004c3a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c3e:	00 00       	add	r0,r0
80004c40:	00 00       	add	r0,r0
80004c42:	01 9c       	ld.ub	r12,r0[0x1]
80004c44:	80 00       	ld.sh	r0,r0[0x0]
80004c46:	47 dc       	lddsp	r12,sp[0x1f4]
80004c48:	80 00       	ld.sh	r0,r0[0x0]
80004c4a:	47 58       	lddsp	r8,sp[0x1d4]

80004c4c <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004c4c:	e0 6d 80 00 	mov	sp,32768

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004c50:	fe c0 be 50 	sub	r0,pc,-16816

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004c54:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004c58:	d5 53       	csrf	0x15
  cp      r0, r1
80004c5a:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80004c5c:	e0 61 00 e8 	mov	r1,232
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004c60:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004c62:	c0 72       	brcc	80004c70 <idata_load_loop_end>
  cp      r0, r1
80004c64:	fe c2 bb ac 	sub	r2,pc,-17492

80004c68 <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004c68:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80004c6a:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80004c6c:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80004c6e:	cf d3       	brcs	80004c68 <idata_load_loop>

80004c70 <idata_load_loop_end>:
  mov     r2, 0
80004c70:	e0 60 00 e8 	mov	r0,232
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80004c74:	e0 61 46 68 	mov	r1,18024
  cp      r0, r1
  brlo    udata_clear_loop
80004c78:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004c7a:	c0 62       	brcc	80004c86 <udata_clear_loop_end>
80004c7c:	30 02       	mov	r2,0
80004c7e:	30 03       	mov	r3,0

80004c80 <udata_clear_loop>:
80004c80:	a1 22       	st.d	r0++,r2
80004c82:	02 30       	cp.w	r0,r1
80004c84:	cf e3       	brcs	80004c80 <udata_clear_loop>

80004c86 <udata_clear_loop_end>:
80004c86:	fe cf d7 96 	sub	pc,pc,-10346
80004c8a:	d7 03       	nop

80004c8c <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80004c8c:	eb cd 40 80 	pushm	r7,lr
80004c90:	1a 97       	mov	r7,sp
80004c92:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004c94:	e1 b8 00 00 	mfsr	r8,0x0
80004c98:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80004c9c:	d3 03       	ssrf	0x10

	return flags;
80004c9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004ca2:	10 9c       	mov	r12,r8
80004ca4:	2f fd       	sub	sp,-4
80004ca6:	e3 cd 80 80 	ldm	sp++,r7,pc

80004caa <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004caa:	eb cd 40 80 	pushm	r7,lr
80004cae:	1a 97       	mov	r7,sp
80004cb0:	20 1d       	sub	sp,4
80004cb2:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80004cb6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cba:	e6 18 00 01 	andh	r8,0x1,COH
80004cbe:	5f 08       	sreq	r8
80004cc0:	5c 58       	castu.b	r8
}
80004cc2:	10 9c       	mov	r12,r8
80004cc4:	2f fd       	sub	sp,-4
80004cc6:	e3 cd 80 80 	ldm	sp++,r7,pc
80004cca:	d7 03       	nop

80004ccc <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80004ccc:	eb cd 40 80 	pushm	r7,lr
80004cd0:	1a 97       	mov	r7,sp
80004cd2:	20 1d       	sub	sp,4
80004cd4:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004cd8:	ee fc ff fc 	ld.w	r12,r7[-4]
80004cdc:	f0 1f 00 05 	mcall	80004cf0 <cpu_irq_restore+0x24>
80004ce0:	18 98       	mov	r8,r12
80004ce2:	58 08       	cp.w	r8,0
80004ce4:	c0 20       	breq	80004ce8 <cpu_irq_restore+0x1c>
      cpu_irq_enable();
80004ce6:	d5 03       	csrf	0x10
   }

	barrier();
}
80004ce8:	2f fd       	sub	sp,-4
80004cea:	e3 cd 80 80 	ldm	sp++,r7,pc
80004cee:	00 00       	add	r0,r0
80004cf0:	80 00       	ld.sh	r0,r0[0x0]
80004cf2:	4c aa       	lddpc	r10,80004e18 <osc_wait_ready+0x18>

80004cf4 <osc_enable>:
#include <stdbool.h>
#include <stdint.h>
#include <avr32/io.h>

static inline void osc_enable(uint8_t id)
{
80004cf4:	eb cd 40 80 	pushm	r7,lr
80004cf8:	1a 97       	mov	r7,sp
80004cfa:	20 3d       	sub	sp,12
80004cfc:	18 98       	mov	r8,r12
80004cfe:	ef 68 ff f4 	st.b	r7[-12],r8
	irqflags_t flags;
	uint32_t   oscctrl;

	flags = cpu_irq_save();
80004d02:	f0 1f 00 1f 	mcall	80004d7c <osc_enable+0x88>
80004d06:	18 98       	mov	r8,r12
80004d08:	ef 48 ff f8 	st.w	r7[-8],r8

	switch (id) {
80004d0c:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80004d10:	58 08       	cp.w	r8,0
80004d12:	c0 40       	breq	80004d1a <osc_enable+0x26>
80004d14:	58 28       	cp.w	r8,2
80004d16:	c1 90       	breq	80004d48 <osc_enable+0x54>
80004d18:	c2 b8       	rjmp	80004d6e <osc_enable+0x7a>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
80004d1a:	e0 68 03 00 	mov	r8,768
80004d1e:	ef 48 ff fc 	st.w	r7[-4],r8
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
80004d22:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d26:	e8 18 00 07 	orl	r8,0x7
80004d2a:	ef 48 ff fc 	st.w	r7[-4],r8
		AVR32_PM.oscctrl0 = oscctrl;
80004d2e:	fe 78 0c 00 	mov	r8,-62464
80004d32:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d36:	91 a9       	st.w	r8[0x28],r9
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
80004d38:	fe 78 0c 00 	mov	r8,-62464
80004d3c:	fe 79 0c 00 	mov	r9,-62464
80004d40:	72 09       	ld.w	r9,r9[0x0]
80004d42:	a3 a9       	sbr	r9,0x2
80004d44:	91 09       	st.w	r8[0x0],r9
		break;
80004d46:	c1 48       	rjmp	80004d6e <osc_enable+0x7a>
		break;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		oscctrl = OSC32_STARTUP_VALUE
80004d48:	e2 68 00 00 	mov	r8,131072
80004d4c:	ef 48 ff fc 	st.w	r7[-4],r8
				<< AVR32_PM_OSCCTRL32_STARTUP_OFFSET;
		oscctrl |= OSC32_MODE_VALUE << AVR32_PM_OSCCTRL32_MODE_OFFSET;
80004d50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d54:	a9 a8       	sbr	r8,0x8
80004d56:	ef 48 ff fc 	st.w	r7[-4],r8
		oscctrl |= 1 << AVR32_PM_OSCCTRL32_OSC32EN_OFFSET;
80004d5a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d5e:	a1 a8       	sbr	r8,0x0
80004d60:	ef 48 ff fc 	st.w	r7[-4],r8
		AVR32_PM.oscctrl32 = oscctrl;
80004d64:	fe 78 0c 00 	mov	r8,-62464
80004d68:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d6c:	91 c9       	st.w	r8[0x30],r9
	default:
		/* unhandled_case(id); */
		break;
	}

	cpu_irq_restore(flags);
80004d6e:	ee fc ff f8 	ld.w	r12,r7[-8]
80004d72:	f0 1f 00 04 	mcall	80004d80 <osc_enable+0x8c>
}
80004d76:	2f dd       	sub	sp,-12
80004d78:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d7c:	80 00       	ld.sh	r0,r0[0x0]
80004d7e:	4c 8c       	lddpc	r12,80004e9c <pll_config_init+0x40>
80004d80:	80 00       	ld.sh	r0,r0[0x0]
80004d82:	4c cc       	lddpc	r12,80004eb0 <pll_config_init+0x54>

80004d84 <osc_is_ready>:
	}
	cpu_irq_restore(flags);
}

static inline bool osc_is_ready(uint8_t id)
{
80004d84:	eb cd 40 80 	pushm	r7,lr
80004d88:	1a 97       	mov	r7,sp
80004d8a:	20 1d       	sub	sp,4
80004d8c:	18 98       	mov	r8,r12
80004d8e:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
80004d92:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80004d96:	58 08       	cp.w	r8,0
80004d98:	c0 40       	breq	80004da0 <osc_is_ready+0x1c>
80004d9a:	58 28       	cp.w	r8,2
80004d9c:	c0 a0       	breq	80004db0 <osc_is_ready+0x2c>
80004d9e:	c1 18       	rjmp	80004dc0 <osc_is_ready+0x3c>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC0RDY));
80004da0:	fe 78 0c 00 	mov	r8,-62464
80004da4:	71 58       	ld.w	r8,r8[0x54]
80004da6:	e2 18 00 80 	andl	r8,0x80,COH
80004daa:	5f 18       	srne	r8
80004dac:	5c 58       	castu.b	r8
80004dae:	c0 a8       	rjmp	80004dc2 <osc_is_ready+0x3e>
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC1RDY));
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC32RDY));
80004db0:	fe 78 0c 00 	mov	r8,-62464
80004db4:	71 58       	ld.w	r8,r8[0x54]
80004db6:	e2 18 02 00 	andl	r8,0x200,COH
80004dba:	5f 18       	srne	r8
80004dbc:	5c 58       	castu.b	r8
80004dbe:	c0 28       	rjmp	80004dc2 <osc_is_ready+0x3e>
#endif

	default:
		/* unhandled_case(id); */
		return false;
80004dc0:	30 08       	mov	r8,0
	}
}
80004dc2:	10 9c       	mov	r12,r8
80004dc4:	2f fd       	sub	sp,-4
80004dc6:	e3 cd 80 80 	ldm	sp++,r7,pc

80004dca <osc_get_rate>:

static inline uint32_t osc_get_rate(uint8_t id)
{
80004dca:	eb cd 40 80 	pushm	r7,lr
80004dce:	1a 97       	mov	r7,sp
80004dd0:	20 1d       	sub	sp,4
80004dd2:	18 98       	mov	r8,r12
80004dd4:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
80004dd8:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80004ddc:	58 08       	cp.w	r8,0
80004dde:	c0 40       	breq	80004de6 <osc_get_rate+0x1c>
80004de0:	58 28       	cp.w	r8,2
80004de2:	c0 70       	breq	80004df0 <osc_get_rate+0x26>
80004de4:	c0 98       	rjmp	80004df6 <osc_get_rate+0x2c>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return BOARD_OSC0_HZ;
80004de6:	e0 68 1b 00 	mov	r8,6912
80004dea:	ea 18 00 b7 	orh	r8,0xb7
80004dee:	c0 58       	rjmp	80004df8 <osc_get_rate+0x2e>
		return BOARD_OSC1_HZ;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		return BOARD_OSC32_HZ;
80004df0:	e0 68 80 00 	mov	r8,32768
80004df4:	c0 28       	rjmp	80004df8 <osc_get_rate+0x2e>
#endif
	default:
		/* unhandled_case(id); */
		return 0;
80004df6:	30 08       	mov	r8,0
	}
}
80004df8:	10 9c       	mov	r12,r8
80004dfa:	2f fd       	sub	sp,-4
80004dfc:	e3 cd 80 80 	ldm	sp++,r7,pc

80004e00 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
80004e00:	eb cd 40 80 	pushm	r7,lr
80004e04:	1a 97       	mov	r7,sp
80004e06:	20 1d       	sub	sp,4
80004e08:	18 98       	mov	r8,r12
80004e0a:	ef 68 ff fc 	st.b	r7[-4],r8
	while (!osc_is_ready(id)) {
80004e0e:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80004e12:	10 9c       	mov	r12,r8
80004e14:	f0 1f 00 05 	mcall	80004e28 <osc_wait_ready+0x28>
80004e18:	18 98       	mov	r8,r12
80004e1a:	ec 18 00 01 	eorl	r8,0x1
80004e1e:	5c 58       	castu.b	r8
80004e20:	cf 71       	brne	80004e0e <osc_wait_ready+0xe>
		/* Do nothing */
	}
}
80004e22:	2f fd       	sub	sp,-4
80004e24:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e28:	80 00       	ld.sh	r0,r0[0x0]
80004e2a:	4d 84       	lddpc	r4,80004f88 <pll_is_locked+0x20>

80004e2c <pll_config_set_option>:
			* CONFIG_PLL##pll_id##_MUL)                            \
			/ CONFIG_PLL##pll_id##_DIV)

static inline void pll_config_set_option(struct pll_config *cfg,
		unsigned int option)
{
80004e2c:	eb cd 40 80 	pushm	r7,lr
80004e30:	1a 97       	mov	r7,sp
80004e32:	20 2d       	sub	sp,8
80004e34:	ef 4c ff fc 	st.w	r7[-4],r12
80004e38:	ef 4b ff f8 	st.w	r7[-8],r11
	Assert(option < PLL_NR_OPTIONS);

	cfg->ctrl |= 1U << (AVR32_PM_PLL0_PLLOPT + option);
80004e3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e40:	70 09       	ld.w	r9,r8[0x0]
80004e42:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e46:	2f e8       	sub	r8,-2
80004e48:	30 1a       	mov	r10,1
80004e4a:	f4 08 09 48 	lsl	r8,r10,r8
80004e4e:	10 49       	or	r9,r8
80004e50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e54:	91 09       	st.w	r8[0x0],r9
}
80004e56:	2f ed       	sub	sp,-8
80004e58:	e3 cd 80 80 	ldm	sp++,r7,pc

80004e5c <pll_config_init>:
 * The PLL options #PLL_OPT_VCO_RANGE_LOW and #PLL_OPT_OUTPUT_DIV will
 * be set automatically based on the calculated target frequency.
 */
static inline void pll_config_init(struct pll_config *cfg,
		enum pll_source src, unsigned int div, unsigned int mul)
{
80004e5c:	eb cd 40 80 	pushm	r7,lr
80004e60:	1a 97       	mov	r7,sp
80004e62:	20 5d       	sub	sp,20
80004e64:	ef 4c ff f8 	st.w	r7[-8],r12
80004e68:	ef 4b ff f4 	st.w	r7[-12],r11
80004e6c:	ef 4a ff f0 	st.w	r7[-16],r10
80004e70:	ef 49 ff ec 	st.w	r7[-20],r9
	uint32_t vco_hz;

	Assert(src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(src) * mul;
80004e74:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004e78:	5c 58       	castu.b	r8
80004e7a:	10 9c       	mov	r12,r8
80004e7c:	f0 1f 00 2e 	mcall	80004f34 <pll_config_init+0xd8>
80004e80:	18 99       	mov	r9,r12
80004e82:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004e86:	f2 08 02 48 	mul	r8,r9,r8
80004e8a:	ef 48 ff fc 	st.w	r7[-4],r8
	vco_hz /= div;
80004e8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e92:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004e96:	f0 09 0d 08 	divu	r8,r8,r9
80004e9a:	ef 48 ff fc 	st.w	r7[-4],r8
	Assert(vco_hz >= PLL_MIN_HZ);
	Assert(vco_hz <= PLL_MAX_HZ);

	cfg->ctrl = 0;
80004e9e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ea2:	30 09       	mov	r9,0
80004ea4:	91 09       	st.w	r8[0x0],r9

	/* Bring the internal VCO frequency up to the minimum value */
	if ((vco_hz < PLL_MIN_HZ * 2) && (mul <= 8)) {
80004ea6:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004eaa:	e0 69 b3 ff 	mov	r9,46079
80004eae:	ea 19 04 c4 	orh	r9,0x4c4
80004eb2:	12 38       	cp.w	r8,r9
80004eb4:	e0 8b 00 16 	brhi	80004ee0 <pll_config_init+0x84>
80004eb8:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004ebc:	58 88       	cp.w	r8,8
80004ebe:	e0 8b 00 11 	brhi	80004ee0 <pll_config_init+0x84>
		mul *= 2;
80004ec2:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004ec6:	a1 78       	lsl	r8,0x1
80004ec8:	ef 48 ff ec 	st.w	r7[-20],r8
		vco_hz *= 2;
80004ecc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ed0:	a1 78       	lsl	r8,0x1
80004ed2:	ef 48 ff fc 	st.w	r7[-4],r8
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
80004ed6:	30 1b       	mov	r11,1
80004ed8:	ee fc ff f8 	ld.w	r12,r7[-8]
80004edc:	f0 1f 00 17 	mcall	80004f38 <pll_config_init+0xdc>
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80004ee0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ee4:	e0 69 fe 7f 	mov	r9,65151
80004ee8:	ea 19 0a 21 	orh	r9,0xa21
80004eec:	12 38       	cp.w	r8,r9
80004eee:	e0 8b 00 07 	brhi	80004efc <pll_config_init+0xa0>
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);
80004ef2:	30 0b       	mov	r11,0
80004ef4:	ee fc ff f8 	ld.w	r12,r7[-8]
80004ef8:	f0 1f 00 10 	mcall	80004f38 <pll_config_init+0xdc>

	Assert((mul > 2) && (mul <= 16));
	Assert((div > 0) && (div <= 15));

	cfg->ctrl |= ((mul - 1) << AVR32_PM_PLL0_PLLMUL)
80004efc:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f00:	70 09       	ld.w	r9,r8[0x0]
80004f02:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004f06:	20 18       	sub	r8,1
80004f08:	f0 0a 15 10 	lsl	r10,r8,0x10
			| (div << AVR32_PM_PLL0_PLLDIV)
80004f0c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004f10:	a9 68       	lsl	r8,0x8
			| (PLL_MAX_STARTUP_CYCLES << AVR32_PM_PLL0_PLLCOUNT)
80004f12:	10 4a       	or	r10,r8
			| (src << AVR32_PM_PLL0_PLLOSC);
80004f14:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004f18:	a1 78       	lsl	r8,0x1
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);

	Assert((mul > 2) && (mul <= 16));
	Assert((div > 0) && (div <= 15));

	cfg->ctrl |= ((mul - 1) << AVR32_PM_PLL0_PLLMUL)
80004f1a:	f5 e8 10 08 	or	r8,r10,r8
80004f1e:	f3 e8 10 08 	or	r8,r9,r8
80004f22:	10 99       	mov	r9,r8
80004f24:	ea 19 3f 00 	orh	r9,0x3f00
80004f28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f2c:	91 09       	st.w	r8[0x0],r9
			| (div << AVR32_PM_PLL0_PLLDIV)
			| (PLL_MAX_STARTUP_CYCLES << AVR32_PM_PLL0_PLLCOUNT)
			| (src << AVR32_PM_PLL0_PLLOSC);
}
80004f2e:	2f bd       	sub	sp,-20
80004f30:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f34:	80 00       	ld.sh	r0,r0[0x0]
80004f36:	4d ca       	lddpc	r10,800050a4 <genclk_config_set_source+0x12>
80004f38:	80 00       	ld.sh	r0,r0[0x0]
80004f3a:	4e 2c       	lddpc	r12,800050c0 <genclk_config_set_source+0x2e>

80004f3c <pll_enable>:
	AVR32_PM.pll[pll_id] = cfg->ctrl;
}

static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
80004f3c:	eb cd 40 80 	pushm	r7,lr
80004f40:	1a 97       	mov	r7,sp
80004f42:	20 2d       	sub	sp,8
80004f44:	ef 4c ff fc 	st.w	r7[-4],r12
80004f48:	ef 4b ff f8 	st.w	r7[-8],r11
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80004f4c:	fe 78 0c 00 	mov	r8,-62464
80004f50:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004f54:	ee fa ff fc 	ld.w	r10,r7[-4]
80004f58:	74 0a       	ld.w	r10,r10[0x0]
80004f5a:	a1 aa       	sbr	r10,0x0
80004f5c:	2f 89       	sub	r9,-8
80004f5e:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
}
80004f62:	2f ed       	sub	sp,-8
80004f64:	e3 cd 80 80 	ldm	sp++,r7,pc

80004f68 <pll_is_locked>:

	AVR32_PM.pll[pll_id] = 0;
}

static inline bool pll_is_locked(unsigned int pll_id)
{
80004f68:	eb cd 40 80 	pushm	r7,lr
80004f6c:	1a 97       	mov	r7,sp
80004f6e:	20 1d       	sub	sp,4
80004f70:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80004f74:	fe 78 0c 00 	mov	r8,-62464
80004f78:	71 59       	ld.w	r9,r8[0x54]
80004f7a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f7e:	30 1a       	mov	r10,1
80004f80:	f4 08 09 48 	lsl	r8,r10,r8
80004f84:	f3 e8 00 08 	and	r8,r9,r8
80004f88:	5f 18       	srne	r8
80004f8a:	5c 58       	castu.b	r8
}
80004f8c:	10 9c       	mov	r12,r8
80004f8e:	2f fd       	sub	sp,-4
80004f90:	e3 cd 80 80 	ldm	sp++,r7,pc

80004f94 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source src)
{
80004f94:	eb cd 40 80 	pushm	r7,lr
80004f98:	1a 97       	mov	r7,sp
80004f9a:	20 1d       	sub	sp,4
80004f9c:	ef 4c ff fc 	st.w	r7[-4],r12
	switch (src) {
80004fa0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fa4:	58 08       	cp.w	r8,0
80004fa6:	c0 40       	breq	80004fae <pll_enable_source+0x1a>
80004fa8:	58 18       	cp.w	r8,1
80004faa:	c1 10       	breq	80004fcc <pll_enable_source+0x38>
80004fac:	c2 08       	rjmp	80004fec <pll_enable_source+0x58>
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80004fae:	30 0c       	mov	r12,0
80004fb0:	f0 1f 00 11 	mcall	80004ff4 <pll_enable_source+0x60>
80004fb4:	18 98       	mov	r8,r12
80004fb6:	ec 18 00 01 	eorl	r8,0x1
80004fba:	5c 58       	castu.b	r8
80004fbc:	c1 70       	breq	80004fea <pll_enable_source+0x56>
			osc_enable(OSC_ID_OSC0);
80004fbe:	30 0c       	mov	r12,0
80004fc0:	f0 1f 00 0e 	mcall	80004ff8 <pll_enable_source+0x64>
			osc_wait_ready(OSC_ID_OSC0);
80004fc4:	30 0c       	mov	r12,0
80004fc6:	f0 1f 00 0e 	mcall	80004ffc <pll_enable_source+0x68>
		}
		break;
80004fca:	c1 18       	rjmp	80004fec <pll_enable_source+0x58>

	case PLL_SRC_OSC1:
		if (!osc_is_ready(OSC_ID_OSC1)) {
80004fcc:	30 1c       	mov	r12,1
80004fce:	f0 1f 00 0a 	mcall	80004ff4 <pll_enable_source+0x60>
80004fd2:	18 98       	mov	r8,r12
80004fd4:	ec 18 00 01 	eorl	r8,0x1
80004fd8:	5c 58       	castu.b	r8
80004fda:	c0 90       	breq	80004fec <pll_enable_source+0x58>
			osc_enable(OSC_ID_OSC1);
80004fdc:	30 1c       	mov	r12,1
80004fde:	f0 1f 00 07 	mcall	80004ff8 <pll_enable_source+0x64>
			osc_wait_ready(OSC_ID_OSC1);
80004fe2:	30 1c       	mov	r12,1
80004fe4:	f0 1f 00 06 	mcall	80004ffc <pll_enable_source+0x68>
80004fe8:	c0 28       	rjmp	80004fec <pll_enable_source+0x58>
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
			osc_wait_ready(OSC_ID_OSC0);
		}
		break;
80004fea:	d7 03       	nop

	default:
		Assert(false);
		break;
	}
}
80004fec:	2f fd       	sub	sp,-4
80004fee:	e3 cd 80 80 	ldm	sp++,r7,pc
80004ff2:	00 00       	add	r0,r0
80004ff4:	80 00       	ld.sh	r0,r0[0x0]
80004ff6:	4d 84       	lddpc	r4,80005154 <genclk_enable_source+0x4>
80004ff8:	80 00       	ld.sh	r0,r0[0x0]
80004ffa:	4c f4       	lddpc	r4,80005134 <genclk_enable+0x12>
80004ffc:	80 00       	ld.sh	r0,r0[0x0]
80004ffe:	4e 00       	lddpc	r0,8000517c <genclk_enable_source+0x2c>

80005000 <pll_enable_config_defaults>:

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
80005000:	eb cd 40 80 	pushm	r7,lr
80005004:	1a 97       	mov	r7,sp
80005006:	20 2d       	sub	sp,8
80005008:	ef 4c ff f8 	st.w	r7[-8],r12
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
8000500c:	ee fc ff f8 	ld.w	r12,r7[-8]
80005010:	f0 1f 00 15 	mcall	80005064 <pll_enable_config_defaults+0x64>
80005014:	18 98       	mov	r8,r12
80005016:	58 08       	cp.w	r8,0
80005018:	c2 11       	brne	8000505a <pll_enable_config_defaults+0x5a>
		return; // Pll already running
	}
	switch (pll_id) {
8000501a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000501e:	58 08       	cp.w	r8,0
80005020:	c0 c1       	brne	80005038 <pll_enable_config_defaults+0x38>
#ifdef CONFIG_PLL0_SOURCE
	case 0:
		pll_enable_source(CONFIG_PLL0_SOURCE);
80005022:	30 0c       	mov	r12,0
80005024:	f0 1f 00 11 	mcall	80005068 <pll_enable_config_defaults+0x68>
		pll_config_init(&pllcfg,
80005028:	ee c8 00 04 	sub	r8,r7,4
8000502c:	31 09       	mov	r9,16
8000502e:	30 2a       	mov	r10,2
80005030:	30 0b       	mov	r11,0
80005032:	10 9c       	mov	r12,r8
80005034:	f0 1f 00 0e 	mcall	8000506c <pll_enable_config_defaults+0x6c>
#endif
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
80005038:	ee c8 00 04 	sub	r8,r7,4
8000503c:	ee fb ff f8 	ld.w	r11,r7[-8]
80005040:	10 9c       	mov	r12,r8
80005042:	f0 1f 00 0c 	mcall	80005070 <pll_enable_config_defaults+0x70>
	while (!pll_is_locked(pll_id));
80005046:	ee fc ff f8 	ld.w	r12,r7[-8]
8000504a:	f0 1f 00 07 	mcall	80005064 <pll_enable_config_defaults+0x64>
8000504e:	18 98       	mov	r8,r12
80005050:	ec 18 00 01 	eorl	r8,0x1
80005054:	5c 58       	castu.b	r8
80005056:	cf 81       	brne	80005046 <pll_enable_config_defaults+0x46>
80005058:	c0 28       	rjmp	8000505c <pll_enable_config_defaults+0x5c>
static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
		return; // Pll already running
8000505a:	d7 03       	nop
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
}
8000505c:	2f ed       	sub	sp,-8
8000505e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005062:	00 00       	add	r0,r0
80005064:	80 00       	ld.sh	r0,r0[0x0]
80005066:	4f 68       	lddpc	r8,8000523c <sysclk_get_cpu_hz+0x8>
80005068:	80 00       	ld.sh	r0,r0[0x0]
8000506a:	4f 94       	lddpc	r4,8000524c <sysclk_enable_hsb_module>
8000506c:	80 00       	ld.sh	r0,r0[0x0]
8000506e:	4e 5c       	lddpc	r12,80005200 <genclk_enable_config+0x58>
80005070:	80 00       	ld.sh	r0,r0[0x0]
80005072:	4f 3c       	lddpc	r12,8000523c <sysclk_get_cpu_hz+0x8>

80005074 <genclk_config_defaults>:
	uint32_t ctrl;
};

static inline void genclk_config_defaults(struct genclk_config *cfg,
		unsigned int id)
{
80005074:	eb cd 40 80 	pushm	r7,lr
80005078:	1a 97       	mov	r7,sp
8000507a:	20 2d       	sub	sp,8
8000507c:	ef 4c ff fc 	st.w	r7[-4],r12
80005080:	ef 4b ff f8 	st.w	r7[-8],r11
	cfg->ctrl = 0;
80005084:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005088:	30 09       	mov	r9,0
8000508a:	91 09       	st.w	r8[0x0],r9
}
8000508c:	2f ed       	sub	sp,-8
8000508e:	e3 cd 80 80 	ldm	sp++,r7,pc

80005092 <genclk_config_set_source>:
	AVR32_PM.gcctrl[id] = cfg->ctrl;
}

static inline void genclk_config_set_source(struct genclk_config *cfg,
		enum genclk_source src)
{
80005092:	eb cd 40 80 	pushm	r7,lr
80005096:	1a 97       	mov	r7,sp
80005098:	20 3d       	sub	sp,12
8000509a:	ef 4c ff f8 	st.w	r7[-8],r12
8000509e:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t mask;

	mask = AVR32_PM_GCCTRL_OSCSEL_MASK | AVR32_PM_GCCTRL_PLLSEL_MASK;
800050a2:	30 38       	mov	r8,3
800050a4:	ef 48 ff fc 	st.w	r7[-4],r8
	Assert(!(src & ~mask));

	cfg->ctrl = (cfg->ctrl & ~mask) | (src << AVR32_PM_GCCTRL_OSCSEL);
800050a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050ac:	70 09       	ld.w	r9,r8[0x0]
800050ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050b2:	5c d8       	com	r8
800050b4:	10 69       	and	r9,r8
800050b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800050ba:	10 49       	or	r9,r8
800050bc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050c0:	91 09       	st.w	r8[0x0],r9
}
800050c2:	2f dd       	sub	sp,-12
800050c4:	e3 cd 80 80 	ldm	sp++,r7,pc

800050c8 <genclk_config_set_divider>:

static inline void genclk_config_set_divider(struct genclk_config *cfg,
		unsigned int divider)
{
800050c8:	eb cd 40 80 	pushm	r7,lr
800050cc:	1a 97       	mov	r7,sp
800050ce:	20 2d       	sub	sp,8
800050d0:	ef 4c ff fc 	st.w	r7[-4],r12
800050d4:	ef 4b ff f8 	st.w	r7[-8],r11
	Assert((divider > 0) && (divider <= GENCLK_DIV_MAX));

	/* Clear all the bits we're about to modify */
	cfg->ctrl &= ~(AVR32_PM_GCCTRL_DIVEN_MASK | AVR32_PM_GCCTRL_DIV_MASK);
800050d8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050dc:	70 08       	ld.w	r8,r8[0x0]
800050de:	10 99       	mov	r9,r8
800050e0:	e0 19 00 ef 	andl	r9,0xef
800050e4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050e8:	91 09       	st.w	r8[0x0],r9

	if (divider > 1) {
800050ea:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050ee:	58 18       	cp.w	r8,1
800050f0:	e0 88 00 16 	brls	8000511c <genclk_config_set_divider+0x54>
		cfg->ctrl |= 1U << AVR32_PM_GCCTRL_DIVEN;
800050f4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050f8:	70 08       	ld.w	r8,r8[0x0]
800050fa:	10 99       	mov	r9,r8
800050fc:	a5 a9       	sbr	r9,0x4
800050fe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005102:	91 09       	st.w	r8[0x0],r9
		cfg->ctrl |= ((divider >> 1) - 1) << AVR32_PM_GCCTRL_DIV;
80005104:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005108:	70 09       	ld.w	r9,r8[0x0]
8000510a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000510e:	a1 98       	lsr	r8,0x1
80005110:	20 18       	sub	r8,1
80005112:	a9 68       	lsl	r8,0x8
80005114:	10 49       	or	r9,r8
80005116:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000511a:	91 09       	st.w	r8[0x0],r9
	}
}
8000511c:	2f ed       	sub	sp,-8
8000511e:	e3 cd 80 80 	ldm	sp++,r7,pc

80005122 <genclk_enable>:

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
80005122:	eb cd 40 80 	pushm	r7,lr
80005126:	1a 97       	mov	r7,sp
80005128:	20 2d       	sub	sp,8
8000512a:	ef 4c ff fc 	st.w	r7[-4],r12
8000512e:	ef 4b ff f8 	st.w	r7[-8],r11
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
80005132:	fe 78 0c 00 	mov	r8,-62464
80005136:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000513a:	ee fa ff fc 	ld.w	r10,r7[-4]
8000513e:	74 0a       	ld.w	r10,r10[0x0]
80005140:	a3 aa       	sbr	r10,0x2
80005142:	2e 89       	sub	r9,-24
80005144:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
}
80005148:	2f ed       	sub	sp,-8
8000514a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000514e:	d7 03       	nop

80005150 <genclk_enable_source>:
{
	AVR32_PM.gcctrl[id] = 0;
}

static inline void genclk_enable_source(enum genclk_source src)
{
80005150:	eb cd 40 80 	pushm	r7,lr
80005154:	1a 97       	mov	r7,sp
80005156:	20 1d       	sub	sp,4
80005158:	ef 4c ff fc 	st.w	r7[-4],r12
	switch (src) {
8000515c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005160:	58 08       	cp.w	r8,0
80005162:	c0 40       	breq	8000516a <genclk_enable_source+0x1a>
80005164:	58 28       	cp.w	r8,2
80005166:	c1 10       	breq	80005188 <genclk_enable_source+0x38>
80005168:	c1 58       	rjmp	80005192 <genclk_enable_source+0x42>
#ifdef BOARD_OSC0_HZ
	case GENCLK_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
8000516a:	30 0c       	mov	r12,0
8000516c:	f0 1f 00 0b 	mcall	80005198 <genclk_enable_source+0x48>
80005170:	18 98       	mov	r8,r12
80005172:	ec 18 00 01 	eorl	r8,0x1
80005176:	5c 58       	castu.b	r8
80005178:	c0 c0       	breq	80005190 <genclk_enable_source+0x40>
			osc_enable(OSC_ID_OSC0);
8000517a:	30 0c       	mov	r12,0
8000517c:	f0 1f 00 08 	mcall	8000519c <genclk_enable_source+0x4c>
			osc_wait_ready(OSC_ID_OSC0);
80005180:	30 0c       	mov	r12,0
80005182:	f0 1f 00 08 	mcall	800051a0 <genclk_enable_source+0x50>
		}
		break;
80005186:	c0 68       	rjmp	80005192 <genclk_enable_source+0x42>
		break;
#endif

#ifdef CONFIG_PLL0_SOURCE
	case GENCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
80005188:	30 0c       	mov	r12,0
8000518a:	f0 1f 00 07 	mcall	800051a4 <genclk_enable_source+0x54>
8000518e:	c0 28       	rjmp	80005192 <genclk_enable_source+0x42>
	case GENCLK_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
			osc_wait_ready(OSC_ID_OSC0);
		}
		break;
80005190:	d7 03       	nop

	default:
		Assert(false);
		break;
	}
}
80005192:	2f fd       	sub	sp,-4
80005194:	e3 cd 80 80 	ldm	sp++,r7,pc
80005198:	80 00       	ld.sh	r0,r0[0x0]
8000519a:	4d 84       	lddpc	r4,800052f8 <sysclk_set_source+0xc>
8000519c:	80 00       	ld.sh	r0,r0[0x0]
8000519e:	4c f4       	lddpc	r4,800052d8 <sysclk_set_prescalers+0x6c>
800051a0:	80 00       	ld.sh	r0,r0[0x0]
800051a2:	4e 00       	lddpc	r0,80005320 <sysclk_set_source+0x34>
800051a4:	80 00       	ld.sh	r0,r0[0x0]
800051a6:	50 00       	stdsp	sp[0x0],r0

800051a8 <genclk_enable_config>:
 * \param id      The ID of the generic clock.
 * \param src     The source clock of the generic clock.
 * \param divider The divider used to generate the generic clock.
 */
static inline void genclk_enable_config(unsigned int id, enum genclk_source src, unsigned int divider)
{
800051a8:	eb cd 40 80 	pushm	r7,lr
800051ac:	1a 97       	mov	r7,sp
800051ae:	20 4d       	sub	sp,16
800051b0:	ef 4c ff f8 	st.w	r7[-8],r12
800051b4:	ef 4b ff f4 	st.w	r7[-12],r11
800051b8:	ef 4a ff f0 	st.w	r7[-16],r10
	struct genclk_config gcfg;

	genclk_config_defaults(&gcfg, id);
800051bc:	ee c8 00 04 	sub	r8,r7,4
800051c0:	ee fb ff f8 	ld.w	r11,r7[-8]
800051c4:	10 9c       	mov	r12,r8
800051c6:	f0 1f 00 10 	mcall	80005204 <genclk_enable_config+0x5c>
	genclk_enable_source(src);
800051ca:	ee fc ff f4 	ld.w	r12,r7[-12]
800051ce:	f0 1f 00 0f 	mcall	80005208 <genclk_enable_config+0x60>
	genclk_config_set_source(&gcfg, src);
800051d2:	ee c8 00 04 	sub	r8,r7,4
800051d6:	ee fb ff f4 	ld.w	r11,r7[-12]
800051da:	10 9c       	mov	r12,r8
800051dc:	f0 1f 00 0c 	mcall	8000520c <genclk_enable_config+0x64>
	genclk_config_set_divider(&gcfg, divider);
800051e0:	ee c8 00 04 	sub	r8,r7,4
800051e4:	ee fb ff f0 	ld.w	r11,r7[-16]
800051e8:	10 9c       	mov	r12,r8
800051ea:	f0 1f 00 0a 	mcall	80005210 <genclk_enable_config+0x68>
	genclk_enable(&gcfg, id);
800051ee:	ee c8 00 04 	sub	r8,r7,4
800051f2:	ee fb ff f8 	ld.w	r11,r7[-8]
800051f6:	10 9c       	mov	r12,r8
800051f8:	f0 1f 00 07 	mcall	80005214 <genclk_enable_config+0x6c>
}
800051fc:	2f cd       	sub	sp,-16
800051fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80005202:	00 00       	add	r0,r0
80005204:	80 00       	ld.sh	r0,r0[0x0]
80005206:	50 74       	stdsp	sp[0x1c],r4
80005208:	80 00       	ld.sh	r0,r0[0x0]
8000520a:	51 50       	stdsp	sp[0x54],r0
8000520c:	80 00       	ld.sh	r0,r0[0x0]
8000520e:	50 92       	stdsp	sp[0x24],r2
80005210:	80 00       	ld.sh	r0,r0[0x0]
80005212:	50 c8       	stdsp	sp[0x30],r8
80005214:	80 00       	ld.sh	r0,r0[0x0]
80005216:	51 22       	stdsp	sp[0x48],r2

80005218 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
80005218:	eb cd 40 80 	pushm	r7,lr
8000521c:	1a 97       	mov	r7,sp
		return BOARD_OSC0_HZ;
#endif

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0:
		return pll_get_default_rate(0);
8000521e:	30 0c       	mov	r12,0
80005220:	f0 1f 00 04 	mcall	80005230 <sysclk_get_main_hz+0x18>
80005224:	18 98       	mov	r8,r12
80005226:	a5 68       	lsl	r8,0x4
80005228:	a1 98       	lsr	r8,0x1

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
8000522a:	10 9c       	mov	r12,r8
8000522c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005230:	80 00       	ld.sh	r0,r0[0x0]
80005232:	4d ca       	lddpc	r10,800053a0 <sysclk_priv_enable_module+0x60>

80005234 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
80005234:	eb cd 40 80 	pushm	r7,lr
80005238:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
8000523a:	f0 1f 00 04 	mcall	80005248 <sysclk_get_cpu_hz+0x14>
8000523e:	18 98       	mov	r8,r12
}
80005240:	10 9c       	mov	r12,r8
80005242:	e3 cd 80 80 	ldm	sp++,r7,pc
80005246:	00 00       	add	r0,r0
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	52 18       	stdsp	sp[0x84],r8

8000524c <sysclk_enable_hsb_module>:
/**
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
8000524c:	eb cd 40 80 	pushm	r7,lr
80005250:	1a 97       	mov	r7,sp
80005252:	20 1d       	sub	sp,4
80005254:	ef 4c ff fc 	st.w	r7[-4],r12
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
80005258:	ee fb ff fc 	ld.w	r11,r7[-4]
8000525c:	30 1c       	mov	r12,1
8000525e:	f0 1f 00 03 	mcall	80005268 <sysclk_enable_hsb_module+0x1c>
}
80005262:	2f fd       	sub	sp,-4
80005264:	e3 cd 80 80 	ldm	sp++,r7,pc
80005268:	80 00       	ld.sh	r0,r0[0x0]
8000526a:	53 40       	stdsp	sp[0xd0],r0

8000526c <sysclk_set_prescalers>:
 * \param pba_shift The PBA clock will be divided by \f$2^{pba\_shift}\f$
 * \param pbb_shift The PBB clock will be divided by \f$2^{pbb\_shift}\f$
 */
static inline void sysclk_set_prescalers(unsigned int cpu_shift,
		unsigned int pba_shift, unsigned int pbb_shift)
{
8000526c:	eb cd 40 80 	pushm	r7,lr
80005270:	1a 97       	mov	r7,sp
80005272:	20 4d       	sub	sp,16
80005274:	ef 4c ff f8 	st.w	r7[-8],r12
80005278:	ef 4b ff f4 	st.w	r7[-12],r11
8000527c:	ef 4a ff f0 	st.w	r7[-16],r10
	uint32_t cksel = 0;
80005280:	30 08       	mov	r8,0
80005282:	ef 48 ff fc 	st.w	r7[-4],r8

	Assert(cpu_shift <= pba_shift);
	Assert(cpu_shift <= pbb_shift);

	if (cpu_shift > 0)
80005286:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000528a:	58 08       	cp.w	r8,0
8000528c:	c0 70       	breq	8000529a <sysclk_set_prescalers+0x2e>
		cksel = ((cpu_shift - 1) << AVR32_PM_CKSEL_CPUSEL)
8000528e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005292:	20 18       	sub	r8,1
80005294:	a7 b8       	sbr	r8,0x7
80005296:	ef 48 ff fc 	st.w	r7[-4],r8
				| (1U << AVR32_PM_CKSEL_CPUDIV);

	if (pba_shift > 0)
8000529a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000529e:	58 08       	cp.w	r8,0
800052a0:	c0 d0       	breq	800052ba <sysclk_set_prescalers+0x4e>
		cksel |= ((pba_shift - 1) << AVR32_PM_CKSEL_PBASEL)
800052a2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052a6:	20 18       	sub	r8,1
800052a8:	f0 09 15 10 	lsl	r9,r8,0x10
800052ac:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052b0:	f3 e8 10 08 	or	r8,r9,r8
800052b4:	b7 b8       	sbr	r8,0x17
800052b6:	ef 48 ff fc 	st.w	r7[-4],r8
				| (1U << AVR32_PM_CKSEL_PBADIV);

	if (pbb_shift > 0)
800052ba:	ee f8 ff f0 	ld.w	r8,r7[-16]
800052be:	58 08       	cp.w	r8,0
800052c0:	c0 d0       	breq	800052da <sysclk_set_prescalers+0x6e>
		cksel |= ((pbb_shift - 1) << AVR32_PM_CKSEL_PBBSEL)
800052c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800052c6:	20 18       	sub	r8,1
800052c8:	f0 09 15 18 	lsl	r9,r8,0x18
800052cc:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052d0:	f3 e8 10 08 	or	r8,r9,r8
800052d4:	bf b8       	sbr	r8,0x1f
800052d6:	ef 48 ff fc 	st.w	r7[-4],r8
				| (1U << AVR32_PM_CKSEL_PBBDIV);

	AVR32_PM.cksel = cksel;
800052da:	fe 78 0c 00 	mov	r8,-62464
800052de:	ee f9 ff fc 	ld.w	r9,r7[-4]
800052e2:	91 19       	st.w	r8[0x4],r9
}
800052e4:	2f cd       	sub	sp,-16
800052e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800052ea:	d7 03       	nop

800052ec <sysclk_set_source>:
 *
 * \param src The new system clock source. Must be one of the constants
 * from the <em>System Clock Sources</em> section.
 */
static inline void sysclk_set_source(uint_fast8_t src)
{
800052ec:	eb cd 40 80 	pushm	r7,lr
800052f0:	1a 97       	mov	r7,sp
800052f2:	20 3d       	sub	sp,12
800052f4:	ef 4c ff f4 	st.w	r7[-12],r12
	uint32_t   mcctrl;
	irqflags_t flags;

	Assert(src <= SYSCLK_SRC_PLL0);

	flags = cpu_irq_save();
800052f8:	f0 1f 00 10 	mcall	80005338 <sysclk_set_source+0x4c>
800052fc:	18 98       	mov	r8,r12
800052fe:	ef 48 ff fc 	st.w	r7[-4],r8
	mcctrl = AVR32_PM.mcctrl & ~AVR32_PM_MCCTRL_MCSEL_MASK;
80005302:	fe 78 0c 00 	mov	r8,-62464
80005306:	70 08       	ld.w	r8,r8[0x0]
80005308:	e0 18 ff fc 	andl	r8,0xfffc
8000530c:	ef 48 ff f8 	st.w	r7[-8],r8
	mcctrl |= src << AVR32_PM_MCCTRL_MCSEL;
80005310:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005314:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005318:	f3 e8 10 08 	or	r8,r9,r8
8000531c:	ef 48 ff f8 	st.w	r7[-8],r8
	AVR32_PM.mcctrl = mcctrl;
80005320:	fe 78 0c 00 	mov	r8,-62464
80005324:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005328:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
8000532a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000532e:	f0 1f 00 04 	mcall	8000533c <sysclk_set_source+0x50>
}
80005332:	2f dd       	sub	sp,-12
80005334:	e3 cd 80 80 	ldm	sp++,r7,pc
80005338:	80 00       	ld.sh	r0,r0[0x0]
8000533a:	4c 8c       	lddpc	r12,80005458 <sysclk_init+0x1c>
8000533c:	80 00       	ld.sh	r0,r0[0x0]
8000533e:	4c cc       	lddpc	r12,8000546c <sysclk_init+0x30>

80005340 <sysclk_priv_enable_module>:
 * \param bus_id Bus index, given by the \c AVR32_PM_CLK_GRP_xxx definitions.
 * \param module_index Index of the module to be enabled. This is the
 * bit number in the corresponding xxxMASK register.
 */
void sysclk_priv_enable_module(unsigned int bus_id, unsigned int module_index)
{
80005340:	eb cd 40 80 	pushm	r7,lr
80005344:	1a 97       	mov	r7,sp
80005346:	20 4d       	sub	sp,16
80005348:	ef 4c ff f4 	st.w	r7[-12],r12
8000534c:	ef 4b ff f0 	st.w	r7[-16],r11
	irqflags_t flags;
	uint32_t   mask;

	flags = cpu_irq_save();
80005350:	f0 1f 00 17 	mcall	800053ac <sysclk_priv_enable_module+0x6c>
80005354:	18 98       	mov	r8,r12
80005356:	ef 48 ff f8 	st.w	r7[-8],r8

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
8000535a:	fe 78 0c 00 	mov	r8,-62464
8000535e:	71 58       	ld.w	r8,r8[0x54]
80005360:	e2 18 00 40 	andl	r8,0x40,COH
80005364:	cf b0       	breq	8000535a <sysclk_priv_enable_module+0x1a>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
80005366:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000536a:	a3 68       	lsl	r8,0x2
8000536c:	e0 28 f3 f8 	sub	r8,62456
80005370:	70 08       	ld.w	r8,r8[0x0]
80005372:	ef 48 ff fc 	st.w	r7[-4],r8
	mask |= 1U << module_index;
80005376:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000537a:	30 19       	mov	r9,1
8000537c:	f2 08 09 48 	lsl	r8,r9,r8
80005380:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005384:	f3 e8 10 08 	or	r8,r9,r8
80005388:	ef 48 ff fc 	st.w	r7[-4],r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
8000538c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005390:	a3 68       	lsl	r8,0x2
80005392:	e0 28 f3 f8 	sub	r8,62456
80005396:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000539a:	91 09       	st.w	r8[0x0],r9

	cpu_irq_restore(flags);
8000539c:	ee fc ff f8 	ld.w	r12,r7[-8]
800053a0:	f0 1f 00 04 	mcall	800053b0 <sysclk_priv_enable_module+0x70>
}
800053a4:	2f cd       	sub	sp,-16
800053a6:	e3 cd 80 80 	ldm	sp++,r7,pc
800053aa:	00 00       	add	r0,r0
800053ac:	80 00       	ld.sh	r0,r0[0x0]
800053ae:	4c 8c       	lddpc	r12,800054cc <cpu_irq_restore+0x10>
800053b0:	80 00       	ld.sh	r0,r0[0x0]
800053b2:	4c cc       	lddpc	r12,800054e0 <cpu_irq_restore+0x24>

800053b4 <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(unsigned int index)
{
800053b4:	eb cd 40 80 	pushm	r7,lr
800053b8:	1a 97       	mov	r7,sp
800053ba:	20 2d       	sub	sp,8
800053bc:	ef 4c ff f8 	st.w	r7[-8],r12
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();
800053c0:	f0 1f 00 0f 	mcall	800053fc <sysclk_enable_pbb_module+0x48>
800053c4:	18 98       	mov	r8,r12
800053c6:	ef 48 ff fc 	st.w	r7[-4],r8

	if (!sysclk_pbb_refcount)
800053ca:	48 e8       	lddpc	r8,80005400 <sysclk_enable_pbb_module+0x4c>
800053cc:	11 88       	ld.ub	r8,r8[0x0]
800053ce:	58 08       	cp.w	r8,0
800053d0:	c0 41       	brne	800053d8 <sysclk_enable_pbb_module+0x24>
		sysclk_enable_hsb_module(SYSCLK_PBB_BRIDGE);
800053d2:	30 2c       	mov	r12,2
800053d4:	f0 1f 00 0c 	mcall	80005404 <sysclk_enable_pbb_module+0x50>
	sysclk_pbb_refcount++;
800053d8:	48 a8       	lddpc	r8,80005400 <sysclk_enable_pbb_module+0x4c>
800053da:	11 88       	ld.ub	r8,r8[0x0]
800053dc:	2f f8       	sub	r8,-1
800053de:	5c 58       	castu.b	r8
800053e0:	48 89       	lddpc	r9,80005400 <sysclk_enable_pbb_module+0x4c>
800053e2:	b2 88       	st.b	r9[0x0],r8

	cpu_irq_restore(flags);
800053e4:	ee fc ff fc 	ld.w	r12,r7[-4]
800053e8:	f0 1f 00 08 	mcall	80005408 <sysclk_enable_pbb_module+0x54>

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
800053ec:	ee fb ff f8 	ld.w	r11,r7[-8]
800053f0:	30 3c       	mov	r12,3
800053f2:	f0 1f 00 07 	mcall	8000540c <sysclk_enable_pbb_module+0x58>
}
800053f6:	2f ed       	sub	sp,-8
800053f8:	e3 cd 80 80 	ldm	sp++,r7,pc
800053fc:	80 00       	ld.sh	r0,r0[0x0]
800053fe:	4c 8c       	lddpc	r12,8000551c <udi_cdc_comm_enable+0x38>
80005400:	00 00       	add	r0,r0
80005402:	01 d9       	ld.ub	r9,r0[0x5]
80005404:	80 00       	ld.sh	r0,r0[0x0]
80005406:	52 4c       	stdsp	sp[0x90],r12
80005408:	80 00       	ld.sh	r0,r0[0x0]
8000540a:	4c cc       	lddpc	r12,80005538 <udi_cdc_comm_enable+0x54>
8000540c:	80 00       	ld.sh	r0,r0[0x0]
8000540e:	53 40       	stdsp	sp[0xd0],r0

80005410 <sysclk_enable_usb>:
 * \pre The USB generic clock must be configured to 48MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
80005410:	eb cd 40 80 	pushm	r7,lr
80005414:	1a 97       	mov	r7,sp
	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
80005416:	30 1c       	mov	r12,1
80005418:	f0 1f 00 06 	mcall	80005430 <sysclk_enable_usb+0x20>
	sysclk_enable_hsb_module(SYSCLK_USBB_DATA);
8000541c:	30 3c       	mov	r12,3
8000541e:	f0 1f 00 06 	mcall	80005434 <sysclk_enable_usb+0x24>
	genclk_enable_config(AVR32_PM_GCLK_USBB, CONFIG_USBCLK_SOURCE, CONFIG_USBCLK_DIV);
80005422:	30 2a       	mov	r10,2
80005424:	30 2b       	mov	r11,2
80005426:	30 3c       	mov	r12,3
80005428:	f0 1f 00 04 	mcall	80005438 <sysclk_enable_usb+0x28>
}
8000542c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005430:	80 00       	ld.sh	r0,r0[0x0]
80005432:	53 b4       	stdsp	sp[0xec],r4
80005434:	80 00       	ld.sh	r0,r0[0x0]
80005436:	52 4c       	stdsp	sp[0x90],r12
80005438:	80 00       	ld.sh	r0,r0[0x0]
8000543a:	51 a8       	stdsp	sp[0x68],r8

8000543c <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE


void sysclk_init(void)
{
8000543c:	eb cd 40 80 	pushm	r7,lr
80005440:	1a 97       	mov	r7,sp
#endif

	/* Set up system clock dividers if different from defaults */
	if ((CONFIG_SYSCLK_CPU_DIV > 0) || (CONFIG_SYSCLK_PBA_DIV > 0) ||
			(CONFIG_SYSCLK_PBB_DIV > 0)) {
		sysclk_set_prescalers(CONFIG_SYSCLK_CPU_DIV,
80005442:	30 1a       	mov	r10,1
80005444:	30 1b       	mov	r11,1
80005446:	30 0c       	mov	r12,0
80005448:	f0 1f 00 08 	mcall	80005468 <sysclk_init+0x2c>
		break;
#endif

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
8000544c:	30 0c       	mov	r12,0
8000544e:	f0 1f 00 08 	mcall	8000546c <sysclk_init+0x30>
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(sysclk_get_cpu_hz());
80005452:	f0 1f 00 08 	mcall	80005470 <sysclk_init+0x34>
80005456:	18 98       	mov	r8,r12
80005458:	10 9c       	mov	r12,r8
8000545a:	f0 1f 00 07 	mcall	80005474 <sysclk_init+0x38>
		sysclk_set_source(SYSCLK_SRC_PLL0);
8000545e:	30 2c       	mov	r12,2
80005460:	f0 1f 00 06 	mcall	80005478 <sysclk_init+0x3c>

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
80005464:	e3 cd 80 80 	ldm	sp++,r7,pc
80005468:	80 00       	ld.sh	r0,r0[0x0]
8000546a:	52 6c       	stdsp	sp[0x98],r12
8000546c:	80 00       	ld.sh	r0,r0[0x0]
8000546e:	50 00       	stdsp	sp[0x0],r0
80005470:	80 00       	ld.sh	r0,r0[0x0]
80005472:	52 34       	stdsp	sp[0x8c],r4
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	21 04       	sub	r4,16
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	52 ec       	stdsp	sp[0xb8],r12

8000547c <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
8000547c:	eb cd 40 80 	pushm	r7,lr
80005480:	1a 97       	mov	r7,sp
80005482:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80005484:	e1 b8 00 00 	mfsr	r8,0x0
80005488:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
8000548c:	d3 03       	ssrf	0x10

	return flags;
8000548e:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80005492:	10 9c       	mov	r12,r8
80005494:	2f fd       	sub	sp,-4
80005496:	e3 cd 80 80 	ldm	sp++,r7,pc

8000549a <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
8000549a:	eb cd 40 80 	pushm	r7,lr
8000549e:	1a 97       	mov	r7,sp
800054a0:	20 1d       	sub	sp,4
800054a2:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800054a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054aa:	e6 18 00 01 	andh	r8,0x1,COH
800054ae:	5f 08       	sreq	r8
800054b0:	5c 58       	castu.b	r8
}
800054b2:	10 9c       	mov	r12,r8
800054b4:	2f fd       	sub	sp,-4
800054b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800054ba:	d7 03       	nop

800054bc <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
800054bc:	eb cd 40 80 	pushm	r7,lr
800054c0:	1a 97       	mov	r7,sp
800054c2:	20 1d       	sub	sp,4
800054c4:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
800054c8:	ee fc ff fc 	ld.w	r12,r7[-4]
800054cc:	f0 1f 00 05 	mcall	800054e0 <cpu_irq_restore+0x24>
800054d0:	18 98       	mov	r8,r12
800054d2:	58 08       	cp.w	r8,0
800054d4:	c0 20       	breq	800054d8 <cpu_irq_restore+0x1c>
      cpu_irq_enable();
800054d6:	d5 03       	csrf	0x10
   }

	barrier();
}
800054d8:	2f fd       	sub	sp,-4
800054da:	e3 cd 80 80 	ldm	sp++,r7,pc
800054de:	00 00       	add	r0,r0
800054e0:	80 00       	ld.sh	r0,r0[0x0]
800054e2:	54 9a       	stdsp	sp[0x124],r10

800054e4 <udi_cdc_comm_enable>:
static volatile bool udi_cdc_tx_both_buf_to_send[UDI_CDC_PORT_NB];

//@}

bool udi_cdc_comm_enable(void)
{
800054e4:	eb cd 40 80 	pushm	r7,lr
800054e8:	1a 97       	mov	r7,sp
800054ea:	20 1d       	sub	sp,4
	uint8_t port;
	uint8_t iface_comm_num;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
800054ec:	30 08       	mov	r8,0
800054ee:	ef 68 ff fe 	st.b	r7[-2],r8
	udi_cdc_nb_comm_enabled = 0;
800054f2:	4e 89       	lddpc	r9,80005690 <udi_cdc_comm_enable+0x1ac>
800054f4:	30 08       	mov	r8,0
800054f6:	b2 88       	st.b	r9[0x0],r8
	}
	port = udi_cdc_nb_comm_enabled;
#endif

	// Initialize control signal management
	udi_cdc_state[port] = CPU_TO_LE16(0);
800054f8:	ef 3a ff fe 	ld.ub	r10,r7[-2]
800054fc:	4e 69       	lddpc	r9,80005694 <udi_cdc_comm_enable+0x1b0>
800054fe:	30 08       	mov	r8,0
80005500:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8

	uid_cdc_state_msg[port].header.bmRequestType =
80005504:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005508:	4e 4a       	lddpc	r10,80005698 <udi_cdc_comm_enable+0x1b4>
8000550a:	12 98       	mov	r8,r9
8000550c:	a3 68       	lsl	r8,0x2
8000550e:	12 08       	add	r8,r9
80005510:	a1 78       	lsl	r8,0x1
80005512:	f4 08 00 09 	add	r9,r10,r8
80005516:	3a 18       	mov	r8,-95
80005518:	b2 88       	st.b	r9[0x0],r8
			USB_REQ_DIR_IN | USB_REQ_TYPE_CLASS |
			USB_REQ_RECIP_INTERFACE;
	uid_cdc_state_msg[port].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE;
8000551a:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000551e:	4d fa       	lddpc	r10,80005698 <udi_cdc_comm_enable+0x1b4>
80005520:	12 98       	mov	r8,r9
80005522:	a3 68       	lsl	r8,0x2
80005524:	12 08       	add	r8,r9
80005526:	a1 78       	lsl	r8,0x1
80005528:	f4 08 00 09 	add	r9,r10,r8
8000552c:	32 08       	mov	r8,32
8000552e:	b2 98       	st.b	r9[0x1],r8
	uid_cdc_state_msg[port].header.wValue = LE16(0);
80005530:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005534:	4d 9a       	lddpc	r10,80005698 <udi_cdc_comm_enable+0x1b4>
80005536:	12 98       	mov	r8,r9
80005538:	a3 68       	lsl	r8,0x2
8000553a:	12 08       	add	r8,r9
8000553c:	a1 78       	lsl	r8,0x1
8000553e:	f4 08 00 09 	add	r9,r10,r8
80005542:	30 08       	mov	r8,0
80005544:	b2 18       	st.h	r9[0x2],r8

	switch (port) {
80005546:	ef 38 ff fe 	ld.ub	r8,r7[-2]
8000554a:	58 08       	cp.w	r8,0
8000554c:	c0 51       	brne	80005556 <udi_cdc_comm_enable+0x72>
#define UDI_CDC_PORT_TO_IFACE_COMM(index, unused) \
	case index: \
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_IFACE_COMM, ~)
8000554e:	30 08       	mov	r8,0
80005550:	ef 68 ff ff 	st.b	r7[-1],r8
80005554:	c0 48       	rjmp	8000555c <udi_cdc_comm_enable+0x78>
#undef UDI_CDC_PORT_TO_IFACE_COMM
	default:
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_0;
80005556:	30 08       	mov	r8,0
80005558:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}

	uid_cdc_state_msg[port].header.wIndex = LE16(iface_comm_num);
8000555c:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005560:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005564:	a9 48       	asr	r8,0x8
80005566:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
8000556a:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000556e:	a9 68       	lsl	r8,0x8
80005570:	5c 88       	casts.h	r8
80005572:	f5 e8 10 08 	or	r8,r10,r8
80005576:	5c 88       	casts.h	r8
80005578:	10 9a       	mov	r10,r8
8000557a:	4c 8b       	lddpc	r11,80005698 <udi_cdc_comm_enable+0x1b4>
8000557c:	12 98       	mov	r8,r9
8000557e:	a3 68       	lsl	r8,0x2
80005580:	12 08       	add	r8,r9
80005582:	a1 78       	lsl	r8,0x1
80005584:	f6 08 00 08 	add	r8,r11,r8
80005588:	f0 c9 ff fc 	sub	r9,r8,-4
8000558c:	14 98       	mov	r8,r10
8000558e:	b2 08       	st.h	r9[0x0],r8
	uid_cdc_state_msg[port].header.wLength = LE16(2);
80005590:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005594:	4c 1a       	lddpc	r10,80005698 <udi_cdc_comm_enable+0x1b4>
80005596:	12 98       	mov	r8,r9
80005598:	a3 68       	lsl	r8,0x2
8000559a:	12 08       	add	r8,r9
8000559c:	a1 78       	lsl	r8,0x1
8000559e:	f4 08 00 08 	add	r8,r10,r8
800055a2:	f0 c9 ff fc 	sub	r9,r8,-4
800055a6:	e0 68 02 00 	mov	r8,512
800055aa:	b2 18       	st.h	r9[0x2],r8
	uid_cdc_state_msg[port].value = CPU_TO_LE16(0);
800055ac:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800055b0:	4b aa       	lddpc	r10,80005698 <udi_cdc_comm_enable+0x1b4>
800055b2:	12 98       	mov	r8,r9
800055b4:	a3 68       	lsl	r8,0x2
800055b6:	12 08       	add	r8,r9
800055b8:	a1 78       	lsl	r8,0x1
800055ba:	f4 08 00 08 	add	r8,r10,r8
800055be:	f0 c9 ff f8 	sub	r9,r8,-8
800055c2:	30 08       	mov	r8,0
800055c4:	b2 08       	st.h	r9[0x0],r8

	udi_cdc_line_coding[port].dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
800055c6:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800055ca:	4b 5a       	lddpc	r10,8000569c <udi_cdc_comm_enable+0x1b8>
800055cc:	12 98       	mov	r8,r9
800055ce:	a3 78       	lsl	r8,0x3
800055d0:	12 18       	sub	r8,r9
800055d2:	f4 08 00 08 	add	r8,r10,r8
800055d6:	11 89       	ld.ub	r9,r8[0x0]
800055d8:	e2 19 00 00 	andl	r9,0x0,COH
800055dc:	b0 89       	st.b	r8[0x0],r9
800055de:	11 99       	ld.ub	r9,r8[0x1]
800055e0:	e2 19 00 00 	andl	r9,0x0,COH
800055e4:	a5 a9       	sbr	r9,0x4
800055e6:	b0 99       	st.b	r8[0x1],r9
800055e8:	11 a9       	ld.ub	r9,r8[0x2]
800055ea:	e2 19 00 00 	andl	r9,0x0,COH
800055ee:	e8 19 00 0e 	orl	r9,0xe
800055f2:	b0 a9       	st.b	r8[0x2],r9
800055f4:	11 b9       	ld.ub	r9,r8[0x3]
800055f6:	e2 19 00 00 	andl	r9,0x0,COH
800055fa:	b0 b9       	st.b	r8[0x3],r9
	udi_cdc_line_coding[port].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
800055fc:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005600:	4a 7a       	lddpc	r10,8000569c <udi_cdc_comm_enable+0x1b8>
80005602:	12 98       	mov	r8,r9
80005604:	a3 78       	lsl	r8,0x3
80005606:	12 18       	sub	r8,r9
80005608:	f4 08 00 08 	add	r8,r10,r8
8000560c:	f0 c9 ff fc 	sub	r9,r8,-4
80005610:	30 08       	mov	r8,0
80005612:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_line_coding[port].bParityType = UDI_CDC_DEFAULT_PARITY;
80005614:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005618:	4a 1a       	lddpc	r10,8000569c <udi_cdc_comm_enable+0x1b8>
8000561a:	12 98       	mov	r8,r9
8000561c:	a3 78       	lsl	r8,0x3
8000561e:	12 18       	sub	r8,r9
80005620:	f4 08 00 08 	add	r8,r10,r8
80005624:	f0 c9 ff fb 	sub	r9,r8,-5
80005628:	30 08       	mov	r8,0
8000562a:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_line_coding[port].bDataBits = UDI_CDC_DEFAULT_DATABITS;
8000562c:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005630:	49 ba       	lddpc	r10,8000569c <udi_cdc_comm_enable+0x1b8>
80005632:	12 98       	mov	r8,r9
80005634:	a3 78       	lsl	r8,0x3
80005636:	12 18       	sub	r8,r9
80005638:	f4 08 00 08 	add	r8,r10,r8
8000563c:	f0 c9 ff fa 	sub	r9,r8,-6
80005640:	30 88       	mov	r8,8
80005642:	b2 88       	st.b	r9[0x0],r8
	// Call application callback
	// to initialize memories or indicate that interface is enabled
	UDI_CDC_SET_CODING_EXT(port,(&udi_cdc_line_coding[port]));
80005644:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005648:	12 98       	mov	r8,r9
8000564a:	a3 78       	lsl	r8,0x3
8000564c:	f0 09 01 09 	sub	r9,r8,r9
80005650:	49 38       	lddpc	r8,8000569c <udi_cdc_comm_enable+0x1b8>
80005652:	10 09       	add	r9,r8
80005654:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80005658:	12 9b       	mov	r11,r9
8000565a:	10 9c       	mov	r12,r8
8000565c:	f0 1f 00 11 	mcall	800056a0 <udi_cdc_comm_enable+0x1bc>
	if (!UDI_CDC_ENABLE_EXT(port)) {
80005660:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80005664:	10 9c       	mov	r12,r8
80005666:	f0 1f 00 10 	mcall	800056a4 <udi_cdc_comm_enable+0x1c0>
8000566a:	18 98       	mov	r8,r12
8000566c:	ec 18 00 01 	eorl	r8,0x1
80005670:	5c 58       	castu.b	r8
80005672:	c0 30       	breq	80005678 <udi_cdc_comm_enable+0x194>
		return false;
80005674:	30 08       	mov	r8,0
80005676:	c0 98       	rjmp	80005688 <udi_cdc_comm_enable+0x1a4>
	}
	udi_cdc_nb_comm_enabled++;
80005678:	48 68       	lddpc	r8,80005690 <udi_cdc_comm_enable+0x1ac>
8000567a:	11 88       	ld.ub	r8,r8[0x0]
8000567c:	5c 58       	castu.b	r8
8000567e:	2f f8       	sub	r8,-1
80005680:	5c 58       	castu.b	r8
80005682:	48 49       	lddpc	r9,80005690 <udi_cdc_comm_enable+0x1ac>
80005684:	b2 88       	st.b	r9[0x0],r8
	return true;
80005686:	30 18       	mov	r8,1
}
80005688:	10 9c       	mov	r12,r8
8000568a:	2f fd       	sub	sp,-4
8000568c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005690:	00 00       	add	r0,r0
80005692:	01 f8       	ld.ub	r8,r0[0x7]
80005694:	00 00       	add	r0,r0
80005696:	01 e8       	ld.ub	r8,r0[0x6]
80005698:	00 00       	add	r0,r0
8000569a:	01 ec       	ld.ub	r12,r0[0x6]
8000569c:	00 00       	add	r0,r0
8000569e:	01 da       	ld.ub	r10,r0[0x5]
800056a0:	80 00       	ld.sh	r0,r0[0x0]
800056a2:	86 48       	ld.sh	r8,r3[0x8]
800056a4:	80 00       	ld.sh	r0,r0[0x0]
800056a6:	75 d0       	ld.w	r0,r10[0x74]

800056a8 <udi_cdc_data_enable>:

bool udi_cdc_data_enable(void)
{
800056a8:	eb cd 40 80 	pushm	r7,lr
800056ac:	1a 97       	mov	r7,sp
800056ae:	20 1d       	sub	sp,4
	uint8_t port;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
800056b0:	30 08       	mov	r8,0
800056b2:	ef 68 ff ff 	st.b	r7[-1],r8
	udi_cdc_nb_data_enabled = 0;
800056b6:	4b 69       	lddpc	r9,8000578c <udi_cdc_data_enable+0xe4>
800056b8:	30 08       	mov	r8,0
800056ba:	b2 88       	st.b	r9[0x0],r8
	}
	port = udi_cdc_nb_data_enabled;
#endif

	// Initialize TX management
	udi_cdc_tx_trans_ongoing[port] = false;
800056bc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800056c0:	4b 4a       	lddpc	r10,80005790 <udi_cdc_data_enable+0xe8>
800056c2:	30 08       	mov	r8,0
800056c4:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_tx_both_buf_to_send[port] = false;
800056c8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800056cc:	4b 2a       	lddpc	r10,80005794 <udi_cdc_data_enable+0xec>
800056ce:	30 08       	mov	r8,0
800056d0:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_tx_buf_sel[port] = 0;
800056d4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800056d8:	4b 0a       	lddpc	r10,80005798 <udi_cdc_data_enable+0xf0>
800056da:	30 08       	mov	r8,0
800056dc:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_tx_buf_nb[port][0] = 0;
800056e0:	ef 3a ff ff 	ld.ub	r10,r7[-1]
800056e4:	4a e9       	lddpc	r9,8000579c <udi_cdc_data_enable+0xf4>
800056e6:	30 08       	mov	r8,0
800056e8:	f2 0a 0a 28 	st.h	r9[r10<<0x2],r8
	udi_cdc_tx_buf_nb[port][1] = 0;
800056ec:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800056f0:	4a b9       	lddpc	r9,8000579c <udi_cdc_data_enable+0xf4>
800056f2:	a1 78       	lsl	r8,0x1
800056f4:	f0 ca ff ff 	sub	r10,r8,-1
800056f8:	30 08       	mov	r8,0
800056fa:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_tx_sof_num[port] = 0;
800056fe:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005702:	4a 89       	lddpc	r9,800057a0 <udi_cdc_data_enable+0xf8>
80005704:	30 08       	mov	r8,0
80005706:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_tx_send(port);
8000570a:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000570e:	10 9c       	mov	r12,r8
80005710:	f0 1f 00 25 	mcall	800057a4 <udi_cdc_data_enable+0xfc>

	// Initialize RX management
	udi_cdc_rx_trans_ongoing[port] = false;
80005714:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005718:	4a 4a       	lddpc	r10,800057a8 <udi_cdc_data_enable+0x100>
8000571a:	30 08       	mov	r8,0
8000571c:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_rx_buf_sel[port] = 0;
80005720:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005724:	4a 2a       	lddpc	r10,800057ac <udi_cdc_data_enable+0x104>
80005726:	30 08       	mov	r8,0
80005728:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_rx_buf_nb[port][0] = 0;
8000572c:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005730:	4a 09       	lddpc	r9,800057b0 <udi_cdc_data_enable+0x108>
80005732:	30 08       	mov	r8,0
80005734:	f2 0a 0a 28 	st.h	r9[r10<<0x2],r8
	udi_cdc_rx_pos[port] = 0;
80005738:	ef 3a ff ff 	ld.ub	r10,r7[-1]
8000573c:	49 e9       	lddpc	r9,800057b4 <udi_cdc_data_enable+0x10c>
8000573e:	30 08       	mov	r8,0
80005740:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	if (!udi_cdc_rx_start(port)) {
80005744:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005748:	10 9c       	mov	r12,r8
8000574a:	f0 1f 00 1c 	mcall	800057b8 <udi_cdc_data_enable+0x110>
8000574e:	18 98       	mov	r8,r12
80005750:	ec 18 00 01 	eorl	r8,0x1
80005754:	5c 58       	castu.b	r8
80005756:	c0 30       	breq	8000575c <udi_cdc_data_enable+0xb4>
		return false;
80005758:	30 08       	mov	r8,0
8000575a:	c1 48       	rjmp	80005782 <udi_cdc_data_enable+0xda>
	}
	udi_cdc_nb_data_enabled++;
8000575c:	48 c8       	lddpc	r8,8000578c <udi_cdc_data_enable+0xe4>
8000575e:	11 88       	ld.ub	r8,r8[0x0]
80005760:	5c 58       	castu.b	r8
80005762:	2f f8       	sub	r8,-1
80005764:	5c 58       	castu.b	r8
80005766:	48 a9       	lddpc	r9,8000578c <udi_cdc_data_enable+0xe4>
80005768:	b2 88       	st.b	r9[0x0],r8
	if (udi_cdc_nb_data_enabled == UDI_CDC_PORT_NB) {
8000576a:	48 98       	lddpc	r8,8000578c <udi_cdc_data_enable+0xe4>
8000576c:	11 88       	ld.ub	r8,r8[0x0]
8000576e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005772:	30 18       	mov	r8,1
80005774:	f0 09 18 00 	cp.b	r9,r8
80005778:	c0 41       	brne	80005780 <udi_cdc_data_enable+0xd8>
		udi_cdc_data_running = true;
8000577a:	49 19       	lddpc	r9,800057bc <udi_cdc_data_enable+0x114>
8000577c:	30 18       	mov	r8,1
8000577e:	b2 88       	st.b	r9[0x0],r8
	}
	return true;
80005780:	30 18       	mov	r8,1
}
80005782:	10 9c       	mov	r12,r8
80005784:	2f fd       	sub	sp,-4
80005786:	e3 cd 80 80 	ldm	sp++,r7,pc
8000578a:	00 00       	add	r0,r0
8000578c:	00 00       	add	r0,r0
8000578e:	01 f9       	ld.ub	r9,r0[0x7]
80005790:	00 00       	add	r0,r0
80005792:	07 18       	ld.sh	r8,r3++
80005794:	00 00       	add	r0,r0
80005796:	07 1c       	ld.sh	r12,r3++
80005798:	00 00       	add	r0,r0
8000579a:	07 10       	ld.sh	r0,r3++
8000579c:	00 00       	add	r0,r0
8000579e:	07 0c       	ld.w	r12,r3++
800057a0:	00 00       	add	r0,r0
800057a2:	07 14       	ld.sh	r4,r3++
800057a4:	80 00       	ld.sh	r0,r0[0x0]
800057a6:	5e c4       	retvs	r4
800057a8:	00 00       	add	r0,r0
800057aa:	04 88       	andn	r8,r2
800057ac:	00 00       	add	r0,r0
800057ae:	04 80       	andn	r0,r2
800057b0:	00 00       	add	r0,r0
800057b2:	04 7c       	tst	r12,r2
800057b4:	00 00       	add	r0,r0
800057b6:	04 84       	andn	r4,r2
800057b8:	80 00       	ld.sh	r0,r0[0x0]
800057ba:	5c 0c       	acr	r12
800057bc:	00 00       	add	r0,r0
800057be:	01 fa       	ld.ub	r10,r0[0x7]

800057c0 <udi_cdc_comm_disable>:

void udi_cdc_comm_disable(void)
{
800057c0:	eb cd 40 80 	pushm	r7,lr
800057c4:	1a 97       	mov	r7,sp
	Assert(udi_cdc_nb_comm_enabled != 0);
	udi_cdc_nb_comm_enabled--;
800057c6:	48 58       	lddpc	r8,800057d8 <udi_cdc_comm_disable+0x18>
800057c8:	11 88       	ld.ub	r8,r8[0x0]
800057ca:	5c 58       	castu.b	r8
800057cc:	20 18       	sub	r8,1
800057ce:	5c 58       	castu.b	r8
800057d0:	48 29       	lddpc	r9,800057d8 <udi_cdc_comm_disable+0x18>
800057d2:	b2 88       	st.b	r9[0x0],r8
}
800057d4:	e3 cd 80 80 	ldm	sp++,r7,pc
800057d8:	00 00       	add	r0,r0
800057da:	01 f8       	ld.ub	r8,r0[0x7]

800057dc <udi_cdc_data_disable>:

void udi_cdc_data_disable(void)
{
800057dc:	eb cd 40 80 	pushm	r7,lr
800057e0:	1a 97       	mov	r7,sp
800057e2:	20 1d       	sub	sp,4
	uint8_t port;
	UNUSED(port);

	Assert(udi_cdc_nb_data_enabled != 0);
	udi_cdc_nb_data_enabled--;
800057e4:	48 b8       	lddpc	r8,80005810 <udi_cdc_data_disable+0x34>
800057e6:	11 88       	ld.ub	r8,r8[0x0]
800057e8:	5c 58       	castu.b	r8
800057ea:	20 18       	sub	r8,1
800057ec:	5c 58       	castu.b	r8
800057ee:	48 99       	lddpc	r9,80005810 <udi_cdc_data_disable+0x34>
800057f0:	b2 88       	st.b	r9[0x0],r8
	port = udi_cdc_nb_data_enabled;
800057f2:	48 88       	lddpc	r8,80005810 <udi_cdc_data_disable+0x34>
800057f4:	11 88       	ld.ub	r8,r8[0x0]
800057f6:	ef 68 ff ff 	st.b	r7[-1],r8
	UDI_CDC_DISABLE_EXT(port);
800057fa:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800057fe:	10 9c       	mov	r12,r8
80005800:	f0 1f 00 05 	mcall	80005814 <udi_cdc_data_disable+0x38>
	udi_cdc_data_running = false;
80005804:	48 59       	lddpc	r9,80005818 <udi_cdc_data_disable+0x3c>
80005806:	30 08       	mov	r8,0
80005808:	b2 88       	st.b	r9[0x0],r8
}
8000580a:	2f fd       	sub	sp,-4
8000580c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005810:	00 00       	add	r0,r0
80005812:	01 f9       	ld.ub	r9,r0[0x7]
80005814:	80 00       	ld.sh	r0,r0[0x0]
80005816:	76 00       	ld.w	r0,r11[0x0]
80005818:	00 00       	add	r0,r0
8000581a:	01 fa       	ld.ub	r10,r0[0x7]

8000581c <udi_cdc_comm_setup>:

bool udi_cdc_comm_setup(void)
{
8000581c:	eb cd 40 80 	pushm	r7,lr
80005820:	1a 97       	mov	r7,sp
80005822:	20 1d       	sub	sp,4
	uint8_t port = udi_cdc_setup_to_port();
80005824:	f0 1f 00 3a 	mcall	8000590c <udi_cdc_comm_setup+0xf0>
80005828:	18 98       	mov	r8,r12
8000582a:	ef 68 ff ff 	st.b	r7[-1],r8

	if (Udd_setup_is_in()) {
8000582e:	4b 98       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
80005830:	11 88       	ld.ub	r8,r8[0x0]
80005832:	10 99       	mov	r9,r8
80005834:	30 08       	mov	r8,0
80005836:	f0 09 18 00 	cp.b	r9,r8
8000583a:	c2 44       	brge	80005882 <udi_cdc_comm_setup+0x66>
		// GET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
8000583c:	4b 58       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
8000583e:	11 88       	ld.ub	r8,r8[0x0]
80005840:	e2 18 00 60 	andl	r8,0x60,COH
80005844:	e0 48 00 20 	cp.w	r8,32
80005848:	c1 d1       	brne	80005882 <udi_cdc_comm_setup+0x66>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
8000584a:	4b 28       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
8000584c:	11 98       	ld.ub	r8,r8[0x1]
8000584e:	e0 48 00 21 	cp.w	r8,33
80005852:	c1 81       	brne	80005882 <udi_cdc_comm_setup+0x66>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
80005854:	4a f8       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
80005856:	90 39       	ld.sh	r9,r8[0x6]
80005858:	30 78       	mov	r8,7
8000585a:	f0 09 19 00 	cp.h	r9,r8
8000585e:	c0 30       	breq	80005864 <udi_cdc_comm_setup+0x48>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
80005860:	30 08       	mov	r8,0
80005862:	c5 18       	rjmp	80005904 <udi_cdc_comm_setup+0xe8>
				udd_g_ctrlreq.payload =
						(uint8_t *) &
80005864:	4a ca       	lddpc	r10,80005914 <udi_cdc_comm_setup+0xf8>
80005866:	ef 39 ff ff 	ld.ub	r9,r7[-1]
						udi_cdc_line_coding[port];
8000586a:	12 98       	mov	r8,r9
8000586c:	a3 78       	lsl	r8,0x3
8000586e:	12 18       	sub	r8,r9
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.payload =
						(uint8_t *) &
80005870:	f4 08 00 09 	add	r9,r10,r8
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.payload =
80005874:	4a 78       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
80005876:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding[port];
				udd_g_ctrlreq.payload_size =
80005878:	4a 69       	lddpc	r9,80005910 <udi_cdc_comm_setup+0xf4>
8000587a:	30 78       	mov	r8,7
8000587c:	b2 68       	st.h	r9[0xc],r8
						sizeof(usb_cdc_line_coding_t);
				return true;
8000587e:	30 18       	mov	r8,1
80005880:	c4 28       	rjmp	80005904 <udi_cdc_comm_setup+0xe8>
			}
		}
	}
	if (Udd_setup_is_out()) {
80005882:	4a 48       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
80005884:	11 88       	ld.ub	r8,r8[0x0]
80005886:	10 99       	mov	r9,r8
80005888:	30 08       	mov	r8,0
8000588a:	f0 09 18 00 	cp.b	r9,r8
8000588e:	c3 a5       	brlt	80005902 <udi_cdc_comm_setup+0xe6>
		// SET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
80005890:	4a 08       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
80005892:	11 88       	ld.ub	r8,r8[0x0]
80005894:	e2 18 00 60 	andl	r8,0x60,COH
80005898:	e0 48 00 20 	cp.w	r8,32
8000589c:	c3 31       	brne	80005902 <udi_cdc_comm_setup+0xe6>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
8000589e:	49 d8       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
800058a0:	11 98       	ld.ub	r8,r8[0x1]
800058a2:	e0 48 00 20 	cp.w	r8,32
800058a6:	c0 50       	breq	800058b0 <udi_cdc_comm_setup+0x94>
800058a8:	e0 48 00 22 	cp.w	r8,34
800058ac:	c1 c0       	breq	800058e4 <udi_cdc_comm_setup+0xc8>
800058ae:	c2 a8       	rjmp	80005902 <udi_cdc_comm_setup+0xe6>
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
800058b0:	49 88       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
800058b2:	90 39       	ld.sh	r9,r8[0x6]
800058b4:	30 78       	mov	r8,7
800058b6:	f0 09 19 00 	cp.h	r9,r8
800058ba:	c0 30       	breq	800058c0 <udi_cdc_comm_setup+0xa4>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
800058bc:	30 08       	mov	r8,0
800058be:	c2 38       	rjmp	80005904 <udi_cdc_comm_setup+0xe8>
				udd_g_ctrlreq.callback =
800058c0:	49 48       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
800058c2:	49 69       	lddpc	r9,80005918 <udi_cdc_comm_setup+0xfc>
800058c4:	91 49       	st.w	r8[0x10],r9
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
						(uint8_t *) &
800058c6:	49 4a       	lddpc	r10,80005914 <udi_cdc_comm_setup+0xf8>
800058c8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
						udi_cdc_line_coding[port];
800058cc:	12 98       	mov	r8,r9
800058ce:	a3 78       	lsl	r8,0x3
800058d0:	12 18       	sub	r8,r9
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.callback =
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
						(uint8_t *) &
800058d2:	f4 08 00 09 	add	r9,r10,r8
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.callback =
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
800058d6:	48 f8       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
800058d8:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding[port];
				udd_g_ctrlreq.payload_size =
800058da:	48 e9       	lddpc	r9,80005910 <udi_cdc_comm_setup+0xf4>
800058dc:	30 78       	mov	r8,7
800058de:	b2 68       	st.h	r9[0xc],r8
						sizeof(usb_cdc_line_coding_t);
				return true;
800058e0:	30 18       	mov	r8,1
800058e2:	c1 18       	rjmp	80005904 <udi_cdc_comm_setup+0xe8>
			case USB_REQ_CDC_SET_CONTROL_LINE_STATE:
				// According cdc spec 1.1 chapter 6.2.14
				UDI_CDC_SET_DTR_EXT(port, (0 !=
800058e4:	48 b8       	lddpc	r8,80005910 <udi_cdc_comm_setup+0xf4>
800058e6:	90 18       	ld.sh	r8,r8[0x2]
800058e8:	5c 78       	castu.h	r8
800058ea:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800058ee:	5c 58       	castu.b	r8
800058f0:	10 99       	mov	r9,r8
800058f2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800058f6:	12 9b       	mov	r11,r9
800058f8:	10 9c       	mov	r12,r8
800058fa:	f0 1f 00 09 	mcall	8000591c <udi_cdc_comm_setup+0x100>
						(udd_g_ctrlreq.req.wValue
						 & CDC_CTRL_SIGNAL_DTE_PRESENT)));
				UDI_CDC_SET_RTS_EXT(port, (0 !=
						(udd_g_ctrlreq.req.wValue
						 & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
				return true;
800058fe:	30 18       	mov	r8,1
80005900:	c0 28       	rjmp	80005904 <udi_cdc_comm_setup+0xe8>
			}
		}
	}
	return false;  // request Not supported
80005902:	30 08       	mov	r8,0
}
80005904:	10 9c       	mov	r12,r8
80005906:	2f fd       	sub	sp,-4
80005908:	e3 cd 80 80 	ldm	sp++,r7,pc
8000590c:	80 00       	ld.sh	r0,r0[0x0]
8000590e:	59 58       	cp.w	r8,21
80005910:	00 00       	add	r0,r0
80005912:	46 48       	lddsp	r8,sp[0x190]
80005914:	00 00       	add	r0,r0
80005916:	01 da       	ld.ub	r10,r0[0x5]
80005918:	80 00       	ld.sh	r0,r0[0x0]
8000591a:	59 8c       	cp.w	r12,24
8000591c:	80 00       	ld.sh	r0,r0[0x0]
8000591e:	76 2c       	ld.w	r12,r11[0x8]

80005920 <udi_cdc_data_setup>:

bool udi_cdc_data_setup(void)
{
80005920:	eb cd 40 80 	pushm	r7,lr
80005924:	1a 97       	mov	r7,sp
	return false;  // request Not supported
80005926:	30 08       	mov	r8,0
}
80005928:	10 9c       	mov	r12,r8
8000592a:	e3 cd 80 80 	ldm	sp++,r7,pc

8000592e <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
8000592e:	eb cd 40 80 	pushm	r7,lr
80005932:	1a 97       	mov	r7,sp
	return 0;      // CDC don't have multiple alternate setting
80005934:	30 08       	mov	r8,0
}
80005936:	10 9c       	mov	r12,r8
80005938:	e3 cd 80 80 	ldm	sp++,r7,pc

8000593c <udi_cdc_data_sof_notify>:

void udi_cdc_data_sof_notify(void)
{
8000593c:	eb cd 40 80 	pushm	r7,lr
80005940:	1a 97       	mov	r7,sp
	static uint8_t port_notify = 0;

	// A call of udi_cdc_data_sof_notify() is done for each port
	udi_cdc_tx_send(port_notify);
80005942:	48 48       	lddpc	r8,80005950 <udi_cdc_data_sof_notify+0x14>
80005944:	11 88       	ld.ub	r8,r8[0x0]
80005946:	10 9c       	mov	r12,r8
80005948:	f0 1f 00 03 	mcall	80005954 <udi_cdc_data_sof_notify+0x18>
	port_notify++;
	if (port_notify >= UDI_CDC_PORT_NB) {
		port_notify = 0;
	}
#endif
}
8000594c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005950:	00 00       	add	r0,r0
80005952:	07 22       	ld.uh	r2,r3++
80005954:	80 00       	ld.sh	r0,r0[0x0]
80005956:	5e c4       	retvs	r4

80005958 <udi_cdc_setup_to_port>:

//-------------------------------------------------
//------- Internal routines to control serial line

static uint8_t udi_cdc_setup_to_port(void)
{
80005958:	eb cd 40 80 	pushm	r7,lr
8000595c:	1a 97       	mov	r7,sp
8000595e:	20 1d       	sub	sp,4
	uint8_t port;

	switch (udd_g_ctrlreq.req.wIndex & 0xFF) {
80005960:	48 a8       	lddpc	r8,80005988 <udi_cdc_setup_to_port+0x30>
80005962:	90 28       	ld.sh	r8,r8[0x4]
80005964:	5c 78       	castu.h	r8
80005966:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
8000596a:	c0 51       	brne	80005974 <udi_cdc_setup_to_port+0x1c>
#define UDI_CDC_IFACE_COMM_TO_PORT(iface, unused) \
	case UDI_CDC_COMM_IFACE_NUMBER_##iface: \
		port = iface; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_IFACE_COMM_TO_PORT, ~)
8000596c:	30 08       	mov	r8,0
8000596e:	ef 68 ff ff 	st.b	r7[-1],r8
80005972:	c0 48       	rjmp	8000597a <udi_cdc_setup_to_port+0x22>
#undef UDI_CDC_IFACE_COMM_TO_PORT
	default:
		port = 0;
80005974:	30 08       	mov	r8,0
80005976:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}
	return port;
8000597a:	ef 38 ff ff 	ld.ub	r8,r7[-1]
}
8000597e:	10 9c       	mov	r12,r8
80005980:	2f fd       	sub	sp,-4
80005982:	e3 cd 80 80 	ldm	sp++,r7,pc
80005986:	00 00       	add	r0,r0
80005988:	00 00       	add	r0,r0
8000598a:	46 48       	lddsp	r8,sp[0x190]

8000598c <udi_cdc_line_coding_received>:

static void udi_cdc_line_coding_received(void)
{
8000598c:	eb cd 40 80 	pushm	r7,lr
80005990:	1a 97       	mov	r7,sp
80005992:	20 1d       	sub	sp,4
	uint8_t port = udi_cdc_setup_to_port();
80005994:	f0 1f 00 0b 	mcall	800059c0 <udi_cdc_line_coding_received+0x34>
80005998:	18 98       	mov	r8,r12
8000599a:	ef 68 ff ff 	st.b	r7[-1],r8
	UNUSED(port);

	UDI_CDC_SET_CODING_EXT(port, (&udi_cdc_line_coding[port]));
8000599e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800059a2:	12 98       	mov	r8,r9
800059a4:	a3 78       	lsl	r8,0x3
800059a6:	f0 09 01 09 	sub	r9,r8,r9
800059aa:	48 78       	lddpc	r8,800059c4 <udi_cdc_line_coding_received+0x38>
800059ac:	10 09       	add	r9,r8
800059ae:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800059b2:	12 9b       	mov	r11,r9
800059b4:	10 9c       	mov	r12,r8
800059b6:	f0 1f 00 05 	mcall	800059c8 <udi_cdc_line_coding_received+0x3c>
}
800059ba:	2f fd       	sub	sp,-4
800059bc:	e3 cd 80 80 	ldm	sp++,r7,pc
800059c0:	80 00       	ld.sh	r0,r0[0x0]
800059c2:	59 58       	cp.w	r8,21
800059c4:	00 00       	add	r0,r0
800059c6:	01 da       	ld.ub	r10,r0[0x5]
800059c8:	80 00       	ld.sh	r0,r0[0x0]
800059ca:	86 48       	ld.sh	r8,r3[0x8]

800059cc <udi_cdc_ctrl_state_change>:

static void udi_cdc_ctrl_state_change(uint8_t port, bool b_set, le16_t bit_mask)
{
800059cc:	eb cd 40 80 	pushm	r7,lr
800059d0:	1a 97       	mov	r7,sp
800059d2:	20 5d       	sub	sp,20
800059d4:	16 99       	mov	r9,r11
800059d6:	14 98       	mov	r8,r10
800059d8:	18 9a       	mov	r10,r12
800059da:	ef 6a ff f4 	st.b	r7[-12],r10
800059de:	ef 69 ff f0 	st.b	r7[-16],r9
800059e2:	ef 58 ff ec 	st.h	r7[-20],r8
	irqflags_t flags;
	udd_ep_id_t ep_comm;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
800059e6:	30 08       	mov	r8,0
800059e8:	ef 68 ff f4 	st.b	r7[-12],r8
#endif

	// Update state
	flags = cpu_irq_save(); // Protect udi_cdc_state
800059ec:	f0 1f 00 25 	mcall	80005a80 <udi_cdc_ctrl_state_change+0xb4>
800059f0:	18 98       	mov	r8,r12
800059f2:	ef 48 ff f8 	st.w	r7[-8],r8
	if (b_set) {
800059f6:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800059fa:	30 08       	mov	r8,0
800059fc:	f0 09 18 00 	cp.b	r9,r8
80005a00:	c1 30       	breq	80005a26 <udi_cdc_ctrl_state_change+0x5a>
		udi_cdc_state[port] |= bit_mask;
80005a02:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005a06:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005a0a:	49 f8       	lddpc	r8,80005a84 <udi_cdc_ctrl_state_change+0xb8>
80005a0c:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005a10:	5c 88       	casts.h	r8
80005a12:	10 99       	mov	r9,r8
80005a14:	ef 08 ff ec 	ld.sh	r8,r7[-20]
80005a18:	f3 e8 10 08 	or	r8,r9,r8
80005a1c:	5c 88       	casts.h	r8
80005a1e:	49 a9       	lddpc	r9,80005a84 <udi_cdc_ctrl_state_change+0xb8>
80005a20:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
80005a24:	c1 48       	rjmp	80005a4c <udi_cdc_ctrl_state_change+0x80>
	} else {
		udi_cdc_state[port] &= ~(unsigned)bit_mask;
80005a26:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005a2a:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005a2e:	49 68       	lddpc	r8,80005a84 <udi_cdc_ctrl_state_change+0xb8>
80005a30:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005a34:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005a38:	ef 08 ff ec 	ld.sh	r8,r7[-20]
80005a3c:	5c d8       	com	r8
80005a3e:	5c 88       	casts.h	r8
80005a40:	f3 e8 00 08 	and	r8,r9,r8
80005a44:	5c 88       	casts.h	r8
80005a46:	49 09       	lddpc	r9,80005a84 <udi_cdc_ctrl_state_change+0xb8>
80005a48:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	}
	cpu_irq_restore(flags);
80005a4c:	ee fc ff f8 	ld.w	r12,r7[-8]
80005a50:	f0 1f 00 0e 	mcall	80005a88 <udi_cdc_ctrl_state_change+0xbc>

	// Send it if possible and state changed
	switch (port) {
80005a54:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005a58:	58 08       	cp.w	r8,0
80005a5a:	c0 51       	brne	80005a64 <udi_cdc_ctrl_state_change+0x98>
#define UDI_CDC_PORT_TO_COMM_EP(index, unused) \
	case index: \
		ep_comm = UDI_CDC_COMM_EP_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_COMM_EP, ~)
80005a5c:	38 38       	mov	r8,-125
80005a5e:	ef 68 ff ff 	st.b	r7[-1],r8
80005a62:	c0 48       	rjmp	80005a6a <udi_cdc_ctrl_state_change+0x9e>
#undef UDI_CDC_PORT_TO_COMM_EP
	default:
		ep_comm = UDI_CDC_COMM_EP_0;
80005a64:	38 38       	mov	r8,-125
80005a66:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}
	udi_cdc_ctrl_state_notify(port, ep_comm);
80005a6a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005a6e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005a72:	12 9b       	mov	r11,r9
80005a74:	10 9c       	mov	r12,r8
80005a76:	f0 1f 00 06 	mcall	80005a8c <udi_cdc_ctrl_state_change+0xc0>
}
80005a7a:	2f bd       	sub	sp,-20
80005a7c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a80:	80 00       	ld.sh	r0,r0[0x0]
80005a82:	54 7c       	stdsp	sp[0x11c],r12
80005a84:	00 00       	add	r0,r0
80005a86:	01 e8       	ld.ub	r8,r0[0x6]
80005a88:	80 00       	ld.sh	r0,r0[0x0]
80005a8a:	54 bc       	stdsp	sp[0x12c],r12
80005a8c:	80 00       	ld.sh	r0,r0[0x0]
80005a8e:	5a 90       	cp.w	r0,-23

80005a90 <udi_cdc_ctrl_state_notify>:


static void udi_cdc_ctrl_state_notify(uint8_t port, udd_ep_id_t ep)
{
80005a90:	eb cd 40 c0 	pushm	r6-r7,lr
80005a94:	1a 97       	mov	r7,sp
80005a96:	20 2d       	sub	sp,8
80005a98:	18 99       	mov	r9,r12
80005a9a:	16 98       	mov	r8,r11
80005a9c:	ef 69 ff fc 	st.b	r7[-4],r9
80005aa0:	ef 68 ff f8 	st.b	r7[-8],r8
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80005aa4:	30 08       	mov	r8,0
80005aa6:	ef 68 ff fc 	st.b	r7[-4],r8
#endif

	// Send it if possible and state changed
	if ((!udi_cdc_serial_state_msg_ongoing[port])
80005aaa:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80005aae:	4a 59       	lddpc	r9,80005b40 <udi_cdc_ctrl_state_notify+0xb0>
80005ab0:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005ab4:	ec 18 00 01 	eorl	r8,0x1
80005ab8:	5c 58       	castu.b	r8
80005aba:	c4 00       	breq	80005b3a <udi_cdc_ctrl_state_notify+0xaa>
			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
80005abc:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80005ac0:	4a 18       	lddpc	r8,80005b44 <udi_cdc_ctrl_state_notify+0xb4>
80005ac2:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005ac6:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
80005aca:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80005ace:	49 fb       	lddpc	r11,80005b48 <udi_cdc_ctrl_state_notify+0xb8>
80005ad0:	12 98       	mov	r8,r9
80005ad2:	a3 68       	lsl	r8,0x2
80005ad4:	12 08       	add	r8,r9
80005ad6:	a1 78       	lsl	r8,0x1
80005ad8:	f6 08 00 08 	add	r8,r11,r8
80005adc:	2f 88       	sub	r8,-8
80005ade:	90 08       	ld.sh	r8,r8[0x0]
80005ae0:	5c 88       	casts.h	r8
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	// Send it if possible and state changed
	if ((!udi_cdc_serial_state_msg_ongoing[port])
80005ae2:	f0 0a 19 00 	cp.h	r10,r8
80005ae6:	c2 a0       	breq	80005b3a <udi_cdc_ctrl_state_notify+0xaa>
			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
		// Fill notification message
		uid_cdc_state_msg[port].value = udi_cdc_state[port];
80005ae8:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80005aec:	ef 3a ff fc 	ld.ub	r10,r7[-4]
80005af0:	49 58       	lddpc	r8,80005b44 <udi_cdc_ctrl_state_notify+0xb4>
80005af2:	f0 0a 04 18 	ld.sh	r8,r8[r10<<0x1]
80005af6:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
80005afa:	49 4b       	lddpc	r11,80005b48 <udi_cdc_ctrl_state_notify+0xb8>
80005afc:	12 98       	mov	r8,r9
80005afe:	a3 68       	lsl	r8,0x2
80005b00:	12 08       	add	r8,r9
80005b02:	a1 78       	lsl	r8,0x1
80005b04:	f6 08 00 08 	add	r8,r11,r8
80005b08:	f0 c9 ff f8 	sub	r9,r8,-8
80005b0c:	14 98       	mov	r8,r10
80005b0e:	b2 08       	st.h	r9[0x0],r8
		// Send notification message
		udi_cdc_serial_state_msg_ongoing[port] =
80005b10:	ef 36 ff fc 	ld.ub	r6,r7[-4]
				udd_ep_run(ep,
80005b14:	48 da       	lddpc	r10,80005b48 <udi_cdc_ctrl_state_notify+0xb8>
80005b16:	ef 39 ff fc 	ld.ub	r9,r7[-4]
				false,
				(uint8_t *) & uid_cdc_state_msg[port],
80005b1a:	12 98       	mov	r8,r9
80005b1c:	a3 68       	lsl	r8,0x2
80005b1e:	12 08       	add	r8,r9
80005b20:	a1 78       	lsl	r8,0x1
			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
		// Fill notification message
		uid_cdc_state_msg[port].value = udi_cdc_state[port];
		// Send notification message
		udi_cdc_serial_state_msg_ongoing[port] =
				udd_ep_run(ep,
80005b22:	10 0a       	add	r10,r8
80005b24:	ef 3c ff f8 	ld.ub	r12,r7[-8]
80005b28:	48 98       	lddpc	r8,80005b4c <udi_cdc_ctrl_state_notify+0xbc>
80005b2a:	30 a9       	mov	r9,10
80005b2c:	30 0b       	mov	r11,0
80005b2e:	f0 1f 00 09 	mcall	80005b50 <udi_cdc_ctrl_state_notify+0xc0>
80005b32:	18 98       	mov	r8,r12
	if ((!udi_cdc_serial_state_msg_ongoing[port])
			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
		// Fill notification message
		uid_cdc_state_msg[port].value = udi_cdc_state[port];
		// Send notification message
		udi_cdc_serial_state_msg_ongoing[port] =
80005b34:	48 39       	lddpc	r9,80005b40 <udi_cdc_ctrl_state_notify+0xb0>
80005b36:	f2 06 0b 08 	st.b	r9[r6],r8
				false,
				(uint8_t *) & uid_cdc_state_msg[port],
				sizeof(uid_cdc_state_msg[0]),
				udi_cdc_serial_state_msg_sent);
	}
}
80005b3a:	2f ed       	sub	sp,-8
80005b3c:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b40:	00 00       	add	r0,r0
80005b42:	01 e4       	ld.ub	r4,r0[0x6]
80005b44:	00 00       	add	r0,r0
80005b46:	01 e8       	ld.ub	r8,r0[0x6]
80005b48:	00 00       	add	r0,r0
80005b4a:	01 ec       	ld.ub	r12,r0[0x6]
80005b4c:	80 00       	ld.sh	r0,r0[0x0]
80005b4e:	5b 54       	cp.w	r4,-11
80005b50:	80 00       	ld.sh	r0,r0[0x0]
80005b52:	3c 38       	mov	r8,-61

80005b54 <udi_cdc_serial_state_msg_sent>:


static void udi_cdc_serial_state_msg_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
80005b54:	eb cd 40 80 	pushm	r7,lr
80005b58:	1a 97       	mov	r7,sp
80005b5a:	20 4d       	sub	sp,16
80005b5c:	ef 4c ff f8 	st.w	r7[-8],r12
80005b60:	ef 4b ff f4 	st.w	r7[-12],r11
80005b64:	14 98       	mov	r8,r10
80005b66:	ef 68 ff f0 	st.b	r7[-16],r8
	uint8_t port;
	UNUSED(n);
	UNUSED(status);

	switch (ep) {
80005b6a:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80005b6e:	e0 48 00 83 	cp.w	r8,131
80005b72:	c0 51       	brne	80005b7c <udi_cdc_serial_state_msg_sent+0x28>
#define UDI_CDC_GET_PORT_FROM_COMM_EP(iface, unused) \
	case UDI_CDC_COMM_EP_##iface: \
		port = iface; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_GET_PORT_FROM_COMM_EP, ~)
80005b74:	30 08       	mov	r8,0
80005b76:	ef 68 ff ff 	st.b	r7[-1],r8
80005b7a:	c0 48       	rjmp	80005b82 <udi_cdc_serial_state_msg_sent+0x2e>
#undef UDI_CDC_GET_PORT_FROM_COMM_EP
	default:
		port = 0;
80005b7c:	30 08       	mov	r8,0
80005b7e:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}

	udi_cdc_serial_state_msg_ongoing[port] = false;
80005b82:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005b86:	49 ea       	lddpc	r10,80005bfc <udi_cdc_serial_state_msg_sent+0xa8>
80005b88:	30 08       	mov	r8,0
80005b8a:	f4 09 0b 08 	st.b	r10[r9],r8

	// For the irregular signals like break, the incoming ring signal,
	// or the overrun error state, this will reset their values to zero
	// and again will not send another notification until their state changes.
	udi_cdc_state[port] &= ~(CDC_SERIAL_STATE_BREAK |
80005b8e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005b92:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005b96:	49 b8       	lddpc	r8,80005c00 <udi_cdc_serial_state_msg_sent+0xac>
80005b98:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005b9c:	5c 88       	casts.h	r8
80005b9e:	e0 18 83 ff 	andl	r8,0x83ff
80005ba2:	5c 88       	casts.h	r8
80005ba4:	49 79       	lddpc	r9,80005c00 <udi_cdc_serial_state_msg_sent+0xac>
80005ba6:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			CDC_SERIAL_STATE_RING |
			CDC_SERIAL_STATE_FRAMING |
			CDC_SERIAL_STATE_PARITY | CDC_SERIAL_STATE_OVERRUN);
	uid_cdc_state_msg[port].value &= ~(CDC_SERIAL_STATE_BREAK |
80005baa:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005bae:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005bb2:	49 5b       	lddpc	r11,80005c04 <udi_cdc_serial_state_msg_sent+0xb0>
80005bb4:	14 98       	mov	r8,r10
80005bb6:	a3 68       	lsl	r8,0x2
80005bb8:	14 08       	add	r8,r10
80005bba:	a1 78       	lsl	r8,0x1
80005bbc:	f6 08 00 08 	add	r8,r11,r8
80005bc0:	2f 88       	sub	r8,-8
80005bc2:	90 08       	ld.sh	r8,r8[0x0]
80005bc4:	5c 88       	casts.h	r8
80005bc6:	e0 18 83 ff 	andl	r8,0x83ff
80005bca:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
80005bce:	48 eb       	lddpc	r11,80005c04 <udi_cdc_serial_state_msg_sent+0xb0>
80005bd0:	12 98       	mov	r8,r9
80005bd2:	a3 68       	lsl	r8,0x2
80005bd4:	12 08       	add	r8,r9
80005bd6:	a1 78       	lsl	r8,0x1
80005bd8:	f6 08 00 08 	add	r8,r11,r8
80005bdc:	f0 c9 ff f8 	sub	r9,r8,-8
80005be0:	14 98       	mov	r8,r10
80005be2:	b2 08       	st.h	r9[0x0],r8
			CDC_SERIAL_STATE_RING |
			CDC_SERIAL_STATE_FRAMING |
			CDC_SERIAL_STATE_PARITY | CDC_SERIAL_STATE_OVERRUN);
	// Send it if possible and state changed
	udi_cdc_ctrl_state_notify(port, ep);
80005be4:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80005be8:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005bec:	12 9b       	mov	r11,r9
80005bee:	10 9c       	mov	r12,r8
80005bf0:	f0 1f 00 06 	mcall	80005c08 <udi_cdc_serial_state_msg_sent+0xb4>
}
80005bf4:	2f cd       	sub	sp,-16
80005bf6:	e3 cd 80 80 	ldm	sp++,r7,pc
80005bfa:	00 00       	add	r0,r0
80005bfc:	00 00       	add	r0,r0
80005bfe:	01 e4       	ld.ub	r4,r0[0x6]
80005c00:	00 00       	add	r0,r0
80005c02:	01 e8       	ld.ub	r8,r0[0x6]
80005c04:	00 00       	add	r0,r0
80005c06:	01 ec       	ld.ub	r12,r0[0x6]
80005c08:	80 00       	ld.sh	r0,r0[0x0]
80005c0a:	5a 90       	cp.w	r0,-23

80005c0c <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(uint8_t port)
{
80005c0c:	eb cd 40 80 	pushm	r7,lr
80005c10:	1a 97       	mov	r7,sp
80005c12:	20 3d       	sub	sp,12
80005c14:	18 98       	mov	r8,r12
80005c16:	ef 68 ff f4 	st.b	r7[-12],r8
	irqflags_t flags;
	uint8_t buf_sel_trans;
	udd_ep_id_t ep;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80005c1a:	30 08       	mov	r8,0
80005c1c:	ef 68 ff f4 	st.b	r7[-12],r8
#endif

	flags = cpu_irq_save();
80005c20:	f0 1f 00 3f 	mcall	80005d1c <udi_cdc_rx_start+0x110>
80005c24:	18 98       	mov	r8,r12
80005c26:	ef 48 ff f8 	st.w	r7[-8],r8
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
80005c2a:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005c2e:	4b d9       	lddpc	r9,80005d20 <udi_cdc_rx_start+0x114>
80005c30:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005c34:	ef 68 ff fe 	st.b	r7[-2],r8
	if (udi_cdc_rx_trans_ongoing[port] ||
80005c38:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005c3c:	4b a9       	lddpc	r9,80005d24 <udi_cdc_rx_start+0x118>
80005c3e:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005c42:	5c 58       	castu.b	r8
80005c44:	c1 51       	brne	80005c6e <udi_cdc_rx_start+0x62>
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
80005c46:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005c4a:	4b 88       	lddpc	r8,80005d28 <udi_cdc_rx_start+0x11c>
80005c4c:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005c50:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005c54:	ef 3b ff f4 	ld.ub	r11,r7[-12]
80005c58:	ef 3a ff fe 	ld.ub	r10,r7[-2]
80005c5c:	4b 48       	lddpc	r8,80005d2c <udi_cdc_rx_start+0x120>
80005c5e:	a1 7b       	lsl	r11,0x1
80005c60:	f6 0a 00 0a 	add	r10,r11,r10
80005c64:	f0 0a 04 18 	ld.sh	r8,r8[r10<<0x1]
	port = 0;
#endif

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
	if (udi_cdc_rx_trans_ongoing[port] ||
80005c68:	f0 09 19 00 	cp.h	r9,r8
80005c6c:	c0 72       	brcc	80005c7a <udi_cdc_rx_start+0x6e>
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
		// Transfer already on-going or current buffer no empty
		cpu_irq_restore(flags);
80005c6e:	ee fc ff f8 	ld.w	r12,r7[-8]
80005c72:	f0 1f 00 30 	mcall	80005d30 <udi_cdc_rx_start+0x124>
		return false;
80005c76:	30 08       	mov	r8,0
80005c78:	c4 e8       	rjmp	80005d14 <udi_cdc_rx_start+0x108>
	}

	// Change current buffer
	udi_cdc_rx_pos[port] = 0;
80005c7a:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005c7e:	4a b9       	lddpc	r9,80005d28 <udi_cdc_rx_start+0x11c>
80005c80:	30 08       	mov	r8,0
80005c82:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_rx_buf_sel[port] = (buf_sel_trans==0)?1:0;
80005c86:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005c8a:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005c8e:	30 08       	mov	r8,0
80005c90:	f0 09 18 00 	cp.b	r9,r8
80005c94:	5f 08       	sreq	r8
80005c96:	4a 39       	lddpc	r9,80005d20 <udi_cdc_rx_start+0x114>
80005c98:	f2 0a 0b 08 	st.b	r9[r10],r8

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing[port] = true;
80005c9c:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005ca0:	4a 1a       	lddpc	r10,80005d24 <udi_cdc_rx_start+0x118>
80005ca2:	30 18       	mov	r8,1
80005ca4:	f4 09 0b 08 	st.b	r10[r9],r8
	cpu_irq_restore(flags);
80005ca8:	ee fc ff f8 	ld.w	r12,r7[-8]
80005cac:	f0 1f 00 21 	mcall	80005d30 <udi_cdc_rx_start+0x124>

	if (udi_cdc_multi_is_rx_ready(port)) {
80005cb0:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005cb4:	10 9c       	mov	r12,r8
80005cb6:	f0 1f 00 20 	mcall	80005d34 <udi_cdc_rx_start+0x128>
80005cba:	18 98       	mov	r8,r12
80005cbc:	58 08       	cp.w	r8,0
80005cbe:	c0 60       	breq	80005cca <udi_cdc_rx_start+0xbe>
		UDI_CDC_RX_NOTIFY(port);
80005cc0:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005cc4:	10 9c       	mov	r12,r8
80005cc6:	f0 1f 00 1d 	mcall	80005d38 <udi_cdc_rx_start+0x12c>
	}
	// Send the buffer with enable of short packet
	switch (port) {
80005cca:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005cce:	58 08       	cp.w	r8,0
80005cd0:	c0 51       	brne	80005cda <udi_cdc_rx_start+0xce>
#define UDI_CDC_PORT_TO_DATA_EP_OUT(index, unused) \
	case index: \
		ep = UDI_CDC_DATA_EP_OUT_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_OUT, ~)
80005cd2:	30 28       	mov	r8,2
80005cd4:	ef 68 ff ff 	st.b	r7[-1],r8
80005cd8:	c0 48       	rjmp	80005ce0 <udi_cdc_rx_start+0xd4>
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
80005cda:	30 28       	mov	r8,2
80005cdc:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}
	return udd_ep_run(ep,
80005ce0:	49 7a       	lddpc	r10,80005d3c <udi_cdc_rx_start+0x130>
80005ce2:	ef 39 ff f4 	ld.ub	r9,r7[-12]
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
80005ce6:	12 98       	mov	r8,r9
80005ce8:	a3 68       	lsl	r8,0x2
80005cea:	12 08       	add	r8,r9
80005cec:	a7 78       	lsl	r8,0x7
80005cee:	10 9b       	mov	r11,r8
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
		break;
	}
	return udd_ep_run(ep,
80005cf0:	ef 39 ff fe 	ld.ub	r9,r7[-2]
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
80005cf4:	12 98       	mov	r8,r9
80005cf6:	a3 68       	lsl	r8,0x2
80005cf8:	12 08       	add	r8,r9
80005cfa:	a7 68       	lsl	r8,0x6
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
		break;
	}
	return udd_ep_run(ep,
80005cfc:	f6 08 00 08 	add	r8,r11,r8
80005d00:	10 0a       	add	r10,r8
80005d02:	ef 3c ff ff 	ld.ub	r12,r7[-1]
80005d06:	48 f8       	lddpc	r8,80005d40 <udi_cdc_rx_start+0x134>
80005d08:	e0 69 01 40 	mov	r9,320
80005d0c:	30 1b       	mov	r11,1
80005d0e:	f0 1f 00 0e 	mcall	80005d44 <udi_cdc_rx_start+0x138>
80005d12:	18 98       	mov	r8,r12
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
			UDI_CDC_RX_BUFFERS,
			udi_cdc_data_received);
}
80005d14:	10 9c       	mov	r12,r8
80005d16:	2f dd       	sub	sp,-12
80005d18:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d1c:	80 00       	ld.sh	r0,r0[0x0]
80005d1e:	54 7c       	stdsp	sp[0x11c],r12
80005d20:	00 00       	add	r0,r0
80005d22:	04 80       	andn	r0,r2
80005d24:	00 00       	add	r0,r0
80005d26:	04 88       	andn	r8,r2
80005d28:	00 00       	add	r0,r0
80005d2a:	04 84       	andn	r4,r2
80005d2c:	00 00       	add	r0,r0
80005d2e:	04 7c       	tst	r12,r2
80005d30:	80 00       	ld.sh	r0,r0[0x0]
80005d32:	54 bc       	stdsp	sp[0x12c],r12
80005d34:	80 00       	ld.sh	r0,r0[0x0]
80005d36:	61 ac       	ld.w	r12,r0[0x68]
80005d38:	80 00       	ld.sh	r0,r0[0x0]
80005d3a:	85 e4       	st.w	r2[0x38],r4
80005d3c:	00 00       	add	r0,r0
80005d3e:	01 fc       	ld.ub	r12,r0[0x7]
80005d40:	80 00       	ld.sh	r0,r0[0x0]
80005d42:	5d 48       	*unknown*
80005d44:	80 00       	ld.sh	r0,r0[0x0]
80005d46:	3c 38       	mov	r8,-61

80005d48 <udi_cdc_data_received>:


static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
80005d48:	eb cd 40 80 	pushm	r7,lr
80005d4c:	1a 97       	mov	r7,sp
80005d4e:	20 4d       	sub	sp,16
80005d50:	ef 4c ff f8 	st.w	r7[-8],r12
80005d54:	ef 4b ff f4 	st.w	r7[-12],r11
80005d58:	14 98       	mov	r8,r10
80005d5a:	ef 68 ff f0 	st.b	r7[-16],r8
	uint8_t buf_sel_trans;
	uint8_t port;

	switch (ep) {
80005d5e:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80005d62:	58 28       	cp.w	r8,2
80005d64:	c0 51       	brne	80005d6e <udi_cdc_data_received+0x26>
#define UDI_CDC_DATA_EP_OUT_TO_PORT(index, unused) \
	case UDI_CDC_DATA_EP_OUT_##index: \
		port = index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_OUT_TO_PORT, ~)
80005d66:	30 08       	mov	r8,0
80005d68:	ef 68 ff ff 	st.b	r7[-1],r8
80005d6c:	c0 48       	rjmp	80005d74 <udi_cdc_data_received+0x2c>
#undef UDI_CDC_DATA_EP_OUT_TO_PORT
	default:
		port = 0;
80005d6e:	30 08       	mov	r8,0
80005d70:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
80005d74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005d78:	58 08       	cp.w	r8,0
80005d7a:	c4 61       	brne	80005e06 <udi_cdc_data_received+0xbe>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
80005d7c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005d80:	4a 49       	lddpc	r9,80005e10 <udi_cdc_data_received+0xc8>
80005d82:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005d86:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005d8a:	30 08       	mov	r8,0
80005d8c:	f0 09 18 00 	cp.b	r9,r8
80005d90:	5f 08       	sreq	r8
80005d92:	ef 68 ff fe 	st.b	r7[-2],r8
	if (!n) {
80005d96:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005d9a:	58 08       	cp.w	r8,0
80005d9c:	c1 c1       	brne	80005dd4 <udi_cdc_data_received+0x8c>
		udd_ep_run( ep,
80005d9e:	49 ea       	lddpc	r10,80005e14 <udi_cdc_data_received+0xcc>
80005da0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
80005da4:	12 98       	mov	r8,r9
80005da6:	a3 68       	lsl	r8,0x2
80005da8:	12 08       	add	r8,r9
80005daa:	a7 78       	lsl	r8,0x7
80005dac:	10 9b       	mov	r11,r8
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
	if (!n) {
		udd_ep_run( ep,
80005dae:	ef 39 ff fe 	ld.ub	r9,r7[-2]
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
80005db2:	12 98       	mov	r8,r9
80005db4:	a3 68       	lsl	r8,0x2
80005db6:	12 08       	add	r8,r9
80005db8:	a7 68       	lsl	r8,0x6
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
	if (!n) {
		udd_ep_run( ep,
80005dba:	f6 08 00 08 	add	r8,r11,r8
80005dbe:	10 0a       	add	r10,r8
80005dc0:	ef 3c ff f0 	ld.ub	r12,r7[-16]
80005dc4:	fe c8 00 7c 	sub	r8,pc,124
80005dc8:	e0 69 01 40 	mov	r9,320
80005dcc:	30 1b       	mov	r11,1
80005dce:	f0 1f 00 13 	mcall	80005e18 <udi_cdc_data_received+0xd0>
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
				UDI_CDC_RX_BUFFERS,
				udi_cdc_data_received);
		return;
80005dd2:	c1 b8       	rjmp	80005e08 <udi_cdc_data_received+0xc0>
	}
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
80005dd4:	ef 3b ff ff 	ld.ub	r11,r7[-1]
80005dd8:	ef 3a ff fe 	ld.ub	r10,r7[-2]
80005ddc:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005de0:	5c 88       	casts.h	r8
80005de2:	48 f9       	lddpc	r9,80005e1c <udi_cdc_data_received+0xd4>
80005de4:	a1 7b       	lsl	r11,0x1
80005de6:	f6 0a 00 0a 	add	r10,r11,r10
80005dea:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_rx_trans_ongoing[port] = false;
80005dee:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005df2:	48 ca       	lddpc	r10,80005e20 <udi_cdc_data_received+0xd8>
80005df4:	30 08       	mov	r8,0
80005df6:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_rx_start(port);
80005dfa:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005dfe:	10 9c       	mov	r12,r8
80005e00:	f0 1f 00 09 	mcall	80005e24 <udi_cdc_data_received+0xdc>
80005e04:	c0 28       	rjmp	80005e08 <udi_cdc_data_received+0xc0>
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
		// Abort reception
		return;
80005e06:	d7 03       	nop
		return;
	}
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
	udi_cdc_rx_trans_ongoing[port] = false;
	udi_cdc_rx_start(port);
}
80005e08:	2f cd       	sub	sp,-16
80005e0a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e0e:	00 00       	add	r0,r0
80005e10:	00 00       	add	r0,r0
80005e12:	04 80       	andn	r0,r2
80005e14:	00 00       	add	r0,r0
80005e16:	01 fc       	ld.ub	r12,r0[0x7]
80005e18:	80 00       	ld.sh	r0,r0[0x0]
80005e1a:	3c 38       	mov	r8,-61
80005e1c:	00 00       	add	r0,r0
80005e1e:	04 7c       	tst	r12,r2
80005e20:	00 00       	add	r0,r0
80005e22:	04 88       	andn	r8,r2
80005e24:	80 00       	ld.sh	r0,r0[0x0]
80005e26:	5c 0c       	acr	r12

80005e28 <udi_cdc_data_sent>:


static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
80005e28:	eb cd 40 80 	pushm	r7,lr
80005e2c:	1a 97       	mov	r7,sp
80005e2e:	20 4d       	sub	sp,16
80005e30:	ef 4c ff f8 	st.w	r7[-8],r12
80005e34:	ef 4b ff f4 	st.w	r7[-12],r11
80005e38:	14 98       	mov	r8,r10
80005e3a:	ef 68 ff f0 	st.b	r7[-16],r8
	uint8_t port;
	UNUSED(n);

	switch (ep) {
80005e3e:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80005e42:	e0 48 00 81 	cp.w	r8,129
80005e46:	c0 51       	brne	80005e50 <udi_cdc_data_sent+0x28>
#define UDI_CDC_DATA_EP_IN_TO_PORT(index, unused) \
	case UDI_CDC_DATA_EP_IN_##index: \
		port = index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_IN_TO_PORT, ~)
80005e48:	30 08       	mov	r8,0
80005e4a:	ef 68 ff ff 	st.b	r7[-1],r8
80005e4e:	c0 48       	rjmp	80005e56 <udi_cdc_data_sent+0x2e>
#undef UDI_CDC_DATA_EP_IN_TO_PORT
	default:
		port = 0;
80005e50:	30 08       	mov	r8,0
80005e52:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
80005e56:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e5a:	58 08       	cp.w	r8,0
80005e5c:	c2 61       	brne	80005ea8 <udi_cdc_data_sent+0x80>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[port][(udi_cdc_tx_buf_sel[port]==0)?1:0] = 0;
80005e5e:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005e62:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005e66:	49 39       	lddpc	r9,80005eb0 <udi_cdc_data_sent+0x88>
80005e68:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005e6c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005e70:	30 08       	mov	r8,0
80005e72:	f0 09 18 00 	cp.b	r9,r8
80005e76:	5f 08       	sreq	r8
80005e78:	48 f9       	lddpc	r9,80005eb4 <udi_cdc_data_sent+0x8c>
80005e7a:	a1 7a       	lsl	r10,0x1
80005e7c:	10 0a       	add	r10,r8
80005e7e:	30 08       	mov	r8,0
80005e80:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_tx_both_buf_to_send[port] = false;
80005e84:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005e88:	48 ca       	lddpc	r10,80005eb8 <udi_cdc_data_sent+0x90>
80005e8a:	30 08       	mov	r8,0
80005e8c:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_tx_trans_ongoing[port] = false;
80005e90:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005e94:	48 aa       	lddpc	r10,80005ebc <udi_cdc_data_sent+0x94>
80005e96:	30 08       	mov	r8,0
80005e98:	f4 09 0b 08 	st.b	r10[r9],r8

	if (n != 0) {
		UDI_CDC_TX_EMPTY_NOTIFY(port);
	}
	udi_cdc_tx_send(port);
80005e9c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005ea0:	10 9c       	mov	r12,r8
80005ea2:	f0 1f 00 08 	mcall	80005ec0 <udi_cdc_data_sent+0x98>
80005ea6:	c0 28       	rjmp	80005eaa <udi_cdc_data_sent+0x82>
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
		// Abort transfer
		return;
80005ea8:	d7 03       	nop

	if (n != 0) {
		UDI_CDC_TX_EMPTY_NOTIFY(port);
	}
	udi_cdc_tx_send(port);
}
80005eaa:	2f cd       	sub	sp,-16
80005eac:	e3 cd 80 80 	ldm	sp++,r7,pc
80005eb0:	00 00       	add	r0,r0
80005eb2:	07 10       	ld.sh	r0,r3++
80005eb4:	00 00       	add	r0,r0
80005eb6:	07 0c       	ld.w	r12,r3++
80005eb8:	00 00       	add	r0,r0
80005eba:	07 1c       	ld.sh	r12,r3++
80005ebc:	00 00       	add	r0,r0
80005ebe:	07 18       	ld.sh	r8,r3++
80005ec0:	80 00       	ld.sh	r0,r0[0x0]
80005ec2:	5e c4       	retvs	r4

80005ec4 <udi_cdc_tx_send>:


static void udi_cdc_tx_send(uint8_t port)
{
80005ec4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ec8:	1a 97       	mov	r7,sp
80005eca:	20 3d       	sub	sp,12
80005ecc:	18 98       	mov	r8,r12
80005ece:	ef 68 ff f4 	st.b	r7[-12],r8
	bool b_short_packet;
	udd_ep_id_t ep;
	static uint16_t sof_zlp_counter = 0;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80005ed2:	30 08       	mov	r8,0
80005ed4:	ef 68 ff f4 	st.b	r7[-12],r8
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
80005ed8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005edc:	4f e9       	lddpc	r9,800060d4 <udi_cdc_tx_send+0x210>
80005ede:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005ee2:	5c 58       	castu.b	r8
80005ee4:	e0 81 00 f1 	brne	800060c6 <udi_cdc_tx_send+0x202>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
80005ee8:	f0 1f 00 7c 	mcall	800060d8 <udi_cdc_tx_send+0x214>
80005eec:	18 98       	mov	r8,r12
80005eee:	58 08       	cp.w	r8,0
80005ef0:	c0 e0       	breq	80005f0c <udi_cdc_tx_send+0x48>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
80005ef2:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005ef6:	4f a8       	lddpc	r8,800060dc <udi_cdc_tx_send+0x218>
80005ef8:	f0 09 04 16 	ld.sh	r6,r8[r9<<0x1]
80005efc:	f0 1f 00 79 	mcall	800060e0 <udi_cdc_tx_send+0x21c>
80005f00:	18 98       	mov	r8,r12
80005f02:	5c 88       	casts.h	r8
80005f04:	f0 06 19 00 	cp.h	r6,r8
80005f08:	c0 f1       	brne	80005f26 <udi_cdc_tx_send+0x62>
			return; // Wait next SOF to send next data
80005f0a:	ce 18       	rjmp	800060cc <udi_cdc_tx_send+0x208>
		}
	}else{
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
80005f0c:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005f10:	4f 38       	lddpc	r8,800060dc <udi_cdc_tx_send+0x218>
80005f12:	f0 09 04 16 	ld.sh	r6,r8[r9<<0x1]
80005f16:	f0 1f 00 74 	mcall	800060e4 <udi_cdc_tx_send+0x220>
80005f1a:	18 98       	mov	r8,r12
80005f1c:	5c 88       	casts.h	r8
80005f1e:	f0 06 19 00 	cp.h	r6,r8
80005f22:	e0 80 00 d4 	breq	800060ca <udi_cdc_tx_send+0x206>
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
80005f26:	f0 1f 00 71 	mcall	800060e8 <udi_cdc_tx_send+0x224>
80005f2a:	18 98       	mov	r8,r12
80005f2c:	ef 48 ff f8 	st.w	r7[-8],r8
	buf_sel_trans = udi_cdc_tx_buf_sel[port];
80005f30:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005f34:	4e e9       	lddpc	r9,800060ec <udi_cdc_tx_send+0x228>
80005f36:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005f3a:	ef 68 ff fd 	st.b	r7[-3],r8
	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
80005f3e:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005f42:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80005f46:	4e b8       	lddpc	r8,800060f0 <udi_cdc_tx_send+0x22c>
80005f48:	a1 7a       	lsl	r10,0x1
80005f4a:	f4 09 00 09 	add	r9,r10,r9
80005f4e:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005f52:	58 08       	cp.w	r8,0
80005f54:	c2 71       	brne	80005fa2 <udi_cdc_tx_send+0xde>
		sof_zlp_counter++;
80005f56:	4e 88       	lddpc	r8,800060f4 <udi_cdc_tx_send+0x230>
80005f58:	90 08       	ld.sh	r8,r8[0x0]
80005f5a:	2f f8       	sub	r8,-1
80005f5c:	5c 88       	casts.h	r8
80005f5e:	4e 69       	lddpc	r9,800060f4 <udi_cdc_tx_send+0x230>
80005f60:	b2 08       	st.h	r9[0x0],r8
		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
80005f62:	f0 1f 00 5e 	mcall	800060d8 <udi_cdc_tx_send+0x214>
80005f66:	18 98       	mov	r8,r12
80005f68:	ec 18 00 01 	eorl	r8,0x1
80005f6c:	5c 58       	castu.b	r8
80005f6e:	c0 80       	breq	80005f7e <udi_cdc_tx_send+0xba>
80005f70:	4e 18       	lddpc	r8,800060f4 <udi_cdc_tx_send+0x230>
80005f72:	90 09       	ld.sh	r9,r8[0x0]
80005f74:	36 38       	mov	r8,99
80005f76:	f0 09 19 00 	cp.h	r9,r8
80005f7a:	e0 88 00 0f 	brls	80005f98 <udi_cdc_tx_send+0xd4>
80005f7e:	f0 1f 00 57 	mcall	800060d8 <udi_cdc_tx_send+0x214>
80005f82:	18 98       	mov	r8,r12
80005f84:	58 08       	cp.w	r8,0
80005f86:	c0 e0       	breq	80005fa2 <udi_cdc_tx_send+0xde>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
80005f88:	4d b8       	lddpc	r8,800060f4 <udi_cdc_tx_send+0x230>
80005f8a:	90 09       	ld.sh	r9,r8[0x0]

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel[port];
	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
		sof_zlp_counter++;
		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
80005f8c:	e0 68 03 1f 	mov	r8,799
80005f90:	f0 09 19 00 	cp.h	r9,r8
80005f94:	e0 8b 00 07 	brhi	80005fa2 <udi_cdc_tx_send+0xde>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
			cpu_irq_restore(flags);
80005f98:	ee fc ff f8 	ld.w	r12,r7[-8]
80005f9c:	f0 1f 00 57 	mcall	800060f8 <udi_cdc_tx_send+0x234>
			return;
80005fa0:	c9 68       	rjmp	800060cc <udi_cdc_tx_send+0x208>
		}
	}
	sof_zlp_counter = 0;
80005fa2:	4d 59       	lddpc	r9,800060f4 <udi_cdc_tx_send+0x230>
80005fa4:	30 08       	mov	r8,0
80005fa6:	b2 08       	st.h	r9[0x0],r8

	if (!udi_cdc_tx_both_buf_to_send[port]) {
80005fa8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005fac:	4d 49       	lddpc	r9,800060fc <udi_cdc_tx_send+0x238>
80005fae:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005fb2:	5c 58       	castu.b	r8
80005fb4:	ec 18 00 01 	eorl	r8,0x1
80005fb8:	5c 58       	castu.b	r8
80005fba:	c0 d0       	breq	80005fd4 <udi_cdc_tx_send+0x110>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel[port] = (buf_sel_trans==0)?1:0;
80005fbc:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005fc0:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80005fc4:	30 08       	mov	r8,0
80005fc6:	f0 09 18 00 	cp.b	r9,r8
80005fca:	5f 08       	sreq	r8
80005fcc:	4c 89       	lddpc	r9,800060ec <udi_cdc_tx_send+0x228>
80005fce:	f2 0a 0b 08 	st.b	r9[r10],r8
80005fd2:	c0 98       	rjmp	80005fe4 <udi_cdc_tx_send+0x120>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
80005fd4:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80005fd8:	30 08       	mov	r8,0
80005fda:	f0 09 18 00 	cp.b	r9,r8
80005fde:	5f 08       	sreq	r8
80005fe0:	ef 68 ff fd 	st.b	r7[-3],r8
	}
	udi_cdc_tx_trans_ongoing[port] = true;
80005fe4:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005fe8:	4b ba       	lddpc	r10,800060d4 <udi_cdc_tx_send+0x210>
80005fea:	30 18       	mov	r8,1
80005fec:	f4 09 0b 08 	st.b	r10[r9],r8
	cpu_irq_restore(flags);
80005ff0:	ee fc ff f8 	ld.w	r12,r7[-8]
80005ff4:	f0 1f 00 41 	mcall	800060f8 <udi_cdc_tx_send+0x234>

	b_short_packet = (udi_cdc_tx_buf_nb[port][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
80005ff8:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005ffc:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80006000:	4b c8       	lddpc	r8,800060f0 <udi_cdc_tx_send+0x22c>
80006002:	a1 7a       	lsl	r10,0x1
80006004:	f4 09 00 09 	add	r9,r10,r9
80006008:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
8000600c:	e0 68 01 40 	mov	r8,320
80006010:	f0 09 19 00 	cp.h	r9,r8
80006014:	5f 18       	srne	r8
80006016:	ef 68 ff fe 	st.b	r7[-2],r8
	if (b_short_packet) {
8000601a:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000601e:	30 08       	mov	r8,0
80006020:	f0 09 18 00 	cp.b	r9,r8
80006024:	c1 a0       	breq	80006058 <udi_cdc_tx_send+0x194>
		if (udd_is_high_speed()) {
80006026:	f0 1f 00 2d 	mcall	800060d8 <udi_cdc_tx_send+0x214>
8000602a:	18 98       	mov	r8,r12
8000602c:	58 08       	cp.w	r8,0
8000602e:	c0 b0       	breq	80006044 <udi_cdc_tx_send+0x180>
			udi_cdc_tx_sof_num[port] = udd_get_micro_frame_number();
80006030:	ef 36 ff f4 	ld.ub	r6,r7[-12]
80006034:	f0 1f 00 2b 	mcall	800060e0 <udi_cdc_tx_send+0x21c>
80006038:	18 98       	mov	r8,r12
8000603a:	5c 88       	casts.h	r8
8000603c:	4a 89       	lddpc	r9,800060dc <udi_cdc_tx_send+0x218>
8000603e:	f2 06 0a 18 	st.h	r9[r6<<0x1],r8
80006042:	c1 18       	rjmp	80006064 <udi_cdc_tx_send+0x1a0>
		}else{
			udi_cdc_tx_sof_num[port] = udd_get_frame_number();
80006044:	ef 36 ff f4 	ld.ub	r6,r7[-12]
80006048:	f0 1f 00 27 	mcall	800060e4 <udi_cdc_tx_send+0x220>
8000604c:	18 98       	mov	r8,r12
8000604e:	5c 88       	casts.h	r8
80006050:	4a 39       	lddpc	r9,800060dc <udi_cdc_tx_send+0x218>
80006052:	f2 06 0a 18 	st.h	r9[r6<<0x1],r8
80006056:	c0 78       	rjmp	80006064 <udi_cdc_tx_send+0x1a0>
		}
	}else{
		udi_cdc_tx_sof_num[port] = 0; // Force next transfer without wait SOF
80006058:	ef 3a ff f4 	ld.ub	r10,r7[-12]
8000605c:	4a 09       	lddpc	r9,800060dc <udi_cdc_tx_send+0x218>
8000605e:	30 08       	mov	r8,0
80006060:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	}

	// Send the buffer with enable of short packet
	switch (port) {
80006064:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006068:	58 08       	cp.w	r8,0
8000606a:	c0 51       	brne	80006074 <udi_cdc_tx_send+0x1b0>
#define UDI_CDC_PORT_TO_DATA_EP_IN(index, unused) \
	case index: \
		ep = UDI_CDC_DATA_EP_IN_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_IN, ~)
8000606c:	38 18       	mov	r8,-127
8000606e:	ef 68 ff ff 	st.b	r7[-1],r8
80006072:	c0 48       	rjmp	8000607a <udi_cdc_tx_send+0x1b6>
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
80006074:	38 18       	mov	r8,-127
80006076:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
8000607a:	ef 3a ff f4 	ld.ub	r10,r7[-12]
8000607e:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80006082:	49 c8       	lddpc	r8,800060f0 <udi_cdc_tx_send+0x22c>
80006084:	a1 7a       	lsl	r10,0x1
80006086:	f4 09 00 09 	add	r9,r10,r9
8000608a:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
		break;
	}
	udd_ep_run( ep,
8000608e:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
80006092:	49 ca       	lddpc	r10,80006100 <udi_cdc_tx_send+0x23c>
80006094:	ef 39 ff f4 	ld.ub	r9,r7[-12]
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
80006098:	12 98       	mov	r8,r9
8000609a:	a3 68       	lsl	r8,0x2
8000609c:	12 08       	add	r8,r9
8000609e:	a7 78       	lsl	r8,0x7
800060a0:	10 9b       	mov	r11,r8
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
		break;
	}
	udd_ep_run( ep,
800060a2:	ef 39 ff fd 	ld.ub	r9,r7[-3]
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
800060a6:	12 98       	mov	r8,r9
800060a8:	a3 68       	lsl	r8,0x2
800060aa:	12 08       	add	r8,r9
800060ac:	a7 68       	lsl	r8,0x6
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
		break;
	}
	udd_ep_run( ep,
800060ae:	f6 08 00 08 	add	r8,r11,r8
800060b2:	10 0a       	add	r10,r8
800060b4:	ef 3b ff fe 	ld.ub	r11,r7[-2]
800060b8:	ef 3c ff ff 	ld.ub	r12,r7[-1]
800060bc:	49 28       	lddpc	r8,80006104 <udi_cdc_tx_send+0x240>
800060be:	1c 99       	mov	r9,lr
800060c0:	f0 1f 00 12 	mcall	80006108 <udi_cdc_tx_send+0x244>
800060c4:	c0 48       	rjmp	800060cc <udi_cdc_tx_send+0x208>
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
		return; // Already on going or wait next SOF to send next data
800060c6:	d7 03       	nop
800060c8:	c0 28       	rjmp	800060cc <udi_cdc_tx_send+0x208>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
			return; // Wait next SOF to send next data
800060ca:	d7 03       	nop
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
			udi_cdc_data_sent);
}
800060cc:	2f dd       	sub	sp,-12
800060ce:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
800060d2:	00 00       	add	r0,r0
800060d4:	00 00       	add	r0,r0
800060d6:	07 18       	ld.sh	r8,r3++
800060d8:	80 00       	ld.sh	r0,r0[0x0]
800060da:	34 f4       	mov	r4,79
800060dc:	00 00       	add	r0,r0
800060de:	07 14       	ld.sh	r4,r3++
800060e0:	80 00       	ld.sh	r0,r0[0x0]
800060e2:	35 82       	mov	r2,88
800060e4:	80 00       	ld.sh	r0,r0[0x0]
800060e6:	35 68       	mov	r8,86
800060e8:	80 00       	ld.sh	r0,r0[0x0]
800060ea:	54 7c       	stdsp	sp[0x11c],r12
800060ec:	00 00       	add	r0,r0
800060ee:	07 10       	ld.sh	r0,r3++
800060f0:	00 00       	add	r0,r0
800060f2:	07 0c       	ld.w	r12,r3++
800060f4:	00 00       	add	r0,r0
800060f6:	07 20       	ld.uh	r0,r3++
800060f8:	80 00       	ld.sh	r0,r0[0x0]
800060fa:	54 bc       	stdsp	sp[0x12c],r12
800060fc:	00 00       	add	r0,r0
800060fe:	07 1c       	ld.sh	r12,r3++
80006100:	00 00       	add	r0,r0
80006102:	04 8c       	andn	r12,r2
80006104:	80 00       	ld.sh	r0,r0[0x0]
80006106:	5e 28       	reths	r8
80006108:	80 00       	ld.sh	r0,r0[0x0]
8000610a:	3c 38       	mov	r8,-61

8000610c <udi_cdc_signal_framing_error>:
{
	udi_cdc_ctrl_state_change(0, b_set, CDC_SERIAL_STATE_DSR);
}

void udi_cdc_signal_framing_error(void)
{
8000610c:	eb cd 40 80 	pushm	r7,lr
80006110:	1a 97       	mov	r7,sp
	udi_cdc_ctrl_state_change(0, true, CDC_SERIAL_STATE_FRAMING);
80006112:	e0 6a 10 00 	mov	r10,4096
80006116:	30 1b       	mov	r11,1
80006118:	30 0c       	mov	r12,0
8000611a:	f0 1f 00 03 	mcall	80006124 <udi_cdc_signal_framing_error+0x18>
}
8000611e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006122:	00 00       	add	r0,r0
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	59 cc       	cp.w	r12,28

80006128 <udi_cdc_multi_get_nb_received_data>:
{
	udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_STATE_OVERRUN);
}

iram_size_t udi_cdc_multi_get_nb_received_data(uint8_t port)
{
80006128:	eb cd 40 80 	pushm	r7,lr
8000612c:	1a 97       	mov	r7,sp
8000612e:	20 4d       	sub	sp,16
80006130:	18 98       	mov	r8,r12
80006132:	ef 68 ff f0 	st.b	r7[-16],r8
	irqflags_t flags;
	uint16_t pos;
	iram_size_t nb_received;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80006136:	30 08       	mov	r8,0
80006138:	ef 68 ff f0 	st.b	r7[-16],r8
#endif
	flags = cpu_irq_save();
8000613c:	f0 1f 00 17 	mcall	80006198 <udi_cdc_multi_get_nb_received_data+0x70>
80006140:	18 98       	mov	r8,r12
80006142:	ef 48 ff f4 	st.w	r7[-12],r8
	pos = udi_cdc_rx_pos[port];
80006146:	ef 39 ff f0 	ld.ub	r9,r7[-16]
8000614a:	49 58       	lddpc	r8,8000619c <udi_cdc_multi_get_nb_received_data+0x74>
8000614c:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006150:	ef 58 ff fa 	st.h	r7[-6],r8
	nb_received = udi_cdc_rx_buf_nb[port][udi_cdc_rx_buf_sel[port]] - pos;
80006154:	ef 3a ff f0 	ld.ub	r10,r7[-16]
80006158:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000615c:	49 19       	lddpc	r9,800061a0 <udi_cdc_multi_get_nb_received_data+0x78>
8000615e:	f2 08 07 08 	ld.ub	r8,r9[r8]
80006162:	5c 58       	castu.b	r8
80006164:	10 99       	mov	r9,r8
80006166:	49 08       	lddpc	r8,800061a4 <udi_cdc_multi_get_nb_received_data+0x7c>
80006168:	a1 7a       	lsl	r10,0x1
8000616a:	f4 09 00 09 	add	r9,r10,r9
8000616e:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006172:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80006176:	ef 18 ff fa 	ld.uh	r8,r7[-6]
8000617a:	f2 08 01 08 	sub	r8,r9,r8
8000617e:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_restore(flags);
80006182:	ee fc ff f4 	ld.w	r12,r7[-12]
80006186:	f0 1f 00 09 	mcall	800061a8 <udi_cdc_multi_get_nb_received_data+0x80>
	return nb_received;
8000618a:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000618e:	10 9c       	mov	r12,r8
80006190:	2f cd       	sub	sp,-16
80006192:	e3 cd 80 80 	ldm	sp++,r7,pc
80006196:	00 00       	add	r0,r0
80006198:	80 00       	ld.sh	r0,r0[0x0]
8000619a:	54 7c       	stdsp	sp[0x11c],r12
8000619c:	00 00       	add	r0,r0
8000619e:	04 84       	andn	r4,r2
800061a0:	00 00       	add	r0,r0
800061a2:	04 80       	andn	r0,r2
800061a4:	00 00       	add	r0,r0
800061a6:	04 7c       	tst	r12,r2
800061a8:	80 00       	ld.sh	r0,r0[0x0]
800061aa:	54 bc       	stdsp	sp[0x12c],r12

800061ac <udi_cdc_multi_is_rx_ready>:
{
	return udi_cdc_multi_get_nb_received_data(0);
}

bool udi_cdc_multi_is_rx_ready(uint8_t port)
{
800061ac:	eb cd 40 80 	pushm	r7,lr
800061b0:	1a 97       	mov	r7,sp
800061b2:	20 1d       	sub	sp,4
800061b4:	18 98       	mov	r8,r12
800061b6:	ef 68 ff fc 	st.b	r7[-4],r8
	return (udi_cdc_multi_get_nb_received_data(port) > 0);
800061ba:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800061be:	10 9c       	mov	r12,r8
800061c0:	f0 1f 00 05 	mcall	800061d4 <udi_cdc_multi_is_rx_ready+0x28>
800061c4:	18 98       	mov	r8,r12
800061c6:	58 08       	cp.w	r8,0
800061c8:	5f 18       	srne	r8
800061ca:	5c 58       	castu.b	r8
}
800061cc:	10 9c       	mov	r12,r8
800061ce:	2f fd       	sub	sp,-4
800061d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800061d4:	80 00       	ld.sh	r0,r0[0x0]
800061d6:	61 28       	ld.w	r8,r0[0x48]

800061d8 <udi_cdc_is_rx_ready>:

bool udi_cdc_is_rx_ready(void)
{
800061d8:	eb cd 40 80 	pushm	r7,lr
800061dc:	1a 97       	mov	r7,sp
	return udi_cdc_multi_is_rx_ready(0);
800061de:	30 0c       	mov	r12,0
800061e0:	f0 1f 00 03 	mcall	800061ec <udi_cdc_is_rx_ready+0x14>
800061e4:	18 98       	mov	r8,r12
}
800061e6:	10 9c       	mov	r12,r8
800061e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	61 ac       	ld.w	r12,r0[0x68]

800061f0 <udi_cdc_multi_read_buf>:
{
	return udi_cdc_multi_getc(0);
}

iram_size_t udi_cdc_multi_read_buf(uint8_t port, void* buf, iram_size_t size)
{
800061f0:	eb cd 40 80 	pushm	r7,lr
800061f4:	1a 97       	mov	r7,sp
800061f6:	20 7d       	sub	sp,28
800061f8:	18 98       	mov	r8,r12
800061fa:	ef 4b ff e8 	st.w	r7[-24],r11
800061fe:	ef 4a ff e4 	st.w	r7[-28],r10
80006202:	ef 68 ff ec 	st.b	r7[-20],r8
	irqflags_t flags;
	uint8_t *ptr_buf = (uint8_t *)buf;
80006206:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000620a:	ef 48 ff f4 	st.w	r7[-12],r8
	iram_size_t copy_nb;
	uint16_t pos;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
8000620e:	30 08       	mov	r8,0
80006210:	ef 68 ff ec 	st.b	r7[-20],r8
80006214:	c0 48       	rjmp	8000621c <udi_cdc_multi_read_buf+0x2c>
	cpu_irq_restore(flags);
	while (pos >= udi_cdc_rx_buf_nb[port][buf_sel]) {
		if (!udi_cdc_data_running) {
			return size;
		}
		goto udi_cdc_read_buf_loop_wait;
80006216:	d7 03       	nop
80006218:	c0 28       	rjmp	8000621c <udi_cdc_multi_read_buf+0x2c>
	ptr_buf += copy_nb;
	size -= copy_nb;
	udi_cdc_rx_start(port);

	if (size) {
		goto udi_cdc_read_buf_loop_wait;
8000621a:	d7 03       	nop
	port = 0;
#endif

udi_cdc_read_buf_loop_wait:
	// Check available data
	flags = cpu_irq_save();
8000621c:	f0 1f 00 4d 	mcall	80006350 <udi_cdc_multi_read_buf+0x160>
80006220:	18 98       	mov	r8,r12
80006222:	ef 48 ff f0 	st.w	r7[-16],r8
	pos = udi_cdc_rx_pos[port];
80006226:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000622a:	4c b8       	lddpc	r8,80006354 <udi_cdc_multi_read_buf+0x164>
8000622c:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006230:	ef 58 ff fc 	st.h	r7[-4],r8
	buf_sel = udi_cdc_rx_buf_sel[port];
80006234:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80006238:	4c 89       	lddpc	r9,80006358 <udi_cdc_multi_read_buf+0x168>
8000623a:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000623e:	ef 68 ff ff 	st.b	r7[-1],r8
	cpu_irq_restore(flags);
80006242:	ee fc ff f0 	ld.w	r12,r7[-16]
80006246:	f0 1f 00 46 	mcall	8000635c <udi_cdc_multi_read_buf+0x16c>
	while (pos >= udi_cdc_rx_buf_nb[port][buf_sel]) {
8000624a:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000624e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006252:	4c 48       	lddpc	r8,80006360 <udi_cdc_multi_read_buf+0x170>
80006254:	a1 7a       	lsl	r10,0x1
80006256:	f4 09 00 09 	add	r9,r10,r9
8000625a:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000625e:	ef 09 ff fc 	ld.sh	r9,r7[-4]
80006262:	f0 09 19 00 	cp.h	r9,r8
80006266:	c0 b3       	brcs	8000627c <udi_cdc_multi_read_buf+0x8c>
		if (!udi_cdc_data_running) {
80006268:	4b f8       	lddpc	r8,80006364 <udi_cdc_multi_read_buf+0x174>
8000626a:	11 88       	ld.ub	r8,r8[0x0]
8000626c:	5c 58       	castu.b	r8
8000626e:	ec 18 00 01 	eorl	r8,0x1
80006272:	5c 58       	castu.b	r8
80006274:	cd 10       	breq	80006216 <udi_cdc_multi_read_buf+0x26>
			return size;
80006276:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000627a:	c6 78       	rjmp	80006348 <udi_cdc_multi_read_buf+0x158>
		}
		goto udi_cdc_read_buf_loop_wait;
	}

	// Read data
	copy_nb = udi_cdc_rx_buf_nb[port][buf_sel] - pos;
8000627c:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80006280:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006284:	4b 78       	lddpc	r8,80006360 <udi_cdc_multi_read_buf+0x170>
80006286:	a1 7a       	lsl	r10,0x1
80006288:	f4 09 00 09 	add	r9,r10,r9
8000628c:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006290:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80006294:	ef 18 ff fc 	ld.uh	r8,r7[-4]
80006298:	f2 08 01 08 	sub	r8,r9,r8
8000629c:	ef 48 ff f8 	st.w	r7[-8],r8
	if (copy_nb>size) {
800062a0:	ee f9 ff f8 	ld.w	r9,r7[-8]
800062a4:	ee f8 ff e4 	ld.w	r8,r7[-28]
800062a8:	10 39       	cp.w	r9,r8
800062aa:	e0 88 00 06 	brls	800062b6 <udi_cdc_multi_read_buf+0xc6>
		copy_nb = size;
800062ae:	ee f8 ff e4 	ld.w	r8,r7[-28]
800062b2:	ef 48 ff f8 	st.w	r7[-8],r8
	}
	memcpy(ptr_buf, &udi_cdc_rx_buf[port][buf_sel][pos], copy_nb);
800062b6:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800062ba:	12 98       	mov	r8,r9
800062bc:	a3 68       	lsl	r8,0x2
800062be:	12 08       	add	r8,r9
800062c0:	a7 78       	lsl	r8,0x7
800062c2:	10 9a       	mov	r10,r8
800062c4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800062c8:	12 98       	mov	r8,r9
800062ca:	a3 68       	lsl	r8,0x2
800062cc:	12 08       	add	r8,r9
800062ce:	a7 68       	lsl	r8,0x6
800062d0:	f4 08 00 09 	add	r9,r10,r8
800062d4:	ef 18 ff fc 	ld.uh	r8,r7[-4]
800062d8:	10 09       	add	r9,r8
800062da:	4a 48       	lddpc	r8,80006368 <udi_cdc_multi_read_buf+0x178>
800062dc:	f2 08 00 08 	add	r8,r9,r8
800062e0:	ee fa ff f8 	ld.w	r10,r7[-8]
800062e4:	10 9b       	mov	r11,r8
800062e6:	ee fc ff f4 	ld.w	r12,r7[-12]
800062ea:	f0 1f 00 21 	mcall	8000636c <udi_cdc_multi_read_buf+0x17c>
	udi_cdc_rx_pos[port] += copy_nb;
800062ee:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800062f2:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800062f6:	49 88       	lddpc	r8,80006354 <udi_cdc_multi_read_buf+0x164>
800062f8:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800062fc:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80006300:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006304:	5c 88       	casts.h	r8
80006306:	f2 08 00 08 	add	r8,r9,r8
8000630a:	5c 88       	casts.h	r8
8000630c:	49 29       	lddpc	r9,80006354 <udi_cdc_multi_read_buf+0x164>
8000630e:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	ptr_buf += copy_nb;
80006312:	ee f9 ff f4 	ld.w	r9,r7[-12]
80006316:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000631a:	f2 08 00 08 	add	r8,r9,r8
8000631e:	ef 48 ff f4 	st.w	r7[-12],r8
	size -= copy_nb;
80006322:	ee f9 ff e4 	ld.w	r9,r7[-28]
80006326:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000632a:	f2 08 01 08 	sub	r8,r9,r8
8000632e:	ef 48 ff e4 	st.w	r7[-28],r8
	udi_cdc_rx_start(port);
80006332:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80006336:	10 9c       	mov	r12,r8
80006338:	f0 1f 00 0e 	mcall	80006370 <udi_cdc_multi_read_buf+0x180>

	if (size) {
8000633c:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006340:	58 08       	cp.w	r8,0
80006342:	fe 91 ff 6c 	brne	8000621a <udi_cdc_multi_read_buf+0x2a>
		goto udi_cdc_read_buf_loop_wait;
	}
	return 0;
80006346:	30 08       	mov	r8,0
}
80006348:	10 9c       	mov	r12,r8
8000634a:	2f 9d       	sub	sp,-28
8000634c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006350:	80 00       	ld.sh	r0,r0[0x0]
80006352:	54 7c       	stdsp	sp[0x11c],r12
80006354:	00 00       	add	r0,r0
80006356:	04 84       	andn	r4,r2
80006358:	00 00       	add	r0,r0
8000635a:	04 80       	andn	r0,r2
8000635c:	80 00       	ld.sh	r0,r0[0x0]
8000635e:	54 bc       	stdsp	sp[0x12c],r12
80006360:	00 00       	add	r0,r0
80006362:	04 7c       	tst	r12,r2
80006364:	00 00       	add	r0,r0
80006366:	01 fa       	ld.ub	r10,r0[0x7]
80006368:	00 00       	add	r0,r0
8000636a:	01 fc       	ld.ub	r12,r0[0x7]
8000636c:	80 00       	ld.sh	r0,r0[0x0]
8000636e:	8c 08       	ld.sh	r8,r6[0x0]
80006370:	80 00       	ld.sh	r0,r0[0x0]
80006372:	5c 0c       	acr	r12

80006374 <udi_cdc_read_buf>:

iram_size_t udi_cdc_read_buf(void* buf, iram_size_t size)
{
80006374:	eb cd 40 80 	pushm	r7,lr
80006378:	1a 97       	mov	r7,sp
8000637a:	20 2d       	sub	sp,8
8000637c:	ef 4c ff fc 	st.w	r7[-4],r12
80006380:	ef 4b ff f8 	st.w	r7[-8],r11
	return udi_cdc_multi_read_buf(0, buf, size);
80006384:	ee fa ff f8 	ld.w	r10,r7[-8]
80006388:	ee fb ff fc 	ld.w	r11,r7[-4]
8000638c:	30 0c       	mov	r12,0
8000638e:	f0 1f 00 04 	mcall	8000639c <udi_cdc_read_buf+0x28>
80006392:	18 98       	mov	r8,r12
}
80006394:	10 9c       	mov	r12,r8
80006396:	2f ed       	sub	sp,-8
80006398:	e3 cd 80 80 	ldm	sp++,r7,pc
8000639c:	80 00       	ld.sh	r0,r0[0x0]
8000639e:	61 f0       	ld.w	r0,r0[0x7c]

800063a0 <udi_cdc_multi_get_free_tx_buffer>:

iram_size_t udi_cdc_multi_get_free_tx_buffer(uint8_t port)
{
800063a0:	eb cd 40 80 	pushm	r7,lr
800063a4:	1a 97       	mov	r7,sp
800063a6:	20 5d       	sub	sp,20
800063a8:	18 98       	mov	r8,r12
800063aa:	ef 68 ff ec 	st.b	r7[-20],r8
	irqflags_t flags;
	iram_size_t buf_sel_nb, buf_nosel_nb;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
800063ae:	30 08       	mov	r8,0
800063b0:	ef 68 ff ec 	st.b	r7[-20],r8
#endif

	flags = cpu_irq_save();
800063b4:	f0 1f 00 37 	mcall	80006490 <udi_cdc_multi_get_free_tx_buffer+0xf0>
800063b8:	18 98       	mov	r8,r12
800063ba:	ef 48 ff f0 	st.w	r7[-16],r8
	buf_sel = udi_cdc_tx_buf_sel[port];
800063be:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800063c2:	4b 59       	lddpc	r9,80006494 <udi_cdc_multi_get_free_tx_buffer+0xf4>
800063c4:	f2 08 07 08 	ld.ub	r8,r9[r8]
800063c8:	ef 68 ff ff 	st.b	r7[-1],r8
	buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
800063cc:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800063d0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800063d4:	4b 18       	lddpc	r8,80006498 <udi_cdc_multi_get_free_tx_buffer+0xf8>
800063d6:	a1 7a       	lsl	r10,0x1
800063d8:	f4 09 00 09 	add	r9,r10,r9
800063dc:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800063e0:	5c 78       	castu.h	r8
800063e2:	ef 48 ff f4 	st.w	r7[-12],r8
	buf_nosel_nb = udi_cdc_tx_buf_nb[port][(buf_sel == 0)? 1 : 0];
800063e6:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800063ea:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800063ee:	30 08       	mov	r8,0
800063f0:	f0 09 18 00 	cp.b	r9,r8
800063f4:	5f 09       	sreq	r9
800063f6:	4a 98       	lddpc	r8,80006498 <udi_cdc_multi_get_free_tx_buffer+0xf8>
800063f8:	a1 7a       	lsl	r10,0x1
800063fa:	f4 09 00 09 	add	r9,r10,r9
800063fe:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006402:	5c 78       	castu.h	r8
80006404:	ef 48 ff f8 	st.w	r7[-8],r8
	if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
80006408:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000640c:	e0 48 01 40 	cp.w	r8,320
80006410:	c2 d1       	brne	8000646a <udi_cdc_multi_get_free_tx_buffer+0xca>
		if ((!udi_cdc_tx_trans_ongoing[port])
80006412:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80006416:	4a 29       	lddpc	r9,8000649c <udi_cdc_multi_get_free_tx_buffer+0xfc>
80006418:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000641c:	5c 58       	castu.b	r8
8000641e:	ec 18 00 01 	eorl	r8,0x1
80006422:	5c 58       	castu.b	r8
80006424:	c2 30       	breq	8000646a <udi_cdc_multi_get_free_tx_buffer+0xca>
80006426:	ef 38 ff ec 	ld.ub	r8,r7[-20]
			&& (!udi_cdc_tx_both_buf_to_send[port])) {
8000642a:	49 e9       	lddpc	r9,800064a0 <udi_cdc_multi_get_free_tx_buffer+0x100>
8000642c:	f2 08 07 08 	ld.ub	r8,r9[r8]
80006430:	5c 58       	castu.b	r8
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel[port];
	buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
	buf_nosel_nb = udi_cdc_tx_buf_nb[port][(buf_sel == 0)? 1 : 0];
	if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
		if ((!udi_cdc_tx_trans_ongoing[port])
80006432:	ec 18 00 01 	eorl	r8,0x1
80006436:	5c 58       	castu.b	r8
80006438:	c1 90       	breq	8000646a <udi_cdc_multi_get_free_tx_buffer+0xca>
			&& (!udi_cdc_tx_both_buf_to_send[port])) {
			/* One buffer is full, but the other buffer is not used.
			 * (not used = transfer on-going)
			 * then move to the other buffer to store data */
			udi_cdc_tx_both_buf_to_send[port] = true;
8000643a:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000643e:	49 9a       	lddpc	r10,800064a0 <udi_cdc_multi_get_free_tx_buffer+0x100>
80006440:	30 18       	mov	r8,1
80006442:	f4 09 0b 08 	st.b	r10[r9],r8
			udi_cdc_tx_buf_sel[port] = (buf_sel == 0)? 1 : 0;
80006446:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000644a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000644e:	30 08       	mov	r8,0
80006450:	f0 09 18 00 	cp.b	r9,r8
80006454:	5f 08       	sreq	r8
80006456:	49 09       	lddpc	r9,80006494 <udi_cdc_multi_get_free_tx_buffer+0xf4>
80006458:	f2 0a 0b 08 	st.b	r9[r10],r8
			buf_sel_nb = 0;
8000645c:	30 08       	mov	r8,0
8000645e:	ef 48 ff f4 	st.w	r7[-12],r8
			buf_nosel_nb = UDI_CDC_TX_BUFFERS;
80006462:	e0 68 01 40 	mov	r8,320
80006466:	ef 48 ff f8 	st.w	r7[-8],r8
		}
	}
	cpu_irq_restore(flags);
8000646a:	ee fc ff f0 	ld.w	r12,r7[-16]
8000646e:	f0 1f 00 0e 	mcall	800064a4 <udi_cdc_multi_get_free_tx_buffer+0x104>

	return (UDI_CDC_TX_BUFFERS - buf_sel_nb) + (UDI_CDC_TX_BUFFERS - buf_nosel_nb);
80006472:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006476:	f0 09 11 00 	rsub	r9,r8,0
8000647a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000647e:	f2 08 01 08 	sub	r8,r9,r8
80006482:	f0 c8 fd 80 	sub	r8,r8,-640
}
80006486:	10 9c       	mov	r12,r8
80006488:	2f bd       	sub	sp,-20
8000648a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000648e:	00 00       	add	r0,r0
80006490:	80 00       	ld.sh	r0,r0[0x0]
80006492:	54 7c       	stdsp	sp[0x11c],r12
80006494:	00 00       	add	r0,r0
80006496:	07 10       	ld.sh	r0,r3++
80006498:	00 00       	add	r0,r0
8000649a:	07 0c       	ld.w	r12,r3++
8000649c:	00 00       	add	r0,r0
8000649e:	07 18       	ld.sh	r8,r3++
800064a0:	00 00       	add	r0,r0
800064a2:	07 1c       	ld.sh	r12,r3++
800064a4:	80 00       	ld.sh	r0,r0[0x0]
800064a6:	54 bc       	stdsp	sp[0x12c],r12

800064a8 <udi_cdc_multi_is_tx_ready>:
{
	return udi_cdc_multi_get_free_tx_buffer(0);
}

bool udi_cdc_multi_is_tx_ready(uint8_t port)
{
800064a8:	eb cd 40 80 	pushm	r7,lr
800064ac:	1a 97       	mov	r7,sp
800064ae:	20 1d       	sub	sp,4
800064b0:	18 98       	mov	r8,r12
800064b2:	ef 68 ff fc 	st.b	r7[-4],r8
	return (udi_cdc_multi_get_free_tx_buffer(port) != 0);
800064b6:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800064ba:	10 9c       	mov	r12,r8
800064bc:	f0 1f 00 05 	mcall	800064d0 <udi_cdc_multi_is_tx_ready+0x28>
800064c0:	18 98       	mov	r8,r12
800064c2:	58 08       	cp.w	r8,0
800064c4:	5f 18       	srne	r8
800064c6:	5c 58       	castu.b	r8
}
800064c8:	10 9c       	mov	r12,r8
800064ca:	2f fd       	sub	sp,-4
800064cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800064d0:	80 00       	ld.sh	r0,r0[0x0]
800064d2:	63 a0       	ld.w	r0,r1[0x68]

800064d4 <udi_cdc_multi_putc>:
{
	return udi_cdc_multi_is_tx_ready(0);
}

int udi_cdc_multi_putc(uint8_t port, int value)
{
800064d4:	eb cd 40 e8 	pushm	r3,r5-r7,lr
800064d8:	1a 97       	mov	r7,sp
800064da:	20 4d       	sub	sp,16
800064dc:	18 98       	mov	r8,r12
800064de:	ef 4b ff f0 	st.w	r7[-16],r11
800064e2:	ef 68 ff f4 	st.b	r7[-12],r8
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
800064e6:	30 08       	mov	r8,0
800064e8:	ef 68 ff f4 	st.b	r7[-12],r8
#endif

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
800064ec:	ef 39 ff f4 	ld.ub	r9,r7[-12]
800064f0:	4b ca       	lddpc	r10,800065e0 <udi_cdc_multi_putc+0x10c>
800064f2:	12 98       	mov	r8,r9
800064f4:	a3 78       	lsl	r8,0x3
800064f6:	12 18       	sub	r8,r9
800064f8:	f4 08 00 08 	add	r8,r10,r8
800064fc:	2f a8       	sub	r8,-6
800064fe:	11 89       	ld.ub	r9,r8[0x0]
80006500:	30 98       	mov	r8,9
80006502:	f0 09 18 00 	cp.b	r9,r8
80006506:	5f 08       	sreq	r8
80006508:	ef 68 ff fe 	st.b	r7[-2],r8
8000650c:	c0 28       	rjmp	80006510 <udi_cdc_multi_putc+0x3c>
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
		if (!udi_cdc_data_running) {
			return false;
		}
		goto udi_cdc_putc_process_one_byte;
8000650e:	d7 03       	nop

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);

udi_cdc_putc_process_one_byte:
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
80006510:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006514:	10 9c       	mov	r12,r8
80006516:	f0 1f 00 34 	mcall	800065e4 <udi_cdc_multi_putc+0x110>
8000651a:	18 98       	mov	r8,r12
8000651c:	ec 18 00 01 	eorl	r8,0x1
80006520:	5c 58       	castu.b	r8
80006522:	c0 a0       	breq	80006536 <udi_cdc_multi_putc+0x62>
		if (!udi_cdc_data_running) {
80006524:	4b 18       	lddpc	r8,800065e8 <udi_cdc_multi_putc+0x114>
80006526:	11 88       	ld.ub	r8,r8[0x0]
80006528:	5c 58       	castu.b	r8
8000652a:	ec 18 00 01 	eorl	r8,0x1
8000652e:	5c 58       	castu.b	r8
80006530:	ce f0       	breq	8000650e <udi_cdc_multi_putc+0x3a>
			return false;
80006532:	30 08       	mov	r8,0
80006534:	c5 18       	rjmp	800065d6 <udi_cdc_multi_putc+0x102>
		}
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
80006536:	f0 1f 00 2e 	mcall	800065ec <udi_cdc_multi_putc+0x118>
8000653a:	18 98       	mov	r8,r12
8000653c:	ef 48 ff f8 	st.w	r7[-8],r8
	buf_sel = udi_cdc_tx_buf_sel[port];
80006540:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006544:	4a b9       	lddpc	r9,800065f0 <udi_cdc_multi_putc+0x11c>
80006546:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000654a:	ef 68 ff ff 	st.b	r7[-1],r8
	udi_cdc_tx_buf[port][buf_sel][udi_cdc_tx_buf_nb[port][buf_sel]++] = value;
8000654e:	ef 3e ff f4 	ld.ub	lr,r7[-12]
80006552:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006556:	ef 3c ff f4 	ld.ub	r12,r7[-12]
8000655a:	ef 3b ff ff 	ld.ub	r11,r7[-1]
8000655e:	4a 69       	lddpc	r9,800065f4 <udi_cdc_multi_putc+0x120>
80006560:	f8 0a 15 01 	lsl	r10,r12,0x1
80006564:	16 0a       	add	r10,r11
80006566:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
8000656a:	eb da c0 10 	bfextu	r5,r10,0x0,0x10
8000656e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80006572:	ed d9 c0 08 	bfextu	r6,r9,0x0,0x8
80006576:	4a 13       	lddpc	r3,800065f8 <udi_cdc_multi_putc+0x124>
80006578:	10 99       	mov	r9,r8
8000657a:	a3 69       	lsl	r9,0x2
8000657c:	10 09       	add	r9,r8
8000657e:	f2 08 15 06 	lsl	r8,r9,0x6
80006582:	10 99       	mov	r9,r8
80006584:	1c 98       	mov	r8,lr
80006586:	a3 68       	lsl	r8,0x2
80006588:	1c 08       	add	r8,lr
8000658a:	a7 78       	lsl	r8,0x7
8000658c:	f2 08 00 08 	add	r8,r9,r8
80006590:	e6 08 00 08 	add	r8,r3,r8
80006594:	f0 05 00 09 	add	r9,r8,r5
80006598:	0c 98       	mov	r8,r6
8000659a:	b2 88       	st.b	r9[0x0],r8
8000659c:	f4 c8 ff ff 	sub	r8,r10,-1
800065a0:	5c 88       	casts.h	r8
800065a2:	49 59       	lddpc	r9,800065f4 <udi_cdc_multi_putc+0x120>
800065a4:	f8 0a 15 01 	lsl	r10,r12,0x1
800065a8:	16 0a       	add	r10,r11
800065aa:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	cpu_irq_restore(flags);
800065ae:	ee fc ff f8 	ld.w	r12,r7[-8]
800065b2:	f0 1f 00 13 	mcall	800065fc <udi_cdc_multi_putc+0x128>

	if (b_databit_9) {
800065b6:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800065ba:	30 08       	mov	r8,0
800065bc:	f0 09 18 00 	cp.b	r9,r8
800065c0:	c0 a0       	breq	800065d4 <udi_cdc_multi_putc+0x100>
		// Send MSB
		b_databit_9 = false;
800065c2:	30 08       	mov	r8,0
800065c4:	ef 68 ff fe 	st.b	r7[-2],r8
		value = value >> 8;
800065c8:	ee f8 ff f0 	ld.w	r8,r7[-16]
800065cc:	a9 48       	asr	r8,0x8
800065ce:	ef 48 ff f0 	st.w	r7[-16],r8
		goto udi_cdc_putc_process_one_byte;
800065d2:	c9 fb       	rjmp	80006510 <udi_cdc_multi_putc+0x3c>
	}
	return true;
800065d4:	30 18       	mov	r8,1
}
800065d6:	10 9c       	mov	r12,r8
800065d8:	2f cd       	sub	sp,-16
800065da:	e3 cd 80 e8 	ldm	sp++,r3,r5-r7,pc
800065de:	00 00       	add	r0,r0
800065e0:	00 00       	add	r0,r0
800065e2:	01 da       	ld.ub	r10,r0[0x5]
800065e4:	80 00       	ld.sh	r0,r0[0x0]
800065e6:	64 a8       	ld.w	r8,r2[0x28]
800065e8:	00 00       	add	r0,r0
800065ea:	01 fa       	ld.ub	r10,r0[0x7]
800065ec:	80 00       	ld.sh	r0,r0[0x0]
800065ee:	54 7c       	stdsp	sp[0x11c],r12
800065f0:	00 00       	add	r0,r0
800065f2:	07 10       	ld.sh	r0,r3++
800065f4:	00 00       	add	r0,r0
800065f6:	07 0c       	ld.w	r12,r3++
800065f8:	00 00       	add	r0,r0
800065fa:	04 8c       	andn	r12,r2
800065fc:	80 00       	ld.sh	r0,r0[0x0]
800065fe:	54 bc       	stdsp	sp[0x12c],r12

80006600 <udi_cdc_putc>:

int udi_cdc_putc(int value)
{
80006600:	eb cd 40 80 	pushm	r7,lr
80006604:	1a 97       	mov	r7,sp
80006606:	20 1d       	sub	sp,4
80006608:	ef 4c ff fc 	st.w	r7[-4],r12
	return udi_cdc_multi_putc(0, value);
8000660c:	ee fb ff fc 	ld.w	r11,r7[-4]
80006610:	30 0c       	mov	r12,0
80006612:	f0 1f 00 04 	mcall	80006620 <udi_cdc_putc+0x20>
80006616:	18 98       	mov	r8,r12
}
80006618:	10 9c       	mov	r12,r8
8000661a:	2f fd       	sub	sp,-4
8000661c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006620:	80 00       	ld.sh	r0,r0[0x0]
80006622:	64 d4       	ld.w	r4,r2[0x34]
80006624:	54 41       	stdsp	sp[0x110],r1
80006626:	4a 33       	lddpc	r3,800066b0 <udc_next_desc_in_iface+0x34>
80006628:	38 35       	mov	r5,-125
8000662a:	30 5f       	mov	pc,5
8000662c:	30 78       	mov	r8,7
8000662e:	30 30       	mov	r0,3
80006630:	00 00       	add	r0,r0
	...

80006634 <udc_get_string_serial_name>:
	}
#  define USB_DEVICE_SERIAL_NAME_SIZE \
	USB_DEVICE_GET_SERIAL_NAME_LENGTH
#elif defined USB_DEVICE_SERIAL_NAME
	static const uint8_t *udc_get_string_serial_name(void)
	{
80006634:	eb cd 40 80 	pushm	r7,lr
80006638:	1a 97       	mov	r7,sp
		return (const uint8_t *)USB_DEVICE_SERIAL_NAME;
8000663a:	48 38       	lddpc	r8,80006644 <udc_get_string_serial_name+0x10>
	}
8000663c:	10 9c       	mov	r12,r8
8000663e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006642:	00 00       	add	r0,r0
80006644:	80 00       	ld.sh	r0,r0[0x0]
80006646:	66 24       	ld.w	r4,r3[0x8]

80006648 <udc_get_eof_conf>:
 * \brief Returns a value to check the end of USB Configuration descriptor
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
80006648:	eb cd 40 80 	pushm	r7,lr
8000664c:	1a 97       	mov	r7,sp
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
8000664e:	48 b8       	lddpc	r8,80006678 <udc_get_eof_conf+0x30>
80006650:	70 08       	ld.w	r8,r8[0x0]
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
80006652:	70 09       	ld.w	r9,r8[0x0]
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
80006654:	48 98       	lddpc	r8,80006678 <udc_get_eof_conf+0x30>
80006656:	70 08       	ld.w	r8,r8[0x0]
80006658:	70 08       	ld.w	r8,r8[0x0]
8000665a:	11 aa       	ld.ub	r10,r8[0x2]
8000665c:	a9 6a       	lsl	r10,0x8
8000665e:	11 b8       	ld.ub	r8,r8[0x3]
80006660:	14 48       	or	r8,r10
80006662:	5c 88       	casts.h	r8
80006664:	5c 88       	casts.h	r8
80006666:	5c c8       	swap.bh	r8
80006668:	5c 88       	casts.h	r8
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
8000666a:	5c 78       	castu.h	r8
8000666c:	f2 08 00 08 	add	r8,r9,r8
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
}
80006670:	10 9c       	mov	r12,r8
80006672:	e3 cd 80 80 	ldm	sp++,r7,pc
80006676:	00 00       	add	r0,r0
80006678:	00 00       	add	r0,r0
8000667a:	07 28       	ld.uh	r8,r3++

8000667c <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
8000667c:	eb cd 40 80 	pushm	r7,lr
80006680:	1a 97       	mov	r7,sp
80006682:	20 3d       	sub	sp,12
80006684:	ef 4c ff f8 	st.w	r7[-8],r12
80006688:	16 98       	mov	r8,r11
8000668a:	ef 68 ff f4 	st.b	r7[-12],r8
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
8000668e:	f0 1f 00 1d 	mcall	80006700 <udc_next_desc_in_iface+0x84>
80006692:	18 98       	mov	r8,r12
80006694:	ef 48 ff fc 	st.w	r7[-4],r8
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
80006698:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000669c:	11 88       	ld.ub	r8,r8[0x0]
8000669e:	ee f9 ff f8 	ld.w	r9,r7[-8]
800066a2:	f2 08 00 08 	add	r8,r9,r8
800066a6:	ef 48 ff f8 	st.w	r7[-8],r8
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800066aa:	c1 c8       	rjmp	800066e2 <udc_next_desc_in_iface+0x66>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
800066ac:	ee f8 ff f8 	ld.w	r8,r7[-8]
800066b0:	11 99       	ld.ub	r9,r8[0x1]
800066b2:	30 48       	mov	r8,4
800066b4:	f0 09 18 00 	cp.b	r9,r8
800066b8:	c1 d0       	breq	800066f2 <udc_next_desc_in_iface+0x76>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
800066ba:	ee f8 ff f8 	ld.w	r8,r7[-8]
800066be:	11 98       	ld.ub	r8,r8[0x1]
800066c0:	ef 39 ff f4 	ld.ub	r9,r7[-12]
800066c4:	f0 09 18 00 	cp.b	r9,r8
800066c8:	c0 41       	brne	800066d0 <udc_next_desc_in_iface+0x54>
			return desc; // Specific descriptor found
800066ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800066ce:	c1 48       	rjmp	800066f6 <udc_next_desc_in_iface+0x7a>
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
800066d0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800066d4:	11 88       	ld.ub	r8,r8[0x0]
800066d6:	ee f9 ff f8 	ld.w	r9,r7[-8]
800066da:	f2 08 00 08 	add	r8,r9,r8
800066de:	ef 48 ff f8 	st.w	r7[-8],r8
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800066e2:	ee f9 ff fc 	ld.w	r9,r7[-4]
800066e6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800066ea:	10 39       	cp.w	r9,r8
800066ec:	fe 9b ff e0 	brhi	800066ac <udc_next_desc_in_iface+0x30>
800066f0:	c0 28       	rjmp	800066f4 <udc_next_desc_in_iface+0x78>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
			break; // End of global interface descriptor
800066f2:	d7 03       	nop
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL; // No specific descriptor found
800066f4:	30 08       	mov	r8,0
}
800066f6:	10 9c       	mov	r12,r8
800066f8:	2f dd       	sub	sp,-12
800066fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800066fe:	00 00       	add	r0,r0
80006700:	80 00       	ld.sh	r0,r0[0x0]
80006702:	66 48       	ld.w	r8,r3[0x10]

80006704 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
80006704:	eb cd 40 80 	pushm	r7,lr
80006708:	1a 97       	mov	r7,sp
8000670a:	20 3d       	sub	sp,12
8000670c:	18 99       	mov	r9,r12
8000670e:	16 98       	mov	r8,r11
80006710:	ef 69 ff f8 	st.b	r7[-8],r9
80006714:	ef 68 ff f4 	st.b	r7[-12],r8
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
80006718:	4a 58       	lddpc	r8,800067ac <udc_update_iface_desc+0xa8>
8000671a:	11 88       	ld.ub	r8,r8[0x0]
8000671c:	58 08       	cp.w	r8,0
8000671e:	c0 31       	brne	80006724 <udc_update_iface_desc+0x20>
		return false;
80006720:	30 08       	mov	r8,0
80006722:	c4 18       	rjmp	800067a4 <udc_update_iface_desc+0xa0>
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
80006724:	4a 38       	lddpc	r8,800067b0 <udc_update_iface_desc+0xac>
80006726:	70 08       	ld.w	r8,r8[0x0]
80006728:	70 08       	ld.w	r8,r8[0x0]
8000672a:	11 c8       	ld.ub	r8,r8[0x4]
8000672c:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80006730:	f0 09 18 00 	cp.b	r9,r8
80006734:	c0 33       	brcs	8000673a <udc_update_iface_desc+0x36>
		return false;
80006736:	30 08       	mov	r8,0
80006738:	c3 68       	rjmp	800067a4 <udc_update_iface_desc+0xa0>
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;
8000673a:	49 e8       	lddpc	r8,800067b0 <udc_update_iface_desc+0xac>
8000673c:	70 08       	ld.w	r8,r8[0x0]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
		return false;
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
8000673e:	70 08       	ld.w	r8,r8[0x0]
80006740:	10 99       	mov	r9,r8
80006742:	49 d8       	lddpc	r8,800067b4 <udc_update_iface_desc+0xb0>
80006744:	91 09       	st.w	r8[0x0],r9
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
80006746:	f0 1f 00 1d 	mcall	800067b8 <udc_update_iface_desc+0xb4>
8000674a:	18 98       	mov	r8,r12
8000674c:	ef 48 ff fc 	st.w	r7[-4],r8
	while (ptr_end_desc >
80006750:	c2 28       	rjmp	80006794 <udc_update_iface_desc+0x90>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
80006752:	49 98       	lddpc	r8,800067b4 <udc_update_iface_desc+0xb0>
80006754:	70 08       	ld.w	r8,r8[0x0]
80006756:	11 99       	ld.ub	r9,r8[0x1]
80006758:	30 48       	mov	r8,4
8000675a:	f0 09 18 00 	cp.b	r9,r8
8000675e:	c1 31       	brne	80006784 <udc_update_iface_desc+0x80>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
80006760:	49 58       	lddpc	r8,800067b4 <udc_update_iface_desc+0xb0>
80006762:	70 08       	ld.w	r8,r8[0x0]
80006764:	11 a8       	ld.ub	r8,r8[0x2]
80006766:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000676a:	f0 09 18 00 	cp.b	r9,r8
8000676e:	c0 b1       	brne	80006784 <udc_update_iface_desc+0x80>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
80006770:	49 18       	lddpc	r8,800067b4 <udc_update_iface_desc+0xb0>
80006772:	70 08       	ld.w	r8,r8[0x0]
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
					(setting_num ==
80006774:	11 b8       	ld.ub	r8,r8[0x3]
	while (ptr_end_desc >
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
80006776:	ef 39 ff f4 	ld.ub	r9,r7[-12]
8000677a:	f0 09 18 00 	cp.b	r9,r8
8000677e:	c0 31       	brne	80006784 <udc_update_iface_desc+0x80>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
				return true; // Interface found
80006780:	30 18       	mov	r8,1
80006782:	c1 18       	rjmp	800067a4 <udc_update_iface_desc+0xa0>
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
80006784:	48 c8       	lddpc	r8,800067b4 <udc_update_iface_desc+0xb0>
80006786:	70 09       	ld.w	r9,r8[0x0]
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
80006788:	48 b8       	lddpc	r8,800067b4 <udc_update_iface_desc+0xb0>
8000678a:	70 08       	ld.w	r8,r8[0x0]
					udc_ptr_iface->bAlternateSetting)) {
				return true; // Interface found
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
8000678c:	11 88       	ld.ub	r8,r8[0x0]
8000678e:	10 09       	add	r9,r8
80006790:	48 98       	lddpc	r8,800067b4 <udc_update_iface_desc+0xb0>
80006792:	91 09       	st.w	r8[0x0],r9
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
80006794:	48 88       	lddpc	r8,800067b4 <udc_update_iface_desc+0xb0>
80006796:	70 08       	ld.w	r8,r8[0x0]
80006798:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000679c:	10 39       	cp.w	r9,r8
8000679e:	fe 9b ff da 	brhi	80006752 <udc_update_iface_desc+0x4e>
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
	}
	return false; // Interface not found
800067a2:	30 08       	mov	r8,0
}
800067a4:	10 9c       	mov	r12,r8
800067a6:	2f dd       	sub	sp,-12
800067a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800067ac:	00 00       	add	r0,r0
800067ae:	07 26       	ld.uh	r6,r3++
800067b0:	00 00       	add	r0,r0
800067b2:	07 28       	ld.uh	r8,r3++
800067b4:	00 00       	add	r0,r0
800067b6:	07 2c       	ld.uh	r12,r3++
800067b8:	80 00       	ld.sh	r0,r0[0x0]
800067ba:	66 48       	ld.w	r8,r3[0x10]

800067bc <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
800067bc:	eb cd 40 80 	pushm	r7,lr
800067c0:	1a 97       	mov	r7,sp
800067c2:	20 3d       	sub	sp,12
800067c4:	18 98       	mov	r8,r12
800067c6:	ef 68 ff f4 	st.b	r7[-12],r8
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface
	// to update udc_ptr_iface before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
800067ca:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800067ce:	30 0b       	mov	r11,0
800067d0:	10 9c       	mov	r12,r8
800067d2:	f0 1f 00 25 	mcall	80006864 <udc_iface_disable+0xa8>
800067d6:	18 98       	mov	r8,r12
800067d8:	ec 18 00 01 	eorl	r8,0x1
800067dc:	5c 58       	castu.b	r8
800067de:	c0 30       	breq	800067e4 <udc_iface_disable+0x28>
		return false;
800067e0:	30 08       	mov	r8,0
800067e2:	c3 d8       	rjmp	8000685c <udc_iface_disable+0xa0>
	}

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
800067e4:	4a 18       	lddpc	r8,80006868 <udc_iface_disable+0xac>
800067e6:	70 08       	ld.w	r8,r8[0x0]
800067e8:	70 19       	ld.w	r9,r8[0x4]
800067ea:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800067ee:	a3 68       	lsl	r8,0x2
800067f0:	f2 08 00 08 	add	r8,r9,r8
800067f4:	70 08       	ld.w	r8,r8[0x0]
800067f6:	ef 48 ff f8 	st.w	r7[-8],r8

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
800067fa:	ee f8 ff f8 	ld.w	r8,r7[-8]
800067fe:	70 38       	ld.w	r8,r8[0xc]
80006800:	5d 18       	icall	r8
80006802:	18 98       	mov	r8,r12
80006804:	10 99       	mov	r9,r8
80006806:	ef 38 ff f4 	ld.ub	r8,r7[-12]
8000680a:	12 9b       	mov	r11,r9
8000680c:	10 9c       	mov	r12,r8
8000680e:	f0 1f 00 16 	mcall	80006864 <udc_iface_disable+0xa8>
80006812:	18 98       	mov	r8,r12
80006814:	ec 18 00 01 	eorl	r8,0x1
80006818:	5c 58       	castu.b	r8
8000681a:	c0 30       	breq	80006820 <udc_iface_disable+0x64>
		return false;
8000681c:	30 08       	mov	r8,0
8000681e:	c1 f8       	rjmp	8000685c <udc_iface_disable+0xa0>
	}

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
80006820:	49 38       	lddpc	r8,8000686c <udc_iface_disable+0xb0>
80006822:	70 08       	ld.w	r8,r8[0x0]
80006824:	ef 48 ff fc 	st.w	r7[-4],r8
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
80006828:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000682c:	30 5b       	mov	r11,5
8000682e:	10 9c       	mov	r12,r8
80006830:	f0 1f 00 10 	mcall	80006870 <udc_iface_disable+0xb4>
80006834:	18 98       	mov	r8,r12
80006836:	ef 48 ff fc 	st.w	r7[-4],r8
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
8000683a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000683e:	58 08       	cp.w	r8,0
80006840:	c0 71       	brne	8000684e <udc_iface_disable+0x92>
		}
	}
#endif

	// Disable interface
	udi_api->disable();
80006842:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006846:	70 18       	ld.w	r8,r8[0x4]
80006848:	5d 18       	icall	r8
	return true;
8000684a:	30 18       	mov	r8,1
8000684c:	c0 88       	rjmp	8000685c <udc_iface_disable+0xa0>
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
8000684e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006852:	11 a8       	ld.ub	r8,r8[0x2]
80006854:	10 9c       	mov	r12,r8
80006856:	f0 1f 00 08 	mcall	80006874 <udc_iface_disable+0xb8>
		}
8000685a:	ce 7b       	rjmp	80006828 <udc_iface_disable+0x6c>
#endif

	// Disable interface
	udi_api->disable();
	return true;
}
8000685c:	10 9c       	mov	r12,r8
8000685e:	2f dd       	sub	sp,-12
80006860:	e3 cd 80 80 	ldm	sp++,r7,pc
80006864:	80 00       	ld.sh	r0,r0[0x0]
80006866:	67 04       	ld.w	r4,r3[0x40]
80006868:	00 00       	add	r0,r0
8000686a:	07 28       	ld.uh	r8,r3++
8000686c:	00 00       	add	r0,r0
8000686e:	07 2c       	ld.uh	r12,r3++
80006870:	80 00       	ld.sh	r0,r0[0x0]
80006872:	66 7c       	ld.w	r12,r3[0x1c]
80006874:	80 00       	ld.sh	r0,r0[0x0]
80006876:	39 18       	mov	r8,-111

80006878 <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
80006878:	eb cd 40 80 	pushm	r7,lr
8000687c:	1a 97       	mov	r7,sp
8000687e:	20 3d       	sub	sp,12
80006880:	18 99       	mov	r9,r12
80006882:	16 98       	mov	r8,r11
80006884:	ef 69 ff f8 	st.b	r7[-8],r9
80006888:	ef 68 ff f4 	st.b	r7[-12],r8
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num)) {
8000688c:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80006890:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80006894:	12 9b       	mov	r11,r9
80006896:	10 9c       	mov	r12,r8
80006898:	f0 1f 00 25 	mcall	8000692c <udc_iface_enable+0xb4>
8000689c:	18 98       	mov	r8,r12
8000689e:	ec 18 00 01 	eorl	r8,0x1
800068a2:	5c 58       	castu.b	r8
800068a4:	c0 30       	breq	800068aa <udc_iface_enable+0x32>
		return false;
800068a6:	30 08       	mov	r8,0
800068a8:	c3 e8       	rjmp	80006924 <udc_iface_enable+0xac>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
800068aa:	4a 28       	lddpc	r8,80006930 <udc_iface_enable+0xb8>
800068ac:	70 08       	ld.w	r8,r8[0x0]
800068ae:	ef 48 ff fc 	st.w	r7[-4],r8
800068b2:	c0 28       	rjmp	800068b6 <udc_iface_enable+0x3e>
				ep_desc->bmAttributes,
				le16_to_cpu
				(ep_desc->wMaxPacketSize))) {
			return false;
		}
	}
800068b4:	d7 03       	nop

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
800068b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800068ba:	30 5b       	mov	r11,5
800068bc:	10 9c       	mov	r12,r8
800068be:	f0 1f 00 1e 	mcall	80006934 <udc_iface_enable+0xbc>
800068c2:	18 98       	mov	r8,r12
800068c4:	ef 48 ff fc 	st.w	r7[-4],r8
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
800068c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800068cc:	58 08       	cp.w	r8,0
800068ce:	c0 e1       	brne	800068ea <udc_iface_enable+0x72>
			return false;
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
800068d0:	49 a8       	lddpc	r8,80006938 <udc_iface_enable+0xc0>
800068d2:	70 08       	ld.w	r8,r8[0x0]
800068d4:	70 19       	ld.w	r9,r8[0x4]
800068d6:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800068da:	a3 68       	lsl	r8,0x2
800068dc:	f2 08 00 08 	add	r8,r9,r8
800068e0:	70 08       	ld.w	r8,r8[0x0]
800068e2:	70 08       	ld.w	r8,r8[0x0]
800068e4:	5d 18       	icall	r8
800068e6:	18 98       	mov	r8,r12
800068e8:	c1 e8       	rjmp	80006924 <udc_iface_enable+0xac>
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
				ep_desc->bmAttributes,
				le16_to_cpu
800068ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800068ee:	11 c9       	ld.ub	r9,r8[0x4]
800068f0:	a9 69       	lsl	r9,0x8
800068f2:	11 d8       	ld.ub	r8,r8[0x5]
800068f4:	12 48       	or	r8,r9
800068f6:	5c 88       	casts.h	r8
800068f8:	5c 88       	casts.h	r8
800068fa:	5c c8       	swap.bh	r8
800068fc:	5c 88       	casts.h	r8
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
800068fe:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
				ep_desc->bmAttributes,
80006902:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006906:	11 b8       	ld.ub	r8,r8[0x3]
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
80006908:	10 99       	mov	r9,r8
8000690a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000690e:	11 a8       	ld.ub	r8,r8[0x2]
80006910:	12 9b       	mov	r11,r9
80006912:	10 9c       	mov	r12,r8
80006914:	f0 1f 00 0a 	mcall	8000693c <udc_iface_enable+0xc4>
80006918:	18 98       	mov	r8,r12
8000691a:	ec 18 00 01 	eorl	r8,0x1
8000691e:	5c 58       	castu.b	r8
80006920:	cc a0       	breq	800068b4 <udc_iface_enable+0x3c>
				ep_desc->bmAttributes,
				le16_to_cpu
				(ep_desc->wMaxPacketSize))) {
			return false;
80006922:	30 08       	mov	r8,0
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
}
80006924:	10 9c       	mov	r12,r8
80006926:	2f dd       	sub	sp,-12
80006928:	e3 cd 80 80 	ldm	sp++,r7,pc
8000692c:	80 00       	ld.sh	r0,r0[0x0]
8000692e:	67 04       	ld.w	r4,r3[0x40]
80006930:	00 00       	add	r0,r0
80006932:	07 2c       	ld.uh	r12,r3++
80006934:	80 00       	ld.sh	r0,r0[0x0]
80006936:	66 7c       	ld.w	r12,r3[0x1c]
80006938:	00 00       	add	r0,r0
8000693a:	07 28       	ld.uh	r8,r3++
8000693c:	80 00       	ld.sh	r0,r0[0x0]
8000693e:	35 c8       	mov	r8,92

80006940 <udc_start>:

/*! \brief Start the USB Device stack
 */
void udc_start(void)
{
80006940:	eb cd 40 80 	pushm	r7,lr
80006944:	1a 97       	mov	r7,sp
	udd_enable();
80006946:	f0 1f 00 03 	mcall	80006950 <udc_start+0x10>
}
8000694a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000694e:	00 00       	add	r0,r0
80006950:	80 00       	ld.sh	r0,r0[0x0]
80006952:	32 e4       	mov	r4,46

80006954 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device,
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
80006954:	eb cd 40 80 	pushm	r7,lr
80006958:	1a 97       	mov	r7,sp
8000695a:	20 1d       	sub	sp,4
	uint8_t iface_num;

	if (udc_num_configuration) {
8000695c:	49 28       	lddpc	r8,800069a4 <udc_reset+0x50>
8000695e:	11 88       	ld.ub	r8,r8[0x0]
80006960:	58 08       	cp.w	r8,0
80006962:	c1 80       	breq	80006992 <udc_reset+0x3e>
		for (iface_num = 0;
80006964:	30 08       	mov	r8,0
80006966:	ef 68 ff ff 	st.b	r7[-1],r8
8000696a:	c0 b8       	rjmp	80006980 <udc_reset+0x2c>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
8000696c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006970:	10 9c       	mov	r12,r8
80006972:	f0 1f 00 0e 	mcall	800069a8 <udc_reset+0x54>
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
80006976:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000697a:	2f f8       	sub	r8,-1
8000697c:	ef 68 ff ff 	st.b	r7[-1],r8
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80006980:	48 b8       	lddpc	r8,800069ac <udc_reset+0x58>
80006982:	70 08       	ld.w	r8,r8[0x0]
80006984:	70 08       	ld.w	r8,r8[0x0]
80006986:	11 c8       	ld.ub	r8,r8[0x4]
void udc_reset(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
80006988:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000698c:	f0 09 18 00 	cp.b	r9,r8
80006990:	ce e3       	brcs	8000696c <udc_reset+0x18>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
80006992:	48 59       	lddpc	r9,800069a4 <udc_reset+0x50>
80006994:	30 08       	mov	r8,0
80006996:	b2 88       	st.b	r9[0x0],r8
	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
80006998:	48 69       	lddpc	r9,800069b0 <udc_reset+0x5c>
8000699a:	30 08       	mov	r8,0
8000699c:	b2 08       	st.h	r9[0x0],r8
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
8000699e:	2f fd       	sub	sp,-4
800069a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800069a4:	00 00       	add	r0,r0
800069a6:	07 26       	ld.uh	r6,r3++
800069a8:	80 00       	ld.sh	r0,r0[0x0]
800069aa:	67 bc       	ld.w	r12,r3[0x6c]
800069ac:	00 00       	add	r0,r0
800069ae:	07 28       	ld.uh	r8,r3++
800069b0:	00 00       	add	r0,r0
800069b2:	07 24       	ld.uh	r4,r3++

800069b4 <udc_sof_notify>:

void udc_sof_notify(void)
{
800069b4:	eb cd 40 80 	pushm	r7,lr
800069b8:	1a 97       	mov	r7,sp
800069ba:	20 1d       	sub	sp,4
	uint8_t iface_num;

	if (udc_num_configuration) {
800069bc:	49 88       	lddpc	r8,80006a1c <udc_sof_notify+0x68>
800069be:	11 88       	ld.ub	r8,r8[0x0]
800069c0:	58 08       	cp.w	r8,0
800069c2:	c2 a0       	breq	80006a16 <udc_sof_notify+0x62>
		for (iface_num = 0;
800069c4:	30 08       	mov	r8,0
800069c6:	ef 68 ff ff 	st.b	r7[-1],r8
800069ca:	c1 d8       	rjmp	80006a04 <udc_sof_notify+0x50>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
800069cc:	49 58       	lddpc	r8,80006a20 <udc_sof_notify+0x6c>
800069ce:	70 08       	ld.w	r8,r8[0x0]
800069d0:	70 19       	ld.w	r9,r8[0x4]
800069d2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800069d6:	a3 68       	lsl	r8,0x2
800069d8:	f2 08 00 08 	add	r8,r9,r8
800069dc:	70 08       	ld.w	r8,r8[0x0]
800069de:	70 48       	ld.w	r8,r8[0x10]
800069e0:	58 08       	cp.w	r8,0
800069e2:	c0 c0       	breq	800069fa <udc_sof_notify+0x46>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
800069e4:	48 f8       	lddpc	r8,80006a20 <udc_sof_notify+0x6c>
800069e6:	70 08       	ld.w	r8,r8[0x0]
800069e8:	70 19       	ld.w	r9,r8[0x4]
800069ea:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800069ee:	a3 68       	lsl	r8,0x2
800069f0:	f2 08 00 08 	add	r8,r9,r8
800069f4:	70 08       	ld.w	r8,r8[0x0]
800069f6:	70 48       	ld.w	r8,r8[0x10]
800069f8:	5d 18       	icall	r8
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
800069fa:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800069fe:	2f f8       	sub	r8,-1
80006a00:	ef 68 ff ff 	st.b	r7[-1],r8
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80006a04:	48 78       	lddpc	r8,80006a20 <udc_sof_notify+0x6c>
80006a06:	70 08       	ld.w	r8,r8[0x0]
80006a08:	70 08       	ld.w	r8,r8[0x0]
80006a0a:	11 c8       	ld.ub	r8,r8[0x4]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
80006a0c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006a10:	f0 09 18 00 	cp.b	r9,r8
80006a14:	cd c3       	brcs	800069cc <udc_sof_notify+0x18>
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
			}
		}
	}
}
80006a16:	2f fd       	sub	sp,-4
80006a18:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a1c:	00 00       	add	r0,r0
80006a1e:	07 26       	ld.uh	r6,r3++
80006a20:	00 00       	add	r0,r0
80006a22:	07 28       	ld.uh	r8,r3++

80006a24 <udc_req_std_dev_get_status>:
 * \brief Standard device request to get device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
80006a24:	eb cd 40 80 	pushm	r7,lr
80006a28:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
80006a2a:	48 98       	lddpc	r8,80006a4c <udc_req_std_dev_get_status+0x28>
80006a2c:	90 39       	ld.sh	r9,r8[0x6]
80006a2e:	30 28       	mov	r8,2
80006a30:	f0 09 19 00 	cp.h	r9,r8
80006a34:	c0 30       	breq	80006a3a <udc_req_std_dev_get_status+0x16>
		return false;
80006a36:	30 08       	mov	r8,0
80006a38:	c0 78       	rjmp	80006a46 <udc_req_std_dev_get_status+0x22>
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
80006a3a:	48 68       	lddpc	r8,80006a50 <udc_req_std_dev_get_status+0x2c>
80006a3c:	30 2b       	mov	r11,2
80006a3e:	10 9c       	mov	r12,r8
80006a40:	f0 1f 00 05 	mcall	80006a54 <udc_req_std_dev_get_status+0x30>
			sizeof(udc_device_status));
	return true;
80006a44:	30 18       	mov	r8,1
}
80006a46:	10 9c       	mov	r12,r8
80006a48:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a4c:	00 00       	add	r0,r0
80006a4e:	46 48       	lddsp	r8,sp[0x190]
80006a50:	00 00       	add	r0,r0
80006a52:	07 24       	ld.uh	r4,r3++
80006a54:	80 00       	ld.sh	r0,r0[0x0]
80006a56:	35 9c       	mov	r12,89

80006a58 <udc_req_std_ep_get_status>:
 * \brief Standard endpoint request to get endpoint status
 *
 * \return true if success
 */
static bool udc_req_std_ep_get_status(void)
{
80006a58:	eb cd 40 80 	pushm	r7,lr
80006a5c:	1a 97       	mov	r7,sp
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
80006a5e:	49 18       	lddpc	r8,80006aa0 <udc_req_std_ep_get_status+0x48>
80006a60:	90 39       	ld.sh	r9,r8[0x6]
80006a62:	30 28       	mov	r8,2
80006a64:	f0 09 19 00 	cp.h	r9,r8
80006a68:	c0 30       	breq	80006a6e <udc_req_std_ep_get_status+0x16>
		return false;
80006a6a:	30 08       	mov	r8,0
80006a6c:	c1 68       	rjmp	80006a98 <udc_req_std_ep_get_status+0x40>
	}

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
80006a6e:	48 d8       	lddpc	r8,80006aa0 <udc_req_std_ep_get_status+0x48>
80006a70:	90 28       	ld.sh	r8,r8[0x4]
80006a72:	5c 58       	castu.b	r8
80006a74:	10 9c       	mov	r12,r8
80006a76:	f0 1f 00 0c 	mcall	80006aa4 <udc_req_std_ep_get_status+0x4c>
80006a7a:	18 98       	mov	r8,r12
80006a7c:	58 08       	cp.w	r8,0
80006a7e:	c0 40       	breq	80006a86 <udc_req_std_ep_get_status+0x2e>
80006a80:	e0 68 01 00 	mov	r8,256
80006a84:	c0 28       	rjmp	80006a88 <udc_req_std_ep_get_status+0x30>
80006a86:	30 08       	mov	r8,0
80006a88:	48 89       	lddpc	r9,80006aa8 <udc_req_std_ep_get_status+0x50>
80006a8a:	b2 08       	st.h	r9[0x0],r8
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
80006a8c:	48 78       	lddpc	r8,80006aa8 <udc_req_std_ep_get_status+0x50>
80006a8e:	30 2b       	mov	r11,2
80006a90:	10 9c       	mov	r12,r8
80006a92:	f0 1f 00 07 	mcall	80006aac <udc_req_std_ep_get_status+0x54>
			sizeof(udc_ep_status));
	return true;
80006a96:	30 18       	mov	r8,1
}
80006a98:	10 9c       	mov	r12,r8
80006a9a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a9e:	00 00       	add	r0,r0
80006aa0:	00 00       	add	r0,r0
80006aa2:	46 48       	lddsp	r8,sp[0x190]
80006aa4:	80 00       	ld.sh	r0,r0[0x0]
80006aa6:	39 b4       	mov	r4,-101
80006aa8:	00 00       	add	r0,r0
80006aaa:	07 32       	ld.ub	r2,r3++
80006aac:	80 00       	ld.sh	r0,r0[0x0]
80006aae:	35 9c       	mov	r12,89

80006ab0 <udc_req_std_dev_clear_feature>:
 * \brief Standard device request to change device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
80006ab0:	eb cd 40 80 	pushm	r7,lr
80006ab4:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006ab6:	48 d8       	lddpc	r8,80006ae8 <udc_req_std_dev_clear_feature+0x38>
80006ab8:	90 38       	ld.sh	r8,r8[0x6]
80006aba:	58 08       	cp.w	r8,0
80006abc:	c0 30       	breq	80006ac2 <udc_req_std_dev_clear_feature+0x12>
		return false;
80006abe:	30 08       	mov	r8,0
80006ac0:	c1 08       	rjmp	80006ae0 <udc_req_std_dev_clear_feature+0x30>
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
80006ac2:	48 a8       	lddpc	r8,80006ae8 <udc_req_std_dev_clear_feature+0x38>
80006ac4:	90 19       	ld.sh	r9,r8[0x2]
80006ac6:	30 18       	mov	r8,1
80006ac8:	f0 09 19 00 	cp.h	r9,r8
80006acc:	c0 91       	brne	80006ade <udc_req_std_dev_clear_feature+0x2e>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
80006ace:	48 88       	lddpc	r8,80006aec <udc_req_std_dev_clear_feature+0x3c>
80006ad0:	90 08       	ld.sh	r8,r8[0x0]
80006ad2:	a9 d8       	cbr	r8,0x9
80006ad4:	5c 88       	casts.h	r8
80006ad6:	48 69       	lddpc	r9,80006aec <udc_req_std_dev_clear_feature+0x3c>
80006ad8:	b2 08       	st.h	r9[0x0],r8
#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
80006ada:	30 18       	mov	r8,1
80006adc:	c0 28       	rjmp	80006ae0 <udc_req_std_dev_clear_feature+0x30>
	}
	return false;
80006ade:	30 08       	mov	r8,0
}
80006ae0:	10 9c       	mov	r12,r8
80006ae2:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ae6:	00 00       	add	r0,r0
80006ae8:	00 00       	add	r0,r0
80006aea:	46 48       	lddsp	r8,sp[0x190]
80006aec:	00 00       	add	r0,r0
80006aee:	07 24       	ld.uh	r4,r3++

80006af0 <udc_req_std_ep_clear_feature>:
 * \brief Standard endpoint request to clear endpoint feature
 *
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
80006af0:	eb cd 40 80 	pushm	r7,lr
80006af4:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006af6:	48 c8       	lddpc	r8,80006b24 <udc_req_std_ep_clear_feature+0x34>
80006af8:	90 38       	ld.sh	r8,r8[0x6]
80006afa:	58 08       	cp.w	r8,0
80006afc:	c0 30       	breq	80006b02 <udc_req_std_ep_clear_feature+0x12>
		return false;
80006afe:	30 08       	mov	r8,0
80006b00:	c0 e8       	rjmp	80006b1c <udc_req_std_ep_clear_feature+0x2c>
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80006b02:	48 98       	lddpc	r8,80006b24 <udc_req_std_ep_clear_feature+0x34>
80006b04:	90 18       	ld.sh	r8,r8[0x2]
80006b06:	58 08       	cp.w	r8,0
80006b08:	c0 91       	brne	80006b1a <udc_req_std_ep_clear_feature+0x2a>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80006b0a:	48 78       	lddpc	r8,80006b24 <udc_req_std_ep_clear_feature+0x34>
80006b0c:	90 28       	ld.sh	r8,r8[0x4]
80006b0e:	5c 58       	castu.b	r8
80006b10:	10 9c       	mov	r12,r8
80006b12:	f0 1f 00 06 	mcall	80006b28 <udc_req_std_ep_clear_feature+0x38>
80006b16:	18 98       	mov	r8,r12
80006b18:	c0 28       	rjmp	80006b1c <udc_req_std_ep_clear_feature+0x2c>
	}
	return false;
80006b1a:	30 08       	mov	r8,0
}
80006b1c:	10 9c       	mov	r12,r8
80006b1e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b22:	00 00       	add	r0,r0
80006b24:	00 00       	add	r0,r0
80006b26:	46 48       	lddsp	r8,sp[0x190]
80006b28:	80 00       	ld.sh	r0,r0[0x0]
80006b2a:	3a f8       	mov	r8,-81

80006b2c <udc_req_std_dev_set_feature>:
 * \brief Standard device request to set a feature
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_feature(void)
{
80006b2c:	eb cd 40 80 	pushm	r7,lr
80006b30:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006b32:	48 98       	lddpc	r8,80006b54 <udc_req_std_dev_set_feature+0x28>
80006b34:	90 38       	ld.sh	r8,r8[0x6]
80006b36:	58 08       	cp.w	r8,0
80006b38:	c0 30       	breq	80006b3e <udc_req_std_dev_set_feature+0x12>
		return false;
80006b3a:	30 08       	mov	r8,0
80006b3c:	c0 98       	rjmp	80006b4e <udc_req_std_dev_set_feature+0x22>
	}

	switch (udd_g_ctrlreq.req.wValue) {
80006b3e:	48 68       	lddpc	r8,80006b54 <udc_req_std_dev_set_feature+0x28>
80006b40:	90 18       	ld.sh	r8,r8[0x2]
80006b42:	5c 78       	castu.h	r8
80006b44:	58 18       	cp.w	r8,1
80006b46:	c0 31       	brne	80006b4c <udc_req_std_dev_set_feature+0x20>
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		udc_device_status |= CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP);
		UDC_REMOTEWAKEUP_ENABLE();
		return true;
#else
		return false;
80006b48:	30 08       	mov	r8,0
80006b4a:	c0 28       	rjmp	80006b4e <udc_req_std_dev_set_feature+0x22>
		break;
#endif
	default:
		break;
	}
	return false;
80006b4c:	30 08       	mov	r8,0
}
80006b4e:	10 9c       	mov	r12,r8
80006b50:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b54:	00 00       	add	r0,r0
80006b56:	46 48       	lddsp	r8,sp[0x190]

80006b58 <udc_req_std_ep_set_feature>:
 *
 * \return true if success
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_ep_set_feature(void)
{
80006b58:	eb cd 40 80 	pushm	r7,lr
80006b5c:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006b5e:	48 f8       	lddpc	r8,80006b98 <udc_req_std_ep_set_feature+0x40>
80006b60:	90 38       	ld.sh	r8,r8[0x6]
80006b62:	58 08       	cp.w	r8,0
80006b64:	c0 30       	breq	80006b6a <udc_req_std_ep_set_feature+0x12>
		return false;
80006b66:	30 08       	mov	r8,0
80006b68:	c1 48       	rjmp	80006b90 <udc_req_std_ep_set_feature+0x38>
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80006b6a:	48 c8       	lddpc	r8,80006b98 <udc_req_std_ep_set_feature+0x40>
80006b6c:	90 18       	ld.sh	r8,r8[0x2]
80006b6e:	58 08       	cp.w	r8,0
80006b70:	c0 f1       	brne	80006b8e <udc_req_std_ep_set_feature+0x36>
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
80006b72:	48 a8       	lddpc	r8,80006b98 <udc_req_std_ep_set_feature+0x40>
80006b74:	90 28       	ld.sh	r8,r8[0x4]
80006b76:	5c 58       	castu.b	r8
80006b78:	10 9c       	mov	r12,r8
80006b7a:	f0 1f 00 09 	mcall	80006b9c <udc_req_std_ep_set_feature+0x44>
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80006b7e:	48 78       	lddpc	r8,80006b98 <udc_req_std_ep_set_feature+0x40>
80006b80:	90 28       	ld.sh	r8,r8[0x4]
80006b82:	5c 58       	castu.b	r8
80006b84:	10 9c       	mov	r12,r8
80006b86:	f0 1f 00 07 	mcall	80006ba0 <udc_req_std_ep_set_feature+0x48>
80006b8a:	18 98       	mov	r8,r12
80006b8c:	c0 28       	rjmp	80006b90 <udc_req_std_ep_set_feature+0x38>
	}
	return false;
80006b8e:	30 08       	mov	r8,0
}
80006b90:	10 9c       	mov	r12,r8
80006b92:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b96:	00 00       	add	r0,r0
80006b98:	00 00       	add	r0,r0
80006b9a:	46 48       	lddsp	r8,sp[0x190]
80006b9c:	80 00       	ld.sh	r0,r0[0x0]
80006b9e:	3d 5c       	mov	r12,-43
80006ba0:	80 00       	ld.sh	r0,r0[0x0]
80006ba2:	39 e4       	mov	r4,-98

80006ba4 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
80006ba4:	eb cd 40 80 	pushm	r7,lr
80006ba8:	1a 97       	mov	r7,sp
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
80006baa:	48 68       	lddpc	r8,80006bc0 <udc_valid_address+0x1c>
80006bac:	90 18       	ld.sh	r8,r8[0x2]
80006bae:	5c 58       	castu.b	r8
80006bb0:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006bb4:	10 9c       	mov	r12,r8
80006bb6:	f0 1f 00 04 	mcall	80006bc4 <udc_valid_address+0x20>
}
80006bba:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bbe:	00 00       	add	r0,r0
80006bc0:	00 00       	add	r0,r0
80006bc2:	46 48       	lddsp	r8,sp[0x190]
80006bc4:	80 00       	ld.sh	r0,r0[0x0]
80006bc6:	35 02       	mov	r2,80

80006bc8 <udc_req_std_dev_set_address>:
 * \brief Standard device request to set device address
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
80006bc8:	eb cd 40 80 	pushm	r7,lr
80006bcc:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006bce:	48 78       	lddpc	r8,80006be8 <udc_req_std_dev_set_address+0x20>
80006bd0:	90 38       	ld.sh	r8,r8[0x6]
80006bd2:	58 08       	cp.w	r8,0
80006bd4:	c0 30       	breq	80006bda <udc_req_std_dev_set_address+0x12>
		return false;
80006bd6:	30 08       	mov	r8,0
80006bd8:	c0 58       	rjmp	80006be2 <udc_req_std_dev_set_address+0x1a>
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
80006bda:	48 48       	lddpc	r8,80006be8 <udc_req_std_dev_set_address+0x20>
80006bdc:	48 49       	lddpc	r9,80006bec <udc_req_std_dev_set_address+0x24>
80006bde:	91 49       	st.w	r8[0x10],r9
	return true;
80006be0:	30 18       	mov	r8,1
}
80006be2:	10 9c       	mov	r12,r8
80006be4:	e3 cd 80 80 	ldm	sp++,r7,pc
80006be8:	00 00       	add	r0,r0
80006bea:	46 48       	lddsp	r8,sp[0x190]
80006bec:	80 00       	ld.sh	r0,r0[0x0]
80006bee:	6b a4       	ld.w	r4,r5[0x68]

80006bf0 <udc_req_std_dev_get_str_desc>:
 * \brief Standard device request to get device string descriptor
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_str_desc(void)
{
80006bf0:	eb cd 40 80 	pushm	r7,lr
80006bf4:	1a 97       	mov	r7,sp
80006bf6:	20 3d       	sub	sp,12
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;
80006bf8:	30 08       	mov	r8,0
80006bfa:	ef 68 ff ff 	st.b	r7[-1],r8

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
80006bfe:	4b 68       	lddpc	r8,80006cd4 <udc_req_std_dev_get_str_desc+0xe4>
80006c00:	90 18       	ld.sh	r8,r8[0x2]
80006c02:	5c 78       	castu.h	r8
80006c04:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80006c08:	58 18       	cp.w	r8,1
80006c0a:	c1 00       	breq	80006c2a <udc_req_std_dev_get_str_desc+0x3a>
80006c0c:	e0 89 00 05 	brgt	80006c16 <udc_req_std_dev_get_str_desc+0x26>
80006c10:	58 08       	cp.w	r8,0
80006c12:	c0 70       	breq	80006c20 <udc_req_std_dev_get_str_desc+0x30>
80006c14:	c2 28       	rjmp	80006c58 <udc_req_std_dev_get_str_desc+0x68>
80006c16:	58 28       	cp.w	r8,2
80006c18:	c1 00       	breq	80006c38 <udc_req_std_dev_get_str_desc+0x48>
80006c1a:	58 38       	cp.w	r8,3
80006c1c:	c1 50       	breq	80006c46 <udc_req_std_dev_get_str_desc+0x56>
80006c1e:	c1 d8       	rjmp	80006c58 <udc_req_std_dev_get_str_desc+0x68>
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
80006c20:	30 4b       	mov	r11,4
80006c22:	4a ec       	lddpc	r12,80006cd8 <udc_req_std_dev_get_str_desc+0xe8>
80006c24:	f0 1f 00 2e 	mcall	80006cdc <udc_req_std_dev_get_str_desc+0xec>
				sizeof(udc_string_desc_languageid));
		break;
80006c28:	c1 a8       	rjmp	80006c5c <udc_req_std_dev_get_str_desc+0x6c>

#ifdef USB_DEVICE_MANUFACTURE_NAME
	case 1:
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
80006c2a:	30 98       	mov	r8,9
80006c2c:	ef 68 ff ff 	st.b	r7[-1],r8
		str = udc_string_manufacturer_name;
80006c30:	4a c8       	lddpc	r8,80006ce0 <udc_req_std_dev_get_str_desc+0xf0>
80006c32:	ef 48 ff f8 	st.w	r7[-8],r8
		break;
80006c36:	c1 38       	rjmp	80006c5c <udc_req_std_dev_get_str_desc+0x6c>
#endif
#ifdef USB_DEVICE_PRODUCT_NAME
	case 2:
		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
80006c38:	30 f8       	mov	r8,15
80006c3a:	ef 68 ff ff 	st.b	r7[-1],r8
		str = udc_string_product_name;
80006c3e:	4a a8       	lddpc	r8,80006ce4 <udc_req_std_dev_get_str_desc+0xf4>
80006c40:	ef 48 ff f8 	st.w	r7[-8],r8
		break;
80006c44:	c0 c8       	rjmp	80006c5c <udc_req_std_dev_get_str_desc+0x6c>
#endif
#if defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER
	case 3:
		str_length = USB_DEVICE_SERIAL_NAME_SIZE;
80006c46:	30 c8       	mov	r8,12
80006c48:	ef 68 ff ff 	st.b	r7[-1],r8
		str = udc_get_string_serial_name();
80006c4c:	f0 1f 00 27 	mcall	80006ce8 <udc_req_std_dev_get_str_desc+0xf8>
80006c50:	18 98       	mov	r8,r12
80006c52:	ef 48 ff f8 	st.w	r7[-8],r8
		break;
80006c56:	c0 38       	rjmp	80006c5c <udc_req_std_dev_get_str_desc+0x6c>
#ifdef UDC_GET_EXTRA_STRING
		if (UDC_GET_EXTRA_STRING()) {
			break;
		}
#endif
		return false;
80006c58:	30 08       	mov	r8,0
80006c5a:	c3 88       	rjmp	80006cca <udc_req_std_dev_get_str_desc+0xda>
	}

	if (str_length) {
80006c5c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006c60:	30 08       	mov	r8,0
80006c62:	f0 09 18 00 	cp.b	r9,r8
80006c66:	c3 10       	breq	80006cc8 <udc_req_std_dev_get_str_desc+0xd8>
		for(i = 0; i < str_length; i++) {
80006c68:	30 08       	mov	r8,0
80006c6a:	ef 68 ff f7 	st.b	r7[-9],r8
80006c6e:	c1 88       	rjmp	80006c9e <udc_req_std_dev_get_str_desc+0xae>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
80006c70:	ef 3b ff f7 	ld.ub	r11,r7[-9]
80006c74:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80006c78:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006c7c:	f2 08 00 08 	add	r8,r9,r8
80006c80:	11 88       	ld.ub	r8,r8[0x0]
80006c82:	5c c8       	swap.bh	r8
80006c84:	5c 88       	casts.h	r8
80006c86:	10 99       	mov	r9,r8
80006c88:	49 9a       	lddpc	r10,80006cec <udc_req_std_dev_get_str_desc+0xfc>
80006c8a:	f6 08 15 01 	lsl	r8,r11,0x1
80006c8e:	f4 08 00 08 	add	r8,r10,r8
80006c92:	b0 19       	st.h	r8[0x2],r9
#endif
		return false;
	}

	if (str_length) {
		for(i = 0; i < str_length; i++) {
80006c94:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80006c98:	2f f8       	sub	r8,-1
80006c9a:	ef 68 ff f7 	st.b	r7[-9],r8
80006c9e:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80006ca2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006ca6:	f0 09 18 00 	cp.b	r9,r8
80006caa:	ce 33       	brcs	80006c70 <udc_req_std_dev_get_str_desc+0x80>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
80006cac:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006cb0:	2f f8       	sub	r8,-1
80006cb2:	5c 58       	castu.b	r8
80006cb4:	a1 78       	lsl	r8,0x1
80006cb6:	5c 58       	castu.b	r8
80006cb8:	48 d9       	lddpc	r9,80006cec <udc_req_std_dev_get_str_desc+0xfc>
80006cba:	b2 88       	st.b	r9[0x0],r8
		udd_set_setup_payload(
			(uint8_t *) &udc_string_desc,
			udc_string_desc.header.bLength);
80006cbc:	48 c8       	lddpc	r8,80006cec <udc_req_std_dev_get_str_desc+0xfc>
80006cbe:	11 88       	ld.ub	r8,r8[0x0]
		for(i = 0; i < str_length; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
		udd_set_setup_payload(
80006cc0:	10 9b       	mov	r11,r8
80006cc2:	48 bc       	lddpc	r12,80006cec <udc_req_std_dev_get_str_desc+0xfc>
80006cc4:	f0 1f 00 06 	mcall	80006cdc <udc_req_std_dev_get_str_desc+0xec>
			(uint8_t *) &udc_string_desc,
			udc_string_desc.header.bLength);
	}

	return true;
80006cc8:	30 18       	mov	r8,1
}
80006cca:	10 9c       	mov	r12,r8
80006ccc:	2f dd       	sub	sp,-12
80006cce:	e3 cd 80 80 	ldm	sp++,r7,pc
80006cd2:	00 00       	add	r0,r0
80006cd4:	00 00       	add	r0,r0
80006cd6:	46 48       	lddsp	r8,sp[0x190]
80006cd8:	00 00       	add	r0,r0
80006cda:	00 a4       	st.w	r0++,r4
80006cdc:	80 00       	ld.sh	r0,r0[0x0]
80006cde:	35 9c       	mov	r12,89
80006ce0:	00 00       	add	r0,r0
80006ce2:	00 a8       	st.w	r0++,r8
80006ce4:	00 00       	add	r0,r0
80006ce6:	00 b4       	st.h	r0++,r4
80006ce8:	80 00       	ld.sh	r0,r0[0x0]
80006cea:	66 34       	ld.w	r4,r3[0xc]
80006cec:	00 00       	add	r0,r0
80006cee:	00 c4       	st.b	r0++,r4

80006cf0 <udc_req_std_dev_get_descriptor>:
 * \brief Standard device request to get descriptors about USB device
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_descriptor(void)
{
80006cf0:	eb cd 40 80 	pushm	r7,lr
80006cf4:	1a 97       	mov	r7,sp
80006cf6:	20 1d       	sub	sp,4
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80006cf8:	4b 38       	lddpc	r8,80006dc4 <udc_req_std_dev_get_descriptor+0xd4>
80006cfa:	90 18       	ld.sh	r8,r8[0x2]
80006cfc:	ef 68 ff ff 	st.b	r7[-1],r8

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
80006d00:	4b 18       	lddpc	r8,80006dc4 <udc_req_std_dev_get_descriptor+0xd4>
80006d02:	90 18       	ld.sh	r8,r8[0x2]
80006d04:	5c 78       	castu.h	r8
80006d06:	a9 88       	lsr	r8,0x8
80006d08:	5c 88       	casts.h	r8
80006d0a:	5c 58       	castu.b	r8
80006d0c:	58 28       	cp.w	r8,2
80006d0e:	c1 00       	breq	80006d2e <udc_req_std_dev_get_descriptor+0x3e>
80006d10:	58 38       	cp.w	r8,3
80006d12:	c3 d0       	breq	80006d8c <udc_req_std_dev_get_descriptor+0x9c>
80006d14:	58 18       	cp.w	r8,1
80006d16:	c4 41       	brne	80006d9e <udc_req_std_dev_get_descriptor+0xae>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
80006d18:	4a c8       	lddpc	r8,80006dc8 <udc_req_std_dev_get_descriptor+0xd8>
80006d1a:	70 08       	ld.w	r8,r8[0x0]
80006d1c:	11 88       	ld.ub	r8,r8[0x0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
80006d1e:	10 99       	mov	r9,r8
80006d20:	4a a8       	lddpc	r8,80006dc8 <udc_req_std_dev_get_descriptor+0xd8>
80006d22:	70 08       	ld.w	r8,r8[0x0]
80006d24:	12 9b       	mov	r11,r9
80006d26:	10 9c       	mov	r12,r8
80006d28:	f0 1f 00 29 	mcall	80006dcc <udc_req_std_dev_get_descriptor+0xdc>
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
		}
		break;
80006d2c:	c3 c8       	rjmp	80006da4 <udc_req_std_dev_get_descriptor+0xb4>
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
80006d2e:	4a 78       	lddpc	r8,80006dc8 <udc_req_std_dev_get_descriptor+0xd8>
80006d30:	70 08       	ld.w	r8,r8[0x0]
80006d32:	f1 38 00 11 	ld.ub	r8,r8[17]
80006d36:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006d3a:	f0 09 18 00 	cp.b	r9,r8
80006d3e:	c0 33       	brcs	80006d44 <udc_req_std_dev_get_descriptor+0x54>
					bNumConfigurations) {
				return false;
80006d40:	30 08       	mov	r8,0
80006d42:	c3 d8       	rjmp	80006dbc <udc_req_std_dev_get_descriptor+0xcc>
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
80006d44:	4a 18       	lddpc	r8,80006dc8 <udc_req_std_dev_get_descriptor+0xd8>
80006d46:	70 19       	ld.w	r9,r8[0x4]
80006d48:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006d4c:	a3 78       	lsl	r8,0x3
80006d4e:	f2 08 00 08 	add	r8,r9,r8
80006d52:	70 08       	ld.w	r8,r8[0x0]
80006d54:	11 a9       	ld.ub	r9,r8[0x2]
80006d56:	a9 69       	lsl	r9,0x8
80006d58:	11 b8       	ld.ub	r8,r8[0x3]
80006d5a:	12 48       	or	r8,r9
80006d5c:	5c 88       	casts.h	r8
80006d5e:	5c 88       	casts.h	r8
80006d60:	5c c8       	swap.bh	r8
80006d62:	5c 88       	casts.h	r8
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
80006d64:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
80006d68:	49 88       	lddpc	r8,80006dc8 <udc_req_std_dev_get_descriptor+0xd8>
80006d6a:	70 1a       	ld.w	r10,r8[0x4]
80006d6c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006d70:	a3 78       	lsl	r8,0x3
80006d72:	f4 08 00 08 	add	r8,r10,r8
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
80006d76:	70 08       	ld.w	r8,r8[0x0]
80006d78:	12 9b       	mov	r11,r9
80006d7a:	10 9c       	mov	r12,r8
80006d7c:	f0 1f 00 14 	mcall	80006dcc <udc_req_std_dev_get_descriptor+0xdc>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
80006d80:	49 18       	lddpc	r8,80006dc4 <udc_req_std_dev_get_descriptor+0xd4>
80006d82:	70 28       	ld.w	r8,r8[0x8]
80006d84:	10 99       	mov	r9,r8
80006d86:	30 28       	mov	r8,2
80006d88:	b2 98       	st.b	r9[0x1],r8
				USB_DT_CONFIGURATION;
		break;
80006d8a:	c0 d8       	rjmp	80006da4 <udc_req_std_dev_get_descriptor+0xb4>
		break;
#endif

	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
80006d8c:	f0 1f 00 11 	mcall	80006dd0 <udc_req_std_dev_get_descriptor+0xe0>
80006d90:	18 98       	mov	r8,r12
80006d92:	ec 18 00 01 	eorl	r8,0x1
80006d96:	5c 58       	castu.b	r8
80006d98:	c0 50       	breq	80006da2 <udc_req_std_dev_get_descriptor+0xb2>
			return false;
80006d9a:	30 08       	mov	r8,0
80006d9c:	c1 08       	rjmp	80006dbc <udc_req_std_dev_get_descriptor+0xcc>
		}
		break;

	default:
		// Unknown descriptor requested
		return false;
80006d9e:	30 08       	mov	r8,0
80006da0:	c0 e8       	rjmp	80006dbc <udc_req_std_dev_get_descriptor+0xcc>
	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
			return false;
		}
		break;
80006da2:	d7 03       	nop
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
80006da4:	48 88       	lddpc	r8,80006dc4 <udc_req_std_dev_get_descriptor+0xd4>
80006da6:	90 39       	ld.sh	r9,r8[0x6]
80006da8:	48 78       	lddpc	r8,80006dc4 <udc_req_std_dev_get_descriptor+0xd4>
80006daa:	90 68       	ld.sh	r8,r8[0xc]
80006dac:	f0 09 19 00 	cp.h	r9,r8
80006db0:	c0 52       	brcc	80006dba <udc_req_std_dev_get_descriptor+0xca>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
80006db2:	48 58       	lddpc	r8,80006dc4 <udc_req_std_dev_get_descriptor+0xd4>
80006db4:	90 38       	ld.sh	r8,r8[0x6]
80006db6:	48 49       	lddpc	r9,80006dc4 <udc_req_std_dev_get_descriptor+0xd4>
80006db8:	b2 68       	st.h	r9[0xc],r8
	}
	return true;
80006dba:	30 18       	mov	r8,1
}
80006dbc:	10 9c       	mov	r12,r8
80006dbe:	2f fd       	sub	sp,-4
80006dc0:	e3 cd 80 80 	ldm	sp++,r7,pc
80006dc4:	00 00       	add	r0,r0
80006dc6:	46 48       	lddsp	r8,sp[0x190]
80006dc8:	00 00       	add	r0,r0
80006dca:	00 9c       	mov	r12,r0
80006dcc:	80 00       	ld.sh	r0,r0[0x0]
80006dce:	35 9c       	mov	r12,89
80006dd0:	80 00       	ld.sh	r0,r0[0x0]
80006dd2:	6b f0       	ld.w	r0,r5[0x7c]

80006dd4 <udc_req_std_dev_get_configuration>:
 * \brief Standard device request to get configuration number
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
80006dd4:	eb cd 40 80 	pushm	r7,lr
80006dd8:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength != 1) {
80006dda:	48 98       	lddpc	r8,80006dfc <udc_req_std_dev_get_configuration+0x28>
80006ddc:	90 39       	ld.sh	r9,r8[0x6]
80006dde:	30 18       	mov	r8,1
80006de0:	f0 09 19 00 	cp.h	r9,r8
80006de4:	c0 30       	breq	80006dea <udc_req_std_dev_get_configuration+0x16>
		return false;
80006de6:	30 08       	mov	r8,0
80006de8:	c0 68       	rjmp	80006df4 <udc_req_std_dev_get_configuration+0x20>
	}

	udd_set_setup_payload(&udc_num_configuration,1);
80006dea:	30 1b       	mov	r11,1
80006dec:	48 5c       	lddpc	r12,80006e00 <udc_req_std_dev_get_configuration+0x2c>
80006dee:	f0 1f 00 06 	mcall	80006e04 <udc_req_std_dev_get_configuration+0x30>
	return true;
80006df2:	30 18       	mov	r8,1
}
80006df4:	10 9c       	mov	r12,r8
80006df6:	e3 cd 80 80 	ldm	sp++,r7,pc
80006dfa:	00 00       	add	r0,r0
80006dfc:	00 00       	add	r0,r0
80006dfe:	46 48       	lddsp	r8,sp[0x190]
80006e00:	00 00       	add	r0,r0
80006e02:	07 26       	ld.uh	r6,r3++
80006e04:	80 00       	ld.sh	r0,r0[0x0]
80006e06:	35 9c       	mov	r12,89

80006e08 <udc_req_std_dev_set_configuration>:
 * \brief Standard device request to enable a configuration
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_configuration(void)
{
80006e08:	eb cd 40 80 	pushm	r7,lr
80006e0c:	1a 97       	mov	r7,sp
80006e0e:	20 1d       	sub	sp,4
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
80006e10:	4a b8       	lddpc	r8,80006ebc <udc_req_std_dev_set_configuration+0xb4>
80006e12:	90 38       	ld.sh	r8,r8[0x6]
80006e14:	58 08       	cp.w	r8,0
80006e16:	c0 30       	breq	80006e1c <udc_req_std_dev_set_configuration+0x14>
		return false;
80006e18:	30 08       	mov	r8,0
80006e1a:	c4 c8       	rjmp	80006eb2 <udc_req_std_dev_set_configuration+0xaa>
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
80006e1c:	f0 1f 00 29 	mcall	80006ec0 <udc_req_std_dev_set_configuration+0xb8>
80006e20:	18 98       	mov	r8,r12
80006e22:	58 08       	cp.w	r8,0
80006e24:	c0 31       	brne	80006e2a <udc_req_std_dev_set_configuration+0x22>
		return false;
80006e26:	30 08       	mov	r8,0
80006e28:	c4 58       	rjmp	80006eb2 <udc_req_std_dev_set_configuration+0xaa>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80006e2a:	4a 58       	lddpc	r8,80006ebc <udc_req_std_dev_set_configuration+0xb4>
80006e2c:	90 18       	ld.sh	r8,r8[0x2]
80006e2e:	5c 78       	castu.h	r8
80006e30:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
				udc_config.confdev_lsfs->bNumConfigurations) {
80006e34:	4a 48       	lddpc	r8,80006ec4 <udc_req_std_dev_set_configuration+0xbc>
80006e36:	70 08       	ld.w	r8,r8[0x0]
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80006e38:	f1 38 00 11 	ld.ub	r8,r8[17]
80006e3c:	10 39       	cp.w	r9,r8
80006e3e:	e0 8a 00 04 	brle	80006e46 <udc_req_std_dev_set_configuration+0x3e>
				udc_config.confdev_lsfs->bNumConfigurations) {
			return false;
80006e42:	30 08       	mov	r8,0
80006e44:	c3 78       	rjmp	80006eb2 <udc_req_std_dev_set_configuration+0xaa>
		}
	}

	// Reset current configuration
	udc_reset();
80006e46:	f0 1f 00 21 	mcall	80006ec8 <udc_req_std_dev_set_configuration+0xc0>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
80006e4a:	49 d8       	lddpc	r8,80006ebc <udc_req_std_dev_set_configuration+0xb4>
80006e4c:	90 18       	ld.sh	r8,r8[0x2]
80006e4e:	5c 58       	castu.b	r8
80006e50:	49 f9       	lddpc	r9,80006ecc <udc_req_std_dev_set_configuration+0xc4>
80006e52:	b2 88       	st.b	r9[0x0],r8
	if (udc_num_configuration == 0) {
80006e54:	49 e8       	lddpc	r8,80006ecc <udc_req_std_dev_set_configuration+0xc4>
80006e56:	11 88       	ld.ub	r8,r8[0x0]
80006e58:	58 08       	cp.w	r8,0
80006e5a:	c0 31       	brne	80006e60 <udc_req_std_dev_set_configuration+0x58>
		return true; // Default empty configuration requested
80006e5c:	30 18       	mov	r8,1
80006e5e:	c2 a8       	rjmp	80006eb2 <udc_req_std_dev_set_configuration+0xaa>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
80006e60:	49 98       	lddpc	r8,80006ec4 <udc_req_std_dev_set_configuration+0xbc>
80006e62:	70 19       	ld.w	r9,r8[0x4]
80006e64:	49 a8       	lddpc	r8,80006ecc <udc_req_std_dev_set_configuration+0xc4>
80006e66:	11 88       	ld.ub	r8,r8[0x0]
80006e68:	20 18       	sub	r8,1
80006e6a:	a3 78       	lsl	r8,0x3
80006e6c:	10 09       	add	r9,r8
80006e6e:	49 98       	lddpc	r8,80006ed0 <udc_req_std_dev_set_configuration+0xc8>
80006e70:	91 09       	st.w	r8[0x0],r9
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80006e72:	30 08       	mov	r8,0
80006e74:	ef 68 ff ff 	st.b	r7[-1],r8
80006e78:	c1 38       	rjmp	80006e9e <udc_req_std_dev_set_configuration+0x96>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
80006e7a:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006e7e:	30 0b       	mov	r11,0
80006e80:	10 9c       	mov	r12,r8
80006e82:	f0 1f 00 15 	mcall	80006ed4 <udc_req_std_dev_set_configuration+0xcc>
80006e86:	18 98       	mov	r8,r12
80006e88:	ec 18 00 01 	eorl	r8,0x1
80006e8c:	5c 58       	castu.b	r8
80006e8e:	c0 30       	breq	80006e94 <udc_req_std_dev_set_configuration+0x8c>
			return false;
80006e90:	30 08       	mov	r8,0
80006e92:	c1 08       	rjmp	80006eb2 <udc_req_std_dev_set_configuration+0xaa>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
80006e94:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006e98:	2f f8       	sub	r8,-1
80006e9a:	ef 68 ff ff 	st.b	r7[-1],r8
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80006e9e:	48 d8       	lddpc	r8,80006ed0 <udc_req_std_dev_set_configuration+0xc8>
80006ea0:	70 08       	ld.w	r8,r8[0x0]
80006ea2:	70 08       	ld.w	r8,r8[0x0]
80006ea4:	11 c8       	ld.ub	r8,r8[0x4]
80006ea6:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006eaa:	f0 09 18 00 	cp.b	r9,r8
80006eae:	ce 63       	brcs	80006e7a <udc_req_std_dev_set_configuration+0x72>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
			return false;
		}
	}
	return true;
80006eb0:	30 18       	mov	r8,1
}
80006eb2:	10 9c       	mov	r12,r8
80006eb4:	2f fd       	sub	sp,-4
80006eb6:	e3 cd 80 80 	ldm	sp++,r7,pc
80006eba:	00 00       	add	r0,r0
80006ebc:	00 00       	add	r0,r0
80006ebe:	46 48       	lddsp	r8,sp[0x190]
80006ec0:	80 00       	ld.sh	r0,r0[0x0]
80006ec2:	35 50       	mov	r0,85
80006ec4:	00 00       	add	r0,r0
80006ec6:	00 9c       	mov	r12,r0
80006ec8:	80 00       	ld.sh	r0,r0[0x0]
80006eca:	69 54       	ld.w	r4,r4[0x54]
80006ecc:	00 00       	add	r0,r0
80006ece:	07 26       	ld.uh	r6,r3++
80006ed0:	00 00       	add	r0,r0
80006ed2:	07 28       	ld.uh	r8,r3++
80006ed4:	80 00       	ld.sh	r0,r0[0x0]
80006ed6:	68 78       	ld.w	r8,r4[0x1c]

80006ed8 <udc_req_std_iface_get_setting>:
 * to get the alternate setting number of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_get_setting(void)
{
80006ed8:	eb cd 40 80 	pushm	r7,lr
80006edc:	1a 97       	mov	r7,sp
80006ede:	20 2d       	sub	sp,8
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
80006ee0:	4a 38       	lddpc	r8,80006f6c <udc_req_std_iface_get_setting+0x94>
80006ee2:	90 39       	ld.sh	r9,r8[0x6]
80006ee4:	30 18       	mov	r8,1
80006ee6:	f0 09 19 00 	cp.h	r9,r8
80006eea:	c0 30       	breq	80006ef0 <udc_req_std_iface_get_setting+0x18>
		return false; // Error in request
80006eec:	30 08       	mov	r8,0
80006eee:	c3 a8       	rjmp	80006f62 <udc_req_std_iface_get_setting+0x8a>
	}
	if (!udc_num_configuration) {
80006ef0:	4a 08       	lddpc	r8,80006f70 <udc_req_std_iface_get_setting+0x98>
80006ef2:	11 88       	ld.ub	r8,r8[0x0]
80006ef4:	58 08       	cp.w	r8,0
80006ef6:	c0 31       	brne	80006efc <udc_req_std_iface_get_setting+0x24>
		return false; // The device is not is configured state yet
80006ef8:	30 08       	mov	r8,0
80006efa:	c3 48       	rjmp	80006f62 <udc_req_std_iface_get_setting+0x8a>
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80006efc:	49 c8       	lddpc	r8,80006f6c <udc_req_std_iface_get_setting+0x94>
80006efe:	90 28       	ld.sh	r8,r8[0x4]
80006f00:	ef 68 ff fb 	st.b	r7[-5],r8
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
80006f04:	49 c8       	lddpc	r8,80006f74 <udc_req_std_iface_get_setting+0x9c>
80006f06:	70 08       	ld.w	r8,r8[0x0]
80006f08:	70 08       	ld.w	r8,r8[0x0]
80006f0a:	11 c8       	ld.ub	r8,r8[0x4]
80006f0c:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80006f10:	f0 09 18 00 	cp.b	r9,r8
80006f14:	c0 33       	brcs	80006f1a <udc_req_std_iface_get_setting+0x42>
		return false;
80006f16:	30 08       	mov	r8,0
80006f18:	c2 58       	rjmp	80006f62 <udc_req_std_iface_get_setting+0x8a>
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
80006f1a:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006f1e:	30 0b       	mov	r11,0
80006f20:	10 9c       	mov	r12,r8
80006f22:	f0 1f 00 16 	mcall	80006f78 <udc_req_std_iface_get_setting+0xa0>
80006f26:	18 98       	mov	r8,r12
80006f28:	ec 18 00 01 	eorl	r8,0x1
80006f2c:	5c 58       	castu.b	r8
80006f2e:	c0 30       	breq	80006f34 <udc_req_std_iface_get_setting+0x5c>
		return false;
80006f30:	30 08       	mov	r8,0
80006f32:	c1 88       	rjmp	80006f62 <udc_req_std_iface_get_setting+0x8a>
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80006f34:	49 08       	lddpc	r8,80006f74 <udc_req_std_iface_get_setting+0x9c>
80006f36:	70 08       	ld.w	r8,r8[0x0]
80006f38:	70 19       	ld.w	r9,r8[0x4]
80006f3a:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006f3e:	a3 68       	lsl	r8,0x2
80006f40:	f2 08 00 08 	add	r8,r9,r8
80006f44:	70 08       	ld.w	r8,r8[0x0]
80006f46:	ef 48 ff fc 	st.w	r7[-4],r8
	udc_iface_setting = udi_api->getsetting();
80006f4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006f4e:	70 38       	ld.w	r8,r8[0xc]
80006f50:	5d 18       	icall	r8
80006f52:	18 98       	mov	r8,r12
80006f54:	48 a9       	lddpc	r9,80006f7c <udc_req_std_iface_get_setting+0xa4>
80006f56:	b2 88       	st.b	r9[0x0],r8

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
80006f58:	30 1b       	mov	r11,1
80006f5a:	48 9c       	lddpc	r12,80006f7c <udc_req_std_iface_get_setting+0xa4>
80006f5c:	f0 1f 00 09 	mcall	80006f80 <udc_req_std_iface_get_setting+0xa8>
	return true;
80006f60:	30 18       	mov	r8,1
}
80006f62:	10 9c       	mov	r12,r8
80006f64:	2f ed       	sub	sp,-8
80006f66:	e3 cd 80 80 	ldm	sp++,r7,pc
80006f6a:	00 00       	add	r0,r0
80006f6c:	00 00       	add	r0,r0
80006f6e:	46 48       	lddsp	r8,sp[0x190]
80006f70:	00 00       	add	r0,r0
80006f72:	07 26       	ld.uh	r6,r3++
80006f74:	00 00       	add	r0,r0
80006f76:	07 28       	ld.uh	r8,r3++
80006f78:	80 00       	ld.sh	r0,r0[0x0]
80006f7a:	67 04       	ld.w	r4,r3[0x40]
80006f7c:	00 00       	add	r0,r0
80006f7e:	07 30       	ld.ub	r0,r3++
80006f80:	80 00       	ld.sh	r0,r0[0x0]
80006f82:	35 9c       	mov	r12,89

80006f84 <udc_req_std_iface_set_setting>:
 * to set an alternate setting of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_set_setting(void)
{
80006f84:	eb cd 40 80 	pushm	r7,lr
80006f88:	1a 97       	mov	r7,sp
80006f8a:	20 1d       	sub	sp,4
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
80006f8c:	49 78       	lddpc	r8,80006fe8 <udc_req_std_iface_set_setting+0x64>
80006f8e:	90 38       	ld.sh	r8,r8[0x6]
80006f90:	58 08       	cp.w	r8,0
80006f92:	c0 30       	breq	80006f98 <udc_req_std_iface_set_setting+0x14>
		return false; // Error in request
80006f94:	30 08       	mov	r8,0
80006f96:	c2 48       	rjmp	80006fde <udc_req_std_iface_set_setting+0x5a>
	}
	if (!udc_num_configuration) {
80006f98:	49 58       	lddpc	r8,80006fec <udc_req_std_iface_set_setting+0x68>
80006f9a:	11 88       	ld.ub	r8,r8[0x0]
80006f9c:	58 08       	cp.w	r8,0
80006f9e:	c0 31       	brne	80006fa4 <udc_req_std_iface_set_setting+0x20>
		return false; // The device is not is configured state yet
80006fa0:	30 08       	mov	r8,0
80006fa2:	c1 e8       	rjmp	80006fde <udc_req_std_iface_set_setting+0x5a>
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80006fa4:	49 18       	lddpc	r8,80006fe8 <udc_req_std_iface_set_setting+0x64>
80006fa6:	90 28       	ld.sh	r8,r8[0x4]
80006fa8:	ef 68 ff fe 	st.b	r7[-2],r8
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
80006fac:	48 f8       	lddpc	r8,80006fe8 <udc_req_std_iface_set_setting+0x64>
80006fae:	90 18       	ld.sh	r8,r8[0x2]
80006fb0:	ef 68 ff ff 	st.b	r7[-1],r8

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
80006fb4:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80006fb8:	10 9c       	mov	r12,r8
80006fba:	f0 1f 00 0e 	mcall	80006ff0 <udc_req_std_iface_set_setting+0x6c>
80006fbe:	18 98       	mov	r8,r12
80006fc0:	ec 18 00 01 	eorl	r8,0x1
80006fc4:	5c 58       	castu.b	r8
80006fc6:	c0 30       	breq	80006fcc <udc_req_std_iface_set_setting+0x48>
		return false;
80006fc8:	30 08       	mov	r8,0
80006fca:	c0 a8       	rjmp	80006fde <udc_req_std_iface_set_setting+0x5a>
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
80006fcc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006fd0:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80006fd4:	12 9b       	mov	r11,r9
80006fd6:	10 9c       	mov	r12,r8
80006fd8:	f0 1f 00 07 	mcall	80006ff4 <udc_req_std_iface_set_setting+0x70>
80006fdc:	18 98       	mov	r8,r12
}
80006fde:	10 9c       	mov	r12,r8
80006fe0:	2f fd       	sub	sp,-4
80006fe2:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fe6:	00 00       	add	r0,r0
80006fe8:	00 00       	add	r0,r0
80006fea:	46 48       	lddsp	r8,sp[0x190]
80006fec:	00 00       	add	r0,r0
80006fee:	07 26       	ld.uh	r6,r3++
80006ff0:	80 00       	ld.sh	r0,r0[0x0]
80006ff2:	67 bc       	ld.w	r12,r3[0x6c]
80006ff4:	80 00       	ld.sh	r0,r0[0x0]
80006ff6:	68 78       	ld.w	r8,r4[0x1c]

80006ff8 <udc_reqstd>:
 * \brief Main routine to manage the standard USB SETUP request
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
80006ff8:	eb cd 40 80 	pushm	r7,lr
80006ffc:	1a 97       	mov	r7,sp
	if (Udd_setup_is_in()) {
80006ffe:	4c 78       	lddpc	r8,80007118 <udc_reqstd+0x120>
80007000:	11 88       	ld.ub	r8,r8[0x0]
80007002:	10 99       	mov	r9,r8
80007004:	30 08       	mov	r8,0
80007006:	f0 09 18 00 	cp.b	r9,r8
8000700a:	c3 c4       	brge	80007082 <udc_reqstd+0x8a>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
8000700c:	4c 38       	lddpc	r8,80007118 <udc_reqstd+0x120>
8000700e:	90 38       	ld.sh	r8,r8[0x6]
80007010:	58 08       	cp.w	r8,0
80007012:	c0 31       	brne	80007018 <udc_reqstd+0x20>
			return false; // Error for USB host
80007014:	30 08       	mov	r8,0
80007016:	c7 d8       	rjmp	80007110 <udc_reqstd+0x118>
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80007018:	4c 08       	lddpc	r8,80007118 <udc_reqstd+0x120>
8000701a:	11 88       	ld.ub	r8,r8[0x0]
8000701c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80007020:	c1 51       	brne	8000704a <udc_reqstd+0x52>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80007022:	4b e8       	lddpc	r8,80007118 <udc_reqstd+0x120>
80007024:	11 98       	ld.ub	r8,r8[0x1]
80007026:	58 68       	cp.w	r8,6
80007028:	c0 90       	breq	8000703a <udc_reqstd+0x42>
8000702a:	58 88       	cp.w	r8,8
8000702c:	c0 b0       	breq	80007042 <udc_reqstd+0x4a>
8000702e:	58 08       	cp.w	r8,0
80007030:	c0 d1       	brne	8000704a <udc_reqstd+0x52>
			case USB_REQ_GET_STATUS:
				return udc_req_std_dev_get_status();
80007032:	f0 1f 00 3b 	mcall	8000711c <udc_reqstd+0x124>
80007036:	18 98       	mov	r8,r12
80007038:	c6 c8       	rjmp	80007110 <udc_reqstd+0x118>
			case USB_REQ_GET_DESCRIPTOR:
				return udc_req_std_dev_get_descriptor();
8000703a:	f0 1f 00 3a 	mcall	80007120 <udc_reqstd+0x128>
8000703e:	18 98       	mov	r8,r12
80007040:	c6 88       	rjmp	80007110 <udc_reqstd+0x118>
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
80007042:	f0 1f 00 39 	mcall	80007124 <udc_reqstd+0x12c>
80007046:	18 98       	mov	r8,r12
80007048:	c6 48       	rjmp	80007110 <udc_reqstd+0x118>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
8000704a:	4b 48       	lddpc	r8,80007118 <udc_reqstd+0x120>
8000704c:	11 88       	ld.ub	r8,r8[0x0]
8000704e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80007052:	58 18       	cp.w	r8,1
80007054:	c0 91       	brne	80007066 <udc_reqstd+0x6e>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80007056:	4b 18       	lddpc	r8,80007118 <udc_reqstd+0x120>
80007058:	11 98       	ld.ub	r8,r8[0x1]
8000705a:	58 a8       	cp.w	r8,10
8000705c:	c0 51       	brne	80007066 <udc_reqstd+0x6e>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
8000705e:	f0 1f 00 33 	mcall	80007128 <udc_reqstd+0x130>
80007062:	18 98       	mov	r8,r12
80007064:	c5 68       	rjmp	80007110 <udc_reqstd+0x118>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80007066:	4a d8       	lddpc	r8,80007118 <udc_reqstd+0x120>
80007068:	11 88       	ld.ub	r8,r8[0x0]
8000706a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000706e:	58 28       	cp.w	r8,2
80007070:	c4 f1       	brne	8000710e <udc_reqstd+0x116>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80007072:	4a a8       	lddpc	r8,80007118 <udc_reqstd+0x120>
80007074:	11 98       	ld.ub	r8,r8[0x1]
80007076:	58 08       	cp.w	r8,0
80007078:	c4 b1       	brne	8000710e <udc_reqstd+0x116>
			case USB_REQ_GET_STATUS:
				return udc_req_std_ep_get_status();
8000707a:	f0 1f 00 2d 	mcall	8000712c <udc_reqstd+0x134>
8000707e:	18 98       	mov	r8,r12
80007080:	c4 88       	rjmp	80007110 <udc_reqstd+0x118>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
80007082:	4a 68       	lddpc	r8,80007118 <udc_reqstd+0x120>
80007084:	11 88       	ld.ub	r8,r8[0x0]
80007086:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000708a:	c1 f1       	brne	800070c8 <udc_reqstd+0xd0>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
8000708c:	4a 38       	lddpc	r8,80007118 <udc_reqstd+0x120>
8000708e:	11 98       	ld.ub	r8,r8[0x1]
80007090:	58 38       	cp.w	r8,3
80007092:	c1 30       	breq	800070b8 <udc_reqstd+0xc0>
80007094:	e0 89 00 05 	brgt	8000709e <udc_reqstd+0xa6>
80007098:	58 18       	cp.w	r8,1
8000709a:	c0 b0       	breq	800070b0 <udc_reqstd+0xb8>
8000709c:	c1 68       	rjmp	800070c8 <udc_reqstd+0xd0>
8000709e:	58 58       	cp.w	r8,5
800070a0:	c0 40       	breq	800070a8 <udc_reqstd+0xb0>
800070a2:	58 98       	cp.w	r8,9
800070a4:	c0 e0       	breq	800070c0 <udc_reqstd+0xc8>
800070a6:	c1 18       	rjmp	800070c8 <udc_reqstd+0xd0>
			case USB_REQ_SET_ADDRESS:
				return udc_req_std_dev_set_address();
800070a8:	f0 1f 00 22 	mcall	80007130 <udc_reqstd+0x138>
800070ac:	18 98       	mov	r8,r12
800070ae:	c3 18       	rjmp	80007110 <udc_reqstd+0x118>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_dev_clear_feature();
800070b0:	f0 1f 00 21 	mcall	80007134 <udc_reqstd+0x13c>
800070b4:	18 98       	mov	r8,r12
800070b6:	c2 d8       	rjmp	80007110 <udc_reqstd+0x118>
			case USB_REQ_SET_FEATURE:
				return udc_req_std_dev_set_feature();
800070b8:	f0 1f 00 20 	mcall	80007138 <udc_reqstd+0x140>
800070bc:	18 98       	mov	r8,r12
800070be:	c2 98       	rjmp	80007110 <udc_reqstd+0x118>
			case USB_REQ_SET_CONFIGURATION:
				return udc_req_std_dev_set_configuration();
800070c0:	f0 1f 00 1f 	mcall	8000713c <udc_reqstd+0x144>
800070c4:	18 98       	mov	r8,r12
800070c6:	c2 58       	rjmp	80007110 <udc_reqstd+0x118>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
800070c8:	49 48       	lddpc	r8,80007118 <udc_reqstd+0x120>
800070ca:	11 88       	ld.ub	r8,r8[0x0]
800070cc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800070d0:	58 18       	cp.w	r8,1
800070d2:	c0 91       	brne	800070e4 <udc_reqstd+0xec>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
800070d4:	49 18       	lddpc	r8,80007118 <udc_reqstd+0x120>
800070d6:	11 98       	ld.ub	r8,r8[0x1]
800070d8:	58 b8       	cp.w	r8,11
800070da:	c0 51       	brne	800070e4 <udc_reqstd+0xec>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
800070dc:	f0 1f 00 19 	mcall	80007140 <udc_reqstd+0x148>
800070e0:	18 98       	mov	r8,r12
800070e2:	c1 78       	rjmp	80007110 <udc_reqstd+0x118>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
800070e4:	48 d8       	lddpc	r8,80007118 <udc_reqstd+0x120>
800070e6:	11 88       	ld.ub	r8,r8[0x0]
800070e8:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800070ec:	58 28       	cp.w	r8,2
800070ee:	c1 01       	brne	8000710e <udc_reqstd+0x116>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
800070f0:	48 a8       	lddpc	r8,80007118 <udc_reqstd+0x120>
800070f2:	11 98       	ld.ub	r8,r8[0x1]
800070f4:	58 18       	cp.w	r8,1
800070f6:	c0 40       	breq	800070fe <udc_reqstd+0x106>
800070f8:	58 38       	cp.w	r8,3
800070fa:	c0 60       	breq	80007106 <udc_reqstd+0x10e>
800070fc:	c0 98       	rjmp	8000710e <udc_reqstd+0x116>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_ep_clear_feature();
800070fe:	f0 1f 00 12 	mcall	80007144 <udc_reqstd+0x14c>
80007102:	18 98       	mov	r8,r12
80007104:	c0 68       	rjmp	80007110 <udc_reqstd+0x118>
			case USB_REQ_SET_FEATURE:
				return udc_req_std_ep_set_feature();
80007106:	f0 1f 00 11 	mcall	80007148 <udc_reqstd+0x150>
8000710a:	18 98       	mov	r8,r12
8000710c:	c0 28       	rjmp	80007110 <udc_reqstd+0x118>
				break;
			}
		}
#endif
	}
	return false;
8000710e:	30 08       	mov	r8,0
}
80007110:	10 9c       	mov	r12,r8
80007112:	e3 cd 80 80 	ldm	sp++,r7,pc
80007116:	00 00       	add	r0,r0
80007118:	00 00       	add	r0,r0
8000711a:	46 48       	lddsp	r8,sp[0x190]
8000711c:	80 00       	ld.sh	r0,r0[0x0]
8000711e:	6a 24       	ld.w	r4,r5[0x8]
80007120:	80 00       	ld.sh	r0,r0[0x0]
80007122:	6c f0       	ld.w	r0,r6[0x3c]
80007124:	80 00       	ld.sh	r0,r0[0x0]
80007126:	6d d4       	ld.w	r4,r6[0x74]
80007128:	80 00       	ld.sh	r0,r0[0x0]
8000712a:	6e d8       	ld.w	r8,r7[0x34]
8000712c:	80 00       	ld.sh	r0,r0[0x0]
8000712e:	6a 58       	ld.w	r8,r5[0x14]
80007130:	80 00       	ld.sh	r0,r0[0x0]
80007132:	6b c8       	ld.w	r8,r5[0x70]
80007134:	80 00       	ld.sh	r0,r0[0x0]
80007136:	6a b0       	ld.w	r0,r5[0x2c]
80007138:	80 00       	ld.sh	r0,r0[0x0]
8000713a:	6b 2c       	ld.w	r12,r5[0x48]
8000713c:	80 00       	ld.sh	r0,r0[0x0]
8000713e:	6e 08       	ld.w	r8,r7[0x0]
80007140:	80 00       	ld.sh	r0,r0[0x0]
80007142:	6f 84       	ld.w	r4,r7[0x60]
80007144:	80 00       	ld.sh	r0,r0[0x0]
80007146:	6a f0       	ld.w	r0,r5[0x3c]
80007148:	80 00       	ld.sh	r0,r0[0x0]
8000714a:	6b 58       	ld.w	r8,r5[0x54]

8000714c <udc_req_iface>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_iface(void)
{
8000714c:	eb cd 40 80 	pushm	r7,lr
80007150:	1a 97       	mov	r7,sp
80007152:	20 2d       	sub	sp,8
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
80007154:	4a 58       	lddpc	r8,800071e8 <udc_req_iface+0x9c>
80007156:	11 88       	ld.ub	r8,r8[0x0]
80007158:	58 08       	cp.w	r8,0
8000715a:	c0 31       	brne	80007160 <udc_req_iface+0x14>
		return false; // The device is not is configured state yet
8000715c:	30 08       	mov	r8,0
8000715e:	c4 08       	rjmp	800071de <udc_req_iface+0x92>
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80007160:	4a 38       	lddpc	r8,800071ec <udc_req_iface+0xa0>
80007162:	90 28       	ld.sh	r8,r8[0x4]
80007164:	ef 68 ff fb 	st.b	r7[-5],r8
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
80007168:	4a 28       	lddpc	r8,800071f0 <udc_req_iface+0xa4>
8000716a:	70 08       	ld.w	r8,r8[0x0]
8000716c:	70 08       	ld.w	r8,r8[0x0]
8000716e:	11 c8       	ld.ub	r8,r8[0x4]
80007170:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80007174:	f0 09 18 00 	cp.b	r9,r8
80007178:	c0 33       	brcs	8000717e <udc_req_iface+0x32>
		return false;
8000717a:	30 08       	mov	r8,0
8000717c:	c3 18       	rjmp	800071de <udc_req_iface+0x92>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
8000717e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80007182:	30 0b       	mov	r11,0
80007184:	10 9c       	mov	r12,r8
80007186:	f0 1f 00 1c 	mcall	800071f4 <udc_req_iface+0xa8>
8000718a:	18 98       	mov	r8,r12
8000718c:	ec 18 00 01 	eorl	r8,0x1
80007190:	5c 58       	castu.b	r8
80007192:	c0 30       	breq	80007198 <udc_req_iface+0x4c>
		return false;
80007194:	30 08       	mov	r8,0
80007196:	c2 48       	rjmp	800071de <udc_req_iface+0x92>
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80007198:	49 68       	lddpc	r8,800071f0 <udc_req_iface+0xa4>
8000719a:	70 08       	ld.w	r8,r8[0x0]
8000719c:	70 19       	ld.w	r9,r8[0x4]
8000719e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800071a2:	a3 68       	lsl	r8,0x2
800071a4:	f2 08 00 08 	add	r8,r9,r8
800071a8:	70 08       	ld.w	r8,r8[0x0]
800071aa:	ef 48 ff fc 	st.w	r7[-4],r8
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
800071ae:	ee f8 ff fc 	ld.w	r8,r7[-4]
800071b2:	70 38       	ld.w	r8,r8[0xc]
800071b4:	5d 18       	icall	r8
800071b6:	18 98       	mov	r8,r12
800071b8:	10 99       	mov	r9,r8
800071ba:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800071be:	12 9b       	mov	r11,r9
800071c0:	10 9c       	mov	r12,r8
800071c2:	f0 1f 00 0d 	mcall	800071f4 <udc_req_iface+0xa8>
800071c6:	18 98       	mov	r8,r12
800071c8:	ec 18 00 01 	eorl	r8,0x1
800071cc:	5c 58       	castu.b	r8
800071ce:	c0 30       	breq	800071d4 <udc_req_iface+0x88>
		return false;
800071d0:	30 08       	mov	r8,0
800071d2:	c0 68       	rjmp	800071de <udc_req_iface+0x92>
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
800071d4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800071d8:	70 28       	ld.w	r8,r8[0x8]
800071da:	5d 18       	icall	r8
800071dc:	18 98       	mov	r8,r12
}
800071de:	10 9c       	mov	r12,r8
800071e0:	2f ed       	sub	sp,-8
800071e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800071e6:	00 00       	add	r0,r0
800071e8:	00 00       	add	r0,r0
800071ea:	07 26       	ld.uh	r6,r3++
800071ec:	00 00       	add	r0,r0
800071ee:	46 48       	lddsp	r8,sp[0x190]
800071f0:	00 00       	add	r0,r0
800071f2:	07 28       	ld.uh	r8,r3++
800071f4:	80 00       	ld.sh	r0,r0[0x0]
800071f6:	67 04       	ld.w	r4,r3[0x40]

800071f8 <udc_req_ep>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_ep(void)
{
800071f8:	eb cd 40 80 	pushm	r7,lr
800071fc:	1a 97       	mov	r7,sp
800071fe:	20 2d       	sub	sp,8
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
80007200:	4a 48       	lddpc	r8,80007290 <udc_req_ep+0x98>
80007202:	11 88       	ld.ub	r8,r8[0x0]
80007204:	58 08       	cp.w	r8,0
80007206:	c0 31       	brne	8000720c <udc_req_ep+0x14>
		return false; // The device is not is configured state yet
80007208:	30 08       	mov	r8,0
8000720a:	c3 f8       	rjmp	80007288 <udc_req_ep+0x90>
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
8000720c:	4a 28       	lddpc	r8,80007294 <udc_req_ep+0x9c>
8000720e:	90 28       	ld.sh	r8,r8[0x4]
80007210:	ef 68 ff fb 	st.b	r7[-5],r8
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80007214:	30 08       	mov	r8,0
80007216:	ef 68 ff fb 	st.b	r7[-5],r8
8000721a:	c2 d8       	rjmp	80007274 <udc_req_ep+0x7c>
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
8000721c:	49 f8       	lddpc	r8,80007298 <udc_req_ep+0xa0>
8000721e:	70 08       	ld.w	r8,r8[0x0]
80007220:	70 19       	ld.w	r9,r8[0x4]
80007222:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80007226:	a3 68       	lsl	r8,0x2
80007228:	f2 08 00 08 	add	r8,r9,r8
8000722c:	70 08       	ld.w	r8,r8[0x0]
8000722e:	ef 48 ff fc 	st.w	r7[-4],r8
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
80007232:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007236:	70 38       	ld.w	r8,r8[0xc]
80007238:	5d 18       	icall	r8
8000723a:	18 98       	mov	r8,r12
8000723c:	10 99       	mov	r9,r8
8000723e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80007242:	12 9b       	mov	r11,r9
80007244:	10 9c       	mov	r12,r8
80007246:	f0 1f 00 16 	mcall	8000729c <udc_req_ep+0xa4>
8000724a:	18 98       	mov	r8,r12
8000724c:	ec 18 00 01 	eorl	r8,0x1
80007250:	5c 58       	castu.b	r8
80007252:	c0 30       	breq	80007258 <udc_req_ep+0x60>
			return false;
80007254:	30 08       	mov	r8,0
80007256:	c1 98       	rjmp	80007288 <udc_req_ep+0x90>
		}

		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
80007258:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000725c:	70 28       	ld.w	r8,r8[0x8]
8000725e:	5d 18       	icall	r8
80007260:	18 98       	mov	r8,r12
80007262:	58 08       	cp.w	r8,0
80007264:	c0 30       	breq	8000726a <udc_req_ep+0x72>
			return true;
80007266:	30 18       	mov	r8,1
80007268:	c1 08       	rjmp	80007288 <udc_req_ep+0x90>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
8000726a:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000726e:	2f f8       	sub	r8,-1
80007270:	ef 68 ff fb 	st.b	r7[-5],r8
	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80007274:	48 98       	lddpc	r8,80007298 <udc_req_ep+0xa0>
80007276:	70 08       	ld.w	r8,r8[0x0]
80007278:	70 08       	ld.w	r8,r8[0x0]
8000727a:	11 c8       	ld.ub	r8,r8[0x4]
8000727c:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80007280:	f0 09 18 00 	cp.b	r9,r8
80007284:	cc c3       	brcs	8000721c <udc_req_ep+0x24>
		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
			return true;
		}
	}
	return false;
80007286:	30 08       	mov	r8,0
}
80007288:	10 9c       	mov	r12,r8
8000728a:	2f ed       	sub	sp,-8
8000728c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007290:	00 00       	add	r0,r0
80007292:	07 26       	ld.uh	r6,r3++
80007294:	00 00       	add	r0,r0
80007296:	46 48       	lddsp	r8,sp[0x190]
80007298:	00 00       	add	r0,r0
8000729a:	07 28       	ld.uh	r8,r3++
8000729c:	80 00       	ld.sh	r0,r0[0x0]
8000729e:	67 04       	ld.w	r4,r3[0x40]

800072a0 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
800072a0:	eb cd 40 80 	pushm	r7,lr
800072a4:	1a 97       	mov	r7,sp
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
800072a6:	4a 19       	lddpc	r9,80007328 <udc_process_setup+0x88>
800072a8:	30 08       	mov	r8,0
800072aa:	b2 68       	st.h	r9[0xc],r8
	udd_g_ctrlreq.callback = NULL;
800072ac:	49 f8       	lddpc	r8,80007328 <udc_process_setup+0x88>
800072ae:	30 09       	mov	r9,0
800072b0:	91 49       	st.w	r8[0x10],r9
	udd_g_ctrlreq.over_under_run = NULL;
800072b2:	49 e8       	lddpc	r8,80007328 <udc_process_setup+0x88>
800072b4:	30 09       	mov	r9,0
800072b6:	91 59       	st.w	r8[0x14],r9

	if (Udd_setup_is_in()) {
800072b8:	49 c8       	lddpc	r8,80007328 <udc_process_setup+0x88>
800072ba:	11 88       	ld.ub	r8,r8[0x0]
800072bc:	10 99       	mov	r9,r8
800072be:	30 08       	mov	r8,0
800072c0:	f0 09 18 00 	cp.b	r9,r8
800072c4:	c0 74       	brge	800072d2 <udc_process_setup+0x32>
		if (udd_g_ctrlreq.req.wLength == 0) {
800072c6:	49 98       	lddpc	r8,80007328 <udc_process_setup+0x88>
800072c8:	90 38       	ld.sh	r8,r8[0x6]
800072ca:	58 08       	cp.w	r8,0
800072cc:	c0 31       	brne	800072d2 <udc_process_setup+0x32>
			return false; // Error from USB host
800072ce:	30 08       	mov	r8,0
800072d0:	c2 88       	rjmp	80007320 <udc_process_setup+0x80>
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
800072d2:	49 68       	lddpc	r8,80007328 <udc_process_setup+0x88>
800072d4:	11 88       	ld.ub	r8,r8[0x0]
800072d6:	e2 18 00 60 	andl	r8,0x60,COH
800072da:	c0 81       	brne	800072ea <udc_process_setup+0x4a>
		if (udc_reqstd()) {
800072dc:	f0 1f 00 14 	mcall	8000732c <udc_process_setup+0x8c>
800072e0:	18 98       	mov	r8,r12
800072e2:	58 08       	cp.w	r8,0
800072e4:	c0 30       	breq	800072ea <udc_process_setup+0x4a>
			return true;
800072e6:	30 18       	mov	r8,1
800072e8:	c1 c8       	rjmp	80007320 <udc_process_setup+0x80>
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
800072ea:	49 08       	lddpc	r8,80007328 <udc_process_setup+0x88>
800072ec:	11 88       	ld.ub	r8,r8[0x0]
800072ee:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800072f2:	58 18       	cp.w	r8,1
800072f4:	c0 81       	brne	80007304 <udc_process_setup+0x64>
		if (udc_req_iface()) {
800072f6:	f0 1f 00 0f 	mcall	80007330 <udc_process_setup+0x90>
800072fa:	18 98       	mov	r8,r12
800072fc:	58 08       	cp.w	r8,0
800072fe:	c0 30       	breq	80007304 <udc_process_setup+0x64>
			return true;
80007300:	30 18       	mov	r8,1
80007302:	c0 f8       	rjmp	80007320 <udc_process_setup+0x80>
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
80007304:	48 98       	lddpc	r8,80007328 <udc_process_setup+0x88>
80007306:	11 88       	ld.ub	r8,r8[0x0]
80007308:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
8000730c:	58 28       	cp.w	r8,2
8000730e:	c0 81       	brne	8000731e <udc_process_setup+0x7e>
		if (udc_req_ep()) {
80007310:	f0 1f 00 09 	mcall	80007334 <udc_process_setup+0x94>
80007314:	18 98       	mov	r8,r12
80007316:	58 08       	cp.w	r8,0
80007318:	c0 30       	breq	8000731e <udc_process_setup+0x7e>
			return true;
8000731a:	30 18       	mov	r8,1
8000731c:	c0 28       	rjmp	80007320 <udc_process_setup+0x80>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
8000731e:	30 08       	mov	r8,0
#endif
}
80007320:	10 9c       	mov	r12,r8
80007322:	e3 cd 80 80 	ldm	sp++,r7,pc
80007326:	00 00       	add	r0,r0
80007328:	00 00       	add	r0,r0
8000732a:	46 48       	lddsp	r8,sp[0x190]
8000732c:	80 00       	ld.sh	r0,r0[0x0]
8000732e:	6f f8       	ld.w	r8,r7[0x7c]
80007330:	80 00       	ld.sh	r0,r0[0x0]
80007332:	71 4c       	ld.w	r12,r8[0x50]
80007334:	80 00       	ld.sh	r0,r0[0x0]
80007336:	71 f8       	ld.w	r8,r8[0x7c]

80007338 <pm_sleep>:
#else
# error Unsupported AVR UC3 series.
#endif

static inline void pm_sleep(int sleep_mode)
{
80007338:	eb cd 40 80 	pushm	r7,lr
8000733c:	1a 97       	mov	r7,sp
8000733e:	20 1d       	sub	sp,4
80007340:	ef 4c ff fc 	st.w	r7[-4],r12
	switch (sleep_mode) {
80007344:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007348:	58 58       	cp.w	r8,5
8000734a:	c4 30       	breq	800073d0 <pm_sleep+0x98>
8000734c:	e0 89 00 10 	brgt	8000736c <pm_sleep+0x34>
80007350:	58 28       	cp.w	r8,2
80007352:	c2 d0       	breq	800073ac <pm_sleep+0x74>
80007354:	e0 89 00 07 	brgt	80007362 <pm_sleep+0x2a>
80007358:	58 08       	cp.w	r8,0
8000735a:	c1 d0       	breq	80007394 <pm_sleep+0x5c>
8000735c:	58 18       	cp.w	r8,1
8000735e:	c2 10       	breq	800073a0 <pm_sleep+0x68>
80007360:	c3 d8       	rjmp	800073da <pm_sleep+0xa2>
80007362:	58 38       	cp.w	r8,3
80007364:	c2 a0       	breq	800073b8 <pm_sleep+0x80>
80007366:	58 48       	cp.w	r8,4
80007368:	c2 e0       	breq	800073c4 <pm_sleep+0x8c>
8000736a:	c3 88       	rjmp	800073da <pm_sleep+0xa2>
8000736c:	e0 48 00 82 	cp.w	r8,130
80007370:	c2 10       	breq	800073b2 <pm_sleep+0x7a>
80007372:	e0 89 00 09 	brgt	80007384 <pm_sleep+0x4c>
80007376:	e0 48 00 80 	cp.w	r8,128
8000737a:	c1 00       	breq	8000739a <pm_sleep+0x62>
8000737c:	e0 48 00 81 	cp.w	r8,129
80007380:	c1 30       	breq	800073a6 <pm_sleep+0x6e>
80007382:	c2 c8       	rjmp	800073da <pm_sleep+0xa2>
80007384:	e0 48 00 84 	cp.w	r8,132
80007388:	c2 10       	breq	800073ca <pm_sleep+0x92>
8000738a:	c1 a5       	brlt	800073be <pm_sleep+0x86>
8000738c:	e0 48 00 85 	cp.w	r8,133
80007390:	c2 30       	breq	800073d6 <pm_sleep+0x9e>
80007392:	c2 48       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_IDLE:
		SLEEP(AVR32_PM_SMODE_IDLE);
80007394:	e9 b0 00 00 	sleep	0x0
		break;
80007398:	c2 18       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_IDLE:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_IDLE);
8000739a:	e9 b0 00 80 	sleep	0x80
		break;
8000739e:	c1 e8       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_FROZEN:
		SLEEP(AVR32_PM_SMODE_FROZEN);
800073a0:	e9 b0 00 01 	sleep	0x1
		break;
800073a4:	c1 b8       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_FROZEN:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_FROZEN);
800073a6:	e9 b0 00 81 	sleep	0x81
		break;
800073aa:	c1 88       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_STANDBY:
		SLEEP(AVR32_PM_SMODE_STANDBY);
800073ac:	e9 b0 00 02 	sleep	0x2
		break;
800073b0:	c1 58       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STANDBY:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STANDBY);
800073b2:	e9 b0 00 82 	sleep	0x82
		break;
800073b6:	c1 28       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_STOP:
		SLEEP(AVR32_PM_SMODE_STOP);
800073b8:	e9 b0 00 03 	sleep	0x3
		break;
800073bc:	c0 f8       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STOP:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STOP);
800073be:	e9 b0 00 83 	sleep	0x83
		break;
800073c2:	c0 c8       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_DEEPSTOP:
		SLEEP(AVR32_PM_SMODE_DEEPSTOP);
800073c4:	e9 b0 00 04 	sleep	0x4
		break;
800073c8:	c0 98       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_DEEPSTOP:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_DEEPSTOP);
800073ca:	e9 b0 00 84 	sleep	0x84
		break;
800073ce:	c0 68       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_STATIC:
		SLEEP(AVR32_PM_SMODE_STATIC);
800073d0:	e9 b0 00 05 	sleep	0x5
		break;
800073d4:	c0 38       	rjmp	800073da <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STATIC:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STATIC);
800073d6:	e9 b0 00 85 	sleep	0x85
		break;
#endif
	default:
		break;
	}
}
800073da:	2f fd       	sub	sp,-4
800073dc:	e3 cd 80 80 	ldm	sp++,r7,pc

800073e0 <sleepmgr_sleep>:
//! @}



static inline void sleepmgr_sleep(const enum sleepmgr_mode sleep_mode)
{
800073e0:	eb cd 40 80 	pushm	r7,lr
800073e4:	1a 97       	mov	r7,sp
800073e6:	20 1d       	sub	sp,4
800073e8:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert(sleep_mode != SLEEPMGR_ACTIVE);
#ifdef CONFIG_SLEEPMGR_ENABLE
	cpu_irq_disable();
800073ec:	d3 03       	ssrf	0x10

	// Atomically enable the global interrupts and enter the sleep mode.
	pm_sleep(AVR32_PM_SMODE_GMCLEAR_MASK | (sleep_mode-1));
800073ee:	ee f8 ff fc 	ld.w	r8,r7[-4]
800073f2:	20 18       	sub	r8,1
800073f4:	a7 b8       	sbr	r8,0x7
800073f6:	10 9c       	mov	r12,r8
800073f8:	f0 1f 00 03 	mcall	80007404 <sleepmgr_sleep+0x24>
#else
	cpu_irq_enable();
#endif /* CONFIG_SLEEPMGR_ENABLE */

}
800073fc:	2f fd       	sub	sp,-4
800073fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80007402:	00 00       	add	r0,r0
80007404:	80 00       	ld.sh	r0,r0[0x0]
80007406:	73 38       	ld.w	r8,r9[0x4c]

80007408 <sleepmgr_init>:
 * Sets all lock counts to 0, except the very last one, which is set to 1. This
 * is done to simplify the algorithm for finding the deepest allowable sleep
 * mode in \ref sleepmgr_enter_sleep.
 */
static inline void sleepmgr_init(void)
{
80007408:	eb cd 40 80 	pushm	r7,lr
8000740c:	1a 97       	mov	r7,sp
8000740e:	20 1d       	sub	sp,4
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
80007410:	30 08       	mov	r8,0
80007412:	ef 68 ff ff 	st.b	r7[-1],r8
80007416:	c0 c8       	rjmp	8000742e <sleepmgr_init+0x26>
		sleepmgr_locks[i] = 0;
80007418:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000741c:	48 ba       	lddpc	r10,80007448 <sleepmgr_init+0x40>
8000741e:	30 08       	mov	r8,0
80007420:	f4 09 0b 08 	st.b	r10[r9],r8
static inline void sleepmgr_init(void)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
80007424:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80007428:	2f f8       	sub	r8,-1
8000742a:	ef 68 ff ff 	st.b	r7[-1],r8
8000742e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007432:	30 58       	mov	r8,5
80007434:	f0 09 18 00 	cp.b	r9,r8
80007438:	fe 98 ff f0 	brls	80007418 <sleepmgr_init+0x10>
		sleepmgr_locks[i] = 0;
	}
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
8000743c:	48 39       	lddpc	r9,80007448 <sleepmgr_init+0x40>
8000743e:	30 18       	mov	r8,1
80007440:	b2 e8       	st.b	r9[0x6],r8
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
80007442:	2f fd       	sub	sp,-4
80007444:	e3 cd 80 80 	ldm	sp++,r7,pc
80007448:	00 00       	add	r0,r0
8000744a:	46 60       	lddsp	r0,sp[0x198]

8000744c <sleepmgr_get_sleep_mode>:
 * Searches through the sleep mode lock counts, starting at the shallowest sleep
 * mode, until the first non-zero lock count is found. The deepest allowable
 * sleep mode is then returned.
 */
static inline enum sleepmgr_mode sleepmgr_get_sleep_mode(void)
{
8000744c:	eb cd 40 80 	pushm	r7,lr
80007450:	1a 97       	mov	r7,sp
80007452:	20 2d       	sub	sp,8
	enum sleepmgr_mode sleep_mode = SLEEPMGR_ACTIVE;
80007454:	30 08       	mov	r8,0
80007456:	ef 48 ff f8 	st.w	r7[-8],r8

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;
8000745a:	48 d8       	lddpc	r8,8000748c <sleepmgr_get_sleep_mode+0x40>
8000745c:	ef 48 ff fc 	st.w	r7[-4],r8

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
80007460:	c0 b8       	rjmp	80007476 <sleepmgr_get_sleep_mode+0x2a>
		lock_ptr++;
80007462:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007466:	2f f8       	sub	r8,-1
80007468:	ef 48 ff fc 	st.w	r7[-4],r8
		sleep_mode = (enum sleepmgr_mode)(sleep_mode + 1);
8000746c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007470:	2f f8       	sub	r8,-1
80007472:	ef 48 ff f8 	st.w	r7[-8],r8

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
80007476:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000747a:	11 88       	ld.ub	r8,r8[0x0]
8000747c:	58 08       	cp.w	r8,0
8000747e:	cf 20       	breq	80007462 <sleepmgr_get_sleep_mode+0x16>
	// performed on the deepest sleep mode.
	Assert((uintptr_t)(lock_ptr - sleepmgr_locks) < SLEEPMGR_NR_OF_MODES);

#endif /* CONFIG_SLEEPMGR_ENABLE */

	return sleep_mode;
80007480:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80007484:	10 9c       	mov	r12,r8
80007486:	2f ed       	sub	sp,-8
80007488:	e3 cd 80 80 	ldm	sp++,r7,pc
8000748c:	00 00       	add	r0,r0
8000748e:	46 60       	lddsp	r0,sp[0x198]

80007490 <sleepmgr_enter_sleep>:
 * them enabled upon return. This also applies if sleep is skipped due to ACTIVE
 * mode being locked.
 */

static inline void sleepmgr_enter_sleep(void)
{
80007490:	eb cd 40 80 	pushm	r7,lr
80007494:	1a 97       	mov	r7,sp
80007496:	20 1d       	sub	sp,4
#ifdef CONFIG_SLEEPMGR_ENABLE
	enum sleepmgr_mode sleep_mode;

	cpu_irq_disable();
80007498:	d3 03       	ssrf	0x10

	// Find the deepest allowable sleep mode
	sleep_mode = sleepmgr_get_sleep_mode();
8000749a:	f0 1f 00 0a 	mcall	800074c0 <sleepmgr_enter_sleep+0x30>
8000749e:	18 98       	mov	r8,r12
800074a0:	ef 48 ff fc 	st.w	r7[-4],r8
	// Return right away if first mode (ACTIVE) is locked.
	if (sleep_mode==SLEEPMGR_ACTIVE) {
800074a4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074a8:	58 08       	cp.w	r8,0
800074aa:	c0 31       	brne	800074b0 <sleepmgr_enter_sleep+0x20>
		cpu_irq_enable();
800074ac:	d5 03       	csrf	0x10
		return;
800074ae:	c0 58       	rjmp	800074b8 <sleepmgr_enter_sleep+0x28>
	}
	// Enter the deepest allowable sleep mode with interrupts enabled
	sleepmgr_sleep(sleep_mode);
800074b0:	ee fc ff fc 	ld.w	r12,r7[-4]
800074b4:	f0 1f 00 04 	mcall	800074c4 <sleepmgr_enter_sleep+0x34>
#else
	cpu_irq_enable();
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
800074b8:	2f fd       	sub	sp,-4
800074ba:	e3 cd 80 80 	ldm	sp++,r7,pc
800074be:	00 00       	add	r0,r0
800074c0:	80 00       	ld.sh	r0,r0[0x0]
800074c2:	74 4c       	ld.w	r12,r10[0x10]
800074c4:	80 00       	ld.sh	r0,r0[0x0]
800074c6:	73 e0       	ld.w	r0,r9[0x78]

800074c8 <udc_attach>:
 * \warning If a VBus control is included in driver,
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
800074c8:	eb cd 40 80 	pushm	r7,lr
800074cc:	1a 97       	mov	r7,sp
	udd_attach();
800074ce:	f0 1f 00 03 	mcall	800074d8 <udc_attach+0x10>
}
800074d2:	e3 cd 80 80 	ldm	sp++,r7,pc
800074d6:	00 00       	add	r0,r0
800074d8:	80 00       	ld.sh	r0,r0[0x0]
800074da:	34 04       	mov	r4,64

800074dc <udc_detach>:
 * \brief Detaches the device from the bus
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
800074dc:	eb cd 40 80 	pushm	r7,lr
800074e0:	1a 97       	mov	r7,sp
	udd_detach();
800074e2:	f0 1f 00 03 	mcall	800074ec <udc_detach+0x10>
}
800074e6:	e3 cd 80 80 	ldm	sp++,r7,pc
800074ea:	00 00       	add	r0,r0
800074ec:	80 00       	ld.sh	r0,r0[0x0]
800074ee:	34 b4       	mov	r4,75

800074f0 <main>:
static volatile bool main_b_cdc_enable = false;

/*! \brief Main function. Execution starts here.
 */
int main(void)
{
800074f0:	eb cd 40 80 	pushm	r7,lr
800074f4:	1a 97       	mov	r7,sp
	// Initialise system clocks.
	sysclk_init();
800074f6:	f0 1f 00 24 	mcall	80007584 <main+0x94>
	
	// Enable all interrupts.
	irq_initialize_vectors();
800074fa:	f0 1f 00 24 	mcall	80007588 <main+0x98>
	cpu_irq_enable();
800074fe:	d5 03       	csrf	0x10
	
	// Initialise board GPIO mappings.
	board_init();
80007500:	f0 1f 00 23 	mcall	8000758c <main+0x9c>
	
	// Initialize the sleep manager
	sleepmgr_init();
80007504:	f0 1f 00 23 	mcall	80007590 <main+0xa0>

	// Start USB stack to authorize VBus monitoring
	udc_start();
80007508:	f0 1f 00 23 	mcall	80007594 <main+0xa4>

	// Initialise triggers.
	readUSB			= 0;
8000750c:	4a 39       	lddpc	r9,80007598 <main+0xa8>
8000750e:	30 08       	mov	r8,0
80007510:	b2 88       	st.b	r9[0x0],r8
	triggerUSART	= 0;
80007512:	4a 39       	lddpc	r9,8000759c <main+0xac>
80007514:	30 08       	mov	r8,0
80007516:	b2 88       	st.b	r9[0x0],r8
	// The main loop manages only the power mode
	// because the USB management is done by interrupt
	while (true)
	{
		// Check to see if there is data in the USB RX FIFO to read in.
		if (readUSB == 1)
80007518:	4a 08       	lddpc	r8,80007598 <main+0xa8>
8000751a:	11 89       	ld.ub	r9,r8[0x0]
8000751c:	30 18       	mov	r8,1
8000751e:	f0 09 18 00 	cp.b	r9,r8
80007522:	c0 31       	brne	80007528 <main+0x38>
		{
			receiveUSBData();
80007524:	f0 1f 00 1f 	mcall	800075a0 <main+0xb0>
		}
		
		// Check to see if a USART ISR has been triggered.
		if (triggerUSART & 0x01)
80007528:	49 d8       	lddpc	r8,8000759c <main+0xac>
8000752a:	11 88       	ld.ub	r8,r8[0x0]
8000752c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007530:	5c 58       	castu.b	r8
80007532:	c0 40       	breq	8000753a <main+0x4a>
		{
			// USART0.
			motorBusIntteruptController(0);
80007534:	30 0c       	mov	r12,0
80007536:	f0 1f 00 1c 	mcall	800075a4 <main+0xb4>
		}
		
		if (triggerUSART & 0x02)
8000753a:	49 98       	lddpc	r8,8000759c <main+0xac>
8000753c:	11 88       	ld.ub	r8,r8[0x0]
8000753e:	e2 18 00 02 	andl	r8,0x2,COH
80007542:	c0 40       	breq	8000754a <main+0x5a>
		{
			// USART1.
			motorBusIntteruptController(1);
80007544:	30 1c       	mov	r12,1
80007546:	f0 1f 00 18 	mcall	800075a4 <main+0xb4>

		}
		
		if (triggerUSART & 0x04)
8000754a:	49 58       	lddpc	r8,8000759c <main+0xac>
8000754c:	11 88       	ld.ub	r8,r8[0x0]
8000754e:	e2 18 00 04 	andl	r8,0x4,COH
80007552:	c0 40       	breq	8000755a <main+0x6a>
		{
			// USART2.
			motorBusIntteruptController(2);
80007554:	30 2c       	mov	r12,2
80007556:	f0 1f 00 14 	mcall	800075a4 <main+0xb4>
		}
		
		if (triggerUSART & 0x08)
8000755a:	49 18       	lddpc	r8,8000759c <main+0xac>
8000755c:	11 88       	ld.ub	r8,r8[0x0]
8000755e:	e2 18 00 08 	andl	r8,0x8,COH
80007562:	c0 40       	breq	8000756a <main+0x7a>
		{
			// USART3.
			motorBusIntteruptController(3);
80007564:	30 3c       	mov	r12,3
80007566:	f0 1f 00 10 	mcall	800075a4 <main+0xb4>
		}
		
		if (triggerUSART & 0x10)
8000756a:	48 d8       	lddpc	r8,8000759c <main+0xac>
8000756c:	11 88       	ld.ub	r8,r8[0x0]
8000756e:	e2 18 00 10 	andl	r8,0x10,COH
80007572:	c0 40       	breq	8000757a <main+0x8a>
		{
			// USART4.
			motorBusIntteruptController(4);
80007574:	30 4c       	mov	r12,4
80007576:	f0 1f 00 0c 	mcall	800075a4 <main+0xb4>
		}
		
		// Check  to see if we need to process any packets.
		processPacket();
8000757a:	f0 1f 00 0c 	mcall	800075a8 <main+0xb8>
		
		sleepmgr_enter_sleep();
8000757e:	f0 1f 00 0c 	mcall	800075ac <main+0xbc>
	}
80007582:	cc bb       	rjmp	80007518 <main+0x28>
80007584:	80 00       	ld.sh	r0,r0[0x0]
80007586:	54 3c       	stdsp	sp[0x10c],r12
80007588:	80 00       	ld.sh	r0,r0[0x0]
8000758a:	2e 04       	sub	r4,-32
8000758c:	80 00       	ld.sh	r0,r0[0x0]
8000758e:	20 08       	sub	r8,0
80007590:	80 00       	ld.sh	r0,r0[0x0]
80007592:	74 08       	ld.w	r8,r10[0x0]
80007594:	80 00       	ld.sh	r0,r0[0x0]
80007596:	69 40       	ld.w	r0,r4[0x50]
80007598:	00 00       	add	r0,r0
8000759a:	46 44       	lddsp	r4,sp[0x190]
8000759c:	00 00       	add	r0,r0
8000759e:	46 45       	lddsp	r5,sp[0x190]
800075a0:	80 00       	ld.sh	r0,r0[0x0]
800075a2:	78 0c       	ld.w	r12,r12[0x0]
800075a4:	80 00       	ld.sh	r0,r0[0x0]
800075a6:	81 e0       	st.w	r0[0x38],r0
800075a8:	80 00       	ld.sh	r0,r0[0x0]
800075aa:	79 64       	ld.w	r4,r12[0x58]
800075ac:	80 00       	ld.sh	r0,r0[0x0]
800075ae:	74 90       	ld.w	r0,r10[0x24]

800075b0 <main_suspend_action>:
}

void main_suspend_action(void)
{
800075b0:	eb cd 40 80 	pushm	r7,lr
800075b4:	1a 97       	mov	r7,sp
	;
}
800075b6:	e3 cd 80 80 	ldm	sp++,r7,pc

800075ba <main_resume_action>:

void main_resume_action(void)
{
800075ba:	eb cd 40 80 	pushm	r7,lr
800075be:	1a 97       	mov	r7,sp
	;
}
800075c0:	e3 cd 80 80 	ldm	sp++,r7,pc

800075c4 <main_sof_action>:

void main_sof_action(void)
{
800075c4:	eb cd 40 80 	pushm	r7,lr
800075c8:	1a 97       	mov	r7,sp
	;
}
800075ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800075ce:	d7 03       	nop

800075d0 <main_cdc_enable>:

bool main_cdc_enable(uint8_t port)
{
800075d0:	eb cd 40 80 	pushm	r7,lr
800075d4:	1a 97       	mov	r7,sp
800075d6:	20 1d       	sub	sp,4
800075d8:	18 98       	mov	r8,r12
800075da:	ef 68 ff fc 	st.b	r7[-4],r8
	main_b_cdc_enable = true;
800075de:	48 79       	lddpc	r9,800075f8 <main_cdc_enable+0x28>
800075e0:	30 18       	mov	r8,1
800075e2:	b2 88       	st.b	r9[0x0],r8
	
	// Open communication
	uart_open(port);
800075e4:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800075e8:	10 9c       	mov	r12,r8
800075ea:	f0 1f 00 05 	mcall	800075fc <main_cdc_enable+0x2c>
	
	return(true);
800075ee:	30 18       	mov	r8,1
}
800075f0:	10 9c       	mov	r12,r8
800075f2:	2f fd       	sub	sp,-4
800075f4:	e3 cd 80 80 	ldm	sp++,r7,pc
800075f8:	00 00       	add	r0,r0
800075fa:	07 34       	ld.ub	r4,r3++
800075fc:	80 00       	ld.sh	r0,r0[0x0]
800075fe:	86 90       	ld.uh	r0,r3[0x2]

80007600 <main_cdc_disable>:

void main_cdc_disable(uint8_t port)
{
80007600:	eb cd 40 80 	pushm	r7,lr
80007604:	1a 97       	mov	r7,sp
80007606:	20 1d       	sub	sp,4
80007608:	18 98       	mov	r8,r12
8000760a:	ef 68 ff fc 	st.b	r7[-4],r8
	main_b_cdc_enable = false;
8000760e:	48 69       	lddpc	r9,80007624 <main_cdc_disable+0x24>
80007610:	30 08       	mov	r8,0
80007612:	b2 88       	st.b	r9[0x0],r8
	
	// Close communication
	uart_close(port);
80007614:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80007618:	10 9c       	mov	r12,r8
8000761a:	f0 1f 00 04 	mcall	80007628 <main_cdc_disable+0x28>
}
8000761e:	2f fd       	sub	sp,-4
80007620:	e3 cd 80 80 	ldm	sp++,r7,pc
80007624:	00 00       	add	r0,r0
80007626:	07 34       	ld.ub	r4,r3++
80007628:	80 00       	ld.sh	r0,r0[0x0]
8000762a:	88 28       	ld.sh	r8,r4[0x4]

8000762c <main_cdc_set_dtr>:

void main_cdc_set_dtr(uint8_t port, bool b_enable)
{
8000762c:	eb cd 40 80 	pushm	r7,lr
80007630:	1a 97       	mov	r7,sp
80007632:	20 2d       	sub	sp,8
80007634:	18 99       	mov	r9,r12
80007636:	16 98       	mov	r8,r11
80007638:	ef 69 ff fc 	st.b	r7[-4],r9
8000763c:	ef 68 ff f8 	st.b	r7[-8],r8
	;
}
80007640:	2f ed       	sub	sp,-8
80007642:	e3 cd 80 80 	ldm	sp++,r7,pc
80007646:	d7 03       	nop

80007648 <main_vbus_action>:


void main_vbus_action(bool b_high)
{
80007648:	eb cd 40 80 	pushm	r7,lr
8000764c:	1a 97       	mov	r7,sp
8000764e:	20 1d       	sub	sp,4
80007650:	18 98       	mov	r8,r12
80007652:	ef 68 ff fc 	st.b	r7[-4],r8
	if (b_high)
80007656:	ef 39 ff fc 	ld.ub	r9,r7[-4]
8000765a:	30 08       	mov	r8,0
8000765c:	f0 09 18 00 	cp.b	r9,r8
80007660:	c0 40       	breq	80007668 <main_vbus_action+0x20>
	{
		// Attach USB Device
		udc_attach();
80007662:	f0 1f 00 05 	mcall	80007674 <main_vbus_action+0x2c>
80007666:	c0 38       	rjmp	8000766c <main_vbus_action+0x24>
	}
	
	else
	{
		// Vbus not present
		udc_detach();
80007668:	f0 1f 00 04 	mcall	80007678 <main_vbus_action+0x30>
	}
8000766c:	2f fd       	sub	sp,-4
8000766e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007672:	00 00       	add	r0,r0
80007674:	80 00       	ld.sh	r0,r0[0x0]
80007676:	74 c8       	ld.w	r8,r10[0x30]
80007678:	80 00       	ld.sh	r0,r0[0x0]
8000767a:	74 dc       	ld.w	r12,r10[0x34]

8000767c <osc_get_rate>:
		return false;
	}
}

static inline uint32_t osc_get_rate(uint8_t id)
{
8000767c:	eb cd 40 80 	pushm	r7,lr
80007680:	1a 97       	mov	r7,sp
80007682:	20 1d       	sub	sp,4
80007684:	18 98       	mov	r8,r12
80007686:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
8000768a:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000768e:	58 08       	cp.w	r8,0
80007690:	c0 40       	breq	80007698 <osc_get_rate+0x1c>
80007692:	58 28       	cp.w	r8,2
80007694:	c0 70       	breq	800076a2 <osc_get_rate+0x26>
80007696:	c0 98       	rjmp	800076a8 <osc_get_rate+0x2c>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return BOARD_OSC0_HZ;
80007698:	e0 68 1b 00 	mov	r8,6912
8000769c:	ea 18 00 b7 	orh	r8,0xb7
800076a0:	c0 58       	rjmp	800076aa <osc_get_rate+0x2e>
		return BOARD_OSC1_HZ;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		return BOARD_OSC32_HZ;
800076a2:	e0 68 80 00 	mov	r8,32768
800076a6:	c0 28       	rjmp	800076aa <osc_get_rate+0x2e>
#endif
	default:
		/* unhandled_case(id); */
		return 0;
800076a8:	30 08       	mov	r8,0
	}
}
800076aa:	10 9c       	mov	r12,r8
800076ac:	2f fd       	sub	sp,-4
800076ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800076b2:	d7 03       	nop

800076b4 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800076b4:	eb cd 40 80 	pushm	r7,lr
800076b8:	1a 97       	mov	r7,sp
		return BOARD_OSC0_HZ;
#endif

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0:
		return pll_get_default_rate(0);
800076ba:	30 0c       	mov	r12,0
800076bc:	f0 1f 00 04 	mcall	800076cc <sysclk_get_main_hz+0x18>
800076c0:	18 98       	mov	r8,r12
800076c2:	a5 68       	lsl	r8,0x4
800076c4:	a1 98       	lsr	r8,0x1

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
800076c6:	10 9c       	mov	r12,r8
800076c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800076cc:	80 00       	ld.sh	r0,r0[0x0]
800076ce:	76 7c       	ld.w	r12,r11[0x1c]

800076d0 <sysclk_get_pba_hz>:
 * \brief Return the current rate in Hz of the Peripheral Bus A clock
 *
 * \return Frequency of the Peripheral Bus A clock, in Hz.
 */
static inline uint32_t sysclk_get_pba_hz(void)
{
800076d0:	eb cd 40 80 	pushm	r7,lr
800076d4:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_PBA_DIV;
800076d6:	f0 1f 00 04 	mcall	800076e4 <sysclk_get_pba_hz+0x14>
800076da:	18 98       	mov	r8,r12
800076dc:	a1 98       	lsr	r8,0x1
}
800076de:	10 9c       	mov	r12,r8
800076e0:	e3 cd 80 80 	ldm	sp++,r7,pc
800076e4:	80 00       	ld.sh	r0,r0[0x0]
800076e6:	76 b4       	ld.w	r4,r11[0x2c]

800076e8 <sysclk_enable_pba_module>:
/**
 * \brief Enable a module clock derived from the PBA clock
 * \param index Index of the module clock in the PBAMASK register
 */
static inline void sysclk_enable_pba_module(unsigned int index)
{
800076e8:	eb cd 40 80 	pushm	r7,lr
800076ec:	1a 97       	mov	r7,sp
800076ee:	20 1d       	sub	sp,4
800076f0:	ef 4c ff fc 	st.w	r7[-4],r12
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBA, index);
800076f4:	ee fb ff fc 	ld.w	r11,r7[-4]
800076f8:	30 2c       	mov	r12,2
800076fa:	f0 1f 00 03 	mcall	80007704 <sysclk_enable_pba_module+0x1c>
}
800076fe:	2f fd       	sub	sp,-4
80007700:	e3 cd 80 80 	ldm	sp++,r7,pc
80007704:	80 00       	ld.sh	r0,r0[0x0]
80007706:	53 40       	stdsp	sp[0xd0],r0

80007708 <initRAM>:
uint8_t					triggerUSART = 0;



void initRAM(void)
{
80007708:	eb cd 40 80 	pushm	r7,lr
8000770c:	1a 97       	mov	r7,sp
8000770e:	20 2d       	sub	sp,8
	uint8_t temp[RAM_TABLE_SIZE] = {MODEL_NUMBER_L_DEFAULT, MODEL_NUMBER_H_DEFAULT, FIRMWARE_VERSION_DEFAULT, DYNAMIXEL_ID_DEFAULT, BAUD_RATE_DEFAULT};
80007710:	49 29       	lddpc	r9,80007758 <initRAM+0x50>
80007712:	ee c8 00 08 	sub	r8,r7,8
80007716:	72 0a       	ld.w	r10,r9[0x0]
80007718:	91 0a       	st.w	r8[0x0],r10
8000771a:	13 c9       	ld.ub	r9,r9[0x4]
8000771c:	b0 c9       	st.b	r8[0x4],r9
		
	// Populate RAM with default values.
	flashc_memset((void *)RAM, 0x00, 8, RAM_TABLE_SIZE, true);
8000771e:	30 19       	mov	r9,1
80007720:	30 5a       	mov	r10,5
80007722:	30 0b       	mov	r11,0
80007724:	48 ec       	lddpc	r12,8000775c <initRAM+0x54>
80007726:	f0 1f 00 0f 	mcall	80007760 <initRAM+0x58>
	flashc_memcpy((void *)RAM, temp, RAM_TABLE_SIZE, true);
8000772a:	ee c8 00 08 	sub	r8,r7,8
8000772e:	30 19       	mov	r9,1
80007730:	30 5a       	mov	r10,5
80007732:	10 9b       	mov	r11,r8
80007734:	48 ac       	lddpc	r12,8000775c <initRAM+0x54>
80007736:	f0 1f 00 0c 	mcall	80007764 <initRAM+0x5c>
	
	BUS[0] = ((avr32_usart_t*)AVR32_USART0_ADDRESS);
8000773a:	48 c8       	lddpc	r8,80007768 <initRAM+0x60>
8000773c:	fe 79 14 00 	mov	r9,-60416
80007740:	91 09       	st.w	r8[0x0],r9
	BUS[1] = ((avr32_usart_t*)AVR32_USART1_ADDRESS);
80007742:	48 a8       	lddpc	r8,80007768 <initRAM+0x60>
80007744:	fe 79 18 00 	mov	r9,-59392
80007748:	91 19       	st.w	r8[0x4],r9
	BUS[2] = ((avr32_usart_t*)AVR32_USART2_ADDRESS);
8000774a:	48 88       	lddpc	r8,80007768 <initRAM+0x60>
8000774c:	fe 79 1c 00 	mov	r9,-58368
80007750:	91 29       	st.w	r8[0x8],r9
}
80007752:	2f ed       	sub	sp,-8
80007754:	e3 cd 80 80 	ldm	sp++,r7,pc
80007758:	80 00       	ld.sh	r0,r0[0x0]
8000775a:	90 b0       	ld.uh	r0,r8[0x6]
8000775c:	80 80       	ld.uh	r0,r0[0x0]
8000775e:	00 00       	add	r0,r0
80007760:	80 00       	ld.sh	r0,r0[0x0]
80007762:	23 70       	sub	r0,55
80007764:	80 00       	ld.sh	r0,r0[0x0]
80007766:	28 98       	sub	r8,-119
80007768:	00 00       	add	r0,r0
8000776a:	46 34       	lddsp	r4,sp[0x18c]

8000776c <isValidInstruction>:

uint8_t isValidInstruction(uint8_t instruction)
{
8000776c:	eb cd 40 80 	pushm	r7,lr
80007770:	1a 97       	mov	r7,sp
80007772:	20 1d       	sub	sp,4
80007774:	18 98       	mov	r8,r12
80007776:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (instruction)
8000777a:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000777e:	e0 48 00 83 	cp.w	r8,131
80007782:	c0 b0       	breq	80007798 <isValidInstruction+0x2c>
80007784:	e0 89 00 07 	brgt	80007792 <isValidInstruction+0x26>
80007788:	20 18       	sub	r8,1
8000778a:	58 58       	cp.w	r8,5
8000778c:	e0 8b 00 08 	brhi	8000779c <isValidInstruction+0x30>
80007790:	c0 48       	rjmp	80007798 <isValidInstruction+0x2c>
80007792:	e0 48 00 92 	cp.w	r8,146
80007796:	c0 31       	brne	8000779c <isValidInstruction+0x30>
		case ACTION:
		case RESET:
		case SYNC_WRITE:
		case BULK_READ:
		{
			return(NO_ERROR);
80007798:	30 08       	mov	r8,0
8000779a:	c0 28       	rjmp	8000779e <isValidInstruction+0x32>
		}
		
		default:
		{
			return(INSTRUCTION_ERROR);
8000779c:	34 08       	mov	r8,64
		}
	}
}
8000779e:	10 9c       	mov	r12,r8
800077a0:	2f fd       	sub	sp,-4
800077a2:	e3 cd 80 80 	ldm	sp++,r7,pc

800077a6 <calculateChecksum>:

uint8_t calculateChecksum(const PACKET packet)
{
800077a6:	eb cd 40 80 	pushm	r7,lr
800077aa:	1a 97       	mov	r7,sp
800077ac:	20 2d       	sub	sp,8
800077ae:	ee c8 ff f8 	sub	r8,r7,-8
	uint32_t checksum = packet.INSTRUCTION_PACKET.nID + packet.INSTRUCTION_PACKET.nLength + packet.INSTRUCTION_PACKET.nInstruction;
800077b2:	11 a9       	ld.ub	r9,r8[0x2]
800077b4:	12 9a       	mov	r10,r9
800077b6:	11 b9       	ld.ub	r9,r8[0x3]
800077b8:	12 0a       	add	r10,r9
800077ba:	11 c9       	ld.ub	r9,r8[0x4]
800077bc:	f4 09 00 09 	add	r9,r10,r9
800077c0:	ef 49 ff f8 	st.w	r7[-8],r9
	uint8_t i;
	
	for (i = 0; i < (packet.INSTRUCTION_PACKET.nLength - 2); i++)
800077c4:	30 09       	mov	r9,0
800077c6:	ef 69 ff ff 	st.b	r7[-1],r9
800077ca:	c1 18       	rjmp	800077ec <calculateChecksum+0x46>
	{
		checksum += packet.INSTRUCTION_PACKET.nParameters[i];
800077cc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800077d0:	f0 09 00 09 	add	r9,r8,r9
800077d4:	13 d9       	ld.ub	r9,r9[0x5]
800077d6:	ee fa ff f8 	ld.w	r10,r7[-8]
800077da:	f4 09 00 09 	add	r9,r10,r9
800077de:	ef 49 ff f8 	st.w	r7[-8],r9
uint8_t calculateChecksum(const PACKET packet)
{
	uint32_t checksum = packet.INSTRUCTION_PACKET.nID + packet.INSTRUCTION_PACKET.nLength + packet.INSTRUCTION_PACKET.nInstruction;
	uint8_t i;
	
	for (i = 0; i < (packet.INSTRUCTION_PACKET.nLength - 2); i++)
800077e2:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800077e6:	2f f9       	sub	r9,-1
800077e8:	ef 69 ff ff 	st.b	r7[-1],r9
800077ec:	ef 3a ff ff 	ld.ub	r10,r7[-1]
800077f0:	11 b9       	ld.ub	r9,r8[0x3]
800077f2:	20 29       	sub	r9,2
800077f4:	12 3a       	cp.w	r10,r9
800077f6:	ce b5       	brlt	800077cc <calculateChecksum+0x26>
	{
		checksum += packet.INSTRUCTION_PACKET.nParameters[i];
	}
	
	return((uint8_t)(~(checksum & 0x000000FF)));
800077f8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800077fc:	5c 58       	castu.b	r8
800077fe:	5c d8       	com	r8
80007800:	5c 58       	castu.b	r8
}
80007802:	10 9c       	mov	r12,r8
80007804:	2f ed       	sub	sp,-8
80007806:	e3 cd 80 80 	ldm	sp++,r7,pc
8000780a:	d7 03       	nop

8000780c <receiveUSBData>:

void receiveUSBData(void)
{
8000780c:	eb cd 40 80 	pushm	r7,lr
80007810:	1a 97       	mov	r7,sp
	if (udi_cdc_is_rx_ready() == 0)
80007812:	f0 1f 00 4e 	mcall	80007948 <receiveUSBData+0x13c>
80007816:	18 98       	mov	r8,r12
80007818:	ec 18 00 01 	eorl	r8,0x1
8000781c:	5c 58       	castu.b	r8
8000781e:	c0 50       	breq	80007828 <receiveUSBData+0x1c>
	{
		// No data to read.
		readUSB = 0;
80007820:	4c b9       	lddpc	r9,8000794c <receiveUSBData+0x140>
80007822:	30 08       	mov	r8,0
80007824:	b2 88       	st.b	r9[0x0],r8
		return;
80007826:	c8 f8       	rjmp	80007944 <receiveUSBData+0x138>
	}

	if (udi_cdc_read_buf(&rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[rxPosition[BUS_6_USB]], 1) != 0)
80007828:	4c a8       	lddpc	r8,80007950 <receiveUSBData+0x144>
8000782a:	11 b8       	ld.ub	r8,r8[0x3]
8000782c:	10 99       	mov	r9,r8
8000782e:	e0 68 00 86 	mov	r8,134
80007832:	f2 08 02 48 	mul	r8,r9,r8
80007836:	f0 c9 e8 72 	sub	r9,r8,-6030
8000783a:	4c 78       	lddpc	r8,80007954 <receiveUSBData+0x148>
8000783c:	10 09       	add	r9,r8
8000783e:	4c 78       	lddpc	r8,80007958 <receiveUSBData+0x14c>
80007840:	90 38       	ld.sh	r8,r8[0x6]
80007842:	5c 78       	castu.h	r8
80007844:	f2 08 00 08 	add	r8,r9,r8
80007848:	30 1b       	mov	r11,1
8000784a:	10 9c       	mov	r12,r8
8000784c:	f0 1f 00 44 	mcall	8000795c <receiveUSBData+0x150>
80007850:	18 98       	mov	r8,r12
80007852:	58 08       	cp.w	r8,0
80007854:	c0 40       	breq	8000785c <receiveUSBData+0x50>
	{
		// Failed to read a character from the USB.
		udi_cdc_signal_framing_error();
80007856:	f0 1f 00 43 	mcall	80007960 <receiveUSBData+0x154>
8000785a:	c7 58       	rjmp	80007944 <receiveUSBData+0x138>
	else
	{
		// We read a character, now sanity check it.
		
		// Verify each byte of the preamble.
		if ((rxPosition[BUS_6_USB] == 0) && (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[0] != 0xFF))
8000785c:	4b f8       	lddpc	r8,80007958 <receiveUSBData+0x14c>
8000785e:	90 38       	ld.sh	r8,r8[0x6]
80007860:	58 08       	cp.w	r8,0
80007862:	c1 61       	brne	8000788e <receiveUSBData+0x82>
80007864:	4b b8       	lddpc	r8,80007950 <receiveUSBData+0x144>
80007866:	11 b8       	ld.ub	r8,r8[0x3]
80007868:	10 9a       	mov	r10,r8
8000786a:	4b b9       	lddpc	r9,80007954 <receiveUSBData+0x148>
8000786c:	e0 68 00 86 	mov	r8,134
80007870:	f4 08 02 48 	mul	r8,r10,r8
80007874:	f2 08 00 08 	add	r8,r9,r8
80007878:	f0 c8 e8 72 	sub	r8,r8,-6030
8000787c:	11 89       	ld.ub	r9,r8[0x0]
8000787e:	3f f8       	mov	r8,-1
80007880:	f0 09 18 00 	cp.b	r9,r8
80007884:	c0 50       	breq	8000788e <receiveUSBData+0x82>
		{
			// Preamble is wrong. Ignore this character and start again.
			rxPosition[BUS_6_USB] = 0;
80007886:	4b 59       	lddpc	r9,80007958 <receiveUSBData+0x14c>
80007888:	30 08       	mov	r8,0
8000788a:	b2 38       	st.h	r9[0x6],r8
	else
	{
		// We read a character, now sanity check it.
		
		// Verify each byte of the preamble.
		if ((rxPosition[BUS_6_USB] == 0) && (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[0] != 0xFF))
8000788c:	c5 c8       	rjmp	80007944 <receiveUSBData+0x138>
		{
			// Preamble is wrong. Ignore this character and start again.
			rxPosition[BUS_6_USB] = 0;
		}
		
		else if ((rxPosition[BUS_6_USB] == 1) && (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[1] != 0xFF))
8000788e:	4b 38       	lddpc	r8,80007958 <receiveUSBData+0x14c>
80007890:	90 39       	ld.sh	r9,r8[0x6]
80007892:	30 18       	mov	r8,1
80007894:	f0 09 19 00 	cp.h	r9,r8
80007898:	c1 61       	brne	800078c4 <receiveUSBData+0xb8>
8000789a:	4a e8       	lddpc	r8,80007950 <receiveUSBData+0x144>
8000789c:	11 b8       	ld.ub	r8,r8[0x3]
8000789e:	10 9a       	mov	r10,r8
800078a0:	4a d9       	lddpc	r9,80007954 <receiveUSBData+0x148>
800078a2:	e0 68 00 86 	mov	r8,134
800078a6:	f4 08 02 48 	mul	r8,r10,r8
800078aa:	f2 08 00 08 	add	r8,r9,r8
800078ae:	f0 c8 e8 71 	sub	r8,r8,-6031
800078b2:	11 89       	ld.ub	r9,r8[0x0]
800078b4:	3f f8       	mov	r8,-1
800078b6:	f0 09 18 00 	cp.b	r9,r8
800078ba:	c0 50       	breq	800078c4 <receiveUSBData+0xb8>
		{
			// Preamble is wrong. Ignore this character and start again.
			rxPosition[BUS_6_USB] = 0;
800078bc:	4a 79       	lddpc	r9,80007958 <receiveUSBData+0x14c>
800078be:	30 08       	mov	r8,0
800078c0:	b2 38       	st.h	r9[0x6],r8
		{
			// Preamble is wrong. Ignore this character and start again.
			rxPosition[BUS_6_USB] = 0;
		}
		
		else if ((rxPosition[BUS_6_USB] == 1) && (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[1] != 0xFF))
800078c2:	c4 18       	rjmp	80007944 <receiveUSBData+0x138>
		// When we read in the last parameter we need to jump to the checksum position.
		// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0. Less another 1 since we need to 
		// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
		// 5 - 1 + (length - 2) = length + 2.
		// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
		else if ((rxPosition[BUS_6_USB] > 3) && (rxPosition[BUS_6_USB] == (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].INSTRUCTION_PACKET.nLength + 2)))
800078c4:	4a 58       	lddpc	r8,80007958 <receiveUSBData+0x14c>
800078c6:	90 39       	ld.sh	r9,r8[0x6]
800078c8:	30 38       	mov	r8,3
800078ca:	f0 09 19 00 	cp.h	r9,r8
800078ce:	e0 88 00 1b 	brls	80007904 <receiveUSBData+0xf8>
800078d2:	4a 28       	lddpc	r8,80007958 <receiveUSBData+0x14c>
800078d4:	90 38       	ld.sh	r8,r8[0x6]
800078d6:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800078da:	49 e8       	lddpc	r8,80007950 <receiveUSBData+0x144>
800078dc:	11 b8       	ld.ub	r8,r8[0x3]
800078de:	10 9b       	mov	r11,r8
800078e0:	49 da       	lddpc	r10,80007954 <receiveUSBData+0x148>
800078e2:	e0 68 00 86 	mov	r8,134
800078e6:	f6 08 02 48 	mul	r8,r11,r8
800078ea:	f4 08 00 08 	add	r8,r10,r8
800078ee:	f0 c8 e8 72 	sub	r8,r8,-6030
800078f2:	11 b8       	ld.ub	r8,r8[0x3]
800078f4:	2f e8       	sub	r8,-2
800078f6:	10 39       	cp.w	r9,r8
800078f8:	c0 61       	brne	80007904 <receiveUSBData+0xf8>
		{
			rxPosition[BUS_6_USB] = MAX_PARAMETERS + 5;
800078fa:	49 89       	lddpc	r9,80007958 <receiveUSBData+0x14c>
800078fc:	e0 68 00 84 	mov	r8,132
80007900:	b2 38       	st.h	r9[0x6],r8
		// When we read in the last parameter we need to jump to the checksum position.
		// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0. Less another 1 since we need to 
		// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
		// 5 - 1 + (length - 2) = length + 2.
		// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
		else if ((rxPosition[BUS_6_USB] > 3) && (rxPosition[BUS_6_USB] == (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].INSTRUCTION_PACKET.nLength + 2)))
80007902:	c2 18       	rjmp	80007944 <receiveUSBData+0x138>
			rxPosition[BUS_6_USB] = MAX_PARAMETERS + 5;
		}

		// We just read in the checksum byte, so we are done.
		// The checksum byte can be verified later.
		else if (rxPosition[BUS_6_USB] == (MAX_PARAMETERS + 5))
80007904:	49 58       	lddpc	r8,80007958 <receiveUSBData+0x14c>
80007906:	90 39       	ld.sh	r9,r8[0x6]
80007908:	e0 68 00 84 	mov	r8,132
8000790c:	f0 09 19 00 	cp.h	r9,r8
80007910:	c1 41       	brne	80007938 <receiveUSBData+0x12c>
		{										
			if (++rxHead[BUS_6_USB] == NUM_BUSES)
80007912:	49 08       	lddpc	r8,80007950 <receiveUSBData+0x144>
80007914:	11 b8       	ld.ub	r8,r8[0x3]
80007916:	2f f8       	sub	r8,-1
80007918:	5c 58       	castu.b	r8
8000791a:	48 e9       	lddpc	r9,80007950 <receiveUSBData+0x144>
8000791c:	b2 b8       	st.b	r9[0x3],r8
8000791e:	48 d8       	lddpc	r8,80007950 <receiveUSBData+0x144>
80007920:	11 b9       	ld.ub	r9,r8[0x3]
80007922:	30 48       	mov	r8,4
80007924:	f0 09 18 00 	cp.b	r9,r8
80007928:	c0 41       	brne	80007930 <receiveUSBData+0x124>
			{
				rxHead[BUS_6_USB] = 0;
8000792a:	48 a9       	lddpc	r9,80007950 <receiveUSBData+0x144>
8000792c:	30 08       	mov	r8,0
8000792e:	b2 b8       	st.b	r9[0x3],r8
			}

			rxPosition[BUS_6_USB] = 0;
80007930:	48 a9       	lddpc	r9,80007958 <receiveUSBData+0x14c>
80007932:	30 08       	mov	r8,0
80007934:	b2 38       	st.h	r9[0x6],r8
80007936:	c0 78       	rjmp	80007944 <receiveUSBData+0x138>
		}

		// There is no sanity checking to perform on this byte.
		else
		{
			rxPosition[BUS_6_USB]++;
80007938:	48 88       	lddpc	r8,80007958 <receiveUSBData+0x14c>
8000793a:	90 38       	ld.sh	r8,r8[0x6]
8000793c:	2f f8       	sub	r8,-1
8000793e:	5c 88       	casts.h	r8
80007940:	48 69       	lddpc	r9,80007958 <receiveUSBData+0x14c>
80007942:	b2 38       	st.h	r9[0x6],r8
		}
	}	
}
80007944:	e3 cd 80 80 	ldm	sp++,r7,pc
80007948:	80 00       	ld.sh	r0,r0[0x0]
8000794a:	61 d8       	ld.w	r8,r0[0x74]
8000794c:	00 00       	add	r0,r0
8000794e:	46 44       	lddsp	r4,sp[0x190]
80007950:	00 00       	add	r0,r0
80007952:	46 24       	lddsp	r4,sp[0x188]
80007954:	00 00       	add	r0,r0
80007956:	26 ac       	sub	r12,106
80007958:	00 00       	add	r0,r0
8000795a:	46 2c       	lddsp	r12,sp[0x188]
8000795c:	80 00       	ld.sh	r0,r0[0x0]
8000795e:	63 74       	ld.w	r4,r1[0x5c]
80007960:	80 00       	ld.sh	r0,r0[0x0]
80007962:	61 0c       	ld.w	r12,r0[0x40]

80007964 <processPacket>:

void processPacket(void)
{
80007964:	eb cd 40 e0 	pushm	r5-r7,lr
80007968:	1a 97       	mov	r7,sp
8000796a:	20 1d       	sub	sp,4
	uint8_t bus, txBus;
	uint8_t error;
	
	// Check each bus for anything to process.
	for (bus = BUS_1_MOTORS; bus <= BUS_6_USB; bus++)
8000796c:	30 08       	mov	r8,0
8000796e:	ef 68 ff fd 	st.b	r7[-3],r8
80007972:	e0 8f 03 f8 	bral	80008162 <processPacket+0x7fe>
		// We need only check the receive buffers to see if there is anything to process.
		// The transmit buffers are filled as a result of our processing.
		while (rxTail[bus] != rxHead[bus])
		{
			// Verify checksum and instruction.
			error = isValidInstruction(rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nInstruction);
80007976:	ef 3b ff fd 	ld.ub	r11,r7[-3]
8000797a:	ef 38 ff fd 	ld.ub	r8,r7[-3]
8000797e:	fe f9 08 3a 	ld.w	r9,pc[2106]
80007982:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007986:	10 9a       	mov	r10,r8
80007988:	fe f9 08 34 	ld.w	r9,pc[2100]
8000798c:	e0 68 00 86 	mov	r8,134
80007990:	b1 3a       	mul	r10,r8
80007992:	e0 68 07 da 	mov	r8,2010
80007996:	f6 08 02 48 	mul	r8,r11,r8
8000799a:	f4 08 00 08 	add	r8,r10,r8
8000799e:	f2 08 00 08 	add	r8,r9,r8
800079a2:	2f c8       	sub	r8,-4
800079a4:	11 88       	ld.ub	r8,r8[0x0]
800079a6:	10 9c       	mov	r12,r8
800079a8:	f0 1f 02 06 	mcall	800081c0 <processPacket+0x85c>
800079ac:	18 98       	mov	r8,r12
800079ae:	ef 68 ff ff 	st.b	r7[-1],r8
			error |= (calculateChecksum(rxCircBuffer[bus][rxTail[bus]]) != rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nChecksum) ? CHECKSUM_ERROR : NO_ERROR;
800079b2:	ef 3b ff fd 	ld.ub	r11,r7[-3]
800079b6:	ef 38 ff fd 	ld.ub	r8,r7[-3]
800079ba:	fe f9 07 fe 	ld.w	r9,pc[2046]
800079be:	f2 08 07 08 	ld.ub	r8,r9[r8]
800079c2:	10 9a       	mov	r10,r8
800079c4:	fe f9 07 f8 	ld.w	r9,pc[2040]
800079c8:	e0 68 00 86 	mov	r8,134
800079cc:	b1 3a       	mul	r10,r8
800079ce:	e0 68 07 da 	mov	r8,2010
800079d2:	f6 08 02 48 	mul	r8,r11,r8
800079d6:	f4 08 00 08 	add	r8,r10,r8
800079da:	10 09       	add	r9,r8
800079dc:	fa cd 00 88 	sub	sp,sp,136
800079e0:	1a 98       	mov	r8,sp
800079e2:	e0 6a 00 86 	mov	r10,134
800079e6:	12 9b       	mov	r11,r9
800079e8:	10 9c       	mov	r12,r8
800079ea:	f0 1f 01 f7 	mcall	800081c4 <processPacket+0x860>
800079ee:	f0 1f 01 f7 	mcall	800081c8 <processPacket+0x864>
800079f2:	fa cd ff 78 	sub	sp,sp,-136
800079f6:	18 98       	mov	r8,r12
800079f8:	10 99       	mov	r9,r8
800079fa:	ef 3c ff fd 	ld.ub	r12,r7[-3]
800079fe:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007a02:	fe fa 07 b6 	ld.w	r10,pc[1974]
80007a06:	f4 08 07 08 	ld.ub	r8,r10[r8]
80007a0a:	10 9b       	mov	r11,r8
80007a0c:	fe fa 07 b0 	ld.w	r10,pc[1968]
80007a10:	e0 68 00 86 	mov	r8,134
80007a14:	b1 3b       	mul	r11,r8
80007a16:	e0 68 07 da 	mov	r8,2010
80007a1a:	f8 08 02 48 	mul	r8,r12,r8
80007a1e:	f6 08 00 08 	add	r8,r11,r8
80007a22:	f4 08 00 08 	add	r8,r10,r8
80007a26:	f0 c8 ff 7c 	sub	r8,r8,-132
80007a2a:	11 88       	ld.ub	r8,r8[0x0]
80007a2c:	f0 09 18 00 	cp.b	r9,r8
80007a30:	c0 30       	breq	80007a36 <processPacket+0xd2>
80007a32:	31 08       	mov	r8,16
80007a34:	c0 28       	rjmp	80007a38 <processPacket+0xd4>
80007a36:	30 08       	mov	r8,0
80007a38:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007a3c:	10 9a       	mov	r10,r8
80007a3e:	12 98       	mov	r8,r9
80007a40:	f5 e8 10 08 	or	r8,r10,r8
80007a44:	5c 58       	castu.b	r8
80007a46:	ef 68 ff ff 	st.b	r7[-1],r8
			
			if (error != NO_ERROR)
80007a4a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007a4e:	30 08       	mov	r8,0
80007a50:	f0 09 18 00 	cp.b	r9,r8
80007a54:	e0 80 00 dd 	breq	80007c0e <processPacket+0x2aa>
			{
				// Generate an error response.
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nPreamble		= 0xFFFF;
80007a58:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007a5c:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007a60:	fe f9 07 6c 	ld.w	r9,pc[1900]
80007a64:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007a68:	10 9a       	mov	r10,r8
80007a6a:	fe f9 07 66 	ld.w	r9,pc[1894]
80007a6e:	e0 68 00 86 	mov	r8,134
80007a72:	b1 3a       	mul	r10,r8
80007a74:	e0 68 07 da 	mov	r8,2010
80007a78:	f6 08 02 48 	mul	r8,r11,r8
80007a7c:	f4 08 00 08 	add	r8,r10,r8
80007a80:	10 09       	add	r9,r8
80007a82:	3f f8       	mov	r8,-1
80007a84:	b2 08       	st.h	r9[0x0],r8
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nID			= RAM[DYNAMIXEL_ID];
80007a86:	ef 3c ff fd 	ld.ub	r12,r7[-3]
80007a8a:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007a8e:	fe f9 07 3e 	ld.w	r9,pc[1854]
80007a92:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007a96:	10 9b       	mov	r11,r8
80007a98:	fe f8 07 3c 	ld.w	r8,pc[1852]
80007a9c:	11 b8       	ld.ub	r8,r8[0x3]
80007a9e:	fe fa 07 32 	ld.w	r10,pc[1842]
80007aa2:	e0 69 00 86 	mov	r9,134
80007aa6:	b3 3b       	mul	r11,r9
80007aa8:	e0 69 07 da 	mov	r9,2010
80007aac:	f8 09 02 49 	mul	r9,r12,r9
80007ab0:	f6 09 00 09 	add	r9,r11,r9
80007ab4:	f4 09 00 09 	add	r9,r10,r9
80007ab8:	b2 a8       	st.b	r9[0x2],r8
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nLength		= 0x02;
80007aba:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007abe:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007ac2:	fe f9 07 0a 	ld.w	r9,pc[1802]
80007ac6:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007aca:	10 9a       	mov	r10,r8
80007acc:	fe f9 07 04 	ld.w	r9,pc[1796]
80007ad0:	e0 68 00 86 	mov	r8,134
80007ad4:	b1 3a       	mul	r10,r8
80007ad6:	e0 68 07 da 	mov	r8,2010
80007ada:	f6 08 02 48 	mul	r8,r11,r8
80007ade:	f4 08 00 08 	add	r8,r10,r8
80007ae2:	10 09       	add	r9,r8
80007ae4:	30 28       	mov	r8,2
80007ae6:	b2 b8       	st.b	r9[0x3],r8
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nInstruction	= error;
80007ae8:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007aec:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007af0:	fe f9 06 dc 	ld.w	r9,pc[1756]
80007af4:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007af8:	10 9a       	mov	r10,r8
80007afa:	fe f9 06 d6 	ld.w	r9,pc[1750]
80007afe:	e0 68 00 86 	mov	r8,134
80007b02:	b1 3a       	mul	r10,r8
80007b04:	e0 68 07 da 	mov	r8,2010
80007b08:	f6 08 02 48 	mul	r8,r11,r8
80007b0c:	f4 08 00 08 	add	r8,r10,r8
80007b10:	f2 08 00 08 	add	r8,r9,r8
80007b14:	f0 c9 ff fc 	sub	r9,r8,-4
80007b18:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80007b1c:	b2 88       	st.b	r9[0x0],r8
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nChecksum		= calculateChecksum(txCircBuffer[bus][txHead[bus]]);
80007b1e:	ef 36 ff fd 	ld.ub	r6,r7[-3]
80007b22:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007b26:	fe f9 06 a6 	ld.w	r9,pc[1702]
80007b2a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007b2e:	10 95       	mov	r5,r8
80007b30:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007b34:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007b38:	fe f9 06 94 	ld.w	r9,pc[1684]
80007b3c:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007b40:	10 9a       	mov	r10,r8
80007b42:	fe f9 06 8e 	ld.w	r9,pc[1678]
80007b46:	e0 68 00 86 	mov	r8,134
80007b4a:	b1 3a       	mul	r10,r8
80007b4c:	e0 68 07 da 	mov	r8,2010
80007b50:	f6 08 02 48 	mul	r8,r11,r8
80007b54:	f4 08 00 08 	add	r8,r10,r8
80007b58:	10 09       	add	r9,r8
80007b5a:	fa cd 00 88 	sub	sp,sp,136
80007b5e:	1a 98       	mov	r8,sp
80007b60:	e0 6a 00 86 	mov	r10,134
80007b64:	12 9b       	mov	r11,r9
80007b66:	10 9c       	mov	r12,r8
80007b68:	f0 1f 01 97 	mcall	800081c4 <processPacket+0x860>
80007b6c:	f0 1f 01 97 	mcall	800081c8 <processPacket+0x864>
80007b70:	fa cd ff 78 	sub	sp,sp,-136
80007b74:	18 98       	mov	r8,r12
80007b76:	fe fa 06 5a 	ld.w	r10,pc[1626]
80007b7a:	e0 69 00 86 	mov	r9,134
80007b7e:	ea 09 02 4b 	mul	r11,r5,r9
80007b82:	e0 69 07 da 	mov	r9,2010
80007b86:	ec 09 02 49 	mul	r9,r6,r9
80007b8a:	f6 09 00 09 	add	r9,r11,r9
80007b8e:	f4 09 00 09 	add	r9,r10,r9
80007b92:	f2 c9 ff 7c 	sub	r9,r9,-132
80007b96:	b2 88       	st.b	r9[0x0],r8
						
				// Increment the head pointer for the current transmit circular buffer.
				if (++txHead[bus] == NUM_BUSES)
80007b98:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007b9c:	fe f9 06 30 	ld.w	r9,pc[1584]
80007ba0:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007ba4:	2f f9       	sub	r9,-1
80007ba6:	5c 59       	castu.b	r9
80007ba8:	fe fa 06 24 	ld.w	r10,pc[1572]
80007bac:	f4 08 0b 09 	st.b	r10[r8],r9
80007bb0:	fe f9 06 1c 	ld.w	r9,pc[1564]
80007bb4:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007bb8:	30 48       	mov	r8,4
80007bba:	f0 09 18 00 	cp.b	r9,r8
80007bbe:	c0 81       	brne	80007bce <processPacket+0x26a>
				{
					txHead[bus] = 0;
80007bc0:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007bc4:	fe fa 06 08 	ld.w	r10,pc[1544]
80007bc8:	30 08       	mov	r8,0
80007bca:	f4 09 0b 08 	st.b	r10[r9],r8
				}
				
				// Increment the tail pointer for the current receive circular buffer.
				if (++rxTail[bus] == NUM_BUSES)
80007bce:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007bd2:	fe f9 05 e6 	ld.w	r9,pc[1510]
80007bd6:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007bda:	2f f9       	sub	r9,-1
80007bdc:	5c 59       	castu.b	r9
80007bde:	fe fa 05 da 	ld.w	r10,pc[1498]
80007be2:	f4 08 0b 09 	st.b	r10[r8],r9
80007be6:	fe f9 05 d2 	ld.w	r9,pc[1490]
80007bea:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007bee:	30 48       	mov	r8,4
80007bf0:	f0 09 18 00 	cp.b	r9,r8
80007bf4:	c0 81       	brne	80007c04 <processPacket+0x2a0>
				{
					rxTail[bus] = 0;
80007bf6:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007bfa:	fe fa 05 be 	ld.w	r10,pc[1470]
80007bfe:	30 08       	mov	r8,0
80007c00:	f4 09 0b 08 	st.b	r10[r9],r8
				}
	
				error = NO_ERROR;		
80007c04:	30 08       	mov	r8,0
80007c06:	ef 68 ff ff 	st.b	r7[-1],r8
				continue;
80007c0a:	e0 8f 02 99 	bral	8000813c <processPacket+0x7d8>
			}

			// Check the ID field and see if this message was meant for us.
			else if ((rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == RAM[DYNAMIXEL_ID]) || (rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == DYNAMIXEL_ID_BROADCAST))
80007c0e:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007c12:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007c16:	fe f9 05 a2 	ld.w	r9,pc[1442]
80007c1a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007c1e:	10 9a       	mov	r10,r8
80007c20:	fe f9 05 9c 	ld.w	r9,pc[1436]
80007c24:	e0 68 00 86 	mov	r8,134
80007c28:	b1 3a       	mul	r10,r8
80007c2a:	e0 68 07 da 	mov	r8,2010
80007c2e:	f6 08 02 48 	mul	r8,r11,r8
80007c32:	f4 08 00 08 	add	r8,r10,r8
80007c36:	f2 08 00 08 	add	r8,r9,r8
80007c3a:	11 a9       	ld.ub	r9,r8[0x2]
80007c3c:	fe f8 05 98 	ld.w	r8,pc[1432]
80007c40:	11 b8       	ld.ub	r8,r8[0x3]
80007c42:	f0 09 18 00 	cp.b	r9,r8
80007c46:	c1 d0       	breq	80007c80 <processPacket+0x31c>
80007c48:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007c4c:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007c50:	fe f9 05 68 	ld.w	r9,pc[1384]
80007c54:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007c58:	10 9a       	mov	r10,r8
80007c5a:	fe f9 05 62 	ld.w	r9,pc[1378]
80007c5e:	e0 68 00 86 	mov	r8,134
80007c62:	b1 3a       	mul	r10,r8
80007c64:	e0 68 07 da 	mov	r8,2010
80007c68:	f6 08 02 48 	mul	r8,r11,r8
80007c6c:	f4 08 00 08 	add	r8,r10,r8
80007c70:	f2 08 00 08 	add	r8,r9,r8
80007c74:	11 a9       	ld.ub	r9,r8[0x2]
80007c76:	3f e8       	mov	r8,-2
80007c78:	f0 09 18 00 	cp.b	r9,r8
80007c7c:	e0 81 02 54 	brne	80008124 <processPacket+0x7c0>
			{
				// Packet is meant for us.
				switch (rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nInstruction)
80007c80:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007c84:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007c88:	fe f9 05 30 	ld.w	r9,pc[1328]
80007c8c:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007c90:	10 9a       	mov	r10,r8
80007c92:	fe f9 05 2a 	ld.w	r9,pc[1322]
80007c96:	e0 68 00 86 	mov	r8,134
80007c9a:	b1 3a       	mul	r10,r8
80007c9c:	e0 68 07 da 	mov	r8,2010
80007ca0:	f6 08 02 48 	mul	r8,r11,r8
80007ca4:	f4 08 00 08 	add	r8,r10,r8
80007ca8:	f2 08 00 08 	add	r8,r9,r8
80007cac:	2f c8       	sub	r8,-4
80007cae:	11 88       	ld.ub	r8,r8[0x0]
80007cb0:	58 18       	cp.w	r8,1
80007cb2:	e0 81 00 bc 	brne	80007e2a <processPacket+0x4c6>
						 * Parameter..: No parameters.
						 * Checksum...:	~((instruction + length + id) & 0xFF).
						 */
						
						// Generate response packet.
						txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nPreamble		= 0xFFFF;
80007cb6:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007cba:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007cbe:	fe f9 05 0e 	ld.w	r9,pc[1294]
80007cc2:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007cc6:	10 9a       	mov	r10,r8
80007cc8:	fe f9 05 08 	ld.w	r9,pc[1288]
80007ccc:	e0 68 00 86 	mov	r8,134
80007cd0:	b1 3a       	mul	r10,r8
80007cd2:	e0 68 07 da 	mov	r8,2010
80007cd6:	f6 08 02 48 	mul	r8,r11,r8
80007cda:	f4 08 00 08 	add	r8,r10,r8
80007cde:	10 09       	add	r9,r8
80007ce0:	3f f8       	mov	r8,-1
80007ce2:	b2 08       	st.h	r9[0x0],r8
						txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nID			= RAM[DYNAMIXEL_ID];
80007ce4:	ef 3c ff fd 	ld.ub	r12,r7[-3]
80007ce8:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007cec:	fe f9 04 e0 	ld.w	r9,pc[1248]
80007cf0:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007cf4:	10 9b       	mov	r11,r8
80007cf6:	fe f8 04 de 	ld.w	r8,pc[1246]
80007cfa:	11 b8       	ld.ub	r8,r8[0x3]
80007cfc:	fe fa 04 d4 	ld.w	r10,pc[1236]
80007d00:	e0 69 00 86 	mov	r9,134
80007d04:	b3 3b       	mul	r11,r9
80007d06:	e0 69 07 da 	mov	r9,2010
80007d0a:	f8 09 02 49 	mul	r9,r12,r9
80007d0e:	f6 09 00 09 	add	r9,r11,r9
80007d12:	f4 09 00 09 	add	r9,r10,r9
80007d16:	b2 a8       	st.b	r9[0x2],r8
						txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nLength		= 0x02;
80007d18:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007d1c:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007d20:	fe f9 04 ac 	ld.w	r9,pc[1196]
80007d24:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007d28:	10 9a       	mov	r10,r8
80007d2a:	fe f9 04 a6 	ld.w	r9,pc[1190]
80007d2e:	e0 68 00 86 	mov	r8,134
80007d32:	b1 3a       	mul	r10,r8
80007d34:	e0 68 07 da 	mov	r8,2010
80007d38:	f6 08 02 48 	mul	r8,r11,r8
80007d3c:	f4 08 00 08 	add	r8,r10,r8
80007d40:	10 09       	add	r9,r8
80007d42:	30 28       	mov	r8,2
80007d44:	b2 b8       	st.b	r9[0x3],r8
						txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nInstruction	= NO_ERROR;
80007d46:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007d4a:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007d4e:	fe f9 04 7e 	ld.w	r9,pc[1150]
80007d52:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007d56:	10 9a       	mov	r10,r8
80007d58:	fe f9 04 78 	ld.w	r9,pc[1144]
80007d5c:	e0 68 00 86 	mov	r8,134
80007d60:	b1 3a       	mul	r10,r8
80007d62:	e0 68 07 da 	mov	r8,2010
80007d66:	f6 08 02 48 	mul	r8,r11,r8
80007d6a:	f4 08 00 08 	add	r8,r10,r8
80007d6e:	f2 08 00 08 	add	r8,r9,r8
80007d72:	f0 c9 ff fc 	sub	r9,r8,-4
80007d76:	30 08       	mov	r8,0
80007d78:	b2 88       	st.b	r9[0x0],r8
						txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nChecksum		= calculateChecksum(txCircBuffer[bus][txHead[bus]]);
80007d7a:	ef 36 ff fd 	ld.ub	r6,r7[-3]
80007d7e:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007d82:	fe f9 04 4a 	ld.w	r9,pc[1098]
80007d86:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007d8a:	10 95       	mov	r5,r8
80007d8c:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007d90:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007d94:	fe f9 04 38 	ld.w	r9,pc[1080]
80007d98:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007d9c:	10 9a       	mov	r10,r8
80007d9e:	fe f9 04 32 	ld.w	r9,pc[1074]
80007da2:	e0 68 00 86 	mov	r8,134
80007da6:	b1 3a       	mul	r10,r8
80007da8:	e0 68 07 da 	mov	r8,2010
80007dac:	f6 08 02 48 	mul	r8,r11,r8
80007db0:	f4 08 00 08 	add	r8,r10,r8
80007db4:	10 09       	add	r9,r8
80007db6:	fa cd 00 88 	sub	sp,sp,136
80007dba:	1a 98       	mov	r8,sp
80007dbc:	e0 6a 00 86 	mov	r10,134
80007dc0:	12 9b       	mov	r11,r9
80007dc2:	10 9c       	mov	r12,r8
80007dc4:	f0 1f 01 00 	mcall	800081c4 <processPacket+0x860>
80007dc8:	f0 1f 01 00 	mcall	800081c8 <processPacket+0x864>
80007dcc:	fa cd ff 78 	sub	sp,sp,-136
80007dd0:	18 98       	mov	r8,r12
80007dd2:	fe fa 03 fe 	ld.w	r10,pc[1022]
80007dd6:	e0 69 00 86 	mov	r9,134
80007dda:	ea 09 02 4b 	mul	r11,r5,r9
80007dde:	e0 69 07 da 	mov	r9,2010
80007de2:	ec 09 02 49 	mul	r9,r6,r9
80007de6:	f6 09 00 09 	add	r9,r11,r9
80007dea:	f4 09 00 09 	add	r9,r10,r9
80007dee:	f2 c9 ff 7c 	sub	r9,r9,-132
80007df2:	b2 88       	st.b	r9[0x0],r8
						
						if (++txHead[bus] == NUM_BUSES)
80007df4:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007df8:	fe f9 03 d4 	ld.w	r9,pc[980]
80007dfc:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007e00:	2f f9       	sub	r9,-1
80007e02:	5c 59       	castu.b	r9
80007e04:	fe fa 03 c8 	ld.w	r10,pc[968]
80007e08:	f4 08 0b 09 	st.b	r10[r8],r9
80007e0c:	fe f9 03 c0 	ld.w	r9,pc[960]
80007e10:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007e14:	30 48       	mov	r8,4
80007e16:	f0 09 18 00 	cp.b	r9,r8
80007e1a:	c0 81       	brne	80007e2a <processPacket+0x4c6>
						{
							txHead[bus] = 0;
80007e1c:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007e20:	fe fa 03 ac 	ld.w	r10,pc[940]
80007e24:	30 08       	mov	r8,0
80007e26:	f4 09 0b 08 	st.b	r10[r9],r8
						break;
					}
				}
						
				// Replicate received packet across all buses if broadcasting.
				if (rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == DYNAMIXEL_ID_BROADCAST)
80007e2a:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007e2e:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007e32:	fe f9 03 86 	ld.w	r9,pc[902]
80007e36:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007e3a:	10 9a       	mov	r10,r8
80007e3c:	fe f9 03 80 	ld.w	r9,pc[896]
80007e40:	e0 68 00 86 	mov	r8,134
80007e44:	b1 3a       	mul	r10,r8
80007e46:	e0 68 07 da 	mov	r8,2010
80007e4a:	f6 08 02 48 	mul	r8,r11,r8
80007e4e:	f4 08 00 08 	add	r8,r10,r8
80007e52:	f2 08 00 08 	add	r8,r9,r8
80007e56:	11 a9       	ld.ub	r9,r8[0x2]
80007e58:	3f e8       	mov	r8,-2
80007e5a:	f0 09 18 00 	cp.b	r9,r8
80007e5e:	e0 81 01 63 	brne	80008124 <processPacket+0x7c0>
				{
					for (txBus = BUS_1_MOTORS; txBus <= BUS_6_USB; txBus++)
80007e62:	30 08       	mov	r8,0
80007e64:	ef 68 ff fe 	st.b	r7[-2],r8
80007e68:	c5 79       	rjmp	80008116 <processPacket+0x7b2>
					{
						// We don't want to broadcast back on to the bus that the message was received on.
						if (txBus != bus)
80007e6a:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80007e6e:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007e72:	f0 09 18 00 	cp.b	r9,r8
80007e76:	e0 80 01 4b 	breq	8000810c <processPacket+0x7a8>
						{
							txCircBuffer[txBus][txHead[txBus]].INSTRUCTION_PACKET.nPreamble		= rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nPreamble;
80007e7a:	ef 3c ff fe 	ld.ub	r12,r7[-2]
80007e7e:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80007e82:	fe f9 03 4a 	ld.w	r9,pc[842]
80007e86:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007e8a:	10 9b       	mov	r11,r8
80007e8c:	ef 3e ff fd 	ld.ub	lr,r7[-3]
80007e90:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007e94:	fe f9 03 24 	ld.w	r9,pc[804]
80007e98:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007e9c:	10 9a       	mov	r10,r8
80007e9e:	fe f9 03 1e 	ld.w	r9,pc[798]
80007ea2:	e0 68 00 86 	mov	r8,134
80007ea6:	b1 3a       	mul	r10,r8
80007ea8:	e0 68 07 da 	mov	r8,2010
80007eac:	fc 08 02 48 	mul	r8,lr,r8
80007eb0:	f4 08 00 08 	add	r8,r10,r8
80007eb4:	f2 08 00 08 	add	r8,r9,r8
80007eb8:	90 08       	ld.sh	r8,r8[0x0]
80007eba:	fe fa 03 16 	ld.w	r10,pc[790]
80007ebe:	e0 69 00 86 	mov	r9,134
80007ec2:	b3 3b       	mul	r11,r9
80007ec4:	e0 69 07 da 	mov	r9,2010
80007ec8:	f8 09 02 49 	mul	r9,r12,r9
80007ecc:	f6 09 00 09 	add	r9,r11,r9
80007ed0:	f4 09 00 09 	add	r9,r10,r9
80007ed4:	b2 08       	st.h	r9[0x0],r8
							txCircBuffer[txBus][txHead[txBus]].INSTRUCTION_PACKET.nID			= rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID;
80007ed6:	ef 3c ff fe 	ld.ub	r12,r7[-2]
80007eda:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80007ede:	fe f9 02 ee 	ld.w	r9,pc[750]
80007ee2:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007ee6:	10 9b       	mov	r11,r8
80007ee8:	ef 3e ff fd 	ld.ub	lr,r7[-3]
80007eec:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007ef0:	fe f9 02 c8 	ld.w	r9,pc[712]
80007ef4:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007ef8:	10 9a       	mov	r10,r8
80007efa:	fe f9 02 c2 	ld.w	r9,pc[706]
80007efe:	e0 68 00 86 	mov	r8,134
80007f02:	b1 3a       	mul	r10,r8
80007f04:	e0 68 07 da 	mov	r8,2010
80007f08:	fc 08 02 48 	mul	r8,lr,r8
80007f0c:	f4 08 00 08 	add	r8,r10,r8
80007f10:	f2 08 00 08 	add	r8,r9,r8
80007f14:	11 a8       	ld.ub	r8,r8[0x2]
80007f16:	fe fa 02 ba 	ld.w	r10,pc[698]
80007f1a:	e0 69 00 86 	mov	r9,134
80007f1e:	b3 3b       	mul	r11,r9
80007f20:	e0 69 07 da 	mov	r9,2010
80007f24:	f8 09 02 49 	mul	r9,r12,r9
80007f28:	f6 09 00 09 	add	r9,r11,r9
80007f2c:	f4 09 00 09 	add	r9,r10,r9
80007f30:	b2 a8       	st.b	r9[0x2],r8
							txCircBuffer[txBus][txHead[txBus]].INSTRUCTION_PACKET.nLength		= rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nLength;
80007f32:	ef 3c ff fe 	ld.ub	r12,r7[-2]
80007f36:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80007f3a:	fe f9 02 92 	ld.w	r9,pc[658]
80007f3e:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007f42:	10 9b       	mov	r11,r8
80007f44:	ef 3e ff fd 	ld.ub	lr,r7[-3]
80007f48:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007f4c:	fe f9 02 6c 	ld.w	r9,pc[620]
80007f50:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007f54:	10 9a       	mov	r10,r8
80007f56:	fe f9 02 66 	ld.w	r9,pc[614]
80007f5a:	e0 68 00 86 	mov	r8,134
80007f5e:	b1 3a       	mul	r10,r8
80007f60:	e0 68 07 da 	mov	r8,2010
80007f64:	fc 08 02 48 	mul	r8,lr,r8
80007f68:	f4 08 00 08 	add	r8,r10,r8
80007f6c:	f2 08 00 08 	add	r8,r9,r8
80007f70:	11 b8       	ld.ub	r8,r8[0x3]
80007f72:	fe fa 02 5e 	ld.w	r10,pc[606]
80007f76:	e0 69 00 86 	mov	r9,134
80007f7a:	b3 3b       	mul	r11,r9
80007f7c:	e0 69 07 da 	mov	r9,2010
80007f80:	f8 09 02 49 	mul	r9,r12,r9
80007f84:	f6 09 00 09 	add	r9,r11,r9
80007f88:	f4 09 00 09 	add	r9,r10,r9
80007f8c:	b2 b8       	st.b	r9[0x3],r8
							txCircBuffer[txBus][txHead[txBus]].INSTRUCTION_PACKET.nInstruction	= rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nInstruction;
80007f8e:	ef 3c ff fe 	ld.ub	r12,r7[-2]
80007f92:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80007f96:	fe f9 02 36 	ld.w	r9,pc[566]
80007f9a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007f9e:	10 9b       	mov	r11,r8
80007fa0:	ef 3e ff fd 	ld.ub	lr,r7[-3]
80007fa4:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007fa8:	fe f9 02 10 	ld.w	r9,pc[528]
80007fac:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007fb0:	10 9a       	mov	r10,r8
80007fb2:	fe f9 02 0a 	ld.w	r9,pc[522]
80007fb6:	e0 68 00 86 	mov	r8,134
80007fba:	b1 3a       	mul	r10,r8
80007fbc:	e0 68 07 da 	mov	r8,2010
80007fc0:	fc 08 02 48 	mul	r8,lr,r8
80007fc4:	f4 08 00 08 	add	r8,r10,r8
80007fc8:	f2 08 00 08 	add	r8,r9,r8
80007fcc:	2f c8       	sub	r8,-4
80007fce:	11 88       	ld.ub	r8,r8[0x0]
80007fd0:	fe fa 02 00 	ld.w	r10,pc[512]
80007fd4:	e0 69 00 86 	mov	r9,134
80007fd8:	b3 3b       	mul	r11,r9
80007fda:	e0 69 07 da 	mov	r9,2010
80007fde:	f8 09 02 49 	mul	r9,r12,r9
80007fe2:	f6 09 00 09 	add	r9,r11,r9
80007fe6:	f4 09 00 09 	add	r9,r10,r9
80007fea:	2f c9       	sub	r9,-4
80007fec:	b2 88       	st.b	r9[0x0],r8
							memcpy(&txCircBuffer[txBus][txHead[txBus]].INSTRUCTION_PACKET.nParameters, &rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nParameters, (rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nLength - 2) * sizeof(uint8_t));
80007fee:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007ff2:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007ff6:	4f 19       	lddpc	r9,800081b8 <processPacket+0x854>
80007ff8:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007ffc:	10 9a       	mov	r10,r8
80007ffe:	4f 09       	lddpc	r9,800081bc <processPacket+0x858>
80008000:	e0 68 00 86 	mov	r8,134
80008004:	b1 3a       	mul	r10,r8
80008006:	e0 68 07 da 	mov	r8,2010
8000800a:	f6 08 02 48 	mul	r8,r11,r8
8000800e:	f4 08 00 08 	add	r8,r10,r8
80008012:	f2 08 00 08 	add	r8,r9,r8
80008016:	11 b8       	ld.ub	r8,r8[0x3]
80008018:	20 28       	sub	r8,2
8000801a:	10 9a       	mov	r10,r8
8000801c:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80008020:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80008024:	4e 59       	lddpc	r9,800081b8 <processPacket+0x854>
80008026:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000802a:	10 99       	mov	r9,r8
8000802c:	e0 68 00 86 	mov	r8,134
80008030:	b1 39       	mul	r9,r8
80008032:	e0 68 07 da 	mov	r8,2010
80008036:	f6 08 02 48 	mul	r8,r11,r8
8000803a:	f2 08 00 08 	add	r8,r9,r8
8000803e:	f0 c9 ff fc 	sub	r9,r8,-4
80008042:	4d f8       	lddpc	r8,800081bc <processPacket+0x858>
80008044:	f2 08 00 08 	add	r8,r9,r8
80008048:	f0 c9 ff ff 	sub	r9,r8,-1
8000804c:	ef 3c ff fe 	ld.ub	r12,r7[-2]
80008050:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80008054:	4d eb       	lddpc	r11,800081cc <processPacket+0x868>
80008056:	f6 08 07 08 	ld.ub	r8,r11[r8]
8000805a:	10 9b       	mov	r11,r8
8000805c:	e0 68 00 86 	mov	r8,134
80008060:	b1 3b       	mul	r11,r8
80008062:	e0 68 07 da 	mov	r8,2010
80008066:	f8 08 02 48 	mul	r8,r12,r8
8000806a:	f6 08 00 08 	add	r8,r11,r8
8000806e:	f0 cb ff fc 	sub	r11,r8,-4
80008072:	4d 88       	lddpc	r8,800081d0 <processPacket+0x86c>
80008074:	f6 08 00 08 	add	r8,r11,r8
80008078:	2f f8       	sub	r8,-1
8000807a:	12 9b       	mov	r11,r9
8000807c:	10 9c       	mov	r12,r8
8000807e:	f0 1f 00 52 	mcall	800081c4 <processPacket+0x860>
							txCircBuffer[txBus][txHead[txBus]].INSTRUCTION_PACKET.nChecksum		= rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nChecksum;
80008082:	ef 3c ff fe 	ld.ub	r12,r7[-2]
80008086:	ef 38 ff fe 	ld.ub	r8,r7[-2]
8000808a:	4d 19       	lddpc	r9,800081cc <processPacket+0x868>
8000808c:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008090:	10 9b       	mov	r11,r8
80008092:	ef 3e ff fd 	ld.ub	lr,r7[-3]
80008096:	ef 38 ff fd 	ld.ub	r8,r7[-3]
8000809a:	4c 89       	lddpc	r9,800081b8 <processPacket+0x854>
8000809c:	f2 08 07 08 	ld.ub	r8,r9[r8]
800080a0:	10 9a       	mov	r10,r8
800080a2:	4c 79       	lddpc	r9,800081bc <processPacket+0x858>
800080a4:	e0 68 00 86 	mov	r8,134
800080a8:	b1 3a       	mul	r10,r8
800080aa:	e0 68 07 da 	mov	r8,2010
800080ae:	fc 08 02 48 	mul	r8,lr,r8
800080b2:	f4 08 00 08 	add	r8,r10,r8
800080b6:	f2 08 00 08 	add	r8,r9,r8
800080ba:	f0 c8 ff 7c 	sub	r8,r8,-132
800080be:	11 88       	ld.ub	r8,r8[0x0]
800080c0:	4c 4a       	lddpc	r10,800081d0 <processPacket+0x86c>
800080c2:	e0 69 00 86 	mov	r9,134
800080c6:	b3 3b       	mul	r11,r9
800080c8:	e0 69 07 da 	mov	r9,2010
800080cc:	f8 09 02 49 	mul	r9,r12,r9
800080d0:	f6 09 00 09 	add	r9,r11,r9
800080d4:	f4 09 00 09 	add	r9,r10,r9
800080d8:	f2 c9 ff 7c 	sub	r9,r9,-132
800080dc:	b2 88       	st.b	r9[0x0],r8
						
							// Increment the head pointer for the current transmit circular buffer.
							if (++txHead[txBus] == NUM_BUSES)
800080de:	ef 38 ff fe 	ld.ub	r8,r7[-2]
800080e2:	4b b9       	lddpc	r9,800081cc <processPacket+0x868>
800080e4:	f2 08 07 09 	ld.ub	r9,r9[r8]
800080e8:	2f f9       	sub	r9,-1
800080ea:	5c 59       	castu.b	r9
800080ec:	4b 8a       	lddpc	r10,800081cc <processPacket+0x868>
800080ee:	f4 08 0b 09 	st.b	r10[r8],r9
800080f2:	4b 79       	lddpc	r9,800081cc <processPacket+0x868>
800080f4:	f2 08 07 09 	ld.ub	r9,r9[r8]
800080f8:	30 48       	mov	r8,4
800080fa:	f0 09 18 00 	cp.b	r9,r8
800080fe:	c0 71       	brne	8000810c <processPacket+0x7a8>
							{
								txHead[txBus] = 0;
80008100:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80008104:	4b 2a       	lddpc	r10,800081cc <processPacket+0x868>
80008106:	30 08       	mov	r8,0
80008108:	f4 09 0b 08 	st.b	r10[r9],r8
				}
						
				// Replicate received packet across all buses if broadcasting.
				if (rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == DYNAMIXEL_ID_BROADCAST)
				{
					for (txBus = BUS_1_MOTORS; txBus <= BUS_6_USB; txBus++)
8000810c:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80008110:	2f f8       	sub	r8,-1
80008112:	ef 68 ff fe 	st.b	r7[-2],r8
80008116:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000811a:	30 38       	mov	r8,3
8000811c:	f0 09 18 00 	cp.b	r9,r8
80008120:	fe 98 fe a5 	brls	80007e6a <processPacket+0x506>
				// Packet is meant for a different device. So route it to the correct USART accordingly.
				;
			}
			
			// Increment the tail pointer for the current receive circular buffer.
			rxTail[bus]++;
80008124:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80008128:	4a 49       	lddpc	r9,800081b8 <processPacket+0x854>
8000812a:	f2 08 07 09 	ld.ub	r9,r9[r8]
8000812e:	2f f9       	sub	r9,-1
80008130:	5c 59       	castu.b	r9
80008132:	4a 2a       	lddpc	r10,800081b8 <processPacket+0x854>
80008134:	f4 08 0b 09 	st.b	r10[r8],r9
80008138:	c0 28       	rjmp	8000813c <processPacket+0x7d8>
	// Check each bus for anything to process.
	for (bus = BUS_1_MOTORS; bus <= BUS_6_USB; bus++)
	{
		// We need only check the receive buffers to see if there is anything to process.
		// The transmit buffers are filled as a result of our processing.
		while (rxTail[bus] != rxHead[bus])
8000813a:	d7 03       	nop
8000813c:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80008140:	49 e9       	lddpc	r9,800081b8 <processPacket+0x854>
80008142:	f2 08 07 09 	ld.ub	r9,r9[r8]
80008146:	ef 38 ff fd 	ld.ub	r8,r7[-3]
8000814a:	4a 4a       	lddpc	r10,800081d8 <processPacket+0x874>
8000814c:	f4 08 07 08 	ld.ub	r8,r10[r8]
80008150:	f0 09 18 00 	cp.b	r9,r8
80008154:	fe 91 fc 11 	brne	80007976 <processPacket+0x12>
{
	uint8_t bus, txBus;
	uint8_t error;
	
	// Check each bus for anything to process.
	for (bus = BUS_1_MOTORS; bus <= BUS_6_USB; bus++)
80008158:	ef 38 ff fd 	ld.ub	r8,r7[-3]
8000815c:	2f f8       	sub	r8,-1
8000815e:	ef 68 ff fd 	st.b	r7[-3],r8
80008162:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80008166:	30 38       	mov	r8,3
80008168:	f0 09 18 00 	cp.b	r9,r8
8000816c:	fe 98 ff e7 	brls	8000813a <processPacket+0x7d6>
			// Increment the tail pointer for the current receive circular buffer.
			rxTail[bus]++;
		}
	}

	for (bus = BUS_1_MOTORS; bus < BUS_6_USB; bus++)
80008170:	30 08       	mov	r8,0
80008172:	ef 68 ff fd 	st.b	r7[-3],r8
80008176:	c1 78       	rjmp	800081a4 <processPacket+0x840>
	{
		// If UART is open
		if (BUS[bus]->imr & AVR32_USART_IER_RXRDY_MASK)
80008178:	ef 39 ff fd 	ld.ub	r9,r7[-3]
8000817c:	49 88       	lddpc	r8,800081dc <processPacket+0x878>
8000817e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008182:	70 48       	ld.w	r8,r8[0x10]
80008184:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008188:	5c 58       	castu.b	r8
8000818a:	c0 80       	breq	8000819a <processPacket+0x836>
		{
			// Enable UART TX interrupt to send a new value
			BUS[bus]->ier = AVR32_USART_IER_TXRDY_MASK;
8000818c:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80008190:	49 38       	lddpc	r8,800081dc <processPacket+0x878>
80008192:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008196:	30 29       	mov	r9,2
80008198:	91 29       	st.w	r8[0x8],r9
			// Increment the tail pointer for the current receive circular buffer.
			rxTail[bus]++;
		}
	}

	for (bus = BUS_1_MOTORS; bus < BUS_6_USB; bus++)
8000819a:	ef 38 ff fd 	ld.ub	r8,r7[-3]
8000819e:	2f f8       	sub	r8,-1
800081a0:	ef 68 ff fd 	st.b	r7[-3],r8
800081a4:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800081a8:	30 28       	mov	r8,2
800081aa:	f0 09 18 00 	cp.b	r9,r8
800081ae:	fe 98 ff e5 	brls	80008178 <processPacket+0x814>
		{
			// Enable UART TX interrupt to send a new value
			BUS[bus]->ier = AVR32_USART_IER_TXRDY_MASK;
		}
	}
}
800081b2:	2f fd       	sub	sp,-4
800081b4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
800081b8:	00 00       	add	r0,r0
800081ba:	46 28       	lddsp	r8,sp[0x188]
800081bc:	00 00       	add	r0,r0
800081be:	26 ac       	sub	r12,106
800081c0:	80 00       	ld.sh	r0,r0[0x0]
800081c2:	77 6c       	ld.w	r12,r11[0x58]
800081c4:	80 00       	ld.sh	r0,r0[0x0]
800081c6:	8c 08       	ld.sh	r8,r6[0x0]
800081c8:	80 00       	ld.sh	r0,r0[0x0]
800081ca:	77 a6       	ld.w	r6,r11[0x68]
800081cc:	00 00       	add	r0,r0
800081ce:	46 14       	lddsp	r4,sp[0x184]
800081d0:	00 00       	add	r0,r0
800081d2:	07 44       	ld.w	r4,--r3
800081d4:	80 80       	ld.uh	r0,r0[0x0]
800081d6:	00 00       	add	r0,r0
800081d8:	00 00       	add	r0,r0
800081da:	46 24       	lddsp	r4,sp[0x188]
800081dc:	00 00       	add	r0,r0
800081de:	46 34       	lddsp	r4,sp[0x18c]

800081e0 <motorBusIntteruptController>:

void motorBusIntteruptController(uint8_t motorBus)
{	
800081e0:	eb cd 40 80 	pushm	r7,lr
800081e4:	1a 97       	mov	r7,sp
800081e6:	20 5d       	sub	sp,20
800081e8:	18 98       	mov	r8,r12
800081ea:	ef 68 ff ec 	st.b	r7[-20],r8
	int txData;
	
    // There is a message being received from one of the buses.
	if (BUS[motorBus]->csr & AVR32_USART_CSR_RXRDY_MASK)
800081ee:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800081f2:	fe f8 03 b2 	ld.w	r8,pc[946]
800081f6:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800081fa:	70 58       	ld.w	r8,r8[0x14]
800081fc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008200:	5c 58       	castu.b	r8
80008202:	e0 80 00 fd 	breq	800083fc <motorBusIntteruptController+0x21c>
	{
		if (usart_read_char(BUS[motorBus], (int *)&rxCircBuffer[motorBus][txTail[motorBus]].packet[txPosition[motorBus]]) != USART_SUCCESS)
80008206:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000820a:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000820e:	fe f9 03 9a 	ld.w	r9,pc[922]
80008212:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008216:	10 99       	mov	r9,r8
80008218:	e0 68 00 86 	mov	r8,134
8000821c:	b1 39       	mul	r9,r8
8000821e:	e0 68 07 da 	mov	r8,2010
80008222:	f4 08 02 48 	mul	r8,r10,r8
80008226:	10 09       	add	r9,r8
80008228:	fe f8 03 84 	ld.w	r8,pc[900]
8000822c:	f2 08 00 08 	add	r8,r9,r8
80008230:	10 99       	mov	r9,r8
80008232:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80008236:	fe f8 03 7a 	ld.w	r8,pc[890]
8000823a:	f0 0a 04 18 	ld.sh	r8,r8[r10<<0x1]
8000823e:	5c 78       	castu.h	r8
80008240:	10 09       	add	r9,r8
80008242:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80008246:	fe f8 03 5e 	ld.w	r8,pc[862]
8000824a:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
8000824e:	12 9b       	mov	r11,r9
80008250:	10 9c       	mov	r12,r8
80008252:	f0 1f 00 d9 	mcall	800085b4 <motorBusIntteruptController+0x3d4>
80008256:	18 98       	mov	r8,r12
80008258:	58 08       	cp.w	r8,0
8000825a:	c1 70       	breq	80008288 <motorBusIntteruptController+0xa8>
		{
			// Receiver was not ready or an error occurred.
			usart_reset_status(BUS[motorBus]);
8000825c:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008260:	fe f8 03 44 	ld.w	r8,pc[836]
80008264:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008268:	ef 48 ff f4 	st.w	r7[-12],r8
 *
 * \param usart   Base address of the USART instance.
 */
__always_inline static void usart_reset_status(volatile avr32_usart_t *usart)
{
  usart->cr = AVR32_USART_CR_RSTSTA_MASK;
8000826c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008270:	e0 69 01 00 	mov	r9,256
80008274:	91 09       	st.w	r8[0x0],r9
			BUS[motorBus]->idr = AVR32_USART_IER_RXRDY_MASK;
80008276:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000827a:	fe f8 03 2a 	ld.w	r8,pc[810]
8000827e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008282:	30 19       	mov	r9,1
80008284:	91 39       	st.w	r8[0xc],r9
80008286:	cb b8       	rjmp	800083fc <motorBusIntteruptController+0x21c>
		else
		{
			// We read a character, now sanity check it.
	    
			// Verify each byte of the preamble.
			if ((rxPosition[motorBus] == 0) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[0] != 0xFF))
80008288:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000828c:	fe f8 03 2c 	ld.w	r8,pc[812]
80008290:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80008294:	58 08       	cp.w	r8,0
80008296:	c2 41       	brne	800082de <motorBusIntteruptController+0xfe>
80008298:	ef 3b ff ec 	ld.ub	r11,r7[-20]
8000829c:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800082a0:	fe f9 03 1c 	ld.w	r9,pc[796]
800082a4:	f2 08 07 08 	ld.ub	r8,r9[r8]
800082a8:	10 9a       	mov	r10,r8
800082aa:	fe f9 03 02 	ld.w	r9,pc[770]
800082ae:	e0 68 00 86 	mov	r8,134
800082b2:	b1 3a       	mul	r10,r8
800082b4:	e0 68 07 da 	mov	r8,2010
800082b8:	f6 08 02 48 	mul	r8,r11,r8
800082bc:	f4 08 00 08 	add	r8,r10,r8
800082c0:	f2 08 00 08 	add	r8,r9,r8
800082c4:	11 89       	ld.ub	r9,r8[0x0]
800082c6:	3f f8       	mov	r8,-1
800082c8:	f0 09 18 00 	cp.b	r9,r8
800082cc:	c0 90       	breq	800082de <motorBusIntteruptController+0xfe>
			{
				// Preamble is wrong. Ignore this character and start again.
				rxPosition[motorBus] = 0;
800082ce:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800082d2:	fe f9 02 e6 	ld.w	r9,pc[742]
800082d6:	30 08       	mov	r8,0
800082d8:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
		else
		{
			// We read a character, now sanity check it.
	    
			// Verify each byte of the preamble.
			if ((rxPosition[motorBus] == 0) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[0] != 0xFF))
800082dc:	c9 08       	rjmp	800083fc <motorBusIntteruptController+0x21c>
			{
				// Preamble is wrong. Ignore this character and start again.
				rxPosition[motorBus] = 0;
			}
	    
			else if ((rxPosition[motorBus] == 1) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[1] != 0xFF))
800082de:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800082e2:	fe f8 02 d6 	ld.w	r8,pc[726]
800082e6:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800082ea:	30 18       	mov	r8,1
800082ec:	f0 09 19 00 	cp.h	r9,r8
800082f0:	c2 51       	brne	8000833a <motorBusIntteruptController+0x15a>
800082f2:	ef 3b ff ec 	ld.ub	r11,r7[-20]
800082f6:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800082fa:	fe f9 02 c2 	ld.w	r9,pc[706]
800082fe:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008302:	10 9a       	mov	r10,r8
80008304:	fe f9 02 a8 	ld.w	r9,pc[680]
80008308:	e0 68 00 86 	mov	r8,134
8000830c:	b1 3a       	mul	r10,r8
8000830e:	e0 68 07 da 	mov	r8,2010
80008312:	f6 08 02 48 	mul	r8,r11,r8
80008316:	f4 08 00 08 	add	r8,r10,r8
8000831a:	f2 08 00 08 	add	r8,r9,r8
8000831e:	2f f8       	sub	r8,-1
80008320:	11 89       	ld.ub	r9,r8[0x0]
80008322:	3f f8       	mov	r8,-1
80008324:	f0 09 18 00 	cp.b	r9,r8
80008328:	c0 90       	breq	8000833a <motorBusIntteruptController+0x15a>
			{
				// Preamble is wrong. Ignore this character and start again.
				rxPosition[motorBus] = 0;
8000832a:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000832e:	fe f9 02 8a 	ld.w	r9,pc[650]
80008332:	30 08       	mov	r8,0
80008334:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			{
				// Preamble is wrong. Ignore this character and start again.
				rxPosition[motorBus] = 0;
			}
	    
			else if ((rxPosition[motorBus] == 1) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[1] != 0xFF))
80008338:	c6 28       	rjmp	800083fc <motorBusIntteruptController+0x21c>
			// When we read in the last parameter we need to jump to the checksum position.
			// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0.
			// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
			// 5 - 1 + (length - 2) = length + 2.
			// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
			else if (rxPosition[motorBus] == (rxCircBuffer[motorBus][rxHead[motorBus]].INSTRUCTION_PACKET.nLength + 2))
8000833a:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000833e:	fe f8 02 7a 	ld.w	r8,pc[634]
80008342:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80008346:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000834a:	ef 3c ff ec 	ld.ub	r12,r7[-20]
8000834e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008352:	fe fa 02 6a 	ld.w	r10,pc[618]
80008356:	f4 08 07 08 	ld.ub	r8,r10[r8]
8000835a:	10 9b       	mov	r11,r8
8000835c:	fe fa 02 50 	ld.w	r10,pc[592]
80008360:	e0 68 00 86 	mov	r8,134
80008364:	b1 3b       	mul	r11,r8
80008366:	e0 68 07 da 	mov	r8,2010
8000836a:	f8 08 02 48 	mul	r8,r12,r8
8000836e:	f6 08 00 08 	add	r8,r11,r8
80008372:	f4 08 00 08 	add	r8,r10,r8
80008376:	11 b8       	ld.ub	r8,r8[0x3]
80008378:	2f e8       	sub	r8,-2
8000837a:	10 39       	cp.w	r9,r8
8000837c:	c0 a1       	brne	80008390 <motorBusIntteruptController+0x1b0>
			{
				rxPosition[motorBus] = MAX_PARAMETERS + 5;
8000837e:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80008382:	fe f9 02 36 	ld.w	r9,pc[566]
80008386:	e0 68 00 84 	mov	r8,132
8000838a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
8000838e:	c3 78       	rjmp	800083fc <motorBusIntteruptController+0x21c>
			}

			// We just read in the checksum byte, so we are done.
			// The checksum byte can be verified later.
			else if (rxPosition[motorBus] == (MAX_PARAMETERS + 5))
80008390:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008394:	fe f8 02 24 	ld.w	r8,pc[548]
80008398:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
8000839c:	e0 68 00 84 	mov	r8,132
800083a0:	f0 09 19 00 	cp.h	r9,r8
800083a4:	c2 21       	brne	800083e8 <motorBusIntteruptController+0x208>
			{
				if (++rxHead[motorBus] == NUM_BUSES)
800083a6:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800083aa:	fe f9 02 12 	ld.w	r9,pc[530]
800083ae:	f2 08 07 09 	ld.ub	r9,r9[r8]
800083b2:	2f f9       	sub	r9,-1
800083b4:	5c 59       	castu.b	r9
800083b6:	fe fa 02 06 	ld.w	r10,pc[518]
800083ba:	f4 08 0b 09 	st.b	r10[r8],r9
800083be:	fe f9 01 fe 	ld.w	r9,pc[510]
800083c2:	f2 08 07 09 	ld.ub	r9,r9[r8]
800083c6:	30 48       	mov	r8,4
800083c8:	f0 09 18 00 	cp.b	r9,r8
800083cc:	c0 71       	brne	800083da <motorBusIntteruptController+0x1fa>
				{
					rxHead[motorBus] = 0;
800083ce:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800083d2:	4f ba       	lddpc	r10,800085bc <motorBusIntteruptController+0x3dc>
800083d4:	30 08       	mov	r8,0
800083d6:	f4 09 0b 08 	st.b	r10[r9],r8
				}

				rxPosition[motorBus] = 0;
800083da:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800083de:	4f 79       	lddpc	r9,800085b8 <motorBusIntteruptController+0x3d8>
800083e0:	30 08       	mov	r8,0
800083e2:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
800083e6:	c0 b8       	rjmp	800083fc <motorBusIntteruptController+0x21c>
			}

			// There is no sanity checking to perform on this byte.
			else
			{
				rxPosition[motorBus]++;
800083e8:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800083ec:	4f 39       	lddpc	r9,800085b8 <motorBusIntteruptController+0x3d8>
800083ee:	f2 08 04 19 	ld.sh	r9,r9[r8<<0x1]
800083f2:	2f f9       	sub	r9,-1
800083f4:	5c 89       	casts.h	r9
800083f6:	4f 1a       	lddpc	r10,800085b8 <motorBusIntteruptController+0x3d8>
800083f8:	f4 08 0a 19 	st.h	r10[r8<<0x1],r9
			}
		}
	}

	// There is a message to be transmitted to one of the buses.
	if (BUS[motorBus]->csr & AVR32_USART_CSR_TXRDY_MASK)
800083fc:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008400:	4e 98       	lddpc	r8,800085a4 <motorBusIntteruptController+0x3c4>
80008402:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008406:	70 58       	ld.w	r8,r8[0x14]
80008408:	e2 18 00 02 	andl	r8,0x2,COH
8000840c:	e0 80 00 c8 	breq	8000859c <motorBusIntteruptController+0x3bc>
	{
		if (txTail[motorBus] != txHead[motorBus])
80008410:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008414:	4e 59       	lddpc	r9,800085a8 <motorBusIntteruptController+0x3c8>
80008416:	f2 08 07 09 	ld.ub	r9,r9[r8]
8000841a:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000841e:	4e 9a       	lddpc	r10,800085c0 <motorBusIntteruptController+0x3e0>
80008420:	f4 08 07 08 	ld.ub	r8,r10[r8]
80008424:	f0 09 18 00 	cp.b	r9,r8
80008428:	e0 80 00 a7 	breq	80008576 <motorBusIntteruptController+0x396>
		{
			if (usart_tx_ready(BUS[motorBus]))
8000842c:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008430:	4d d8       	lddpc	r8,800085a4 <motorBusIntteruptController+0x3c4>
80008432:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008436:	ef 48 ff f8 	st.w	r7[-8],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
8000843a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000843e:	70 58       	ld.w	r8,r8[0x14]
80008440:	e2 18 00 02 	andl	r8,0x2,COH
80008444:	5f 18       	srne	r8
80008446:	58 08       	cp.w	r8,0
80008448:	e0 80 00 aa 	breq	8000859c <motorBusIntteruptController+0x3bc>
			{
				// Write byte to the Transmitter Holding Register.
				txData = txCircBuffer[motorBus][txTail[motorBus]].packet[txPosition[motorBus]];
8000844c:	ef 3c ff ec 	ld.ub	r12,r7[-20]
80008450:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008454:	4d 59       	lddpc	r9,800085a8 <motorBusIntteruptController+0x3c8>
80008456:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000845a:	10 9b       	mov	r11,r8
8000845c:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008460:	4d 48       	lddpc	r8,800085b0 <motorBusIntteruptController+0x3d0>
80008462:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80008466:	5c 78       	castu.h	r8
80008468:	4d 7a       	lddpc	r10,800085c4 <motorBusIntteruptController+0x3e4>
8000846a:	e0 69 00 86 	mov	r9,134
8000846e:	b3 3b       	mul	r11,r9
80008470:	e0 69 07 da 	mov	r9,2010
80008474:	f8 09 02 49 	mul	r9,r12,r9
80008478:	f6 09 00 09 	add	r9,r11,r9
8000847c:	f4 09 00 09 	add	r9,r10,r9
80008480:	f2 08 00 08 	add	r8,r9,r8
80008484:	11 88       	ld.ub	r8,r8[0x0]
80008486:	ef 48 ff f0 	st.w	r7[-16],r8
			    BUS[motorBus]->THR.txchr = txData & 0x1FF;
8000848a:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000848e:	4c 68       	lddpc	r8,800085a4 <motorBusIntteruptController+0x3c4>
80008490:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80008494:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008498:	5c 88       	casts.h	r8
8000849a:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
8000849e:	5c 88       	casts.h	r8
800084a0:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800084a4:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800084a8:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
800084ac:	72 78       	ld.w	r8,r9[0x1c]
800084ae:	f1 da d0 09 	bfins	r8,r10,0x0,0x9
800084b2:	93 78       	st.w	r9[0x1c],r8

				udi_cdc_putc(txData & 0x1FF);
800084b4:	ee f8 ff f0 	ld.w	r8,r7[-16]
800084b8:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800084bc:	10 9c       	mov	r12,r8
800084be:	f0 1f 00 43 	mcall	800085c8 <motorBusIntteruptController+0x3e8>
				// When we write the last parameter we need to jump to the checksum position.
				// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0.
				// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
				// 5 - 1 + (length - 2) = length + 2.
				// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
				if (txPosition[motorBus] == (txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nLength + 2))
800084c2:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800084c6:	4b b8       	lddpc	r8,800085b0 <motorBusIntteruptController+0x3d0>
800084c8:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800084cc:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800084d0:	ef 3c ff ec 	ld.ub	r12,r7[-20]
800084d4:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800084d8:	4b 4a       	lddpc	r10,800085a8 <motorBusIntteruptController+0x3c8>
800084da:	f4 08 07 08 	ld.ub	r8,r10[r8]
800084de:	10 9b       	mov	r11,r8
800084e0:	4b 9a       	lddpc	r10,800085c4 <motorBusIntteruptController+0x3e4>
800084e2:	e0 68 00 86 	mov	r8,134
800084e6:	b1 3b       	mul	r11,r8
800084e8:	e0 68 07 da 	mov	r8,2010
800084ec:	f8 08 02 48 	mul	r8,r12,r8
800084f0:	f6 08 00 08 	add	r8,r11,r8
800084f4:	f4 08 00 08 	add	r8,r10,r8
800084f8:	11 b8       	ld.ub	r8,r8[0x3]
800084fa:	2f e8       	sub	r8,-2
800084fc:	10 39       	cp.w	r9,r8
800084fe:	c0 91       	brne	80008510 <motorBusIntteruptController+0x330>
				{
					txPosition[motorBus] = MAX_PARAMETERS + 5;
80008500:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80008504:	4a b9       	lddpc	r9,800085b0 <motorBusIntteruptController+0x3d0>
80008506:	e0 68 00 84 	mov	r8,132
8000850a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
8000850e:	c4 78       	rjmp	8000859c <motorBusIntteruptController+0x3bc>
				}

				// We just wrote the checksum byte, so we are done.
				else if (txPosition[motorBus] == (MAX_PARAMETERS + 5))
80008510:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008514:	4a 78       	lddpc	r8,800085b0 <motorBusIntteruptController+0x3d0>
80008516:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
8000851a:	e0 68 00 84 	mov	r8,132
8000851e:	f0 09 19 00 	cp.h	r9,r8
80008522:	c1 f1       	brne	80008560 <motorBusIntteruptController+0x380>
				{
					if (++txTail[motorBus] == NUM_BUSES)
80008524:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008528:	4a 09       	lddpc	r9,800085a8 <motorBusIntteruptController+0x3c8>
8000852a:	f2 08 07 09 	ld.ub	r9,r9[r8]
8000852e:	2f f9       	sub	r9,-1
80008530:	5c 59       	castu.b	r9
80008532:	49 ea       	lddpc	r10,800085a8 <motorBusIntteruptController+0x3c8>
80008534:	f4 08 0b 09 	st.b	r10[r8],r9
80008538:	49 c9       	lddpc	r9,800085a8 <motorBusIntteruptController+0x3c8>
8000853a:	f2 08 07 09 	ld.ub	r9,r9[r8]
8000853e:	30 48       	mov	r8,4
80008540:	f0 09 18 00 	cp.b	r9,r8
80008544:	c0 71       	brne	80008552 <motorBusIntteruptController+0x372>
					{
						txTail[motorBus] = 0;
80008546:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000854a:	49 8a       	lddpc	r10,800085a8 <motorBusIntteruptController+0x3c8>
8000854c:	30 08       	mov	r8,0
8000854e:	f4 09 0b 08 	st.b	r10[r9],r8
					}

					txPosition[motorBus] = 0;
80008552:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80008556:	49 79       	lddpc	r9,800085b0 <motorBusIntteruptController+0x3d0>
80008558:	30 08       	mov	r8,0
8000855a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
8000855e:	c1 f8       	rjmp	8000859c <motorBusIntteruptController+0x3bc>
				}

				else
				{
					txPosition[motorBus]++;
80008560:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008564:	49 39       	lddpc	r9,800085b0 <motorBusIntteruptController+0x3d0>
80008566:	f2 08 04 19 	ld.sh	r9,r9[r8<<0x1]
8000856a:	2f f9       	sub	r9,-1
8000856c:	5c 89       	casts.h	r9
8000856e:	49 1a       	lddpc	r10,800085b0 <motorBusIntteruptController+0x3d0>
80008570:	f4 08 0a 19 	st.h	r10[r8<<0x1],r9
80008574:	c1 48       	rjmp	8000859c <motorBusIntteruptController+0x3bc>
		}
    
		else
		{
			// Nothing to transmit.
			usart_reset_status(BUS[motorBus]);
80008576:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000857a:	48 b8       	lddpc	r8,800085a4 <motorBusIntteruptController+0x3c4>
8000857c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008580:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \param usart   Base address of the USART instance.
 */
__always_inline static void usart_reset_status(volatile avr32_usart_t *usart)
{
  usart->cr = AVR32_USART_CR_RSTSTA_MASK;
80008584:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008588:	e0 69 01 00 	mov	r9,256
8000858c:	91 09       	st.w	r8[0x0],r9
			BUS[motorBus]->idr = AVR32_USART_IER_TXRDY_MASK;
8000858e:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008592:	48 58       	lddpc	r8,800085a4 <motorBusIntteruptController+0x3c4>
80008594:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008598:	30 29       	mov	r9,2
8000859a:	91 39       	st.w	r8[0xc],r9
		}
	}
}
8000859c:	2f bd       	sub	sp,-20
8000859e:	e3 cd 80 80 	ldm	sp++,r7,pc
800085a2:	00 00       	add	r0,r0
800085a4:	00 00       	add	r0,r0
800085a6:	46 34       	lddsp	r4,sp[0x18c]
800085a8:	00 00       	add	r0,r0
800085aa:	46 18       	lddsp	r8,sp[0x184]
800085ac:	00 00       	add	r0,r0
800085ae:	26 ac       	sub	r12,106
800085b0:	00 00       	add	r0,r0
800085b2:	46 1c       	lddsp	r12,sp[0x184]
800085b4:	80 00       	ld.sh	r0,r0[0x0]
800085b6:	2f 70       	sub	r0,-9
800085b8:	00 00       	add	r0,r0
800085ba:	46 2c       	lddsp	r12,sp[0x188]
800085bc:	00 00       	add	r0,r0
800085be:	46 24       	lddsp	r4,sp[0x188]
800085c0:	00 00       	add	r0,r0
800085c2:	46 14       	lddsp	r4,sp[0x184]
800085c4:	00 00       	add	r0,r0
800085c6:	07 44       	ld.w	r4,--r3
800085c8:	80 00       	ld.sh	r0,r0[0x0]
800085ca:	66 00       	ld.w	r0,r3[0x0]

800085cc <usart_interrupt>:

__attribute__((__interrupt__)) static void usart_interrupt(void)
{
800085cc:	eb cd 40 80 	pushm	r7,lr
800085d0:	1a 97       	mov	r7,sp
	motorBusIntteruptController(1);
800085d2:	30 1c       	mov	r12,1
800085d4:	f0 1f 00 03 	mcall	800085e0 <usart_interrupt+0x14>
}
800085d8:	e3 cd 40 80 	ldm	sp++,r7,lr
800085dc:	d6 03       	rete
800085de:	00 00       	add	r0,r0
800085e0:	80 00       	ld.sh	r0,r0[0x0]
800085e2:	81 e0       	st.w	r0[0x38],r0

800085e4 <usb_rx_notify>:

void usb_rx_notify(uint8_t port)
{
800085e4:	eb cd 40 80 	pushm	r7,lr
800085e8:	1a 97       	mov	r7,sp
800085ea:	20 2d       	sub	sp,8
800085ec:	18 98       	mov	r8,r12
800085ee:	ef 68 ff f8 	st.b	r7[-8],r8
	uint8_t bus;
	
	readUSB = 1;
800085f2:	49 49       	lddpc	r9,80008640 <usb_rx_notify+0x5c>
800085f4:	30 18       	mov	r8,1
800085f6:	b2 88       	st.b	r9[0x0],r8
	
	// Loop through all USARTs and, if they are open, trigger the TX interrupt.
	for (bus = BUS_1_MOTORS; bus < BUS_6_USB; bus++)
800085f8:	30 08       	mov	r8,0
800085fa:	ef 68 ff ff 	st.b	r7[-1],r8
800085fe:	c1 78       	rjmp	8000862c <usb_rx_notify+0x48>
	{
		// If UART is open
		if (BUS[bus]->imr & AVR32_USART_IER_RXRDY_MASK)
80008600:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008604:	49 08       	lddpc	r8,80008644 <usb_rx_notify+0x60>
80008606:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000860a:	70 48       	ld.w	r8,r8[0x10]
8000860c:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008610:	5c 58       	castu.b	r8
80008612:	c0 80       	breq	80008622 <usb_rx_notify+0x3e>
		{
			// Enable UART TX interrupt to send a new value
			BUS[bus]->ier = AVR32_USART_IER_TXRDY_MASK;
80008614:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008618:	48 b8       	lddpc	r8,80008644 <usb_rx_notify+0x60>
8000861a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000861e:	30 29       	mov	r9,2
80008620:	91 29       	st.w	r8[0x8],r9
	uint8_t bus;
	
	readUSB = 1;
	
	// Loop through all USARTs and, if they are open, trigger the TX interrupt.
	for (bus = BUS_1_MOTORS; bus < BUS_6_USB; bus++)
80008622:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80008626:	2f f8       	sub	r8,-1
80008628:	ef 68 ff ff 	st.b	r7[-1],r8
8000862c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008630:	30 28       	mov	r8,2
80008632:	f0 09 18 00 	cp.b	r9,r8
80008636:	fe 98 ff e5 	brls	80008600 <usb_rx_notify+0x1c>
	 *						Bit 1: Angle Limit Error. Goal position is out of range from CW Angle Limit to CCW Angle Limit.
	 *						Bit 0: Input Voltage Error. Applied input voltage is out of range.
	 * N-Byte Parameter.	N = Length - 2. This is the packet data.
	 * 1 Byte Checksum.		Checksum = ~((ID + Length + Instruction + Parameter1 + .... = Parameter N) & 0xFF).
	 */	
}
8000863a:	2f ed       	sub	sp,-8
8000863c:	e3 cd 80 80 	ldm	sp++,r7,pc
80008640:	00 00       	add	r0,r0
80008642:	46 44       	lddsp	r4,sp[0x190]
80008644:	00 00       	add	r0,r0
80008646:	46 34       	lddsp	r4,sp[0x18c]

80008648 <uart_config>:


void uart_config(uint8_t port, usb_cdc_line_coding_t * cfg)
{
80008648:	eb cd 40 80 	pushm	r7,lr
8000864c:	1a 97       	mov	r7,sp
8000864e:	20 2d       	sub	sp,8
80008650:	18 98       	mov	r8,r12
80008652:	ef 4b ff f8 	st.w	r7[-8],r11
80008656:	ef 68 ff fc 	st.b	r7[-4],r8
	// Initialise RAM table.
	initRAM();
8000865a:	f0 1f 00 0c 	mcall	80008688 <uart_config+0x40>

	// Options for USART.
	usart_options.baudrate		= 921600; // RAM[BAUD_RATE] * 500000; // 921600;
8000865e:	48 c8       	lddpc	r8,8000868c <uart_config+0x44>
80008660:	ee 69 10 00 	mov	r9,921600
80008664:	91 09       	st.w	r8[0x0],r9
	usart_options.charlength	= 0x08;
80008666:	48 a9       	lddpc	r9,8000868c <uart_config+0x44>
80008668:	30 88       	mov	r8,8
8000866a:	b2 c8       	st.b	r9[0x4],r8
	usart_options.paritytype	= USART_NO_PARITY;
8000866c:	48 89       	lddpc	r9,8000868c <uart_config+0x44>
8000866e:	30 48       	mov	r8,4
80008670:	b2 d8       	st.b	r9[0x5],r8
	usart_options.stopbits		= 1;
80008672:	48 79       	lddpc	r9,8000868c <uart_config+0x44>
80008674:	30 18       	mov	r8,1
80008676:	b2 38       	st.h	r9[0x6],r8
	usart_options.channelmode	= USART_NORMAL_CHMODE;
80008678:	48 59       	lddpc	r9,8000868c <uart_config+0x44>
8000867a:	30 08       	mov	r8,0
8000867c:	f3 68 00 08 	st.b	r9[8],r8
}
80008680:	2f ed       	sub	sp,-8
80008682:	e3 cd 80 80 	ldm	sp++,r7,pc
80008686:	00 00       	add	r0,r0
80008688:	80 00       	ld.sh	r0,r0[0x0]
8000868a:	77 08       	ld.w	r8,r11[0x40]
8000868c:	00 00       	add	r0,r0
8000868e:	07 38       	ld.ub	r8,r3++

80008690 <uart_open>:

void uart_open(uint8_t port)
{
80008690:	eb cd 40 80 	pushm	r7,lr
80008694:	1a 97       	mov	r7,sp
80008696:	20 5d       	sub	sp,20
80008698:	18 98       	mov	r8,r12
8000869a:	ef 68 ff ec 	st.b	r7[-20],r8
	// Enable interrupt with priority higher than USB
	irq_register_handler(usart_interrupt, USART_IRQ, 3);
8000869e:	30 3a       	mov	r10,3
800086a0:	e0 6b 00 c0 	mov	r11,192
800086a4:	4d 8c       	lddpc	r12,80008804 <uart_open+0x174>
800086a6:	f0 1f 00 59 	mcall	80008808 <uart_open+0x178>

	// Initialize it in RS232 mode.
	sysclk_enable_pba_module(USART_SYSCLK);
800086aa:	30 8c       	mov	r12,8
800086ac:	f0 1f 00 58 	mcall	8000880c <uart_open+0x17c>

	// Calculate baud rate parameters.
	unsigned int over = (sysclk_get_pba_hz() >= 16 * usart_options.baudrate) ? 16 : 8;
800086b0:	f0 1f 00 58 	mcall	80008810 <uart_open+0x180>
800086b4:	18 99       	mov	r9,r12
800086b6:	4d 88       	lddpc	r8,80008814 <uart_open+0x184>
800086b8:	70 08       	ld.w	r8,r8[0x0]
800086ba:	a5 68       	lsl	r8,0x4
800086bc:	10 39       	cp.w	r9,r8
800086be:	c0 33       	brcs	800086c4 <uart_open+0x34>
800086c0:	31 08       	mov	r8,16
800086c2:	c0 28       	rjmp	800086c6 <uart_open+0x36>
800086c4:	30 88       	mov	r8,8
800086c6:	ef 48 ff f0 	st.w	r7[-16],r8
	unsigned int cd_fp = (0x08 * sysclk_get_pba_hz()) / (over * usart_options.baudrate) + 0.5;
800086ca:	f0 1f 00 52 	mcall	80008810 <uart_open+0x180>
800086ce:	18 98       	mov	r8,r12
800086d0:	a3 78       	lsl	r8,0x3
800086d2:	4d 19       	lddpc	r9,80008814 <uart_open+0x184>
800086d4:	72 0a       	ld.w	r10,r9[0x0]
800086d6:	ee f9 ff f0 	ld.w	r9,r7[-16]
800086da:	f4 09 02 49 	mul	r9,r10,r9
800086de:	f0 09 0d 08 	divu	r8,r8,r9
800086e2:	10 9c       	mov	r12,r8
800086e4:	f0 1f 00 4d 	mcall	80008818 <uart_open+0x188>
800086e8:	30 08       	mov	r8,0
800086ea:	30 09       	mov	r9,0
800086ec:	ea 19 3f e0 	orh	r9,0x3fe0
800086f0:	f0 1f 00 4b 	mcall	8000881c <uart_open+0x18c>
800086f4:	14 98       	mov	r8,r10
800086f6:	16 99       	mov	r9,r11
800086f8:	10 9a       	mov	r10,r8
800086fa:	12 9b       	mov	r11,r9
800086fc:	f0 1f 00 49 	mcall	80008820 <uart_open+0x190>
80008700:	18 98       	mov	r8,r12
80008702:	ef 48 ff f4 	st.w	r7[-12],r8
	unsigned int cd = cd_fp >> 3;
80008706:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000870a:	a3 98       	lsr	r8,0x3
8000870c:	ef 48 ff f8 	st.w	r7[-8],r8
	unsigned int fp = cd_fp & 0x07;
80008710:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008714:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80008718:	ef 48 ff fc 	st.w	r7[-4],r8
	
	// Set required fields in USART Mode Register.
	if ((cd >= 1) || (cd <= 0x0000FFFF))
8000871c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008720:	58 08       	cp.w	r8,0
80008722:	c0 71       	brne	80008730 <uart_open+0xa0>
80008724:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008728:	e0 48 ff ff 	cp.w	r8,65535
8000872c:	e0 8b 00 64 	brhi	800087f4 <uart_open+0x164>
	{
		USART->mr = 0;
80008730:	fe 78 18 00 	mov	r8,-59392
80008734:	30 09       	mov	r9,0
80008736:	91 19       	st.w	r8[0x4],r9
		USART->MR.over = (over == 16);
80008738:	fe 79 18 00 	mov	r9,-59392
8000873c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008740:	59 08       	cp.w	r8,16
80008742:	5f 08       	sreq	r8
80008744:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80008748:	72 18       	ld.w	r8,r9[0x4]
8000874a:	f1 da d2 61 	bfins	r8,r10,0x13,0x1
8000874e:	93 18       	st.w	r9[0x4],r8
		USART->MR.chrl = 0x3;
80008750:	fe 79 18 00 	mov	r9,-59392
80008754:	72 18       	ld.w	r8,r9[0x4]
80008756:	30 3a       	mov	r10,3
80008758:	f1 da d0 c2 	bfins	r8,r10,0x6,0x2
8000875c:	93 18       	st.w	r9[0x4],r8
		USART->MR.par = USART_NO_PARITY;
8000875e:	fe 79 18 00 	mov	r9,-59392
80008762:	72 18       	ld.w	r8,r9[0x4]
80008764:	30 4a       	mov	r10,4
80008766:	f1 da d1 23 	bfins	r8,r10,0x9,0x3
8000876a:	93 18       	st.w	r9[0x4],r8
		
		USART->brgr = 0;
8000876c:	fe 78 18 00 	mov	r8,-59392
80008770:	30 09       	mov	r9,0
80008772:	91 89       	st.w	r8[0x20],r9
		USART->BRGR.cd = cd;
80008774:	fe 79 18 00 	mov	r9,-59392
80008778:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000877c:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
80008780:	72 88       	ld.w	r8,r9[0x20]
80008782:	f1 da d0 10 	bfins	r8,r10,0x0,0x10
80008786:	93 88       	st.w	r9[0x20],r8
		USART->BRGR.fp = fp;
80008788:	fe 79 18 00 	mov	r9,-59392
8000878c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008790:	5c 58       	castu.b	r8
80008792:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80008796:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
8000879a:	72 88       	ld.w	r8,r9[0x20]
8000879c:	f1 da d2 03 	bfins	r8,r10,0x10,0x3
800087a0:	93 88       	st.w	r9[0x20],r8
		
		USART->cr = 0;
800087a2:	fe 78 18 00 	mov	r8,-59392
800087a6:	30 09       	mov	r9,0
800087a8:	91 09       	st.w	r8[0x0],r9
		USART->CR.rxen = 1;
800087aa:	fe 79 18 00 	mov	r9,-59392
800087ae:	72 08       	ld.w	r8,r9[0x0]
800087b0:	30 1a       	mov	r10,1
800087b2:	f1 da d0 81 	bfins	r8,r10,0x4,0x1
800087b6:	93 08       	st.w	r9[0x0],r8
		USART->CR.txen = 1;
800087b8:	fe 79 18 00 	mov	r9,-59392
800087bc:	72 08       	ld.w	r8,r9[0x0]
800087be:	30 1a       	mov	r10,1
800087c0:	f1 da d0 c1 	bfins	r8,r10,0x6,0x1
800087c4:	93 08       	st.w	r9[0x0],r8
		
		USART->idr = 0xFFFFFFFF;
800087c6:	fe 78 18 00 	mov	r8,-59392
800087ca:	3f f9       	mov	r9,-1
800087cc:	91 39       	st.w	r8[0xc],r9

		USART->ier = 0;
800087ce:	fe 78 18 00 	mov	r8,-59392
800087d2:	30 09       	mov	r9,0
800087d4:	91 29       	st.w	r8[0x8],r9
		USART->IER.rxrdy = 1;
800087d6:	fe 79 18 00 	mov	r9,-59392
800087da:	72 28       	ld.w	r8,r9[0x8]
800087dc:	30 1a       	mov	r10,1
800087de:	f1 da d0 01 	bfins	r8,r10,0x0,0x1
800087e2:	93 28       	st.w	r9[0x8],r8
		USART->IER.txrdy = 1;		
800087e4:	fe 79 18 00 	mov	r9,-59392
800087e8:	72 28       	ld.w	r8,r9[0x8]
800087ea:	30 1a       	mov	r10,1
800087ec:	f1 da d0 21 	bfins	r8,r10,0x1,0x1
800087f0:	93 28       	st.w	r9[0x8],r8
	unsigned int cd_fp = (0x08 * sysclk_get_pba_hz()) / (over * usart_options.baudrate) + 0.5;
	unsigned int cd = cd_fp >> 3;
	unsigned int fp = cd_fp & 0x07;
	
	// Set required fields in USART Mode Register.
	if ((cd >= 1) || (cd <= 0x0000FFFF))
800087f2:	c0 58       	rjmp	800087fc <uart_open+0x16c>
	}

	else
	{
		// Baud rate is not possible with the provided clock.
		udi_cdc_putc(0x00);
800087f4:	30 0c       	mov	r12,0
800087f6:	f0 1f 00 0c 	mcall	80008824 <uart_open+0x194>
		return;
800087fa:	d7 03       	nop
	}
}
800087fc:	2f bd       	sub	sp,-20
800087fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80008802:	00 00       	add	r0,r0
80008804:	80 00       	ld.sh	r0,r0[0x0]
80008806:	85 cc       	st.w	r2[0x30],r12
80008808:	80 00       	ld.sh	r0,r0[0x0]
8000880a:	2e 9c       	sub	r12,-23
8000880c:	80 00       	ld.sh	r0,r0[0x0]
8000880e:	76 e8       	ld.w	r8,r11[0x38]
80008810:	80 00       	ld.sh	r0,r0[0x0]
80008812:	76 d0       	ld.w	r0,r11[0x34]
80008814:	00 00       	add	r0,r0
80008816:	07 38       	ld.ub	r8,r3++
80008818:	80 00       	ld.sh	r0,r0[0x0]
8000881a:	8b 1e       	st.w	r5[0x4],lr
8000881c:	80 00       	ld.sh	r0,r0[0x0]
8000881e:	89 e4       	st.w	r4[0x38],r4
80008820:	80 00       	ld.sh	r0,r0[0x0]
80008822:	8a f4       	ld.uh	r4,r5[0xe]
80008824:	80 00       	ld.sh	r0,r0[0x0]
80008826:	66 00       	ld.w	r0,r3[0x0]

80008828 <uart_close>:

void uart_close(uint8_t port)
{
80008828:	eb cd 40 80 	pushm	r7,lr
8000882c:	1a 97       	mov	r7,sp
8000882e:	20 1d       	sub	sp,4
80008830:	18 98       	mov	r8,r12
80008832:	ef 68 ff fc 	st.b	r7[-4],r8
	// Disable interrupts
	// Close RS232 communication
	USART->idr = 0xFFFFFFFF;
80008836:	fe 78 18 00 	mov	r8,-59392
8000883a:	3f f9       	mov	r9,-1
8000883c:	91 39       	st.w	r8[0xc],r9
}
8000883e:	2f fd       	sub	sp,-4
80008840:	e3 cd 80 80 	ldm	sp++,r7,pc

80008844 <__avr32_f64_sub_from_add>:
80008844:	ee 19 80 00 	eorh	r9,0x8000

80008848 <__avr32_f64_sub>:
80008848:	f7 e9 20 0c 	eor	r12,r11,r9
8000884c:	e0 86 00 ca 	brmi	800089e0 <__avr32_f64_add_from_sub>
80008850:	eb cd 40 e0 	pushm	r5-r7,lr
80008854:	16 9c       	mov	r12,r11
80008856:	e6 1c 80 00 	andh	r12,0x8000,COH
8000885a:	bf db       	cbr	r11,0x1f
8000885c:	bf d9       	cbr	r9,0x1f
8000885e:	10 3a       	cp.w	r10,r8
80008860:	f2 0b 13 00 	cpc	r11,r9
80008864:	c0 92       	brcc	80008876 <__avr32_f64_sub+0x2e>
80008866:	16 97       	mov	r7,r11
80008868:	12 9b       	mov	r11,r9
8000886a:	0e 99       	mov	r9,r7
8000886c:	14 97       	mov	r7,r10
8000886e:	10 9a       	mov	r10,r8
80008870:	0e 98       	mov	r8,r7
80008872:	ee 1c 80 00 	eorh	r12,0x8000
80008876:	f6 07 16 14 	lsr	r7,r11,0x14
8000887a:	ab 7b       	lsl	r11,0xb
8000887c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80008880:	ab 7a       	lsl	r10,0xb
80008882:	bf bb       	sbr	r11,0x1f
80008884:	f2 06 16 14 	lsr	r6,r9,0x14
80008888:	c4 50       	breq	80008912 <__avr32_f64_sub_opL_subnormal>
8000888a:	ab 79       	lsl	r9,0xb
8000888c:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80008890:	ab 78       	lsl	r8,0xb
80008892:	bf b9       	sbr	r9,0x1f

80008894 <__avr32_f64_sub_opL_subnormal_done>:
80008894:	e0 47 07 ff 	cp.w	r7,2047
80008898:	c5 00       	breq	80008938 <__avr32_f64_sub_opH_nan_or_inf>
8000889a:	0e 26       	rsub	r6,r7
8000889c:	c1 20       	breq	800088c0 <__avr32_f64_sub_shift_done>
8000889e:	ec 05 11 20 	rsub	r5,r6,32
800088a2:	e0 46 00 20 	cp.w	r6,32
800088a6:	c7 d2       	brcc	800089a0 <__avr32_f64_sub_longshift>
800088a8:	f0 05 09 4e 	lsl	lr,r8,r5
800088ac:	f2 05 09 45 	lsl	r5,r9,r5
800088b0:	f0 06 0a 48 	lsr	r8,r8,r6
800088b4:	f2 06 0a 49 	lsr	r9,r9,r6
800088b8:	0a 48       	or	r8,r5
800088ba:	58 0e       	cp.w	lr,0
800088bc:	5f 1e       	srne	lr
800088be:	1c 48       	or	r8,lr

800088c0 <__avr32_f64_sub_shift_done>:
800088c0:	10 1a       	sub	r10,r8
800088c2:	f6 09 01 4b 	sbc	r11,r11,r9
800088c6:	f6 06 12 00 	clz	r6,r11
800088ca:	c0 e0       	breq	800088e6 <__avr32_f64_sub_longnormalize_done>
800088cc:	c7 93       	brcs	800089be <__avr32_f64_sub_longnormalize>
800088ce:	ec 0e 11 20 	rsub	lr,r6,32
800088d2:	f6 06 09 4b 	lsl	r11,r11,r6
800088d6:	f4 0e 0a 4e 	lsr	lr,r10,lr
800088da:	1c 4b       	or	r11,lr
800088dc:	f4 06 09 4a 	lsl	r10,r10,r6
800088e0:	0c 17       	sub	r7,r6
800088e2:	e0 8a 00 3a 	brle	80008956 <__avr32_f64_sub_subnormal_result>

800088e6 <__avr32_f64_sub_longnormalize_done>:
800088e6:	f4 09 15 15 	lsl	r9,r10,0x15
800088ea:	ab 9a       	lsr	r10,0xb
800088ec:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
800088f0:	ab 9b       	lsr	r11,0xb
800088f2:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
800088f6:	18 4b       	or	r11,r12

800088f8 <__avr32_f64_sub_round>:
800088f8:	30 07       	mov	r7,0
800088fa:	ea 17 80 00 	orh	r7,0x8000
800088fe:	ed ba 00 00 	bld	r10,0x0
80008902:	f7 b7 01 ff 	subne	r7,-1
80008906:	0e 39       	cp.w	r9,r7
80008908:	5f 29       	srhs	r9
8000890a:	12 0a       	add	r10,r9
8000890c:	5c 0b       	acr	r11
8000890e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008912 <__avr32_f64_sub_opL_subnormal>:
80008912:	ab 79       	lsl	r9,0xb
80008914:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80008918:	ab 78       	lsl	r8,0xb
8000891a:	f3 e8 10 0e 	or	lr,r9,r8
8000891e:	f9 b6 01 01 	movne	r6,1
80008922:	ee 0e 11 00 	rsub	lr,r7,0
80008926:	f9 b7 00 01 	moveq	r7,1
8000892a:	ef bb 00 1f 	bst	r11,0x1f
8000892e:	f7 ea 10 0e 	or	lr,r11,r10
80008932:	f9 b7 00 00 	moveq	r7,0
80008936:	ca fb       	rjmp	80008894 <__avr32_f64_sub_opL_subnormal_done>

80008938 <__avr32_f64_sub_opH_nan_or_inf>:
80008938:	bf db       	cbr	r11,0x1f
8000893a:	f7 ea 10 0e 	or	lr,r11,r10
8000893e:	c0 81       	brne	8000894e <__avr32_f64_sub_return_nan>
80008940:	e0 46 07 ff 	cp.w	r6,2047
80008944:	c0 50       	breq	8000894e <__avr32_f64_sub_return_nan>
80008946:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
8000894a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

8000894e <__avr32_f64_sub_return_nan>:
8000894e:	3f fa       	mov	r10,-1
80008950:	3f fb       	mov	r11,-1
80008952:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008956 <__avr32_f64_sub_subnormal_result>:
80008956:	5c 37       	neg	r7
80008958:	2f f7       	sub	r7,-1
8000895a:	f1 b7 04 c0 	satu	r7,0x6
8000895e:	e0 47 00 20 	cp.w	r7,32
80008962:	c1 14       	brge	80008984 <__avr32_f64_sub_subnormal_result+0x2e>
80008964:	ee 08 11 20 	rsub	r8,r7,32
80008968:	f4 08 09 49 	lsl	r9,r10,r8
8000896c:	5f 16       	srne	r6
8000896e:	f4 07 0a 4a 	lsr	r10,r10,r7
80008972:	0c 4a       	or	r10,r6
80008974:	f6 08 09 49 	lsl	r9,r11,r8
80008978:	f5 e9 10 0a 	or	r10,r10,r9
8000897c:	f4 07 0a 4b 	lsr	r11,r10,r7
80008980:	30 07       	mov	r7,0
80008982:	cb 2b       	rjmp	800088e6 <__avr32_f64_sub_longnormalize_done>
80008984:	ee 08 11 40 	rsub	r8,r7,64
80008988:	f6 08 09 49 	lsl	r9,r11,r8
8000898c:	14 49       	or	r9,r10
8000898e:	5f 16       	srne	r6
80008990:	f6 07 0a 4a 	lsr	r10,r11,r7
80008994:	0c 4a       	or	r10,r6
80008996:	30 0b       	mov	r11,0
80008998:	30 07       	mov	r7,0
8000899a:	ca 6b       	rjmp	800088e6 <__avr32_f64_sub_longnormalize_done>
8000899c:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

800089a0 <__avr32_f64_sub_longshift>:
800089a0:	f1 b6 04 c0 	satu	r6,0x6
800089a4:	f0 0e 17 00 	moveq	lr,r8
800089a8:	c0 40       	breq	800089b0 <__avr32_f64_sub_longshift+0x10>
800089aa:	f2 05 09 4e 	lsl	lr,r9,r5
800089ae:	10 4e       	or	lr,r8
800089b0:	f2 06 0a 48 	lsr	r8,r9,r6
800089b4:	30 09       	mov	r9,0
800089b6:	58 0e       	cp.w	lr,0
800089b8:	5f 1e       	srne	lr
800089ba:	1c 48       	or	r8,lr
800089bc:	c8 2b       	rjmp	800088c0 <__avr32_f64_sub_shift_done>

800089be <__avr32_f64_sub_longnormalize>:
800089be:	f4 06 12 00 	clz	r6,r10
800089c2:	f9 b7 03 00 	movlo	r7,0
800089c6:	f9 b6 03 00 	movlo	r6,0
800089ca:	f9 bc 03 00 	movlo	r12,0
800089ce:	f7 b6 02 e0 	subhs	r6,-32
800089d2:	f4 06 09 4b 	lsl	r11,r10,r6
800089d6:	30 0a       	mov	r10,0
800089d8:	0c 17       	sub	r7,r6
800089da:	fe 9a ff be 	brle	80008956 <__avr32_f64_sub_subnormal_result>
800089de:	c8 4b       	rjmp	800088e6 <__avr32_f64_sub_longnormalize_done>

800089e0 <__avr32_f64_add_from_sub>:
800089e0:	ee 19 80 00 	eorh	r9,0x8000

800089e4 <__avr32_f64_add>:
800089e4:	f7 e9 20 0c 	eor	r12,r11,r9
800089e8:	fe 96 ff 2e 	brmi	80008844 <__avr32_f64_sub_from_add>
800089ec:	eb cd 40 e0 	pushm	r5-r7,lr
800089f0:	16 9c       	mov	r12,r11
800089f2:	e6 1c 80 00 	andh	r12,0x8000,COH
800089f6:	bf db       	cbr	r11,0x1f
800089f8:	bf d9       	cbr	r9,0x1f
800089fa:	12 3b       	cp.w	r11,r9
800089fc:	c0 72       	brcc	80008a0a <__avr32_f64_add+0x26>
800089fe:	16 97       	mov	r7,r11
80008a00:	12 9b       	mov	r11,r9
80008a02:	0e 99       	mov	r9,r7
80008a04:	14 97       	mov	r7,r10
80008a06:	10 9a       	mov	r10,r8
80008a08:	0e 98       	mov	r8,r7
80008a0a:	30 0e       	mov	lr,0
80008a0c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80008a10:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
80008a14:	b5 ab       	sbr	r11,0x14
80008a16:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80008a1a:	c6 30       	breq	80008ae0 <__avr32_f64_add_op2_subnormal>
80008a1c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80008a20:	b5 a9       	sbr	r9,0x14
80008a22:	e0 47 07 ff 	cp.w	r7,2047
80008a26:	c2 80       	breq	80008a76 <__avr32_f64_add_opH_nan_or_inf>
80008a28:	0e 26       	rsub	r6,r7
80008a2a:	c1 20       	breq	80008a4e <__avr32_f64_add_shift_done>
80008a2c:	e0 46 00 36 	cp.w	r6,54
80008a30:	c1 52       	brcc	80008a5a <__avr32_f64_add_res_of_done>
80008a32:	ec 05 11 20 	rsub	r5,r6,32
80008a36:	e0 46 00 20 	cp.w	r6,32
80008a3a:	c3 62       	brcc	80008aa6 <__avr32_f64_add_longshift>
80008a3c:	f0 05 09 4e 	lsl	lr,r8,r5
80008a40:	f2 05 09 45 	lsl	r5,r9,r5
80008a44:	f0 06 0a 48 	lsr	r8,r8,r6
80008a48:	f2 06 0a 49 	lsr	r9,r9,r6
80008a4c:	0a 48       	or	r8,r5

80008a4e <__avr32_f64_add_shift_done>:
80008a4e:	10 0a       	add	r10,r8
80008a50:	f6 09 00 4b 	adc	r11,r11,r9
80008a54:	ed bb 00 15 	bld	r11,0x15
80008a58:	c3 50       	breq	80008ac2 <__avr32_f64_add_res_of>

80008a5a <__avr32_f64_add_res_of_done>:
80008a5a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80008a5e:	18 4b       	or	r11,r12

80008a60 <__avr32_f64_add_round>:
80008a60:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
80008a64:	18 4e       	or	lr,r12
80008a66:	ee 1e 80 00 	eorh	lr,0x8000
80008a6a:	f1 be 04 20 	satu	lr,0x1
80008a6e:	1c 0a       	add	r10,lr
80008a70:	5c 0b       	acr	r11
80008a72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008a76 <__avr32_f64_add_opH_nan_or_inf>:
80008a76:	b5 cb       	cbr	r11,0x14
80008a78:	f7 ea 10 0e 	or	lr,r11,r10
80008a7c:	c1 11       	brne	80008a9e <__avr32_f64_add_return_nan>
80008a7e:	e0 46 07 ff 	cp.w	r6,2047
80008a82:	c0 30       	breq	80008a88 <__avr32_f64_add_opL_nan_or_inf>
80008a84:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008a88 <__avr32_f64_add_opL_nan_or_inf>:
80008a88:	b5 c9       	cbr	r9,0x14
80008a8a:	f3 e8 10 0e 	or	lr,r9,r8
80008a8e:	c0 81       	brne	80008a9e <__avr32_f64_add_return_nan>
80008a90:	30 0a       	mov	r10,0
80008a92:	30 0b       	mov	r11,0
80008a94:	ea 1b 7f f0 	orh	r11,0x7ff0
80008a98:	18 4b       	or	r11,r12
80008a9a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008a9e <__avr32_f64_add_return_nan>:
80008a9e:	3f fa       	mov	r10,-1
80008aa0:	3f fb       	mov	r11,-1
80008aa2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008aa6 <__avr32_f64_add_longshift>:
80008aa6:	f1 b6 04 c0 	satu	r6,0x6
80008aaa:	f0 0e 17 00 	moveq	lr,r8
80008aae:	c0 60       	breq	80008aba <__avr32_f64_add_longshift+0x14>
80008ab0:	f2 05 09 4e 	lsl	lr,r9,r5
80008ab4:	58 08       	cp.w	r8,0
80008ab6:	5f 18       	srne	r8
80008ab8:	10 4e       	or	lr,r8
80008aba:	f2 06 0a 48 	lsr	r8,r9,r6
80008abe:	30 09       	mov	r9,0
80008ac0:	cc 7b       	rjmp	80008a4e <__avr32_f64_add_shift_done>

80008ac2 <__avr32_f64_add_res_of>:
80008ac2:	fd ee 10 1e 	or	lr,lr,lr<<0x1
80008ac6:	a1 9b       	lsr	r11,0x1
80008ac8:	5d 0a       	ror	r10
80008aca:	5d 0e       	ror	lr
80008acc:	2f f7       	sub	r7,-1
80008ace:	e0 47 07 ff 	cp.w	r7,2047
80008ad2:	f9 ba 00 00 	moveq	r10,0
80008ad6:	f9 bb 00 00 	moveq	r11,0
80008ada:	f9 be 00 00 	moveq	lr,0
80008ade:	cb eb       	rjmp	80008a5a <__avr32_f64_add_res_of_done>

80008ae0 <__avr32_f64_add_op2_subnormal>:
80008ae0:	30 16       	mov	r6,1
80008ae2:	58 07       	cp.w	r7,0
80008ae4:	c9 f1       	brne	80008a22 <__avr32_f64_add+0x3e>
80008ae6:	b5 cb       	cbr	r11,0x14
80008ae8:	10 0a       	add	r10,r8
80008aea:	f6 09 00 4b 	adc	r11,r11,r9
80008aee:	18 4b       	or	r11,r12
80008af0:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008af4 <__avr32_f64_to_u32>:
80008af4:	58 0b       	cp.w	r11,0
80008af6:	5e 6d       	retmi	0

80008af8 <__avr32_f64_to_s32>:
80008af8:	f6 0c 15 01 	lsl	r12,r11,0x1
80008afc:	b5 9c       	lsr	r12,0x15
80008afe:	e0 2c 03 ff 	sub	r12,1023
80008b02:	5e 3d       	retlo	0
80008b04:	f8 0c 11 1f 	rsub	r12,r12,31
80008b08:	16 99       	mov	r9,r11
80008b0a:	ab 7b       	lsl	r11,0xb
80008b0c:	bf bb       	sbr	r11,0x1f
80008b0e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80008b12:	f6 0c 0a 4b 	lsr	r11,r11,r12
80008b16:	a1 79       	lsl	r9,0x1
80008b18:	5e 2b       	reths	r11
80008b1a:	5c 3b       	neg	r11
80008b1c:	5e fb       	retal	r11

80008b1e <__avr32_u32_to_f64>:
80008b1e:	f8 cb 00 00 	sub	r11,r12,0
80008b22:	30 0c       	mov	r12,0
80008b24:	c0 38       	rjmp	80008b2a <__avr32_s32_to_f64+0x4>

80008b26 <__avr32_s32_to_f64>:
80008b26:	18 9b       	mov	r11,r12
80008b28:	5c 4b       	abs	r11
80008b2a:	30 0a       	mov	r10,0
80008b2c:	5e 0b       	reteq	r11
80008b2e:	d4 01       	pushm	lr
80008b30:	e0 69 04 1e 	mov	r9,1054
80008b34:	f6 08 12 00 	clz	r8,r11
80008b38:	c1 70       	breq	80008b66 <__avr32_s32_to_f64+0x40>
80008b3a:	c0 c3       	brcs	80008b52 <__avr32_s32_to_f64+0x2c>
80008b3c:	f0 0e 11 20 	rsub	lr,r8,32
80008b40:	f6 08 09 4b 	lsl	r11,r11,r8
80008b44:	f4 0e 0a 4e 	lsr	lr,r10,lr
80008b48:	1c 4b       	or	r11,lr
80008b4a:	f4 08 09 4a 	lsl	r10,r10,r8
80008b4e:	10 19       	sub	r9,r8
80008b50:	c0 b8       	rjmp	80008b66 <__avr32_s32_to_f64+0x40>
80008b52:	f4 08 12 00 	clz	r8,r10
80008b56:	f9 b8 03 00 	movlo	r8,0
80008b5a:	f7 b8 02 e0 	subhs	r8,-32
80008b5e:	f4 08 09 4b 	lsl	r11,r10,r8
80008b62:	30 0a       	mov	r10,0
80008b64:	10 19       	sub	r9,r8
80008b66:	58 09       	cp.w	r9,0
80008b68:	e0 89 00 30 	brgt	80008bc8 <__avr32_s32_to_f64+0xa2>
80008b6c:	5c 39       	neg	r9
80008b6e:	2f f9       	sub	r9,-1
80008b70:	e0 49 00 36 	cp.w	r9,54
80008b74:	c0 43       	brcs	80008b7c <__avr32_s32_to_f64+0x56>
80008b76:	30 0b       	mov	r11,0
80008b78:	30 0a       	mov	r10,0
80008b7a:	c2 68       	rjmp	80008bc6 <__avr32_s32_to_f64+0xa0>
80008b7c:	2f 69       	sub	r9,-10
80008b7e:	f2 08 11 20 	rsub	r8,r9,32
80008b82:	e0 49 00 20 	cp.w	r9,32
80008b86:	c0 b2       	brcc	80008b9c <__avr32_s32_to_f64+0x76>
80008b88:	f4 08 09 4e 	lsl	lr,r10,r8
80008b8c:	f6 08 09 48 	lsl	r8,r11,r8
80008b90:	f4 09 0a 4a 	lsr	r10,r10,r9
80008b94:	f6 09 0a 4b 	lsr	r11,r11,r9
80008b98:	10 4b       	or	r11,r8
80008b9a:	c0 88       	rjmp	80008baa <__avr32_s32_to_f64+0x84>
80008b9c:	f6 08 09 4e 	lsl	lr,r11,r8
80008ba0:	14 4e       	or	lr,r10
80008ba2:	16 9a       	mov	r10,r11
80008ba4:	30 0b       	mov	r11,0
80008ba6:	f4 09 0a 4a 	lsr	r10,r10,r9
80008baa:	ed ba 00 00 	bld	r10,0x0
80008bae:	c0 92       	brcc	80008bc0 <__avr32_s32_to_f64+0x9a>
80008bb0:	1c 7e       	tst	lr,lr
80008bb2:	c0 41       	brne	80008bba <__avr32_s32_to_f64+0x94>
80008bb4:	ed ba 00 01 	bld	r10,0x1
80008bb8:	c0 42       	brcc	80008bc0 <__avr32_s32_to_f64+0x9a>
80008bba:	2f fa       	sub	r10,-1
80008bbc:	f7 bb 02 ff 	subhs	r11,-1
80008bc0:	5c fc       	rol	r12
80008bc2:	5d 0b       	ror	r11
80008bc4:	5d 0a       	ror	r10
80008bc6:	d8 02       	popm	pc
80008bc8:	e0 68 03 ff 	mov	r8,1023
80008bcc:	ed ba 00 0b 	bld	r10,0xb
80008bd0:	f7 b8 00 ff 	subeq	r8,-1
80008bd4:	10 0a       	add	r10,r8
80008bd6:	5c 0b       	acr	r11
80008bd8:	f7 b9 03 fe 	sublo	r9,-2
80008bdc:	e0 49 07 ff 	cp.w	r9,2047
80008be0:	c0 65       	brlt	80008bec <__avr32_s32_to_f64+0xc6>
80008be2:	30 0a       	mov	r10,0
80008be4:	30 0b       	mov	r11,0
80008be6:	ea 1b ff e0 	orh	r11,0xffe0
80008bea:	c0 c8       	rjmp	80008c02 <__floatsidf_return_op1>
80008bec:	ed bb 00 1f 	bld	r11,0x1f
80008bf0:	f7 b9 01 01 	subne	r9,1
80008bf4:	ab 9a       	lsr	r10,0xb
80008bf6:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80008bfa:	a1 7b       	lsl	r11,0x1
80008bfc:	ab 9b       	lsr	r11,0xb
80008bfe:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80008c02 <__floatsidf_return_op1>:
80008c02:	a1 7c       	lsl	r12,0x1
80008c04:	5d 0b       	ror	r11
80008c06:	d8 02       	popm	pc

80008c08 <memcpy>:
80008c08:	58 8a       	cp.w	r10,8
80008c0a:	c2 f5       	brlt	80008c68 <memcpy+0x60>
80008c0c:	f9 eb 10 09 	or	r9,r12,r11
80008c10:	e2 19 00 03 	andl	r9,0x3,COH
80008c14:	e0 81 00 97 	brne	80008d42 <memcpy+0x13a>
80008c18:	e0 4a 00 20 	cp.w	r10,32
80008c1c:	c3 b4       	brge	80008c92 <memcpy+0x8a>
80008c1e:	f4 08 14 02 	asr	r8,r10,0x2
80008c22:	f0 09 11 08 	rsub	r9,r8,8
80008c26:	fe 09 00 2f 	add	pc,pc,r9<<0x2
80008c2a:	76 69       	ld.w	r9,r11[0x18]
80008c2c:	99 69       	st.w	r12[0x18],r9
80008c2e:	76 59       	ld.w	r9,r11[0x14]
80008c30:	99 59       	st.w	r12[0x14],r9
80008c32:	76 49       	ld.w	r9,r11[0x10]
80008c34:	99 49       	st.w	r12[0x10],r9
80008c36:	76 39       	ld.w	r9,r11[0xc]
80008c38:	99 39       	st.w	r12[0xc],r9
80008c3a:	76 29       	ld.w	r9,r11[0x8]
80008c3c:	99 29       	st.w	r12[0x8],r9
80008c3e:	76 19       	ld.w	r9,r11[0x4]
80008c40:	99 19       	st.w	r12[0x4],r9
80008c42:	76 09       	ld.w	r9,r11[0x0]
80008c44:	99 09       	st.w	r12[0x0],r9
80008c46:	f6 08 00 2b 	add	r11,r11,r8<<0x2
80008c4a:	f8 08 00 28 	add	r8,r12,r8<<0x2
80008c4e:	e0 1a 00 03 	andl	r10,0x3
80008c52:	f4 0a 11 04 	rsub	r10,r10,4
80008c56:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008c5a:	17 a9       	ld.ub	r9,r11[0x2]
80008c5c:	b0 a9       	st.b	r8[0x2],r9
80008c5e:	17 99       	ld.ub	r9,r11[0x1]
80008c60:	b0 99       	st.b	r8[0x1],r9
80008c62:	17 89       	ld.ub	r9,r11[0x0]
80008c64:	b0 89       	st.b	r8[0x0],r9
80008c66:	5e fc       	retal	r12
80008c68:	f4 0a 11 09 	rsub	r10,r10,9
80008c6c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80008c70:	17 f9       	ld.ub	r9,r11[0x7]
80008c72:	b8 f9       	st.b	r12[0x7],r9
80008c74:	17 e9       	ld.ub	r9,r11[0x6]
80008c76:	b8 e9       	st.b	r12[0x6],r9
80008c78:	17 d9       	ld.ub	r9,r11[0x5]
80008c7a:	b8 d9       	st.b	r12[0x5],r9
80008c7c:	17 c9       	ld.ub	r9,r11[0x4]
80008c7e:	b8 c9       	st.b	r12[0x4],r9
80008c80:	17 b9       	ld.ub	r9,r11[0x3]
80008c82:	b8 b9       	st.b	r12[0x3],r9
80008c84:	17 a9       	ld.ub	r9,r11[0x2]
80008c86:	b8 a9       	st.b	r12[0x2],r9
80008c88:	17 99       	ld.ub	r9,r11[0x1]
80008c8a:	b8 99       	st.b	r12[0x1],r9
80008c8c:	17 89       	ld.ub	r9,r11[0x0]
80008c8e:	b8 89       	st.b	r12[0x0],r9
80008c90:	5e fc       	retal	r12
80008c92:	eb cd 40 c0 	pushm	r6-r7,lr
80008c96:	18 99       	mov	r9,r12
80008c98:	22 0a       	sub	r10,32
80008c9a:	b7 07       	ld.d	r6,r11++
80008c9c:	b3 26       	st.d	r9++,r6
80008c9e:	b7 07       	ld.d	r6,r11++
80008ca0:	b3 26       	st.d	r9++,r6
80008ca2:	b7 07       	ld.d	r6,r11++
80008ca4:	b3 26       	st.d	r9++,r6
80008ca6:	b7 07       	ld.d	r6,r11++
80008ca8:	b3 26       	st.d	r9++,r6
80008caa:	22 0a       	sub	r10,32
80008cac:	cf 74       	brge	80008c9a <memcpy+0x92>
80008cae:	2f 0a       	sub	r10,-16
80008cb0:	c0 65       	brlt	80008cbc <memcpy+0xb4>
80008cb2:	b7 07       	ld.d	r6,r11++
80008cb4:	b3 26       	st.d	r9++,r6
80008cb6:	b7 07       	ld.d	r6,r11++
80008cb8:	b3 26       	st.d	r9++,r6
80008cba:	21 0a       	sub	r10,16
80008cbc:	5c 3a       	neg	r10
80008cbe:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
80008cc2:	d7 03       	nop
80008cc4:	d7 03       	nop
80008cc6:	f7 36 00 0e 	ld.ub	r6,r11[14]
80008cca:	f3 66 00 0e 	st.b	r9[14],r6
80008cce:	f7 36 00 0d 	ld.ub	r6,r11[13]
80008cd2:	f3 66 00 0d 	st.b	r9[13],r6
80008cd6:	f7 36 00 0c 	ld.ub	r6,r11[12]
80008cda:	f3 66 00 0c 	st.b	r9[12],r6
80008cde:	f7 36 00 0b 	ld.ub	r6,r11[11]
80008ce2:	f3 66 00 0b 	st.b	r9[11],r6
80008ce6:	f7 36 00 0a 	ld.ub	r6,r11[10]
80008cea:	f3 66 00 0a 	st.b	r9[10],r6
80008cee:	f7 36 00 09 	ld.ub	r6,r11[9]
80008cf2:	f3 66 00 09 	st.b	r9[9],r6
80008cf6:	f7 36 00 08 	ld.ub	r6,r11[8]
80008cfa:	f3 66 00 08 	st.b	r9[8],r6
80008cfe:	f7 36 00 07 	ld.ub	r6,r11[7]
80008d02:	f3 66 00 07 	st.b	r9[7],r6
80008d06:	f7 36 00 06 	ld.ub	r6,r11[6]
80008d0a:	f3 66 00 06 	st.b	r9[6],r6
80008d0e:	f7 36 00 05 	ld.ub	r6,r11[5]
80008d12:	f3 66 00 05 	st.b	r9[5],r6
80008d16:	f7 36 00 04 	ld.ub	r6,r11[4]
80008d1a:	f3 66 00 04 	st.b	r9[4],r6
80008d1e:	f7 36 00 03 	ld.ub	r6,r11[3]
80008d22:	f3 66 00 03 	st.b	r9[3],r6
80008d26:	f7 36 00 02 	ld.ub	r6,r11[2]
80008d2a:	f3 66 00 02 	st.b	r9[2],r6
80008d2e:	f7 36 00 01 	ld.ub	r6,r11[1]
80008d32:	f3 66 00 01 	st.b	r9[1],r6
80008d36:	f7 36 00 00 	ld.ub	r6,r11[0]
80008d3a:	f3 66 00 00 	st.b	r9[0],r6
80008d3e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80008d42:	20 1a       	sub	r10,1
80008d44:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80008d48:	f8 0a 0b 09 	st.b	r12[r10],r9
80008d4c:	cf b1       	brne	80008d42 <memcpy+0x13a>
80008d4e:	5e fc       	retal	r12

Disassembly of section .exception:

80008e00 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80008e00:	c0 08       	rjmp	80008e00 <_evba>
	...

80008e04 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80008e04:	c0 08       	rjmp	80008e04 <_handle_TLB_Multiple_Hit>
	...

80008e08 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80008e08:	c0 08       	rjmp	80008e08 <_handle_Bus_Error_Data_Fetch>
	...

80008e0c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
80008e0c:	c0 08       	rjmp	80008e0c <_handle_Bus_Error_Instruction_Fetch>
	...

80008e10 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80008e10:	c0 08       	rjmp	80008e10 <_handle_NMI>
	...

80008e14 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80008e14:	c0 08       	rjmp	80008e14 <_handle_Instruction_Address>
	...

80008e18 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80008e18:	c0 08       	rjmp	80008e18 <_handle_ITLB_Protection>
	...

80008e1c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
80008e1c:	c0 08       	rjmp	80008e1c <_handle_Breakpoint>
	...

80008e20 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80008e20:	c0 08       	rjmp	80008e20 <_handle_Illegal_Opcode>
	...

80008e24 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80008e24:	c0 08       	rjmp	80008e24 <_handle_Unimplemented_Instruction>
	...

80008e28 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80008e28:	c0 08       	rjmp	80008e28 <_handle_Privilege_Violation>
	...

80008e2c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
80008e2c:	c0 08       	rjmp	80008e2c <_handle_Floating_Point>
	...

80008e30 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80008e30:	c0 08       	rjmp	80008e30 <_handle_Coprocessor_Absent>
	...

80008e34 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80008e34:	c0 08       	rjmp	80008e34 <_handle_Data_Address_Read>
	...

80008e38 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80008e38:	c0 08       	rjmp	80008e38 <_handle_Data_Address_Write>
	...

80008e3c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
80008e3c:	c0 08       	rjmp	80008e3c <_handle_DTLB_Protection_Read>
	...

80008e40 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80008e40:	c0 08       	rjmp	80008e40 <_handle_DTLB_Protection_Write>
	...

80008e44 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80008e44:	c0 08       	rjmp	80008e44 <_handle_DTLB_Modified>
	...

80008e50 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80008e50:	c0 08       	rjmp	80008e50 <_handle_ITLB_Miss>
	...

80008e60 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80008e60:	c0 08       	rjmp	80008e60 <_handle_DTLB_Miss_Read>
	...

80008e70 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80008e70:	c0 08       	rjmp	80008e70 <_handle_DTLB_Miss_Write>
	...

80008f00 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80008f00:	c0 08       	rjmp	80008f00 <_handle_Supervisor_Call>
80008f02:	d7 03       	nop

80008f04 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80008f04:	30 0c       	mov	r12,0
80008f06:	fe b0 cf 3d 	rcall	80002d80 <_get_interrupt_handler>
80008f0a:	58 0c       	cp.w	r12,0
80008f0c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80008f10:	d6 03       	rete

80008f12 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80008f12:	30 1c       	mov	r12,1
80008f14:	fe b0 cf 36 	rcall	80002d80 <_get_interrupt_handler>
80008f18:	58 0c       	cp.w	r12,0
80008f1a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80008f1e:	d6 03       	rete

80008f20 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80008f20:	30 2c       	mov	r12,2
80008f22:	fe b0 cf 2f 	rcall	80002d80 <_get_interrupt_handler>
80008f26:	58 0c       	cp.w	r12,0
80008f28:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80008f2c:	d6 03       	rete

80008f2e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80008f2e:	30 3c       	mov	r12,3
80008f30:	fe b0 cf 28 	rcall	80002d80 <_get_interrupt_handler>
80008f34:	58 0c       	cp.w	r12,0
80008f36:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80008f3a:	d6 03       	rete
80008f3c:	d7 03       	nop
80008f3e:	d7 03       	nop
80008f40:	d7 03       	nop
80008f42:	d7 03       	nop
80008f44:	d7 03       	nop
80008f46:	d7 03       	nop
80008f48:	d7 03       	nop
80008f4a:	d7 03       	nop
80008f4c:	d7 03       	nop
80008f4e:	d7 03       	nop
80008f50:	d7 03       	nop
80008f52:	d7 03       	nop
80008f54:	d7 03       	nop
80008f56:	d7 03       	nop
80008f58:	d7 03       	nop
80008f5a:	d7 03       	nop
80008f5c:	d7 03       	nop
80008f5e:	d7 03       	nop
80008f60:	d7 03       	nop
80008f62:	d7 03       	nop
80008f64:	d7 03       	nop
80008f66:	d7 03       	nop
80008f68:	d7 03       	nop
80008f6a:	d7 03       	nop
80008f6c:	d7 03       	nop
80008f6e:	d7 03       	nop
80008f70:	d7 03       	nop
80008f72:	d7 03       	nop
80008f74:	d7 03       	nop
80008f76:	d7 03       	nop
80008f78:	d7 03       	nop
80008f7a:	d7 03       	nop
80008f7c:	d7 03       	nop
80008f7e:	d7 03       	nop
80008f80:	d7 03       	nop
80008f82:	d7 03       	nop
80008f84:	d7 03       	nop
80008f86:	d7 03       	nop
80008f88:	d7 03       	nop
80008f8a:	d7 03       	nop
80008f8c:	d7 03       	nop
80008f8e:	d7 03       	nop
80008f90:	d7 03       	nop
80008f92:	d7 03       	nop
80008f94:	d7 03       	nop
80008f96:	d7 03       	nop
80008f98:	d7 03       	nop
80008f9a:	d7 03       	nop
80008f9c:	d7 03       	nop
80008f9e:	d7 03       	nop
80008fa0:	d7 03       	nop
80008fa2:	d7 03       	nop
80008fa4:	d7 03       	nop
80008fa6:	d7 03       	nop
80008fa8:	d7 03       	nop
80008faa:	d7 03       	nop
80008fac:	d7 03       	nop
80008fae:	d7 03       	nop
80008fb0:	d7 03       	nop
80008fb2:	d7 03       	nop
80008fb4:	d7 03       	nop
80008fb6:	d7 03       	nop
80008fb8:	d7 03       	nop
80008fba:	d7 03       	nop
80008fbc:	d7 03       	nop
80008fbe:	d7 03       	nop
80008fc0:	d7 03       	nop
80008fc2:	d7 03       	nop
80008fc4:	d7 03       	nop
80008fc6:	d7 03       	nop
80008fc8:	d7 03       	nop
80008fca:	d7 03       	nop
80008fcc:	d7 03       	nop
80008fce:	d7 03       	nop
80008fd0:	d7 03       	nop
80008fd2:	d7 03       	nop
80008fd4:	d7 03       	nop
80008fd6:	d7 03       	nop
80008fd8:	d7 03       	nop
80008fda:	d7 03       	nop
80008fdc:	d7 03       	nop
80008fde:	d7 03       	nop
80008fe0:	d7 03       	nop
80008fe2:	d7 03       	nop
80008fe4:	d7 03       	nop
80008fe6:	d7 03       	nop
80008fe8:	d7 03       	nop
80008fea:	d7 03       	nop
80008fec:	d7 03       	nop
80008fee:	d7 03       	nop
80008ff0:	d7 03       	nop
80008ff2:	d7 03       	nop
80008ff4:	d7 03       	nop
80008ff6:	d7 03       	nop
80008ff8:	d7 03       	nop
80008ffa:	d7 03       	nop
80008ffc:	d7 03       	nop
80008ffe:	d7 03       	nop
