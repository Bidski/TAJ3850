
TAJ3850.elf:     file format elf32-avr32

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .reset        00002008  80000000  80000000  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rela.got     00000000  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00007268  80002008  80002008  00002408  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .exception    00000200  80009400  80009400  00009800  2**9
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       000000b8  80009600  80009600  00009a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .dalign       00000004  00000004  00000004  00000000  2**0
                  ALLOC
  6 .data         000000dc  00000008  800096b8  00009c08  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .balign       00000004  000000e4  80009794  00009ce4  2**0
                  ALLOC
  8 .bss          00004580  000000e8  000000e8  00000000  2**2
                  ALLOC
  9 .heap         00002998  00004668  00004668  00000000  2**0
                  ALLOC
 10 .comment      00000030  00000000  00000000  0000a008  2**0
                  CONTENTS, READONLY
 11 .debug_aranges 00000b40  00000000  00000000  0000a038  2**3
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubnames 00001674  00000000  00000000  0000ab78  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00017507  00000000  00000000  0000c1ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 0000191d  00000000  00000000  000236f3  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   00008b1f  00000000  00000000  00025010  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00002394  00000000  00000000  0002db30  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00006e05  00000000  00000000  0002fec4  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000034be  00000000  00000000  00036cc9  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macinfo 00b096de  00000000  00000000  0003a187  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .stack        00001000  00007000  00007000  00000000  2**0
                  ALLOC
 21 .userpage     00000008  80800000  80800000  0000a000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 22 .debug_ranges 00000ab8  00000000  00000000  00b43868  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .reset:

80000000 <_start>:

  .global _start
  .type _start, @function
_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80000000:	fe cf b3 70 	sub	pc,pc,-19600

80000004 <_trampoline>:
80000004:	e0 8f 10 00 	bral	80002004 <program_start>
	...

80002004 <program_start>:
  rjmp    program_start

  .org  PROGRAM_START_OFFSET
program_start:
  // Jump to the C runtime startup routine.
  lda.w   pc, _stext
80002004:	fe cf d3 74 	sub	pc,pc,-11404

Disassembly of section .text:

80002008 <board_init>:
80002008:	eb cd 40 80 	pushm	r7,lr
#if defined (CONF_BOARD_AT45DBX)
#	define AT45DBX_MEM_CNT  1
#endif

void board_init(void)
{
8000200c:	1a 97       	mov	r7,sp
	gpio_configure_pin(LED0_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000200e:	30 3b       	mov	r11,3
80002010:	30 7c       	mov	r12,7
80002012:	f0 1f 00 17 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(LED1_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002016:	30 3b       	mov	r11,3
80002018:	30 8c       	mov	r12,8
8000201a:	f0 1f 00 15 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(LED2_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
8000201e:	30 3b       	mov	r11,3
80002020:	31 5c       	mov	r12,21
80002022:	f0 1f 00 13 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(LED3_GPIO,GPIO_DIR_OUTPUT | GPIO_INIT_HIGH);
80002026:	30 3b       	mov	r11,3
80002028:	31 6c       	mov	r12,22
8000202a:	f0 1f 00 11 	mcall	8000206c <board_init+0x64>

	gpio_configure_pin(GPIO_PUSH_BUTTON_0,GPIO_DIR_INPUT);
8000202e:	30 0b       	mov	r11,0
80002030:	32 2c       	mov	r12,34
80002032:	f0 1f 00 0f 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_PUSH_BUTTON_1,GPIO_DIR_INPUT);
80002036:	30 0b       	mov	r11,0
80002038:	32 3c       	mov	r12,35
8000203a:	f0 1f 00 0d 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_JOYSTICK_PUSH,GPIO_DIR_INPUT);
8000203e:	30 0b       	mov	r11,0
80002040:	30 dc       	mov	r12,13
80002042:	f0 1f 00 0b 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_JOYSTICK_LEFT,GPIO_DIR_INPUT);
80002046:	30 0b       	mov	r11,0
80002048:	32 6c       	mov	r12,38
8000204a:	f0 1f 00 09 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_JOYSTICK_UP,GPIO_DIR_INPUT);
8000204e:	30 0b       	mov	r11,0
80002050:	32 7c       	mov	r12,39
80002052:	f0 1f 00 07 	mcall	8000206c <board_init+0x64>
	gpio_configure_pin(GPIO_JOYSTICK_DOWN,GPIO_DIR_INPUT);
80002056:	30 0b       	mov	r11,0
80002058:	32 8c       	mov	r12,40
8000205a:	f0 1f 00 05 	mcall	8000206c <board_init+0x64>
	// USART GPIO pin configuration.
	static const gpio_map_t COMPORT_GPIO_MAP = {
		{USART_RXD_PIN, USART_RXD_FUNCTION },
		{USART_TXD_PIN, USART_TXD_FUNCTION },
	};
	gpio_enable_module(COMPORT_GPIO_MAP,
8000205e:	30 2b       	mov	r11,2
80002060:	48 4c       	lddpc	r12,80002070 <board_init+0x68>
80002062:	f0 1f 00 05 	mcall	80002074 <board_init+0x6c>

	// Assign GPIO pins to USB.
	gpio_enable_module(USB_GPIO_MAP,
			sizeof(USB_GPIO_MAP) / sizeof(USB_GPIO_MAP[0]));
#endif
}
80002066:	e3 cd 80 80 	ldm	sp++,r7,pc
8000206a:	00 00       	add	r0,r0
8000206c:	80 00       	ld.sh	r0,r0[0x0]
8000206e:	2b c8       	sub	r8,-68
80002070:	80 00       	ld.sh	r0,r0[0x0]
80002072:	96 00       	ld.sh	r0,r11[0x0]
80002074:	80 00       	ld.sh	r0,r0[0x0]
80002076:	2a 48       	sub	r8,-92

80002078 <flashc_get_flash_size>:
 */
//! @{


unsigned int flashc_get_flash_size(void)
{
80002078:	eb cd 40 80 	pushm	r7,lr
8000207c:	1a 97       	mov	r7,sp
8000207e:	20 4d       	sub	sp,16
		256,
		384,
		512,
		768,
		1024,
	};
80002080:	48 d9       	lddpc	r9,800020b4 <flashc_get_flash_size+0x3c>
80002082:	ee c8 00 10 	sub	r8,r7,16
80002086:	31 0a       	mov	r10,16
80002088:	12 9b       	mov	r11,r9
8000208a:	10 9c       	mov	r12,r8
8000208c:	f0 1f 00 0b 	mcall	800020b8 <flashc_get_flash_size+0x40>
	return ((unsigned int)FLASH_SIZE[(AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FSZ_MASK)
80002090:	fe 68 14 00 	mov	r8,-125952
80002094:	70 28       	ld.w	r8,r8[0x8]
80002096:	e2 18 e0 00 	andl	r8,0xe000,COH
8000209a:	ad 98       	lsr	r8,0xd
8000209c:	a1 78       	lsl	r8,0x1
8000209e:	ee 08 00 08 	add	r8,r7,r8
800020a2:	f1 08 ff f0 	ld.sh	r8,r8[-16]
800020a6:	5c 78       	castu.h	r8
800020a8:	ab 68       	lsl	r8,0xa
			>> AVR32_FLASHC_FSR_FSZ_OFFSET]) << 10;
#endif
}
800020aa:	10 9c       	mov	r12,r8
800020ac:	2f cd       	sub	sp,-16
800020ae:	e3 cd 80 80 	ldm	sp++,r7,pc
800020b2:	00 00       	add	r0,r0
800020b4:	80 00       	ld.sh	r0,r0[0x0]
800020b6:	96 10       	ld.sh	r0,r11[0x2]
800020b8:	80 00       	ld.sh	r0,r0[0x0]
800020ba:	91 28       	st.w	r8[0x8],r8

800020bc <flashc_set_wait_state>:
	return (AVR32_FLASHC.fcr & AVR32_FLASHC_FCR_FWS_MASK) >> AVR32_FLASHC_FCR_FWS_OFFSET;
}


void flashc_set_wait_state(unsigned int wait_state)
{
800020bc:	eb cd 40 80 	pushm	r7,lr
800020c0:	1a 97       	mov	r7,sp
800020c2:	20 2d       	sub	sp,8
800020c4:	ef 4c ff f8 	st.w	r7[-8],r12
	u_avr32_flashc_fcr_t u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
800020c8:	fe 68 14 00 	mov	r8,-125952
800020cc:	70 08       	ld.w	r8,r8[0x0]
800020ce:	30 09       	mov	r9,0
800020d0:	ef 49 ff fc 	st.w	r7[-4],r9
800020d4:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_flashc_fcr.FCR.fws = wait_state;
800020d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800020dc:	5c 58       	castu.b	r8
800020de:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800020e2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800020e6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800020ea:	f1 d9 d0 c1 	bfins	r8,r9,0x6,0x1
800020ee:	ef 48 ff fc 	st.w	r7[-4],r8
	AVR32_FLASHC.fcr = u_avr32_flashc_fcr.fcr;
800020f2:	fe 68 14 00 	mov	r8,-125952
800020f6:	ee f9 ff fc 	ld.w	r9,r7[-4]
800020fa:	91 09       	st.w	r8[0x0],r9
}
800020fc:	2f ed       	sub	sp,-8
800020fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80002102:	d7 03       	nop

80002104 <flashc_set_bus_freq>:


void flashc_set_bus_freq(unsigned int cpu_f_hz)
{
80002104:	eb cd 40 80 	pushm	r7,lr
80002108:	1a 97       	mov	r7,sp
8000210a:	20 1d       	sub	sp,4
8000210c:	ef 4c ff fc 	st.w	r7[-4],r12
	if (cpu_f_hz >= AVR32_FLASHC_FWS_0_MAX_FREQ) {
80002110:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002114:	e0 69 8a 3f 	mov	r9,35391
80002118:	ea 19 01 f7 	orh	r9,0x1f7
8000211c:	12 38       	cp.w	r8,r9
8000211e:	e0 88 00 06 	brls	8000212a <flashc_set_bus_freq+0x26>
		// Set 1 WS.
		flashc_set_wait_state(1);
80002122:	30 1c       	mov	r12,1
80002124:	f0 1f 00 05 	mcall	80002138 <flashc_set_bus_freq+0x34>
80002128:	c0 48       	rjmp	80002130 <flashc_set_bus_freq+0x2c>
	} else {
		// Set 0 WS.
		flashc_set_wait_state(0);
8000212a:	30 0c       	mov	r12,0
8000212c:	f0 1f 00 03 	mcall	80002138 <flashc_set_bus_freq+0x34>
	}
}
80002130:	2f fd       	sub	sp,-4
80002132:	e3 cd 80 80 	ldm	sp++,r7,pc
80002136:	00 00       	add	r0,r0
80002138:	80 00       	ld.sh	r0,r0[0x0]
8000213a:	20 bc       	sub	r12,11

8000213c <flashc_is_ready>:
 */
//! @{


bool flashc_is_ready(void)
{
8000213c:	eb cd 40 80 	pushm	r7,lr
80002140:	1a 97       	mov	r7,sp
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_FRDY_MASK) != 0);
80002142:	fe 68 14 00 	mov	r8,-125952
80002146:	70 28       	ld.w	r8,r8[0x8]
80002148:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
8000214c:	5c 58       	castu.b	r8
}
8000214e:	10 9c       	mov	r12,r8
80002150:	e3 cd 80 80 	ldm	sp++,r7,pc

80002154 <flashc_default_wait_until_ready>:


void flashc_default_wait_until_ready(void)
{
80002154:	eb cd 40 80 	pushm	r7,lr
80002158:	1a 97       	mov	r7,sp
	while (!flashc_is_ready());
8000215a:	f0 1f 00 05 	mcall	8000216c <flashc_default_wait_until_ready+0x18>
8000215e:	18 98       	mov	r8,r12
80002160:	ec 18 00 01 	eorl	r8,0x1
80002164:	5c 58       	castu.b	r8
80002166:	cf a1       	brne	8000215a <flashc_default_wait_until_ready+0x6>
}
80002168:	e3 cd 80 80 	ldm	sp++,r7,pc
8000216c:	80 00       	ld.sh	r0,r0[0x0]
8000216e:	21 3c       	sub	r12,19

80002170 <flashc_get_error_status>:
 *          Flash Status Register (FSR). This function is therefore not part of
 *          the driver's API which instead presents \ref flashc_is_lock_error
 *          and \ref flashc_is_programming_error.
 */
static unsigned int flashc_get_error_status(void)
{
80002170:	eb cd 40 80 	pushm	r7,lr
80002174:	1a 97       	mov	r7,sp
	return AVR32_FLASHC.fsr & (AVR32_FLASHC_FSR_LOCKE_MASK |
80002176:	fe 68 14 00 	mov	r8,-125952
8000217a:	70 28       	ld.w	r8,r8[0x8]
8000217c:	e2 18 00 0c 	andl	r8,0xc,COH
			AVR32_FLASHC_FSR_PROGE_MASK);
}
80002180:	10 9c       	mov	r12,r8
80002182:	e3 cd 80 80 	ldm	sp++,r7,pc
80002186:	d7 03       	nop

80002188 <flashc_issue_command>:
	return (AVR32_FLASHC.fcmd & AVR32_FLASHC_FCMD_PAGEN_MASK) >> AVR32_FLASHC_FCMD_PAGEN_OFFSET;
}


void flashc_issue_command(unsigned int command, int page_number)
{
80002188:	eb cd 40 80 	pushm	r7,lr
8000218c:	1a 97       	mov	r7,sp
8000218e:	20 3d       	sub	sp,12
80002190:	ef 4c ff f8 	st.w	r7[-8],r12
80002194:	ef 4b ff f4 	st.w	r7[-12],r11
	u_avr32_flashc_fcmd_t u_avr32_flashc_fcmd;

	flashc_wait_until_ready();
80002198:	49 b8       	lddpc	r8,80002204 <flashc_issue_command+0x7c>
8000219a:	70 08       	ld.w	r8,r8[0x0]
8000219c:	5d 18       	icall	r8
	u_avr32_flashc_fcmd.fcmd = AVR32_FLASHC.fcmd;
8000219e:	fe 68 14 00 	mov	r8,-125952
800021a2:	70 18       	ld.w	r8,r8[0x4]
800021a4:	ef 48 ff fc 	st.w	r7[-4],r8
	u_avr32_flashc_fcmd.FCMD.cmd = command;
800021a8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800021ac:	5c 58       	castu.b	r8
800021ae:	f1 d8 c0 06 	bfextu	r8,r8,0x0,0x6
800021b2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800021b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800021ba:	f1 d9 d0 06 	bfins	r8,r9,0x0,0x6
800021be:	ef 48 ff fc 	st.w	r7[-4],r8
	if (page_number >= 0) {
800021c2:	ee f8 ff f4 	ld.w	r8,r7[-12]
800021c6:	58 08       	cp.w	r8,0
800021c8:	c0 b5       	brlt	800021de <flashc_issue_command+0x56>
		u_avr32_flashc_fcmd.FCMD.pagen = page_number;
800021ca:	ee f8 ff f4 	ld.w	r8,r7[-12]
800021ce:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
800021d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800021d6:	f1 d9 d1 10 	bfins	r8,r9,0x8,0x10
800021da:	ef 48 ff fc 	st.w	r7[-4],r8
	}
	u_avr32_flashc_fcmd.FCMD.key = AVR32_FLASHC_FCMD_KEY_KEY;
800021de:	3a 58       	mov	r8,-91
800021e0:	ef 68 ff fc 	st.b	r7[-4],r8
	AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.fcmd;
800021e4:	fe 68 14 00 	mov	r8,-125952
800021e8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800021ec:	91 19       	st.w	r8[0x4],r9
	flashc_error_status = flashc_get_error_status();
800021ee:	f0 1f 00 07 	mcall	80002208 <flashc_issue_command+0x80>
800021f2:	18 99       	mov	r9,r12
800021f4:	48 68       	lddpc	r8,8000220c <flashc_issue_command+0x84>
800021f6:	91 09       	st.w	r8[0x0],r9
	flashc_wait_until_ready();
800021f8:	48 38       	lddpc	r8,80002204 <flashc_issue_command+0x7c>
800021fa:	70 08       	ld.w	r8,r8[0x0]
800021fc:	5d 18       	icall	r8
}
800021fe:	2f dd       	sub	sp,-12
80002200:	e3 cd 80 80 	ldm	sp++,r7,pc
80002204:	00 00       	add	r0,r0
80002206:	00 08       	add	r8,r0
80002208:	80 00       	ld.sh	r0,r0[0x0]
8000220a:	21 70       	sub	r0,23
8000220c:	00 00       	add	r0,r0
8000220e:	00 e8       	st.h	--r0,r8

80002210 <flashc_clear_page_buffer>:
 */
//! @{


void flashc_clear_page_buffer(void)
{
80002210:	eb cd 40 80 	pushm	r7,lr
80002214:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_CPB, -1);
80002216:	3f fb       	mov	r11,-1
80002218:	30 3c       	mov	r12,3
8000221a:	f0 1f 00 03 	mcall	80002224 <flashc_clear_page_buffer+0x14>
}
8000221e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002222:	00 00       	add	r0,r0
80002224:	80 00       	ld.sh	r0,r0[0x0]
80002226:	21 88       	sub	r8,24

80002228 <flashc_is_page_erased>:


bool flashc_is_page_erased(void)
{
80002228:	eb cd 40 80 	pushm	r7,lr
8000222c:	1a 97       	mov	r7,sp
	return ((AVR32_FLASHC.fsr & AVR32_FLASHC_FSR_QPRR_MASK) != 0);
8000222e:	fe 68 14 00 	mov	r8,-125952
80002232:	70 28       	ld.w	r8,r8[0x8]
80002234:	e2 18 00 20 	andl	r8,0x20,COH
80002238:	5f 18       	srne	r8
8000223a:	5c 58       	castu.b	r8
}
8000223c:	10 9c       	mov	r12,r8
8000223e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002242:	d7 03       	nop

80002244 <flashc_quick_page_read>:


bool flashc_quick_page_read(int page_number)
{
80002244:	eb cd 40 80 	pushm	r7,lr
80002248:	1a 97       	mov	r7,sp
8000224a:	20 1d       	sub	sp,4
8000224c:	ef 4c ff fc 	st.w	r7[-4],r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
80002250:	ee fb ff fc 	ld.w	r11,r7[-4]
80002254:	30 cc       	mov	r12,12
80002256:	f0 1f 00 05 	mcall	80002268 <flashc_quick_page_read+0x24>
	return flashc_is_page_erased();
8000225a:	f0 1f 00 05 	mcall	8000226c <flashc_quick_page_read+0x28>
8000225e:	18 98       	mov	r8,r12
}
80002260:	10 9c       	mov	r12,r8
80002262:	2f fd       	sub	sp,-4
80002264:	e3 cd 80 80 	ldm	sp++,r7,pc
80002268:	80 00       	ld.sh	r0,r0[0x0]
8000226a:	21 88       	sub	r8,24
8000226c:	80 00       	ld.sh	r0,r0[0x0]
8000226e:	22 28       	sub	r8,34

80002270 <flashc_erase_page>:


bool flashc_erase_page(int page_number, bool check)
{
80002270:	eb cd 40 80 	pushm	r7,lr
80002274:	1a 97       	mov	r7,sp
80002276:	20 4d       	sub	sp,16
80002278:	ef 4c ff f4 	st.w	r7[-12],r12
8000227c:	16 98       	mov	r8,r11
8000227e:	ef 68 ff f0 	st.b	r7[-16],r8
	bool page_erased = true;
80002282:	30 18       	mov	r8,1
80002284:	ef 68 ff fb 	st.b	r7[-5],r8

	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EP, page_number);
80002288:	ee fb ff f4 	ld.w	r11,r7[-12]
8000228c:	30 2c       	mov	r12,2
8000228e:	f0 1f 00 10 	mcall	800022cc <flashc_erase_page+0x5c>
	if (check) {
80002292:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80002296:	30 08       	mov	r8,0
80002298:	f0 09 18 00 	cp.b	r9,r8
8000229c:	c1 20       	breq	800022c0 <flashc_erase_page+0x50>
		unsigned int error_status = flashc_error_status;
8000229e:	48 d8       	lddpc	r8,800022d0 <flashc_erase_page+0x60>
800022a0:	70 08       	ld.w	r8,r8[0x0]
800022a2:	ef 48 ff fc 	st.w	r7[-4],r8
		page_erased = flashc_quick_page_read(-1);
800022a6:	3f fc       	mov	r12,-1
800022a8:	f0 1f 00 0b 	mcall	800022d4 <flashc_erase_page+0x64>
800022ac:	18 98       	mov	r8,r12
800022ae:	ef 68 ff fb 	st.b	r7[-5],r8
		flashc_error_status |= error_status;
800022b2:	48 88       	lddpc	r8,800022d0 <flashc_erase_page+0x60>
800022b4:	70 09       	ld.w	r9,r8[0x0]
800022b6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800022ba:	10 49       	or	r9,r8
800022bc:	48 58       	lddpc	r8,800022d0 <flashc_erase_page+0x60>
800022be:	91 09       	st.w	r8[0x0],r9
	}
	return page_erased;
800022c0:	ef 38 ff fb 	ld.ub	r8,r7[-5]
}
800022c4:	10 9c       	mov	r12,r8
800022c6:	2f cd       	sub	sp,-16
800022c8:	e3 cd 80 80 	ldm	sp++,r7,pc
800022cc:	80 00       	ld.sh	r0,r0[0x0]
800022ce:	21 88       	sub	r8,24
800022d0:	00 00       	add	r0,r0
800022d2:	00 e8       	st.h	--r0,r8
800022d4:	80 00       	ld.sh	r0,r0[0x0]
800022d6:	22 44       	sub	r4,36

800022d8 <flashc_write_page>:
	return all_pages_erased;
}


void flashc_write_page(int page_number)
{
800022d8:	eb cd 40 80 	pushm	r7,lr
800022dc:	1a 97       	mov	r7,sp
800022de:	20 1d       	sub	sp,4
800022e0:	ef 4c ff fc 	st.w	r7[-4],r12
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WP, page_number);
800022e4:	ee fb ff fc 	ld.w	r11,r7[-4]
800022e8:	30 1c       	mov	r12,1
800022ea:	f0 1f 00 03 	mcall	800022f4 <flashc_write_page+0x1c>
}
800022ee:	2f fd       	sub	sp,-4
800022f0:	e3 cd 80 80 	ldm	sp++,r7,pc
800022f4:	80 00       	ld.sh	r0,r0[0x0]
800022f6:	21 88       	sub	r8,24

800022f8 <flashc_quick_user_page_read>:


bool flashc_quick_user_page_read(void)
{
800022f8:	eb cd 40 80 	pushm	r7,lr
800022fc:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
800022fe:	3f fb       	mov	r11,-1
80002300:	30 fc       	mov	r12,15
80002302:	f0 1f 00 05 	mcall	80002314 <flashc_quick_user_page_read+0x1c>
	return flashc_is_page_erased();
80002306:	f0 1f 00 05 	mcall	80002318 <flashc_quick_user_page_read+0x20>
8000230a:	18 98       	mov	r8,r12
}
8000230c:	10 9c       	mov	r12,r8
8000230e:	e3 cd 80 80 	ldm	sp++,r7,pc
80002312:	00 00       	add	r0,r0
80002314:	80 00       	ld.sh	r0,r0[0x0]
80002316:	21 88       	sub	r8,24
80002318:	80 00       	ld.sh	r0,r0[0x0]
8000231a:	22 28       	sub	r8,34

8000231c <flashc_erase_user_page>:


bool flashc_erase_user_page(bool check)
{
8000231c:	eb cd 40 80 	pushm	r7,lr
80002320:	1a 97       	mov	r7,sp
80002322:	20 1d       	sub	sp,4
80002324:	18 98       	mov	r8,r12
80002326:	ef 68 ff fc 	st.b	r7[-4],r8
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_EUP, -1);
8000232a:	3f fb       	mov	r11,-1
8000232c:	30 ec       	mov	r12,14
8000232e:	f0 1f 00 09 	mcall	80002350 <flashc_erase_user_page+0x34>
	return (check) ? flashc_quick_user_page_read() : true;
80002332:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80002336:	30 08       	mov	r8,0
80002338:	f0 09 18 00 	cp.b	r9,r8
8000233c:	c0 50       	breq	80002346 <flashc_erase_user_page+0x2a>
8000233e:	f0 1f 00 06 	mcall	80002354 <flashc_erase_user_page+0x38>
80002342:	18 98       	mov	r8,r12
80002344:	c0 28       	rjmp	80002348 <flashc_erase_user_page+0x2c>
80002346:	30 18       	mov	r8,1
}
80002348:	10 9c       	mov	r12,r8
8000234a:	2f fd       	sub	sp,-4
8000234c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002350:	80 00       	ld.sh	r0,r0[0x0]
80002352:	21 88       	sub	r8,24
80002354:	80 00       	ld.sh	r0,r0[0x0]
80002356:	22 f8       	sub	r8,47

80002358 <flashc_write_user_page>:


void flashc_write_user_page(void)
{
80002358:	eb cd 40 80 	pushm	r7,lr
8000235c:	1a 97       	mov	r7,sp
	flashc_issue_command(AVR32_FLASHC_FCMD_CMD_WUP, -1);
8000235e:	3f fb       	mov	r11,-1
80002360:	30 dc       	mov	r12,13
80002362:	f0 1f 00 03 	mcall	8000236c <flashc_write_user_page+0x14>
}
80002366:	e3 cd 80 80 	ldm	sp++,r7,pc
8000236a:	00 00       	add	r0,r0
8000236c:	80 00       	ld.sh	r0,r0[0x0]
8000236e:	21 88       	sub	r8,24

80002370 <flashc_memset8>:


volatile void *flashc_memset8(volatile void *dst, uint8_t src, size_t nbytes, bool erase)
{
80002370:	eb cd 40 80 	pushm	r7,lr
80002374:	1a 97       	mov	r7,sp
80002376:	20 4d       	sub	sp,16
80002378:	ef 4c ff fc 	st.w	r7[-4],r12
8000237c:	ef 4a ff f4 	st.w	r7[-12],r10
80002380:	12 98       	mov	r8,r9
80002382:	16 99       	mov	r9,r11
80002384:	ef 69 ff f8 	st.b	r7[-8],r9
80002388:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset16(dst, src | (uint16_t)src << 8, nbytes, erase);
8000238c:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80002390:	ef 3a ff f8 	ld.ub	r10,r7[-8]
80002394:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80002398:	a9 68       	lsl	r8,0x8
8000239a:	5c 88       	casts.h	r8
8000239c:	f5 e8 10 08 	or	r8,r10,r8
800023a0:	5c 88       	casts.h	r8
800023a2:	5c 78       	castu.h	r8
800023a4:	ee fa ff f4 	ld.w	r10,r7[-12]
800023a8:	10 9b       	mov	r11,r8
800023aa:	ee fc ff fc 	ld.w	r12,r7[-4]
800023ae:	f0 1f 00 04 	mcall	800023bc <flashc_memset8+0x4c>
800023b2:	18 98       	mov	r8,r12
}
800023b4:	10 9c       	mov	r12,r8
800023b6:	2f cd       	sub	sp,-16
800023b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800023bc:	80 00       	ld.sh	r0,r0[0x0]
800023be:	23 c0       	sub	r0,60

800023c0 <flashc_memset16>:


volatile void *flashc_memset16(volatile void *dst, uint16_t src, size_t nbytes, bool erase)
{
800023c0:	eb cd 40 80 	pushm	r7,lr
800023c4:	1a 97       	mov	r7,sp
800023c6:	20 4d       	sub	sp,16
800023c8:	ef 4c ff fc 	st.w	r7[-4],r12
800023cc:	ef 4a ff f4 	st.w	r7[-12],r10
800023d0:	12 98       	mov	r8,r9
800023d2:	16 99       	mov	r9,r11
800023d4:	ef 59 ff f8 	st.h	r7[-8],r9
800023d8:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset32(dst, src | (uint32_t)src << 16, nbytes, erase);
800023dc:	ef 39 ff f0 	ld.ub	r9,r7[-16]
800023e0:	ef 1a ff f8 	ld.uh	r10,r7[-8]
800023e4:	ef 18 ff f8 	ld.uh	r8,r7[-8]
800023e8:	b1 68       	lsl	r8,0x10
800023ea:	f5 e8 10 08 	or	r8,r10,r8
800023ee:	ee fa ff f4 	ld.w	r10,r7[-12]
800023f2:	10 9b       	mov	r11,r8
800023f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800023f8:	f0 1f 00 04 	mcall	80002408 <flashc_memset16+0x48>
800023fc:	18 98       	mov	r8,r12
}
800023fe:	10 9c       	mov	r12,r8
80002400:	2f cd       	sub	sp,-16
80002402:	e3 cd 80 80 	ldm	sp++,r7,pc
80002406:	00 00       	add	r0,r0
80002408:	80 00       	ld.sh	r0,r0[0x0]
8000240a:	24 0c       	sub	r12,64

8000240c <flashc_memset32>:


volatile void *flashc_memset32(volatile void *dst, uint32_t src, size_t nbytes, bool erase)
{
8000240c:	eb cd 40 8f 	pushm	r0-r3,r7,lr
80002410:	1a 97       	mov	r7,sp
80002412:	20 6d       	sub	sp,24
80002414:	ef 4c ff fc 	st.w	r7[-4],r12
80002418:	ef 4b ff f8 	st.w	r7[-8],r11
8000241c:	ef 4a ff f4 	st.w	r7[-12],r10
80002420:	12 98       	mov	r8,r9
80002422:	ef 68 ff f0 	st.b	r7[-16],r8
	return flashc_memset64(dst, src | (uint64_t)src << 32, nbytes, erase);
80002426:	ef 38 ff f0 	ld.ub	r8,r7[-16]
8000242a:	ee f0 ff f8 	ld.w	r0,r7[-8]
8000242e:	30 01       	mov	r1,0
80002430:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002434:	ef 49 ff ec 	st.w	r7[-20],r9
80002438:	30 09       	mov	r9,0
8000243a:	ef 49 ff e8 	st.w	r7[-24],r9
8000243e:	ee f3 ff ec 	ld.w	r3,r7[-20]
80002442:	a1 63       	lsl	r3,0x0
80002444:	30 02       	mov	r2,0
80002446:	e1 e2 10 0a 	or	r10,r0,r2
8000244a:	e3 e3 10 0b 	or	r11,r1,r3
8000244e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002452:	ee fc ff fc 	ld.w	r12,r7[-4]
80002456:	f0 1f 00 04 	mcall	80002464 <flashc_memset32+0x58>
8000245a:	18 98       	mov	r8,r12
}
8000245c:	10 9c       	mov	r12,r8
8000245e:	2f ad       	sub	sp,-24
80002460:	e3 cd 80 8f 	ldm	sp++,r0-r3,r7,pc
80002464:	80 00       	ld.sh	r0,r0[0x0]
80002466:	24 68       	sub	r8,70

80002468 <flashc_memset64>:


volatile void *flashc_memset64(volatile void *dst, uint64_t src, size_t nbytes, bool erase)
{
80002468:	eb cd 40 80 	pushm	r7,lr
8000246c:	1a 97       	mov	r7,sp
8000246e:	21 bd       	sub	sp,108
80002470:	ef 4c ff a4 	st.w	r7[-92],r12
80002474:	ee eb ff 9c 	st.d	r7[-100],r10
80002478:	ef 49 ff 98 	st.w	r7[-104],r9
8000247c:	ef 68 ff 94 	st.b	r7[-108],r8
	// Use aggregated pointers to have several alignments available for a same address.
	UnionCVPtr flash_array_end;
	UnionVPtr dest;
	Union64 source = {0};
80002480:	30 08       	mov	r8,0
80002482:	30 09       	mov	r9,0
80002484:	ee e9 ff d8 	st.d	r7[-40],r8
	StructCVPtr dest_end;
	UnionCVPtr flash_page_source_end;
	bool incomplete_flash_page_end;
	Union64 flash_dword;
	UnionVPtr tmp;
	unsigned int error_status = 0;
80002488:	30 08       	mov	r8,0
8000248a:	ef 48 ff ec 	st.w	r7[-20],r8
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
8000248e:	f0 1f 00 fc 	mcall	8000287c <flashc_memset64+0x414>
80002492:	18 99       	mov	r9,r12
80002494:	30 08       	mov	r8,0
80002496:	ea 18 80 00 	orh	r8,0x8000
8000249a:	f2 08 00 08 	add	r8,r9,r8
8000249e:	ef 48 ff e4 	st.w	r7[-28],r8
	dest.u8ptr = dst;
800024a2:	ee f8 ff a4 	ld.w	r8,r7[-92]
800024a6:	ef 48 ff e0 	st.w	r7[-32],r8
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800024aa:	ee f8 ff e0 	ld.w	r8,r7[-32]
800024ae:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800024b2:	20 18       	sub	r8,1
800024b4:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800024b8:	ef 48 ff f0 	st.w	r7[-16],r8
800024bc:	c1 f8       	rjmp	800024fa <flashc_memset64+0x92>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
800024be:	ee f9 ff f0 	ld.w	r9,r7[-16]
800024c2:	ef 38 ff a3 	ld.ub	r8,r7[-93]
800024c6:	ee 09 00 09 	add	r9,r7,r9
800024ca:	f3 68 ff d8 	st.b	r9[-40],r8
		src >>= 8;
800024ce:	ee f8 ff 9c 	ld.w	r8,r7[-100]
800024d2:	b9 68       	lsl	r8,0x18
800024d4:	ee f9 ff a0 	ld.w	r9,r7[-96]
800024d8:	a9 89       	lsr	r9,0x8
800024da:	f3 e8 10 08 	or	r8,r9,r8
800024de:	ef 48 ff a0 	st.w	r7[-96],r8
800024e2:	ee f8 ff 9c 	ld.w	r8,r7[-100]
800024e6:	a9 88       	lsr	r8,0x8
800024e8:	ef 48 ff 9c 	st.w	r7[-100],r8

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
800024ec:	ee f8 ff f0 	ld.w	r8,r7[-16]
800024f0:	20 18       	sub	r8,1
800024f2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
800024f6:	ef 48 ff f0 	st.w	r7[-16],r8
	unsigned int i;

	// Reformat arguments.
	flash_array_end.u8ptr = AVR32_FLASH + flashc_get_flash_size();
	dest.u8ptr = dst;
	for (i = (Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)) - 1) & (sizeof(uint64_t) - 1);
800024fa:	ee e8 ff 9c 	ld.d	r8,r7[-100]
800024fe:	58 08       	cp.w	r8,0
80002500:	5c 29       	cpc	r9
80002502:	cd e1       	brne	800024be <flashc_memset64+0x56>
			src; i = (i - 1) & (sizeof(uint64_t) - 1)) {
		source.u8[i] = src;
		src >>= 8;
	}
	dest_end.u8ptr = dest.u8ptr + nbytes;
80002504:	ee f9 ff e0 	ld.w	r9,r7[-32]
80002508:	ee f8 ff 98 	ld.w	r8,r7[-104]
8000250c:	f2 08 00 08 	add	r8,r9,r8
80002510:	ef 48 ff d4 	st.w	r7[-44],r8

	// If destination is outside flash, go to next flash page if any.
	if (dest.u8ptr < AVR32_FLASH) {
80002514:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002518:	e0 69 ff ff 	mov	r9,65535
8000251c:	ea 19 7f ff 	orh	r9,0x7fff
80002520:	12 38       	cp.w	r8,r9
80002522:	e0 8b 00 08 	brhi	80002532 <flashc_memset64+0xca>
		dest.u8ptr = AVR32_FLASH;
80002526:	30 08       	mov	r8,0
80002528:	ea 18 80 00 	orh	r8,0x8000
8000252c:	ef 48 ff e0 	st.w	r7[-32],r8
80002530:	c1 68       	rjmp	8000255c <flashc_memset64+0xf4>
	} else if (flash_array_end.u8ptr <= dest.u8ptr && dest.u8ptr < AVR32_FLASHC_USER_PAGE) {
80002532:	ee f9 ff e4 	ld.w	r9,r7[-28]
80002536:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000253a:	10 39       	cp.w	r9,r8
8000253c:	e0 8b 00 10 	brhi	8000255c <flashc_memset64+0xf4>
80002540:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002544:	e0 69 ff ff 	mov	r9,65535
80002548:	ea 19 80 7f 	orh	r9,0x807f
8000254c:	12 38       	cp.w	r8,r9
8000254e:	e0 8b 00 07 	brhi	8000255c <flashc_memset64+0xf4>
		dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80002552:	30 08       	mov	r8,0
80002554:	ea 18 80 80 	orh	r8,0x8080
80002558:	ef 48 ff e0 	st.w	r7[-32],r8
	}

	// If end of destination is outside flash, move it to the end of the previous flash page if any.
	if (dest_end.u8ptr > AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE) {
8000255c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002560:	e0 69 02 00 	mov	r9,512
80002564:	ea 19 80 80 	orh	r9,0x8080
80002568:	12 38       	cp.w	r8,r9
8000256a:	e0 88 00 09 	brls	8000257c <flashc_memset64+0x114>
		dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
8000256e:	e0 68 02 00 	mov	r8,512
80002572:	ea 18 80 80 	orh	r8,0x8080
80002576:	ef 48 ff d4 	st.w	r7[-44],r8
8000257a:	c1 48       	rjmp	800025a2 <flashc_memset64+0x13a>
	} else if (AVR32_FLASHC_USER_PAGE >= dest_end.u8ptr && dest_end.u8ptr > flash_array_end.u8ptr) {
8000257c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002580:	30 09       	mov	r9,0
80002582:	ea 19 80 80 	orh	r9,0x8080
80002586:	12 38       	cp.w	r8,r9
80002588:	e0 8b 00 0d 	brhi	800025a2 <flashc_memset64+0x13a>
8000258c:	ee f9 ff d4 	ld.w	r9,r7[-44]
80002590:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002594:	10 39       	cp.w	r9,r8
80002596:	e0 88 00 06 	brls	800025a2 <flashc_memset64+0x13a>
		dest_end.u8ptr = flash_array_end.u8ptr;
8000259a:	ee f8 ff e4 	ld.w	r8,r7[-28]
8000259e:	ef 48 ff d4 	st.w	r7[-44],r8
	}

	// Align each end of destination pointer with its natural boundary.
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
800025a2:	ee f8 ff d4 	ld.w	r8,r7[-44]
800025a6:	a1 c8       	cbr	r8,0x0
800025a8:	ef 48 ff cc 	st.w	r7[-52],r8
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
800025ac:	ee f8 ff cc 	ld.w	r8,r7[-52]
800025b0:	e0 18 ff fc 	andl	r8,0xfffc
800025b4:	ef 48 ff c4 	st.w	r7[-60],r8
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));
800025b8:	ee f8 ff c4 	ld.w	r8,r7[-60]
800025bc:	e0 18 ff f8 	andl	r8,0xfff8
800025c0:	ef 48 ff bc 	st.w	r7[-68],r8

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
800025c4:	c4 a9       	rjmp	80002858 <flashc_memset64+0x3f0>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800025c6:	f0 1f 00 af 	mcall	80002880 <flashc_memset64+0x418>
		error_status |= flashc_error_status;
800025ca:	fe f8 02 ba 	ld.w	r8,pc[698]
800025ce:	70 08       	ld.w	r8,r8[0x0]
800025d0:	ee f9 ff ec 	ld.w	r9,r7[-20]
800025d4:	f3 e8 10 08 	or	r8,r9,r8
800025d8:	ef 48 ff ec 	st.w	r7[-20],r8

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
800025dc:	ee f8 ff bc 	ld.w	r8,r7[-68]
800025e0:	ef 48 ff f8 	st.w	r7[-8],r8
800025e4:	ee f8 ff e0 	ld.w	r8,r7[-32]
800025e8:	e0 18 fe 00 	andl	r8,0xfe00
800025ec:	f0 c8 fe 00 	sub	r8,r8,-512
800025f0:	ef 48 ff fc 	st.w	r7[-4],r8
800025f4:	ee f8 ff f8 	ld.w	r8,r7[-8]
800025f8:	ee f9 ff fc 	ld.w	r9,r7[-4]
800025fc:	f0 09 0d 48 	min	r8,r8,r9
80002600:	ef 48 ff f4 	st.w	r7[-12],r8
80002604:	ee f8 ff f4 	ld.w	r8,r7[-12]
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Determine where the source data will end in the current flash page.
		flash_page_source_end.u64ptr =
80002608:	ef 48 ff b4 	st.w	r7[-76],r8
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
				Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);

		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
8000260c:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002610:	10 99       	mov	r9,r8
80002612:	e0 19 fe 00 	andl	r9,0xfe00
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
80002616:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000261a:	e0 18 fe 00 	andl	r8,0xfe00
		flash_page_source_end.u64ptr =
				(uint64_t *)min((uint32_t)dest_end.u64ptr,
				Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);

		// Determine if the current destination page has an incomplete end.
		incomplete_flash_page_end = (Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) >=
8000261e:	10 39       	cp.w	r9,r8
80002620:	5f 28       	srhs	r8
80002622:	ef 68 ff eb 	st.b	r7[-21],r8
				Align_down((uint32_t)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));

		// Use a flash double-word buffer to manage unaligned accesses.
		flash_dword.u64 = source.u64;
80002626:	ee e8 ff d8 	ld.d	r8,r7[-40]
8000262a:	ee e9 ff ac 	st.d	r7[-84],r8

		// If destination does not point to the beginning of the current flash page...
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
8000262e:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002632:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
80002636:	c5 b0       	breq	800026ec <flashc_memset64+0x284>
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
80002638:	ee f8 ff e0 	ld.w	r8,r7[-32]
8000263c:	e0 18 fe 00 	andl	r8,0xfe00
80002640:	ef 48 ff a8 	st.w	r7[-88],r8
80002644:	c0 e8       	rjmp	80002660 <flashc_memset64+0x1f8>
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
80002646:	ee fa ff a8 	ld.w	r10,r7[-88]
8000264a:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000264e:	f0 e8 00 00 	ld.d	r8,r8[0]
80002652:	f4 e9 00 00 	st.d	r10[0],r8
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
					tmp.u64ptr++) {
80002656:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000265a:	2f 88       	sub	r8,-8
8000265c:	ef 48 ff a8 	st.w	r7[-88],r8
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
					tmp.u64ptr < (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
80002660:	ee f9 ff a8 	ld.w	r9,r7[-88]
80002664:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002668:	e0 18 ff f8 	andl	r8,0xfff8
		if (!Test_align((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE)) {
			// Fill the beginning of the page buffer with the current flash page data.
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			for (tmp.u8ptr = (uint8_t *)Align_down((uint32_t)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
8000266c:	10 39       	cp.w	r9,r8
8000266e:	ce c3       	brcs	80002646 <flashc_memset64+0x1de>
					tmp.u64ptr++) {
				*tmp.u64ptr = *tmp.u64ptr;
			}

			// If destination is not 64-bit aligned...
			if (!Test_align((uint32_t)dest.u8ptr, sizeof(uint64_t))) {
80002670:	ee f8 ff e0 	ld.w	r8,r7[-32]
80002674:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002678:	c3 a0       	breq	800026ec <flashc_memset64+0x284>
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
8000267a:	30 08       	mov	r8,0
8000267c:	ef 48 ff f0 	st.w	r7[-16],r8
80002680:	c1 38       	rjmp	800026a6 <flashc_memset64+0x23e>
					flash_dword.u8[i] = *tmp.u8ptr++;
80002682:	ee fa ff f0 	ld.w	r10,r7[-16]
80002686:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000268a:	11 89       	ld.ub	r9,r8[0x0]
8000268c:	5c 59       	castu.b	r9
8000268e:	ee 0a 00 0a 	add	r10,r7,r10
80002692:	f5 69 ff ac 	st.b	r10[-84],r9
80002696:	2f f8       	sub	r8,-1
80002698:	ef 48 ff a8 	st.w	r7[-88],r8
				// Fill the beginning of the flash double-word buffer with the current
				// flash page data.
				// This is required by the hardware, even if page erase is not
				// requested, in order to be able to write successfully to erased parts
				// of flash pages that have already been written to.
				for (i = 0; i < Get_align((uint32_t)dest.u8ptr, sizeof(uint64_t)); i++) {
8000269c:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026a0:	2f f8       	sub	r8,-1
800026a2:	ef 48 ff f0 	st.w	r7[-16],r8
800026a6:	ee f8 ff e0 	ld.w	r8,r7[-32]
800026aa:	f3 d8 c0 03 	bfextu	r9,r8,0x0,0x3
800026ae:	ee f8 ff f0 	ld.w	r8,r7[-16]
800026b2:	10 39       	cp.w	r9,r8
800026b4:	fe 9b ff e7 	brhi	80002682 <flashc_memset64+0x21a>
					flash_dword.u8[i] = *tmp.u8ptr++;
				}

				// Align the destination pointer with its 64-bit boundary.
				dest.u64ptr = (uint64_t *)Align_down((uint32_t)dest.u8ptr, sizeof(uint64_t));
800026b8:	ee f8 ff e0 	ld.w	r8,r7[-32]
800026bc:	e0 18 ff f8 	andl	r8,0xfff8
800026c0:	ef 48 ff e0 	st.w	r7[-32],r8

				// If the current destination double-word is not the last one...
				if (dest.u64ptr < dest_end.u64ptr) {
800026c4:	ee f9 ff e0 	ld.w	r9,r7[-32]
800026c8:	ee f8 ff bc 	ld.w	r8,r7[-68]
800026cc:	10 39       	cp.w	r9,r8
800026ce:	c0 f2       	brcc	800026ec <flashc_memset64+0x284>
					// Write the flash double-word buffer to the page buffer and reinitialize it.
					*dest.u64ptr++ = flash_dword.u64;
800026d0:	ee fa ff e0 	ld.w	r10,r7[-32]
800026d4:	ee e8 ff ac 	ld.d	r8,r7[-84]
800026d8:	f4 e9 00 00 	st.d	r10[0],r8
800026dc:	f4 c8 ff f8 	sub	r8,r10,-8
800026e0:	ef 48 ff e0 	st.w	r7[-32],r8
					flash_dword.u64 = source.u64;
800026e4:	ee e8 ff d8 	ld.d	r8,r7[-40]
800026e8:	ee e9 ff ac 	st.d	r7[-84],r8
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
800026ec:	ee f8 ff b4 	ld.w	r8,r7[-76]
800026f0:	10 99       	mov	r9,r8
800026f2:	ee f8 ff e0 	ld.w	r8,r7[-32]
800026f6:	f2 08 01 08 	sub	r8,r9,r8
800026fa:	a3 58       	asr	r8,0x3
800026fc:	ef 48 ff f0 	st.w	r7[-16],r8
80002700:	c1 08       	rjmp	80002720 <flashc_memset64+0x2b8>
			*dest.u64ptr++ = source.u64;
80002702:	ee fa ff e0 	ld.w	r10,r7[-32]
80002706:	ee e8 ff d8 	ld.d	r8,r7[-40]
8000270a:	f4 e9 00 00 	st.d	r10[0],r8
8000270e:	f4 c8 ff f8 	sub	r8,r10,-8
80002712:	ef 48 ff e0 	st.w	r7[-32],r8
				}
			}
		}

		// Write the source data to the page buffer with 64-bit alignment.
		for (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--) {
80002716:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000271a:	20 18       	sub	r8,1
8000271c:	ef 48 ff f0 	st.w	r7[-16],r8
80002720:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002724:	58 08       	cp.w	r8,0
80002726:	ce e1       	brne	80002702 <flashc_memset64+0x29a>
			*dest.u64ptr++ = source.u64;
		}

		// If the current destination page has an incomplete end...
		if (incomplete_flash_page_end) {
80002728:	ef 39 ff eb 	ld.ub	r9,r7[-21]
8000272c:	30 08       	mov	r8,0
8000272e:	f0 09 18 00 	cp.b	r9,r8
80002732:	c4 70       	breq	800027c0 <flashc_memset64+0x358>
			// This is required by the hardware, even if page erase is not requested,
			// in order to be able to write successfully to erased parts of flash
			// pages that have already been written to.
			{
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;
80002734:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002738:	ef 48 ff a8 	st.w	r7[-88],r8

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
8000273c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002740:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80002744:	c3 80       	breq	800027b4 <flashc_memset64+0x34c>
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
80002746:	ee f8 ff d4 	ld.w	r8,r7[-44]
8000274a:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
8000274e:	ef 48 ff f0 	st.w	r7[-16],r8
80002752:	c1 38       	rjmp	80002778 <flashc_memset64+0x310>
						flash_dword.u8[i] = *tmp.u8ptr++;
80002754:	ee fa ff f0 	ld.w	r10,r7[-16]
80002758:	ee f8 ff a8 	ld.w	r8,r7[-88]
8000275c:	11 89       	ld.ub	r9,r8[0x0]
8000275e:	5c 59       	castu.b	r9
80002760:	ee 0a 00 0a 	add	r10,r7,r10
80002764:	f5 69 ff ac 	st.b	r10[-84],r9
80002768:	2f f8       	sub	r8,-1
8000276a:	ef 48 ff a8 	st.w	r7[-88],r8
				tmp.u8ptr = (volatile uint8_t *)dest_end.u8ptr;

				// If end of destination is not 64-bit aligned...
				if (!Test_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t))) {
					// Fill the end of the flash double-word buffer with the current flash page data.
					for (i = Get_align((uint32_t)dest_end.u8ptr, sizeof(uint64_t)); i < sizeof(uint64_t); i++)
8000276e:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002772:	2f f8       	sub	r8,-1
80002774:	ef 48 ff f0 	st.w	r7[-16],r8
80002778:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000277c:	58 78       	cp.w	r8,7
8000277e:	fe 98 ff eb 	brls	80002754 <flashc_memset64+0x2ec>
						flash_dword.u8[i] = *tmp.u8ptr++;

					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
80002782:	ee fa ff e0 	ld.w	r10,r7[-32]
80002786:	ee e8 ff ac 	ld.d	r8,r7[-84]
8000278a:	f4 e9 00 00 	st.d	r10[0],r8
8000278e:	f4 c8 ff f8 	sub	r8,r10,-8
80002792:	ef 48 ff e0 	st.w	r7[-32],r8
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
80002796:	c1 08       	rjmp	800027b6 <flashc_memset64+0x34e>
					*tmp.u64ptr = *tmp.u64ptr;
80002798:	ee fa ff a8 	ld.w	r10,r7[-88]
8000279c:	ee f8 ff a8 	ld.w	r8,r7[-88]
800027a0:	f0 e8 00 00 	ld.d	r8,r8[0]
800027a4:	f4 e9 00 00 	st.d	r10[0],r8
					// Write the flash double-word buffer to the page buffer.
					*dest.u64ptr++ = flash_dword.u64;
				}

				// Fill the end of the page buffer with the current flash page data.
				for (; !Test_align((uint32_t)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++) {
800027a8:	ee f8 ff a8 	ld.w	r8,r7[-88]
800027ac:	2f 88       	sub	r8,-8
800027ae:	ef 48 ff a8 	st.w	r7[-88],r8
800027b2:	c0 28       	rjmp	800027b6 <flashc_memset64+0x34e>
800027b4:	d7 03       	nop
800027b6:	ee f8 ff a8 	ld.w	r8,r7[-88]
800027ba:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800027be:	ce d1       	brne	80002798 <flashc_memset64+0x330>
				}
			}
		}

		// If the current flash page is in the flash array...
		if (dest.u8ptr <= AVR32_FLASHC_USER_PAGE) {
800027c0:	ee f8 ff e0 	ld.w	r8,r7[-32]
800027c4:	30 09       	mov	r9,0
800027c6:	ea 19 80 80 	orh	r9,0x8080
800027ca:	12 38       	cp.w	r8,r9
800027cc:	e0 8b 00 2b 	brhi	80002822 <flashc_memset64+0x3ba>
			// Erase the current page if requested and write it from the page buffer.
			if (erase) {
800027d0:	ef 39 ff 94 	ld.ub	r9,r7[-108]
800027d4:	30 08       	mov	r8,0
800027d6:	f0 09 18 00 	cp.b	r9,r8
800027da:	c0 d0       	breq	800027f4 <flashc_memset64+0x38c>
				flashc_erase_page(-1, false);
800027dc:	30 0b       	mov	r11,0
800027de:	3f fc       	mov	r12,-1
800027e0:	f0 1f 00 2a 	mcall	80002888 <flashc_memset64+0x420>
				error_status |= flashc_error_status;
800027e4:	4a 88       	lddpc	r8,80002884 <flashc_memset64+0x41c>
800027e6:	70 08       	ld.w	r8,r8[0x0]
800027e8:	ee f9 ff ec 	ld.w	r9,r7[-20]
800027ec:	f3 e8 10 08 	or	r8,r9,r8
800027f0:	ef 48 ff ec 	st.w	r7[-20],r8
			}
			flashc_write_page(-1);
800027f4:	3f fc       	mov	r12,-1
800027f6:	f0 1f 00 26 	mcall	8000288c <flashc_memset64+0x424>
			error_status |= flashc_error_status;
800027fa:	4a 38       	lddpc	r8,80002884 <flashc_memset64+0x41c>
800027fc:	70 08       	ld.w	r8,r8[0x0]
800027fe:	ee f9 ff ec 	ld.w	r9,r7[-20]
80002802:	f3 e8 10 08 	or	r8,r9,r8
80002806:	ef 48 ff ec 	st.w	r7[-20],r8

			// If the end of the flash array is reached, go to the User page.
			if (dest.u8ptr >= flash_array_end.u8ptr) {
8000280a:	ee f9 ff e0 	ld.w	r9,r7[-32]
8000280e:	ee f8 ff e4 	ld.w	r8,r7[-28]
80002812:	10 39       	cp.w	r9,r8
80002814:	c2 23       	brcs	80002858 <flashc_memset64+0x3f0>
				dest.u8ptr = AVR32_FLASHC_USER_PAGE;
80002816:	30 08       	mov	r8,0
80002818:	ea 18 80 80 	orh	r8,0x8080
8000281c:	ef 48 ff e0 	st.w	r7[-32],r8
80002820:	c1 c8       	rjmp	80002858 <flashc_memset64+0x3f0>
			}
		} else {
			// Erase the User page if requested and write it from the page buffer.
			if (erase) {
80002822:	ef 39 ff 94 	ld.ub	r9,r7[-108]
80002826:	30 08       	mov	r8,0
80002828:	f0 09 18 00 	cp.b	r9,r8
8000282c:	c0 c0       	breq	80002844 <flashc_memset64+0x3dc>
				flashc_erase_user_page(false);
8000282e:	30 0c       	mov	r12,0
80002830:	f0 1f 00 18 	mcall	80002890 <flashc_memset64+0x428>
				error_status |= flashc_error_status;
80002834:	49 48       	lddpc	r8,80002884 <flashc_memset64+0x41c>
80002836:	70 08       	ld.w	r8,r8[0x0]
80002838:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000283c:	f3 e8 10 08 	or	r8,r9,r8
80002840:	ef 48 ff ec 	st.w	r7[-20],r8
			}
			flashc_write_user_page();
80002844:	f0 1f 00 14 	mcall	80002894 <flashc_memset64+0x42c>
			error_status |= flashc_error_status;
80002848:	48 f8       	lddpc	r8,80002884 <flashc_memset64+0x41c>
8000284a:	70 08       	ld.w	r8,r8[0x0]
8000284c:	ee f9 ff ec 	ld.w	r9,r7[-20]
80002850:	f3 e8 10 08 	or	r8,r9,r8
80002854:	ef 48 ff ec 	st.w	r7[-20],r8
	dest_end.u16ptr = (uint16_t *)Align_down((uint32_t)dest_end.u8ptr, sizeof(uint16_t));
	dest_end.u32ptr = (uint32_t *)Align_down((uint32_t)dest_end.u16ptr, sizeof(uint32_t));
	dest_end.u64ptr = (uint64_t *)Align_down((uint32_t)dest_end.u32ptr, sizeof(uint64_t));

	// While end of destination is not reached...
	while (dest.u8ptr < dest_end.u8ptr) {
80002858:	ee f9 ff e0 	ld.w	r9,r7[-32]
8000285c:	ee f8 ff d4 	ld.w	r8,r7[-44]
80002860:	10 39       	cp.w	r9,r8
80002862:	fe 93 fe b2 	brlo	800025c6 <flashc_memset64+0x15e>
			error_status |= flashc_error_status;
		}
	}

	// Update the FLASHC error status.
	flashc_error_status = error_status;
80002866:	48 88       	lddpc	r8,80002884 <flashc_memset64+0x41c>
80002868:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000286c:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memset function does.
	return dst;
8000286e:	ee f8 ff a4 	ld.w	r8,r7[-92]
}
80002872:	10 9c       	mov	r12,r8
80002874:	2e 5d       	sub	sp,-108
80002876:	e3 cd 80 80 	ldm	sp++,r7,pc
8000287a:	00 00       	add	r0,r0
8000287c:	80 00       	ld.sh	r0,r0[0x0]
8000287e:	20 78       	sub	r8,7
80002880:	80 00       	ld.sh	r0,r0[0x0]
80002882:	22 10       	sub	r0,33
80002884:	00 00       	add	r0,r0
80002886:	00 e8       	st.h	--r0,r8
80002888:	80 00       	ld.sh	r0,r0[0x0]
8000288a:	22 70       	sub	r0,39
8000288c:	80 00       	ld.sh	r0,r0[0x0]
8000288e:	22 d8       	sub	r8,45
80002890:	80 00       	ld.sh	r0,r0[0x0]
80002892:	23 1c       	sub	r12,49
80002894:	80 00       	ld.sh	r0,r0[0x0]
80002896:	23 58       	sub	r8,53

80002898 <flashc_memcpy>:


volatile void *flashc_memcpy(volatile void *dst, const void *src, size_t nbytes, bool erase)
{
80002898:	eb cd 40 80 	pushm	r7,lr
8000289c:	1a 97       	mov	r7,sp
8000289e:	20 bd       	sub	sp,44
800028a0:	ef 4c ff e0 	st.w	r7[-32],r12
800028a4:	ef 4b ff dc 	st.w	r7[-36],r11
800028a8:	ef 4a ff d8 	st.w	r7[-40],r10
800028ac:	12 98       	mov	r8,r9
800028ae:	ef 68 ff d4 	st.b	r7[-44],r8
	uint16_t page_pos;
	Union64 flash_dword;
	uint8_t i;
	bool b_user_page;
	unsigned int error_status = 0;
800028b2:	30 08       	mov	r8,0
800028b4:	ef 48 ff f0 	st.w	r7[-16],r8
	uint8_t* flash_add;
	uint8_t* dest_add=(uint8_t*)dst;
800028b8:	ee f8 ff e0 	ld.w	r8,r7[-32]
800028bc:	ef 48 ff f8 	st.w	r7[-8],r8
	const uint8_t* src_buf=(const uint8_t*)src;
800028c0:	ee f8 ff dc 	ld.w	r8,r7[-36]
800028c4:	ef 48 ff fc 	st.w	r7[-4],r8
	Assert( (((uint8_t *)dst >= AVR32_FLASH)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASH + flashc_get_flash_size())))
			|| (((uint8_t *)dst >= AVR32_FLASHC_USER_PAGE)
			&& (((uint8_t *)dst + nbytes) <= (AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE))) );

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;
800028c8:	ee f8 ff e0 	ld.w	r8,r7[-32]
800028cc:	e0 69 ff ff 	mov	r9,65535
800028d0:	ea 19 80 7f 	orh	r9,0x807f
800028d4:	12 38       	cp.w	r8,r9
800028d6:	5f b8       	srhi	r8
800028d8:	ef 68 ff ef 	st.b	r7[-17],r8

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));
800028dc:	ee f9 ff f8 	ld.w	r9,r7[-8]
800028e0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800028e4:	f1 d8 c0 09 	bfextu	r8,r8,0x0,0x9
800028e8:	f2 08 01 08 	sub	r8,r9,r8
800028ec:	ef 48 ff f4 	st.w	r7[-12],r8

	while (nbytes) {
800028f0:	c9 18       	rjmp	80002a12 <flashc_memcpy+0x17a>
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
800028f2:	f0 1f 00 50 	mcall	80002a30 <flashc_memcpy+0x198>
		error_status |= flashc_error_status;
800028f6:	4d 08       	lddpc	r8,80002a34 <flashc_memcpy+0x19c>
800028f8:	70 08       	ld.w	r8,r8[0x0]
800028fa:	ee f9 ff f0 	ld.w	r9,r7[-16]
800028fe:	f3 e8 10 08 	or	r8,r9,r8
80002902:	ef 48 ff f0 	st.w	r7[-16],r8

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
80002906:	30 08       	mov	r8,0
80002908:	ef 58 ff ec 	st.h	r7[-20],r8
8000290c:	c4 b8       	rjmp	800029a2 <flashc_memcpy+0x10a>
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;
8000290e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002912:	f0 e8 00 00 	ld.d	r8,r8[0]
80002916:	ee e9 ff e4 	st.d	r7[-28],r8

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
8000291a:	30 08       	mov	r8,0
8000291c:	ef 68 ff ee 	st.b	r7[-18],r8
80002920:	c2 d8       	rjmp	8000297a <flashc_memcpy+0xe2>
				if (nbytes && (flash_add == dest_add)) {
80002922:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002926:	58 08       	cp.w	r8,0
80002928:	c1 f0       	breq	80002966 <flashc_memcpy+0xce>
8000292a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000292e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002932:	10 39       	cp.w	r9,r8
80002934:	c1 91       	brne	80002966 <flashc_memcpy+0xce>
					// Update page with data source
					flash_dword.u8[i] = *src_buf++;
80002936:	ef 39 ff ee 	ld.ub	r9,r7[-18]
8000293a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000293e:	11 88       	ld.ub	r8,r8[0x0]
80002940:	ee 09 00 09 	add	r9,r7,r9
80002944:	f3 68 ff e4 	st.b	r9[-28],r8
80002948:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000294c:	2f f8       	sub	r8,-1
8000294e:	ef 48 ff fc 	st.w	r7[-4],r8
					dest_add++;
80002952:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002956:	2f f8       	sub	r8,-1
80002958:	ef 48 ff f8 	st.w	r7[-8],r8
					nbytes--;
8000295c:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002960:	20 18       	sub	r8,1
80002962:	ef 48 ff d8 	st.w	r7[-40],r8
				}
				flash_add++;
80002966:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000296a:	2f f8       	sub	r8,-1
8000296c:	ef 48 ff f4 	st.w	r7[-12],r8
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
			// Read the flash double-word buffer
			flash_dword.u64 = *(volatile uint64_t*)flash_add;

			// Update double-word if necessary
			for (i = 0; i < sizeof(uint64_t); i++) {
80002970:	ef 38 ff ee 	ld.ub	r8,r7[-18]
80002974:	2f f8       	sub	r8,-1
80002976:	ef 68 ff ee 	st.b	r7[-18],r8
8000297a:	ef 39 ff ee 	ld.ub	r9,r7[-18]
8000297e:	30 78       	mov	r8,7
80002980:	f0 09 18 00 	cp.b	r9,r8
80002984:	fe 98 ff cf 	brls	80002922 <flashc_memcpy+0x8a>
				}
				flash_add++;
			}

			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
80002988:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000298c:	20 88       	sub	r8,8
8000298e:	10 9a       	mov	r10,r8
80002990:	ee e8 ff e4 	ld.d	r8,r7[-28]
80002994:	f4 e9 00 00 	st.d	r10[0],r8
		// Clear the page buffer in order to prepare data for a flash page write.
		flashc_clear_page_buffer();
		error_status |= flashc_error_status;

		// Loop in the page
		for (page_pos=0; page_pos<AVR32_FLASHC_PAGE_SIZE; page_pos+=sizeof(uint64_t) ) {
80002998:	ef 08 ff ec 	ld.sh	r8,r7[-20]
8000299c:	2f 88       	sub	r8,-8
8000299e:	ef 58 ff ec 	st.h	r7[-20],r8
800029a2:	ef 09 ff ec 	ld.sh	r9,r7[-20]
800029a6:	e0 68 01 ff 	mov	r8,511
800029aa:	f0 09 19 00 	cp.h	r9,r8
800029ae:	fe 98 ff b0 	brls	8000290e <flashc_memcpy+0x76>
			// Write the flash double-word buffer to the page buffer.
			*(volatile uint64_t*)((uint32_t)flash_add - sizeof(uint64_t))= flash_dword.u64;
		}

		// Erase the current page if requested and write it from the page buffer.
		if (erase) {
800029b2:	ef 39 ff d4 	ld.ub	r9,r7[-44]
800029b6:	30 08       	mov	r8,0
800029b8:	f0 09 18 00 	cp.b	r9,r8
800029bc:	c1 70       	breq	800029ea <flashc_memcpy+0x152>
			(b_user_page)? flashc_erase_user_page(false) : flashc_erase_page(-1, false);
800029be:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800029c2:	30 08       	mov	r8,0
800029c4:	f0 09 18 00 	cp.b	r9,r8
800029c8:	c0 50       	breq	800029d2 <flashc_memcpy+0x13a>
800029ca:	30 0c       	mov	r12,0
800029cc:	f0 1f 00 1b 	mcall	80002a38 <flashc_memcpy+0x1a0>
800029d0:	c0 58       	rjmp	800029da <flashc_memcpy+0x142>
800029d2:	30 0b       	mov	r11,0
800029d4:	3f fc       	mov	r12,-1
800029d6:	f0 1f 00 1a 	mcall	80002a3c <flashc_memcpy+0x1a4>
			error_status |= flashc_error_status;
800029da:	49 78       	lddpc	r8,80002a34 <flashc_memcpy+0x19c>
800029dc:	70 08       	ld.w	r8,r8[0x0]
800029de:	ee f9 ff f0 	ld.w	r9,r7[-16]
800029e2:	f3 e8 10 08 	or	r8,r9,r8
800029e6:	ef 48 ff f0 	st.w	r7[-16],r8
		}

		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
800029ea:	ef 39 ff ef 	ld.ub	r9,r7[-17]
800029ee:	30 08       	mov	r8,0
800029f0:	f0 09 18 00 	cp.b	r9,r8
800029f4:	c0 40       	breq	800029fc <flashc_memcpy+0x164>
800029f6:	f0 1f 00 13 	mcall	80002a40 <flashc_memcpy+0x1a8>
800029fa:	c0 48       	rjmp	80002a02 <flashc_memcpy+0x16a>
800029fc:	3f fc       	mov	r12,-1
800029fe:	f0 1f 00 12 	mcall	80002a44 <flashc_memcpy+0x1ac>
		error_status |= flashc_error_status;
80002a02:	48 d8       	lddpc	r8,80002a34 <flashc_memcpy+0x19c>
80002a04:	70 08       	ld.w	r8,r8[0x0]
80002a06:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002a0a:	f3 e8 10 08 	or	r8,r9,r8
80002a0e:	ef 48 ff f0 	st.w	r7[-16],r8

	b_user_page = (volatile uint8_t *)dst >= AVR32_FLASHC_USER_PAGE;

	flash_add = (uint8_t*)((uint32_t)dest_add - ((uint32_t)dest_add % AVR32_FLASHC_PAGE_SIZE));

	while (nbytes) {
80002a12:	ee f8 ff d8 	ld.w	r8,r7[-40]
80002a16:	58 08       	cp.w	r8,0
80002a18:	fe 91 ff 6d 	brne	800028f2 <flashc_memcpy+0x5a>
		// Write the page
		(b_user_page)? flashc_write_user_page() : flashc_write_page(-1);
		error_status |= flashc_error_status;
	}
	// Update the FLASHC error status.
	flashc_error_status = error_status;
80002a1c:	48 68       	lddpc	r8,80002a34 <flashc_memcpy+0x19c>
80002a1e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80002a22:	91 09       	st.w	r8[0x0],r9

	// Return the initial destination pointer as the standard memcpy function does.
	return dst;
80002a24:	ee f8 ff e0 	ld.w	r8,r7[-32]
}
80002a28:	10 9c       	mov	r12,r8
80002a2a:	2f 5d       	sub	sp,-44
80002a2c:	e3 cd 80 80 	ldm	sp++,r7,pc
80002a30:	80 00       	ld.sh	r0,r0[0x0]
80002a32:	22 10       	sub	r0,33
80002a34:	00 00       	add	r0,r0
80002a36:	00 e8       	st.h	--r0,r8
80002a38:	80 00       	ld.sh	r0,r0[0x0]
80002a3a:	23 1c       	sub	r12,49
80002a3c:	80 00       	ld.sh	r0,r0[0x0]
80002a3e:	22 70       	sub	r0,39
80002a40:	80 00       	ld.sh	r0,r0[0x0]
80002a42:	23 58       	sub	r8,53
80002a44:	80 00       	ld.sh	r0,r0[0x0]
80002a46:	22 d8       	sub	r8,45

80002a48 <gpio_enable_module>:
 * \param size The number of pins in \a gpiomap.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
80002a48:	eb cd 40 80 	pushm	r7,lr
80002a4c:	1a 97       	mov	r7,sp
80002a4e:	20 4d       	sub	sp,16
80002a50:	ef 4c ff f4 	st.w	r7[-12],r12
80002a54:	ef 4b ff f0 	st.w	r7[-16],r11
	uint32_t status = GPIO_SUCCESS;
80002a58:	30 08       	mov	r8,0
80002a5a:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t i;

	for (i = 0; i < size; i++) {
80002a5e:	30 08       	mov	r8,0
80002a60:	ef 48 ff fc 	st.w	r7[-4],r8
80002a64:	c1 c8       	rjmp	80002a9c <gpio_enable_module+0x54>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
80002a66:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a6a:	70 19       	ld.w	r9,r8[0x4]
80002a6c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a70:	70 08       	ld.w	r8,r8[0x0]
80002a72:	12 9b       	mov	r11,r9
80002a74:	10 9c       	mov	r12,r8
80002a76:	f0 1f 00 10 	mcall	80002ab4 <gpio_enable_module+0x6c>
80002a7a:	18 98       	mov	r8,r12
80002a7c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002a80:	f3 e8 10 08 	or	r8,r9,r8
80002a84:	ef 48 ff f8 	st.w	r7[-8],r8
		gpiomap++;
80002a88:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002a8c:	2f 88       	sub	r8,-8
80002a8e:	ef 48 ff f4 	st.w	r7[-12],r8
uint32_t gpio_enable_module(const gpio_map_t gpiomap, uint32_t size)
{
	uint32_t status = GPIO_SUCCESS;
	uint32_t i;

	for (i = 0; i < size; i++) {
80002a92:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002a96:	2f f8       	sub	r8,-1
80002a98:	ef 48 ff fc 	st.w	r7[-4],r8
80002a9c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002aa0:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002aa4:	10 39       	cp.w	r9,r8
80002aa6:	ce 03       	brcs	80002a66 <gpio_enable_module+0x1e>
		status |= gpio_enable_module_pin(gpiomap->pin, gpiomap->function);
		gpiomap++;
	}

	return status;
80002aa8:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
80002aac:	10 9c       	mov	r12,r8
80002aae:	2f cd       	sub	sp,-16
80002ab0:	e3 cd 80 80 	ldm	sp++,r7,pc
80002ab4:	80 00       	ld.sh	r0,r0[0x0]
80002ab6:	2a b8       	sub	r8,-85

80002ab8 <gpio_enable_module_pin>:
 * \param function The pin function.
 *
 * \return \ref GPIO_SUCCESS or \ref GPIO_INVALID_ARGUMENT.
 */
uint32_t gpio_enable_module_pin(uint32_t pin, uint32_t function)
{
80002ab8:	eb cd 40 80 	pushm	r7,lr
80002abc:	1a 97       	mov	r7,sp
80002abe:	20 3d       	sub	sp,12
80002ac0:	ef 4c ff f8 	st.w	r7[-8],r12
80002ac4:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002ac8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002acc:	a5 98       	lsr	r8,0x5
80002ace:	a9 68       	lsl	r8,0x8
80002ad0:	e0 28 f0 00 	sub	r8,61440
80002ad4:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Enable the correct function. */
	switch (function) {
80002ad8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002adc:	58 18       	cp.w	r8,1
80002ade:	c1 e0       	breq	80002b1a <gpio_enable_module_pin+0x62>
80002ae0:	c0 63       	brcs	80002aec <gpio_enable_module_pin+0x34>
80002ae2:	58 28       	cp.w	r8,2
80002ae4:	c3 20       	breq	80002b48 <gpio_enable_module_pin+0x90>
80002ae6:	58 38       	cp.w	r8,3
80002ae8:	c4 70       	breq	80002b76 <gpio_enable_module_pin+0xbe>
80002aea:	c5 d8       	rjmp	80002ba4 <gpio_enable_module_pin+0xec>
	case 0: /* A function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002aec:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002af0:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002af4:	30 19       	mov	r9,1
80002af6:	f2 08 09 48 	lsl	r8,r9,r8
80002afa:	10 99       	mov	r9,r8
80002afc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b00:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002b02:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b06:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b0a:	30 19       	mov	r9,1
80002b0c:	f2 08 09 48 	lsl	r8,r9,r8
80002b10:	10 99       	mov	r9,r8
80002b12:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b16:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b18:	c4 88       	rjmp	80002ba8 <gpio_enable_module_pin+0xf0>

	case 1: /* B function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002b1a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b1e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b22:	30 19       	mov	r9,1
80002b24:	f2 08 09 48 	lsl	r8,r9,r8
80002b28:	10 99       	mov	r9,r8
80002b2a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b2e:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1c = 1 << (pin & 0x1F);
80002b30:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b34:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b38:	30 19       	mov	r9,1
80002b3a:	f2 08 09 48 	lsl	r8,r9,r8
80002b3e:	10 99       	mov	r9,r8
80002b40:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b44:	91 a9       	st.w	r8[0x28],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b46:	c3 18       	rjmp	80002ba8 <gpio_enable_module_pin+0xf0>

	case 2: /* C function. */
		gpio_port->pmr0c = 1 << (pin & 0x1F);
80002b48:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b4c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b50:	30 19       	mov	r9,1
80002b52:	f2 08 09 48 	lsl	r8,r9,r8
80002b56:	10 99       	mov	r9,r8
80002b58:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b5c:	91 69       	st.w	r8[0x18],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002b5e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b62:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b66:	30 19       	mov	r9,1
80002b68:	f2 08 09 48 	lsl	r8,r9,r8
80002b6c:	10 99       	mov	r9,r8
80002b6e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b72:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002b74:	c1 a8       	rjmp	80002ba8 <gpio_enable_module_pin+0xf0>

	case 3: /* D function. */
		gpio_port->pmr0s = 1 << (pin & 0x1F);
80002b76:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b7a:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b7e:	30 19       	mov	r9,1
80002b80:	f2 08 09 48 	lsl	r8,r9,r8
80002b84:	10 99       	mov	r9,r8
80002b86:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002b8a:	91 59       	st.w	r8[0x14],r9
		gpio_port->pmr1s = 1 << (pin & 0x1F);
80002b8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002b90:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002b94:	30 19       	mov	r9,1
80002b96:	f2 08 09 48 	lsl	r8,r9,r8
80002b9a:	10 99       	mov	r9,r8
80002b9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ba0:	91 99       	st.w	r8[0x24],r9
#if (AVR32_GPIO_H_VERSION >= 210)
		gpio_port->pmr2c = 1 << (pin & 0x1F);
#endif
		break;
80002ba2:	c0 38       	rjmp	80002ba8 <gpio_enable_module_pin+0xf0>
		gpio_port->pmr2s = 1 << (pin & 0x1F);
		break;
#endif

	default:
		return GPIO_INVALID_ARGUMENT;
80002ba4:	30 18       	mov	r8,1
80002ba6:	c0 d8       	rjmp	80002bc0 <gpio_enable_module_pin+0x108>
	}

	/* Disable GPIO control. */
	gpio_port->gperc = 1 << (pin & 0x1F);
80002ba8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bac:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002bb0:	30 19       	mov	r9,1
80002bb2:	f2 08 09 48 	lsl	r8,r9,r8
80002bb6:	10 99       	mov	r9,r8
80002bb8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002bbc:	91 29       	st.w	r8[0x8],r9

	return GPIO_SUCCESS;
80002bbe:	30 08       	mov	r8,0
}
80002bc0:	10 9c       	mov	r12,r8
80002bc2:	2f dd       	sub	sp,-12
80002bc4:	e3 cd 80 80 	ldm	sp++,r7,pc

80002bc8 <gpio_configure_pin>:
 *
 * \param pin The pin number.
 * \param flags The configuration.
 */
void gpio_configure_pin(uint32_t pin, uint32_t flags)
{
80002bc8:	eb cd 40 80 	pushm	r7,lr
80002bcc:	1a 97       	mov	r7,sp
80002bce:	20 3d       	sub	sp,12
80002bd0:	ef 4c ff f8 	st.w	r7[-8],r12
80002bd4:	ef 4b ff f4 	st.w	r7[-12],r11
	volatile avr32_gpio_port_t *gpio_port = &AVR32_GPIO.port[pin >> 5];
80002bd8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bdc:	a5 98       	lsr	r8,0x5
80002bde:	a9 68       	lsl	r8,0x8
80002be0:	e0 28 f0 00 	sub	r8,61440
80002be4:	ef 48 ff fc 	st.w	r7[-4],r8
	} else {
		gpio_port->pderc = 1 << (pin & 0x1F);
	}

#endif
	if (flags & GPIO_PULL_UP) {
80002be8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002bec:	e2 18 00 04 	andl	r8,0x4,COH
80002bf0:	c0 e0       	breq	80002c0c <gpio_configure_pin+0x44>
		gpio_port->puers = 1 << (pin & 0x1F);
80002bf2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002bf6:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002bfa:	30 19       	mov	r9,1
80002bfc:	f2 08 09 48 	lsl	r8,r9,r8
80002c00:	10 99       	mov	r9,r8
80002c02:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c06:	f1 49 00 74 	st.w	r8[116],r9
80002c0a:	c0 d8       	rjmp	80002c24 <gpio_configure_pin+0x5c>
	} else {
		gpio_port->puerc = 1 << (pin & 0x1F);
80002c0c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c10:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c14:	30 19       	mov	r9,1
80002c16:	f2 08 09 48 	lsl	r8,r9,r8
80002c1a:	10 99       	mov	r9,r8
80002c1c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c20:	f1 49 00 78 	st.w	r8[120],r9
	}

#endif

	/* Select interrupt level for group */
	if (flags & GPIO_INTERRUPT) {
80002c24:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c28:	e2 18 00 80 	andl	r8,0x80,COH
80002c2c:	c5 a0       	breq	80002ce0 <gpio_configure_pin+0x118>
		if (flags & GPIO_BOTHEDGES) {
80002c2e:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c32:	e2 18 01 80 	andl	r8,0x180,COH
80002c36:	c1 a0       	breq	80002c6a <gpio_configure_pin+0xa2>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80002c38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c3c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c40:	30 19       	mov	r9,1
80002c42:	f2 08 09 48 	lsl	r8,r9,r8
80002c46:	10 99       	mov	r9,r8
80002c48:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c4c:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
80002c50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c54:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c58:	30 19       	mov	r9,1
80002c5a:	f2 08 09 48 	lsl	r8,r9,r8
80002c5e:	10 99       	mov	r9,r8
80002c60:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c64:	f1 49 00 b8 	st.w	r8[184],r9
80002c68:	c3 c8       	rjmp	80002ce0 <gpio_configure_pin+0x118>
		} else if (flags & GPIO_RISING) {
80002c6a:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002c6e:	e2 18 02 80 	andl	r8,0x280,COH
80002c72:	c1 a0       	breq	80002ca6 <gpio_configure_pin+0xde>
			gpio_port->imr0s = 1 << (pin & 0x1F);
80002c74:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c78:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c7c:	30 19       	mov	r9,1
80002c7e:	f2 08 09 48 	lsl	r8,r9,r8
80002c82:	10 99       	mov	r9,r8
80002c84:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002c88:	f1 49 00 a4 	st.w	r8[164],r9
			gpio_port->imr1c = 1 << (pin & 0x1F);
80002c8c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002c90:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002c94:	30 19       	mov	r9,1
80002c96:	f2 08 09 48 	lsl	r8,r9,r8
80002c9a:	10 99       	mov	r9,r8
80002c9c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002ca0:	f1 49 00 b8 	st.w	r8[184],r9
80002ca4:	c1 e8       	rjmp	80002ce0 <gpio_configure_pin+0x118>
		} else if (flags & GPIO_FALLING) {
80002ca6:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002caa:	e2 18 03 80 	andl	r8,0x380,COH
80002cae:	c1 90       	breq	80002ce0 <gpio_configure_pin+0x118>
			gpio_port->imr0c = 1 << (pin & 0x1F);
80002cb0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cb4:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002cb8:	30 19       	mov	r9,1
80002cba:	f2 08 09 48 	lsl	r8,r9,r8
80002cbe:	10 99       	mov	r9,r8
80002cc0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cc4:	f1 49 00 a8 	st.w	r8[168],r9
			gpio_port->imr1s = 1 << (pin & 0x1F);
80002cc8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002ccc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002cd0:	30 19       	mov	r9,1
80002cd2:	f2 08 09 48 	lsl	r8,r9,r8
80002cd6:	10 99       	mov	r9,r8
80002cd8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002cdc:	f1 49 00 b4 	st.w	r8[180],r9
		}
	}

	/* Select direction and initial pin state */
	if (flags & GPIO_DIR_OUTPUT) {
80002ce0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ce4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80002ce8:	5c 58       	castu.b	r8
80002cea:	c2 c0       	breq	80002d42 <gpio_configure_pin+0x17a>
		if (flags & GPIO_INIT_HIGH) {
80002cec:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002cf0:	e2 18 00 02 	andl	r8,0x2,COH
80002cf4:	c0 e0       	breq	80002d10 <gpio_configure_pin+0x148>
			gpio_port->ovrs = 1 << (pin & 0x1F);
80002cf6:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002cfa:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002cfe:	30 19       	mov	r9,1
80002d00:	f2 08 09 48 	lsl	r8,r9,r8
80002d04:	10 99       	mov	r9,r8
80002d06:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d0a:	f1 49 00 54 	st.w	r8[84],r9
80002d0e:	c0 d8       	rjmp	80002d28 <gpio_configure_pin+0x160>
		} else {
			gpio_port->ovrc = 1 << (pin & 0x1F);
80002d10:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d14:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002d18:	30 19       	mov	r9,1
80002d1a:	f2 08 09 48 	lsl	r8,r9,r8
80002d1e:	10 99       	mov	r9,r8
80002d20:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d24:	f1 49 00 58 	st.w	r8[88],r9
		}

		gpio_port->oders = 1 << (pin & 0x1F);
80002d28:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d2c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002d30:	30 19       	mov	r9,1
80002d32:	f2 08 09 48 	lsl	r8,r9,r8
80002d36:	10 99       	mov	r9,r8
80002d38:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d3c:	f1 49 00 44 	st.w	r8[68],r9
80002d40:	c0 d8       	rjmp	80002d5a <gpio_configure_pin+0x192>
	} else {
		gpio_port->oderc = 1 << (pin & 0x1F);
80002d42:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d46:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002d4a:	30 19       	mov	r9,1
80002d4c:	f2 08 09 48 	lsl	r8,r9,r8
80002d50:	10 99       	mov	r9,r8
80002d52:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d56:	f1 49 00 48 	st.w	r8[72],r9
	}

	/* Enable GPIO */
	gpio_port->gpers = 1 << (pin & 0x1F);
80002d5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002d5e:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002d62:	30 19       	mov	r9,1
80002d64:	f2 08 09 48 	lsl	r8,r9,r8
80002d68:	10 99       	mov	r9,r8
80002d6a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002d6e:	91 19       	st.w	r8[0x4],r9
}
80002d70:	2f dd       	sub	sp,-12
80002d72:	e3 cd 80 80 	ldm	sp++,r7,pc

80002d76 <_unhandled_interrupt>:
__attribute__((__interrupt__))
#elif (defined __ICCAVR32__)
__interrupt
#endif
static void _unhandled_interrupt(void)
{
80002d76:	eb cd 40 80 	pushm	r7,lr
80002d7a:	1a 97       	mov	r7,sp
	// Catch unregistered interrupts.
	while (true);
80002d7c:	c0 08       	rjmp	80002d7c <_unhandled_interrupt+0x6>
80002d7e:	d7 03       	nop

80002d80 <_get_interrupt_handler>:
 *
 * \return Interrupt handler to execute.
 */
__int_handler _get_interrupt_handler(uint32_t int_level);
__int_handler _get_interrupt_handler(uint32_t int_level)
{
80002d80:	eb cd 40 80 	pushm	r7,lr
80002d84:	1a 97       	mov	r7,sp
80002d86:	20 3d       	sub	sp,12
80002d88:	ef 4c ff f4 	st.w	r7[-12],r12
	/* ICR3 is mapped first, ICR0 last.
	Code in exception.S puts int_level in R12 which is used by the compiler
	to pass a single argument to a function. */
	uint32_t int_grp = AVR32_INTC.icr[AVR32_INTC_INT3 - int_level];
80002d8c:	fe 78 08 00 	mov	r8,-63488
80002d90:	ee f9 ff f4 	ld.w	r9,r7[-12]
80002d94:	f2 09 11 03 	rsub	r9,r9,3
80002d98:	28 09       	sub	r9,-128
80002d9a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80002d9e:	ef 48 ff f8 	st.w	r7[-8],r8
	uint32_t int_req = AVR32_INTC.irr[int_grp];
80002da2:	fe 78 08 00 	mov	r8,-63488
80002da6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002daa:	2c 09       	sub	r9,-64
80002dac:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80002db0:	ef 48 ff fc 	st.w	r7[-4],r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002db4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002db8:	58 08       	cp.w	r8,0
80002dba:	c1 30       	breq	80002de0 <_get_interrupt_handler+0x60>
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002dbc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002dc0:	48 b8       	lddpc	r8,80002dec <_get_interrupt_handler+0x6c>
80002dc2:	a1 79       	lsl	r9,0x1
80002dc4:	2f f9       	sub	r9,-1
80002dc6:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002dca:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002dce:	f0 08 12 00 	clz	r8,r8
80002dd2:	f0 08 11 1f 	rsub	r8,r8,31
			- clz(int_req) - 1]
80002dd6:	a3 68       	lsl	r8,0x2
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
		? _int_handler_table[int_grp]._int_line_handler_table[32
80002dd8:	f2 08 00 08 	add	r8,r9,r8
	exception.S will provide the interrupt handler with a clean interrupt
	stack frame, with nothing more pushed onto the stack. The interrupt
	handler must manage the `rete' instruction, which can be done using
	pure assembly, inline assembly or the `__attribute__((__interrupt__))'
	C function attribute.*/
	return (int_req)
80002ddc:	70 08       	ld.w	r8,r8[0x0]
80002dde:	c0 28       	rjmp	80002de2 <_get_interrupt_handler+0x62>
80002de0:	30 08       	mov	r8,0
		? _int_handler_table[int_grp]._int_line_handler_table[32
			- clz(int_req) - 1]
		: NULL;
}
80002de2:	10 9c       	mov	r12,r8
80002de4:	2f dd       	sub	sp,-12
80002de6:	e3 cd 80 80 	ldm	sp++,r7,pc
80002dea:	00 00       	add	r0,r0
80002dec:	80 00       	ld.sh	r0,r0[0x0]
80002dee:	96 20       	ld.sh	r0,r11[0x4]

80002df0 <INTC_init_evba>:
 * \internal
 * \brief Init EVBA address. This operation may or may not have been done by the
 * C startup process.
 */
static __inline__ void INTC_init_evba(void)
{
80002df0:	eb cd 40 80 	pushm	r7,lr
80002df4:	1a 97       	mov	r7,sp
  Set_system_register(AVR32_EVBA, (int32_t)&_evba );
80002df6:	48 38       	lddpc	r8,80002e00 <INTC_init_evba+0x10>
80002df8:	e3 b8 00 01 	mtsr	0x4,r8
}
80002dfc:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e00:	80 00       	ld.sh	r0,r0[0x0]
80002e02:	94 00       	ld.sh	r0,r10[0x0]

80002e04 <INTC_init_interrupts>:
/**
 * \brief Initializes the hardware interrupt controller driver.
 *
 */
void INTC_init_interrupts(void)
{
80002e04:	eb cd 40 80 	pushm	r7,lr
80002e08:	1a 97       	mov	r7,sp
80002e0a:	20 2d       	sub	sp,8
	uint32_t int_grp, int_req;

	INTC_init_evba();
80002e0c:	f0 1f 00 1f 	mcall	80002e88 <INTC_init_interrupts+0x84>

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002e10:	30 08       	mov	r8,0
80002e12:	ef 48 ff f8 	st.w	r7[-8],r8
80002e16:	c3 18       	rjmp	80002e78 <INTC_init_interrupts+0x74>
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002e18:	30 08       	mov	r8,0
80002e1a:	ef 48 ff fc 	st.w	r7[-4],r8
80002e1e:	c1 48       	rjmp	80002e46 <INTC_init_interrupts+0x42>
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
				._int_line_handler_table[int_req]
80002e20:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e24:	49 a8       	lddpc	r8,80002e8c <INTC_init_interrupts+0x88>
80002e26:	a1 79       	lsl	r9,0x1
80002e28:	2f f9       	sub	r9,-1
80002e2a:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002e2e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e32:	a3 68       	lsl	r8,0x2
80002e34:	f2 08 00 08 	add	r8,r9,r8
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
		{
			/* Assign _unhandled_interrupt as the default interrupt
			handler. */
			_int_handler_table[int_grp]
80002e38:	49 69       	lddpc	r9,80002e90 <INTC_init_interrupts+0x8c>
80002e3a:	91 09       	st.w	r8[0x0],r9
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
			int_req++)
80002e3c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e40:	2f f8       	sub	r8,-1
80002e42:	ef 48 ff fc 	st.w	r7[-4],r8
	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
			int_req < _int_handler_table[int_grp].num_irqs;
80002e46:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e4a:	49 18       	lddpc	r8,80002e8c <INTC_init_interrupts+0x88>
80002e4c:	f0 09 03 39 	ld.w	r9,r8[r9<<0x3]

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
	{
		// For all interrupt request lines of each group,
		for (int_req = 0;
80002e50:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002e54:	10 39       	cp.w	r9,r8
80002e56:	fe 9b ff e5 	brhi	80002e20 <INTC_init_interrupts+0x1c>

		/* Set the interrupt group priority register to its default
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002e5a:	fe 78 08 00 	mov	r8,-63488
80002e5e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002e62:	48 db       	lddpc	r11,80002e94 <INTC_init_interrupts+0x90>
80002e64:	48 da       	lddpc	r10,80002e98 <INTC_init_interrupts+0x94>
80002e66:	f6 0a 01 0a 	sub	r10,r11,r10
80002e6a:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	uint32_t int_grp, int_req;

	INTC_init_evba();

	// For all interrupt groups,
	for (int_grp = 0; int_grp < AVR32_INTC_NUM_INT_GRPS; int_grp++)
80002e6e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e72:	2f f8       	sub	r8,-1
80002e74:	ef 48 ff f8 	st.w	r7[-8],r8
80002e78:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002e7c:	59 18       	cp.w	r8,17
80002e7e:	fe 98 ff cd 	brls	80002e18 <INTC_init_interrupts+0x14>
		value.
		By default, all interrupt groups are linked to the interrupt
		priority level 0 and to the interrupt vector _int0. */
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
	}
}
80002e82:	2f ed       	sub	sp,-8
80002e84:	e3 cd 80 80 	ldm	sp++,r7,pc
80002e88:	80 00       	ld.sh	r0,r0[0x0]
80002e8a:	2d f0       	sub	r0,-33
80002e8c:	80 00       	ld.sh	r0,r0[0x0]
80002e8e:	96 20       	ld.sh	r0,r11[0x4]
80002e90:	80 00       	ld.sh	r0,r0[0x0]
80002e92:	2d 76       	sub	r6,-41
80002e94:	80 00       	ld.sh	r0,r0[0x0]
80002e96:	95 04       	st.w	r10[0x0],r4
80002e98:	80 00       	ld.sh	r0,r0[0x0]
80002e9a:	94 00       	ld.sh	r0,r10[0x0]

80002e9c <INTC_register_interrupt>:
 *          be effective.
 *
 */
void INTC_register_interrupt(__int_handler handler, uint32_t irq,
	uint32_t int_level)
{
80002e9c:	eb cd 40 80 	pushm	r7,lr
80002ea0:	1a 97       	mov	r7,sp
80002ea2:	20 4d       	sub	sp,16
80002ea4:	ef 4c ff f8 	st.w	r7[-8],r12
80002ea8:	ef 4b ff f4 	st.w	r7[-12],r11
80002eac:	ef 4a ff f0 	st.w	r7[-16],r10
	// Determine the group of the IRQ.
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;
80002eb0:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002eb4:	a5 98       	lsr	r8,0x5
80002eb6:	ef 48 ff fc 	st.w	r7[-4],r8

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
		._int_line_handler_table[irq % AVR32_INTC_MAX_NUM_IRQS_PER_GRP]
80002eba:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002ebe:	4a 78       	lddpc	r8,80002f58 <INTC_register_interrupt+0xbc>
80002ec0:	a1 79       	lsl	r9,0x1
80002ec2:	2f f9       	sub	r9,-1
80002ec4:	f0 09 03 29 	ld.w	r9,r8[r9<<0x2]
80002ec8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ecc:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80002ed0:	a3 68       	lsl	r8,0x2
80002ed2:	f2 08 00 08 	add	r8,r9,r8
	uint32_t int_grp = irq / AVR32_INTC_MAX_NUM_IRQS_PER_GRP;

	/* Store in _int_line_handler_table_x the pointer to the interrupt
	handler, so that _get_interrupt_handler can retrieve it when the
	interrupt is vectored. */
	_int_handler_table[int_grp]
80002ed6:	ee f9 ff f8 	ld.w	r9,r7[-8]
80002eda:	91 09       	st.w	r8[0x0],r9
	/* Program the corresponding IPRX register to set the interrupt priority
	level and the interrupt vector offset that will be fetched by the core
	interrupt system.
	NOTE: The _intx functions are intermediate assembly functions between
	the core interrupt system and the user interrupt handler. */
	if (int_level == AVR32_INTC_INT0) {
80002edc:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002ee0:	58 08       	cp.w	r8,0
80002ee2:	c0 c1       	brne	80002efa <INTC_register_interrupt+0x5e>
		AVR32_INTC.ipr[int_grp] = IPR_INT0;
80002ee4:	fe 78 08 00 	mov	r8,-63488
80002ee8:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002eec:	49 cb       	lddpc	r11,80002f5c <INTC_register_interrupt+0xc0>
80002eee:	49 da       	lddpc	r10,80002f60 <INTC_register_interrupt+0xc4>
80002ef0:	f6 0a 01 0a 	sub	r10,r11,r10
80002ef4:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002ef8:	c2 d8       	rjmp	80002f52 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT1) {
80002efa:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002efe:	58 18       	cp.w	r8,1
80002f00:	c0 d1       	brne	80002f1a <INTC_register_interrupt+0x7e>
		AVR32_INTC.ipr[int_grp] = IPR_INT1;
80002f02:	fe 78 08 00 	mov	r8,-63488
80002f06:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002f0a:	49 7b       	lddpc	r11,80002f64 <INTC_register_interrupt+0xc8>
80002f0c:	49 5a       	lddpc	r10,80002f60 <INTC_register_interrupt+0xc4>
80002f0e:	f6 0a 01 0a 	sub	r10,r11,r10
80002f12:	bf aa       	sbr	r10,0x1e
80002f14:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002f18:	c1 d8       	rjmp	80002f52 <INTC_register_interrupt+0xb6>
	} else if (int_level == AVR32_INTC_INT2) {
80002f1a:	ee f8 ff f0 	ld.w	r8,r7[-16]
80002f1e:	58 28       	cp.w	r8,2
80002f20:	c0 d1       	brne	80002f3a <INTC_register_interrupt+0x9e>
		AVR32_INTC.ipr[int_grp] = IPR_INT2;
80002f22:	fe 78 08 00 	mov	r8,-63488
80002f26:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002f2a:	49 0b       	lddpc	r11,80002f68 <INTC_register_interrupt+0xcc>
80002f2c:	48 da       	lddpc	r10,80002f60 <INTC_register_interrupt+0xc4>
80002f2e:	f6 0a 01 0a 	sub	r10,r11,r10
80002f32:	bf ba       	sbr	r10,0x1f
80002f34:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
80002f38:	c0 d8       	rjmp	80002f52 <INTC_register_interrupt+0xb6>
	} else {
		AVR32_INTC.ipr[int_grp] = IPR_INT3;
80002f3a:	fe 78 08 00 	mov	r8,-63488
80002f3e:	ee f9 ff fc 	ld.w	r9,r7[-4]
80002f42:	48 bb       	lddpc	r11,80002f6c <INTC_register_interrupt+0xd0>
80002f44:	48 7a       	lddpc	r10,80002f60 <INTC_register_interrupt+0xc4>
80002f46:	f6 0a 01 0a 	sub	r10,r11,r10
80002f4a:	ea 1a c0 00 	orh	r10,0xc000
80002f4e:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
	}
}
80002f52:	2f cd       	sub	sp,-16
80002f54:	e3 cd 80 80 	ldm	sp++,r7,pc
80002f58:	80 00       	ld.sh	r0,r0[0x0]
80002f5a:	96 20       	ld.sh	r0,r11[0x4]
80002f5c:	80 00       	ld.sh	r0,r0[0x0]
80002f5e:	95 04       	st.w	r10[0x0],r4
80002f60:	80 00       	ld.sh	r0,r0[0x0]
80002f62:	94 00       	ld.sh	r0,r10[0x0]
80002f64:	80 00       	ld.sh	r0,r0[0x0]
80002f66:	95 12       	st.w	r10[0x4],r2
80002f68:	80 00       	ld.sh	r0,r0[0x0]
80002f6a:	95 20       	st.w	r10[0x8],r0
80002f6c:	80 00       	ld.sh	r0,r0[0x0]
80002f6e:	95 2e       	st.w	r10[0x8],lr

80002f70 <usart_write_char>:
  return USART_SUCCESS;
}


int usart_write_char(volatile avr32_usart_t *usart, int c)
{
80002f70:	eb cd 40 80 	pushm	r7,lr
80002f74:	1a 97       	mov	r7,sp
80002f76:	20 3d       	sub	sp,12
80002f78:	ef 4c ff f8 	st.w	r7[-8],r12
80002f7c:	ef 4b ff f4 	st.w	r7[-12],r11
80002f80:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002f84:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Transmit Holding Register is free, otherwise \c 0.
 */
__always_inline static int usart_tx_ready(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_TXRDY_MASK) != 0;
80002f88:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002f8c:	70 58       	ld.w	r8,r8[0x14]
80002f8e:	e2 18 00 02 	andl	r8,0x2,COH
80002f92:	5f 18       	srne	r8
  if (usart_tx_ready(usart))
80002f94:	58 08       	cp.w	r8,0
80002f96:	c0 a0       	breq	80002faa <usart_write_char+0x3a>
  {
    usart->thr = (c << AVR32_USART_THR_TXCHR_OFFSET) & AVR32_USART_THR_TXCHR_MASK;
80002f98:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002f9c:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002fa0:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002fa4:	91 79       	st.w	r8[0x1c],r9
    return USART_SUCCESS;
80002fa6:	30 08       	mov	r8,0
80002fa8:	c0 28       	rjmp	80002fac <usart_write_char+0x3c>
  }
  else
    return USART_TX_BUSY;
80002faa:	30 28       	mov	r8,2
}
80002fac:	10 9c       	mov	r12,r8
80002fae:	2f dd       	sub	sp,-12
80002fb0:	e3 cd 80 80 	ldm	sp++,r7,pc

80002fb4 <usart_read_char>:
  return USART_SUCCESS;
}


int usart_read_char(volatile avr32_usart_t *usart, int *c)
{
80002fb4:	eb cd 40 80 	pushm	r7,lr
80002fb8:	1a 97       	mov	r7,sp
80002fba:	20 3d       	sub	sp,12
80002fbc:	ef 4c ff f8 	st.w	r7[-8],r12
80002fc0:	ef 4b ff f4 	st.w	r7[-12],r11
  // Check for errors: frame, parity and overrun. In RS485 mode, a parity error
  // would mean that an address char has been received.
  if (usart->csr & (AVR32_USART_CSR_OVRE_MASK |
80002fc4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002fc8:	70 58       	ld.w	r8,r8[0x14]
80002fca:	e2 18 00 e0 	andl	r8,0xe0,COH
80002fce:	c0 30       	breq	80002fd4 <usart_read_char+0x20>
                    AVR32_USART_CSR_FRAME_MASK |
                    AVR32_USART_CSR_PARE_MASK))
    return USART_RX_ERROR;
80002fd0:	30 48       	mov	r8,4
80002fd2:	c1 68       	rjmp	80002ffe <usart_read_char+0x4a>
80002fd4:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002fd8:	ef 48 ff fc 	st.w	r7[-4],r8
 *
 * \return \c 1 if the USART Receive Holding Register is full, otherwise \c 0.
 */
__always_inline static int usart_test_hit(volatile avr32_usart_t *usart)
{
  return (usart->csr & AVR32_USART_CSR_RXRDY_MASK) != 0;
80002fdc:	ee f8 ff fc 	ld.w	r8,r7[-4]
80002fe0:	70 58       	ld.w	r8,r8[0x14]
80002fe2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1

  // No error; if we really did receive a char, read it and return SUCCESS.
  if (usart_test_hit(usart))
80002fe6:	c0 b0       	breq	80002ffc <usart_read_char+0x48>
  {
    *c = (usart->rhr & AVR32_USART_RHR_RXCHR_MASK) >> AVR32_USART_RHR_RXCHR_OFFSET;
80002fe8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80002fec:	70 68       	ld.w	r8,r8[0x18]
80002fee:	f3 d8 c0 09 	bfextu	r9,r8,0x0,0x9
80002ff2:	ee f8 ff f4 	ld.w	r8,r7[-12]
80002ff6:	91 09       	st.w	r8[0x0],r9
    return USART_SUCCESS;
80002ff8:	30 08       	mov	r8,0
80002ffa:	c0 28       	rjmp	80002ffe <usart_read_char+0x4a>
  }
  else
    return USART_RX_EMPTY;
80002ffc:	30 38       	mov	r8,3
}
80002ffe:	10 9c       	mov	r12,r8
80003000:	2f dd       	sub	sp,-12
80003002:	e3 cd 80 80 	ldm	sp++,r7,pc

80003006 <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80003006:	eb cd 40 80 	pushm	r7,lr
8000300a:	1a 97       	mov	r7,sp
8000300c:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
8000300e:	e1 b8 00 00 	mfsr	r8,0x0
80003012:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80003016:	d3 03       	ssrf	0x10

	return flags;
80003018:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
8000301c:	10 9c       	mov	r12,r8
8000301e:	2f fd       	sub	sp,-4
80003020:	e3 cd 80 80 	ldm	sp++,r7,pc

80003024 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80003024:	eb cd 40 80 	pushm	r7,lr
80003028:	1a 97       	mov	r7,sp
8000302a:	20 1d       	sub	sp,4
8000302c:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80003030:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003034:	e6 18 00 01 	andh	r8,0x1,COH
80003038:	5f 08       	sreq	r8
8000303a:	5c 58       	castu.b	r8
}
8000303c:	10 9c       	mov	r12,r8
8000303e:	2f fd       	sub	sp,-4
80003040:	e3 cd 80 80 	ldm	sp++,r7,pc

80003044 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80003044:	eb cd 40 80 	pushm	r7,lr
80003048:	1a 97       	mov	r7,sp
8000304a:	20 1d       	sub	sp,4
8000304c:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80003050:	ee fc ff fc 	ld.w	r12,r7[-4]
80003054:	f0 1f 00 05 	mcall	80003068 <cpu_irq_restore+0x24>
80003058:	18 98       	mov	r8,r12
8000305a:	58 08       	cp.w	r8,0
8000305c:	c0 20       	breq	80003060 <cpu_irq_restore+0x1c>
      cpu_irq_enable();
8000305e:	d5 03       	csrf	0x10
   }

	barrier();
}
80003060:	2f fd       	sub	sp,-4
80003062:	e3 cd 80 80 	ldm	sp++,r7,pc
80003066:	00 00       	add	r0,r0
80003068:	80 00       	ld.sh	r0,r0[0x0]
8000306a:	30 24       	mov	r4,2

8000306c <sleepmgr_lock_mode>:
 * not put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to lock.
 */
static inline void sleepmgr_lock_mode(enum sleepmgr_mode mode)
{
8000306c:	eb cd 40 80 	pushm	r7,lr
80003070:	1a 97       	mov	r7,sp
80003072:	20 2d       	sub	sp,8
80003074:	ef 4c ff f8 	st.w	r7[-8],r12
	irqflags_t flags;

	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();
80003078:	f0 1f 00 0b 	mcall	800030a4 <sleepmgr_lock_mode+0x38>
8000307c:	18 98       	mov	r8,r12
8000307e:	ef 48 ff fc 	st.w	r7[-4],r8

	++sleepmgr_locks[mode];
80003082:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003086:	48 99       	lddpc	r9,800030a8 <sleepmgr_lock_mode+0x3c>
80003088:	f2 08 07 09 	ld.ub	r9,r9[r8]
8000308c:	2f f9       	sub	r9,-1
8000308e:	5c 59       	castu.b	r9
80003090:	48 6a       	lddpc	r10,800030a8 <sleepmgr_lock_mode+0x3c>
80003092:	f4 08 0b 09 	st.b	r10[r8],r9

	// Leave the critical section
	cpu_irq_restore(flags);
80003096:	ee fc ff fc 	ld.w	r12,r7[-4]
8000309a:	f0 1f 00 05 	mcall	800030ac <sleepmgr_lock_mode+0x40>
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
8000309e:	2f ed       	sub	sp,-8
800030a0:	e3 cd 80 80 	ldm	sp++,r7,pc
800030a4:	80 00       	ld.sh	r0,r0[0x0]
800030a6:	30 06       	mov	r6,0
800030a8:	00 00       	add	r0,r0
800030aa:	46 60       	lddsp	r0,sp[0x198]
800030ac:	80 00       	ld.sh	r0,r0[0x0]
800030ae:	30 44       	mov	r4,4

800030b0 <sleepmgr_unlock_mode>:
 * manager can put the device to sleep in the deeper sleep modes.
 *
 * \param mode Sleep mode to unlock.
 */
static inline void sleepmgr_unlock_mode(enum sleepmgr_mode mode)
{
800030b0:	eb cd 40 80 	pushm	r7,lr
800030b4:	1a 97       	mov	r7,sp
800030b6:	20 2d       	sub	sp,8
800030b8:	ef 4c ff f8 	st.w	r7[-8],r12
	irqflags_t flags;

	Assert(sleepmgr_locks[mode]);

	// Enter a critical section
	flags = cpu_irq_save();
800030bc:	f0 1f 00 0b 	mcall	800030e8 <sleepmgr_unlock_mode+0x38>
800030c0:	18 98       	mov	r8,r12
800030c2:	ef 48 ff fc 	st.w	r7[-4],r8

	--sleepmgr_locks[mode];
800030c6:	ee f8 ff f8 	ld.w	r8,r7[-8]
800030ca:	48 99       	lddpc	r9,800030ec <sleepmgr_unlock_mode+0x3c>
800030cc:	f2 08 07 09 	ld.ub	r9,r9[r8]
800030d0:	20 19       	sub	r9,1
800030d2:	5c 59       	castu.b	r9
800030d4:	48 6a       	lddpc	r10,800030ec <sleepmgr_unlock_mode+0x3c>
800030d6:	f4 08 0b 09 	st.b	r10[r8],r9

	// Leave the critical section
	cpu_irq_restore(flags);
800030da:	ee fc ff fc 	ld.w	r12,r7[-4]
800030de:	f0 1f 00 05 	mcall	800030f0 <sleepmgr_unlock_mode+0x40>
#else
	UNUSED(mode);
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
800030e2:	2f ed       	sub	sp,-8
800030e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800030e8:	80 00       	ld.sh	r0,r0[0x0]
800030ea:	30 06       	mov	r6,0
800030ec:	00 00       	add	r0,r0
800030ee:	46 60       	lddsp	r0,sp[0x198]
800030f0:	80 00       	ld.sh	r0,r0[0x0]
800030f2:	30 44       	mov	r4,4

800030f4 <udd_sleep_mode>:
/*! \brief Authorize or not the CPU powerdown mode
 *
 * \param b_enable   true to authorize powerdown mode
 */
static void udd_sleep_mode(bool b_idle)
{
800030f4:	eb cd 40 80 	pushm	r7,lr
800030f8:	1a 97       	mov	r7,sp
800030fa:	20 1d       	sub	sp,4
800030fc:	18 98       	mov	r8,r12
800030fe:	ef 68 ff fc 	st.b	r7[-4],r8
	if (!b_idle && udd_b_idle) {
80003102:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80003106:	ec 18 00 01 	eorl	r8,0x1
8000310a:	5c 58       	castu.b	r8
8000310c:	c0 80       	breq	8000311c <udd_sleep_mode+0x28>
8000310e:	48 f8       	lddpc	r8,80003148 <udd_sleep_mode+0x54>
80003110:	11 88       	ld.ub	r8,r8[0x0]
80003112:	58 08       	cp.w	r8,0
80003114:	c0 40       	breq	8000311c <udd_sleep_mode+0x28>
		sleepmgr_unlock_mode(USBB_SLEEP_MODE_USB_IDLE);
80003116:	30 1c       	mov	r12,1
80003118:	f0 1f 00 0d 	mcall	8000314c <udd_sleep_mode+0x58>
	}
	if (b_idle && !udd_b_idle) {
8000311c:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80003120:	30 08       	mov	r8,0
80003122:	f0 09 18 00 	cp.b	r9,r8
80003126:	c0 a0       	breq	8000313a <udd_sleep_mode+0x46>
80003128:	48 88       	lddpc	r8,80003148 <udd_sleep_mode+0x54>
8000312a:	11 88       	ld.ub	r8,r8[0x0]
8000312c:	ec 18 00 01 	eorl	r8,0x1
80003130:	5c 58       	castu.b	r8
80003132:	c0 40       	breq	8000313a <udd_sleep_mode+0x46>
		sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_IDLE);
80003134:	30 1c       	mov	r12,1
80003136:	f0 1f 00 07 	mcall	80003150 <udd_sleep_mode+0x5c>
	}
	udd_b_idle = b_idle;
8000313a:	48 49       	lddpc	r9,80003148 <udd_sleep_mode+0x54>
8000313c:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80003140:	b2 88       	st.b	r9[0x0],r8
}
80003142:	2f fd       	sub	sp,-4
80003144:	e3 cd 80 80 	ldm	sp++,r7,pc
80003148:	00 00       	add	r0,r0
8000314a:	01 90       	ld.ub	r0,r0[0x1]
8000314c:	80 00       	ld.sh	r0,r0[0x0]
8000314e:	30 b0       	mov	r0,11
80003150:	80 00       	ld.sh	r0,r0[0x0]
80003152:	30 6c       	mov	r12,6

80003154 <udd_interrupt>:
ISR_FREERTOS(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#  else
ISR(udd_interrupt, AVR32_USBB_IRQ_GROUP, UDD_USB_INT_LEVEL)
#  endif
#endif
{
80003154:	eb cd 40 80 	pushm	r7,lr
80003158:	1a 97       	mov	r7,sp
	if (Is_udd_sof()) {
8000315a:	fe 68 00 04 	mov	r8,-131068
8000315e:	70 08       	ld.w	r8,r8[0x0]
80003160:	e2 18 00 04 	andl	r8,0x4,COH
80003164:	c1 10       	breq	80003186 <udd_interrupt+0x32>
		udd_ack_sof();
80003166:	fe 68 00 08 	mov	r8,-131064
8000316a:	30 49       	mov	r9,4
8000316c:	91 09       	st.w	r8[0x0],r9
		if (Is_udd_full_speed_mode()) {
8000316e:	fe 68 08 04 	mov	r8,-129020
80003172:	70 08       	ld.w	r8,r8[0x0]
80003174:	e2 18 30 00 	andl	r8,0x3000,COH
80003178:	ad 88       	lsr	r8,0xc
8000317a:	c0 31       	brne	80003180 <udd_interrupt+0x2c>
			udc_sof_notify();
8000317c:	f0 1f 00 5d 	mcall	800032f0 <udd_interrupt+0x19c>
		}
#ifdef UDC_SOF_EVENT
		UDC_SOF_EVENT();
80003180:	f0 1f 00 5d 	mcall	800032f4 <udd_interrupt+0x1a0>
#endif
		goto udd_interrupt_end;
80003184:	ca e8       	rjmp	800032e0 <udd_interrupt+0x18c>
	}
	if (Is_udd_msof()) {
80003186:	fe 68 00 04 	mov	r8,-131068
8000318a:	70 08       	ld.w	r8,r8[0x0]
8000318c:	e2 18 00 02 	andl	r8,0x2,COH
80003190:	c0 80       	breq	800031a0 <udd_interrupt+0x4c>
		udd_ack_msof();
80003192:	fe 68 00 08 	mov	r8,-131064
80003196:	30 29       	mov	r9,2
80003198:	91 09       	st.w	r8[0x0],r9
		udc_sof_notify();
8000319a:	f0 1f 00 56 	mcall	800032f0 <udd_interrupt+0x19c>
		goto udd_interrupt_end;
8000319e:	ca 18       	rjmp	800032e0 <udd_interrupt+0x18c>
	}

	if (udd_ctrl_interrupt())
800031a0:	f0 1f 00 56 	mcall	800032f8 <udd_interrupt+0x1a4>
800031a4:	18 98       	mov	r8,r12
800031a6:	58 08       	cp.w	r8,0
800031a8:	e0 81 00 99 	brne	800032da <udd_interrupt+0x186>
		goto udd_interrupt_end; // Interrupt acked by control endpoint managed

#if (0 != USB_DEVICE_MAX_EP)
	if (udd_ep_interrupt())
800031ac:	f0 1f 00 54 	mcall	800032fc <udd_interrupt+0x1a8>
800031b0:	18 98       	mov	r8,r12
800031b2:	58 08       	cp.w	r8,0
800031b4:	e0 81 00 95 	brne	800032de <udd_interrupt+0x18a>
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
#endif

	// USB bus reset detection
	if (Is_udd_reset()) {
800031b8:	fe 68 00 04 	mov	r8,-131068
800031bc:	70 08       	ld.w	r8,r8[0x0]
800031be:	e2 18 00 08 	andl	r8,0x8,COH
800031c2:	c0 e0       	breq	800031de <udd_interrupt+0x8a>
		udd_ack_reset();
800031c4:	fe 68 00 08 	mov	r8,-131064
800031c8:	30 89       	mov	r9,8
800031ca:	91 09       	st.w	r8[0x0],r9
		// Abort all jobs on-going
#if (USB_DEVICE_MAX_EP != 0)
		udd_ep_job_table_kill();
800031cc:	f0 1f 00 4d 	mcall	80003300 <udd_interrupt+0x1ac>
#endif
		// Reset USB Device Stack Core
		udc_reset();
800031d0:	f0 1f 00 4d 	mcall	80003304 <udd_interrupt+0x1b0>
		// Reset endpoint control
		udd_reset_ep_ctrl();
800031d4:	f0 1f 00 4d 	mcall	80003308 <udd_interrupt+0x1b4>
		// Reset endpoint control management
		udd_ctrl_init();
800031d8:	f0 1f 00 4d 	mcall	8000330c <udd_interrupt+0x1b8>
		goto udd_interrupt_end;
800031dc:	c8 28       	rjmp	800032e0 <udd_interrupt+0x18c>
	}

	if (Is_udd_suspend_interrupt_enabled() && Is_udd_suspend()) {
800031de:	fe 68 00 10 	mov	r8,-131056
800031e2:	70 08       	ld.w	r8,r8[0x0]
800031e4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800031e8:	5c 58       	castu.b	r8
800031ea:	c2 40       	breq	80003232 <udd_interrupt+0xde>
800031ec:	fe 68 00 04 	mov	r8,-131068
800031f0:	70 08       	ld.w	r8,r8[0x0]
800031f2:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800031f6:	5c 58       	castu.b	r8
800031f8:	c1 d0       	breq	80003232 <udd_interrupt+0xde>
		otg_unfreeze_clock();
800031fa:	fe 68 08 00 	mov	r8,-129024
800031fe:	fe 69 08 00 	mov	r9,-129024
80003202:	72 09       	ld.w	r9,r9[0x0]
80003204:	af c9       	cbr	r9,0xe
80003206:	91 09       	st.w	r8[0x0],r9
		// The suspend interrupt is automatic acked when a wakeup occur
		udd_disable_suspend_interrupt();
80003208:	fe 68 00 14 	mov	r8,-131052
8000320c:	30 19       	mov	r9,1
8000320e:	91 09       	st.w	r8[0x0],r9
		udd_enable_wake_up_interrupt();
80003210:	fe 68 00 18 	mov	r8,-131048
80003214:	31 09       	mov	r9,16
80003216:	91 09       	st.w	r8[0x0],r9
		otg_freeze_clock(); // Mandatory to exit of sleep mode after a wakeup event
80003218:	fe 68 08 00 	mov	r8,-129024
8000321c:	fe 69 08 00 	mov	r9,-129024
80003220:	72 09       	ld.w	r9,r9[0x0]
80003222:	af a9       	sbr	r9,0xe
80003224:	91 09       	st.w	r8[0x0],r9
		udd_sleep_mode(false); // Enter in SUSPEND mode
80003226:	30 0c       	mov	r12,0
80003228:	f0 1f 00 3a 	mcall	80003310 <udd_interrupt+0x1bc>
#ifdef UDC_SUSPEND_EVENT
		UDC_SUSPEND_EVENT();
8000322c:	f0 1f 00 3a 	mcall	80003314 <udd_interrupt+0x1c0>
#endif
		goto udd_interrupt_end;
80003230:	c5 88       	rjmp	800032e0 <udd_interrupt+0x18c>
	}

	if (Is_udd_wake_up_interrupt_enabled() && Is_udd_wake_up()) {
80003232:	fe 68 00 10 	mov	r8,-131056
80003236:	70 08       	ld.w	r8,r8[0x0]
80003238:	e2 18 00 10 	andl	r8,0x10,COH
8000323c:	c2 20       	breq	80003280 <udd_interrupt+0x12c>
8000323e:	fe 68 00 04 	mov	r8,-131068
80003242:	70 08       	ld.w	r8,r8[0x0]
80003244:	e2 18 00 10 	andl	r8,0x10,COH
80003248:	c1 c0       	breq	80003280 <udd_interrupt+0x12c>
		// Ack wakeup interrupt and enable suspend interrupt
		otg_unfreeze_clock();
8000324a:	fe 68 08 00 	mov	r8,-129024
8000324e:	fe 69 08 00 	mov	r9,-129024
80003252:	72 09       	ld.w	r9,r9[0x0]
80003254:	af c9       	cbr	r9,0xe
80003256:	91 09       	st.w	r8[0x0],r9

		// Check USB clock ready after suspend and eventually sleep USB clock
		while( !Is_otg_clock_usable() );
80003258:	fe 68 08 04 	mov	r8,-129020
8000325c:	70 08       	ld.w	r8,r8[0x0]
8000325e:	e2 18 40 00 	andl	r8,0x4000,COH
80003262:	cf b0       	breq	80003258 <udd_interrupt+0x104>

		// The wakeup interrupt is automatic acked when a suspend occur
		udd_disable_wake_up_interrupt();
80003264:	fe 68 00 14 	mov	r8,-131052
80003268:	31 09       	mov	r9,16
8000326a:	91 09       	st.w	r8[0x0],r9
		udd_enable_suspend_interrupt();
8000326c:	fe 68 00 18 	mov	r8,-131048
80003270:	30 19       	mov	r9,1
80003272:	91 09       	st.w	r8[0x0],r9
		udd_sleep_mode(true); // Enter in IDLE mode
80003274:	30 1c       	mov	r12,1
80003276:	f0 1f 00 27 	mcall	80003310 <udd_interrupt+0x1bc>
#ifdef UDC_RESUME_EVENT
		UDC_RESUME_EVENT();
8000327a:	f0 1f 00 28 	mcall	80003318 <udd_interrupt+0x1c4>
#endif
		goto udd_interrupt_end;
8000327e:	c3 18       	rjmp	800032e0 <udd_interrupt+0x18c>
	}

	if (Is_otg_vbus_transition()) {
80003280:	fe 68 08 04 	mov	r8,-129020
80003284:	70 08       	ld.w	r8,r8[0x0]
80003286:	e2 18 00 02 	andl	r8,0x2,COH
8000328a:	c2 b0       	breq	800032e0 <udd_interrupt+0x18c>
		// Ack Vbus transition and send status to high level
		otg_unfreeze_clock();
8000328c:	fe 68 08 00 	mov	r8,-129024
80003290:	fe 69 08 00 	mov	r9,-129024
80003294:	72 09       	ld.w	r9,r9[0x0]
80003296:	af c9       	cbr	r9,0xe
80003298:	91 09       	st.w	r8[0x0],r9
		otg_ack_vbus_transition();
8000329a:	fe 68 08 08 	mov	r8,-129016
8000329e:	30 29       	mov	r9,2
800032a0:	91 09       	st.w	r8[0x0],r9
		otg_freeze_clock();
800032a2:	fe 68 08 00 	mov	r8,-129024
800032a6:	fe 69 08 00 	mov	r9,-129024
800032aa:	72 09       	ld.w	r9,r9[0x0]
800032ac:	af a9       	sbr	r9,0xe
800032ae:	91 09       	st.w	r8[0x0],r9
#ifndef USB_DEVICE_ATTACH_AUTO_DISABLE
		if (Is_otg_vbus_high()) {
800032b0:	fe 68 08 04 	mov	r8,-129020
800032b4:	70 08       	ld.w	r8,r8[0x0]
800032b6:	e2 18 08 00 	andl	r8,0x800,COH
800032ba:	c0 40       	breq	800032c2 <udd_interrupt+0x16e>
			udd_attach();
800032bc:	f0 1f 00 18 	mcall	8000331c <udd_interrupt+0x1c8>
800032c0:	c0 38       	rjmp	800032c6 <udd_interrupt+0x172>
		} else {
			udd_detach();
800032c2:	f0 1f 00 18 	mcall	80003320 <udd_interrupt+0x1cc>
		}
#endif
#ifdef UDC_VBUS_EVENT
		UDC_VBUS_EVENT(Is_otg_vbus_high());
800032c6:	fe 68 08 04 	mov	r8,-129020
800032ca:	70 08       	ld.w	r8,r8[0x0]
800032cc:	e2 18 08 00 	andl	r8,0x800,COH
800032d0:	5f 18       	srne	r8
800032d2:	10 9c       	mov	r12,r8
800032d4:	f0 1f 00 14 	mcall	80003324 <udd_interrupt+0x1d0>
800032d8:	c0 48       	rjmp	800032e0 <udd_interrupt+0x18c>
		udc_sof_notify();
		goto udd_interrupt_end;
	}

	if (udd_ctrl_interrupt())
		goto udd_interrupt_end; // Interrupt acked by control endpoint managed
800032da:	d7 03       	nop
800032dc:	c0 28       	rjmp	800032e0 <udd_interrupt+0x18c>

#if (0 != USB_DEVICE_MAX_EP)
	if (udd_ep_interrupt())
		goto udd_interrupt_end; // Interrupt acked by bulk/interrupt/isochronous endpoint managed
800032de:	d7 03       	nop
		UDC_VBUS_EVENT(Is_otg_vbus_high());
#endif
		goto udd_interrupt_end;
	}
udd_interrupt_end:
	otg_data_memory_barrier();
800032e0:	fe 68 00 00 	mov	r8,-131072
800032e4:	f0 f8 08 18 	ld.w	r8,r8[2072]
	// consider that exiting from the USB interrupt will require a context switch.
	return pdTRUE;
#else
	return;
#endif
}
800032e8:	e3 cd 40 80 	ldm	sp++,r7,lr
800032ec:	d6 03       	rete
800032ee:	00 00       	add	r0,r0
800032f0:	80 00       	ld.sh	r0,r0[0x0]
800032f2:	69 f8       	ld.w	r8,r4[0x7c]
800032f4:	80 00       	ld.sh	r0,r0[0x0]
800032f6:	76 08       	ld.w	r8,r11[0x0]
800032f8:	80 00       	ld.sh	r0,r0[0x0]
800032fa:	45 c0       	lddsp	r0,sp[0x170]
800032fc:	80 00       	ld.sh	r0,r0[0x0]
800032fe:	4a 74       	lddpc	r4,80003398 <udd_enable+0x70>
80003300:	80 00       	ld.sh	r0,r0[0x0]
80003302:	46 f4       	lddsp	r4,sp[0x1bc]
80003304:	80 00       	ld.sh	r0,r0[0x0]
80003306:	69 98       	ld.w	r8,r4[0x64]
80003308:	80 00       	ld.sh	r0,r0[0x0]
8000330a:	3e 3c       	mov	r12,-29
8000330c:	80 00       	ld.sh	r0,r0[0x0]
8000330e:	3f 20       	mov	r0,-14
80003310:	80 00       	ld.sh	r0,r0[0x0]
80003312:	30 f4       	mov	r4,15
80003314:	80 00       	ld.sh	r0,r0[0x0]
80003316:	75 f4       	ld.w	r4,r10[0x7c]
80003318:	80 00       	ld.sh	r0,r0[0x0]
8000331a:	75 fe       	ld.w	lr,r10[0x7c]
8000331c:	80 00       	ld.sh	r0,r0[0x0]
8000331e:	34 48       	mov	r8,68
80003320:	80 00       	ld.sh	r0,r0[0x0]
80003322:	34 f8       	mov	r8,79
80003324:	80 00       	ld.sh	r0,r0[0x0]
80003326:	76 8c       	ld.w	r12,r11[0x20]

80003328 <udd_enable>:
	return true;
}


void udd_enable(void)
{
80003328:	eb cd 40 80 	pushm	r7,lr
8000332c:	1a 97       	mov	r7,sp
8000332e:	20 2d       	sub	sp,8
	irqflags_t flags;

	flags = cpu_irq_save();
80003330:	f0 1f 00 3e 	mcall	80003428 <udd_enable+0x100>
80003334:	18 98       	mov	r8,r12
80003336:	ef 48 ff f8 	st.w	r7[-8],r8
		cpu_irq_restore(flags);
		return;
	}
#else
	//* SINGLE DEVICE MODE INITIALIZATION
	sysclk_enable_usb();
8000333a:	f0 1f 00 3d 	mcall	8000342c <udd_enable+0x104>

	// Here, only the device mode is possible, then link USBB interrupt to UDD interrupt
	irq_register_handler(
8000333e:	30 0a       	mov	r10,0
80003340:	e0 6b 02 20 	mov	r11,544
80003344:	4b bc       	lddpc	r12,80003430 <udd_enable+0x108>
80003346:	f0 1f 00 3c 	mcall	80003434 <udd_enable+0x10c>
8000334a:	30 18       	mov	r8,1
8000334c:	ef 48 ff fc 	st.w	r7[-4],r8
 *  AVR32_PM_AWEN_xxxxWEN_MASK in the part-specific header file under
 *  "toolchain folder"/avr32/inc(lude)/avr32/)
 */
__always_inline static void pm_asyn_wake_up_enable(unsigned long awen_mask)
{
  AVR32_PM.awen |= awen_mask;
80003350:	fe 78 0c 00 	mov	r8,-62464
80003354:	fe 79 0c 00 	mov	r9,-62464
80003358:	f2 fa 01 44 	ld.w	r10,r9[324]
8000335c:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003360:	f5 e9 10 09 	or	r9,r10,r9
80003364:	f1 49 01 44 	st.w	r8[324],r9
		cpu_irq_restore(flags);
		return; // Device is not the current mode
	}
# else
	// ID pin not used then force device mode
	otg_disable_id_pin();
80003368:	fe 68 08 00 	mov	r8,-129024
8000336c:	fe 69 08 00 	mov	r9,-129024
80003370:	72 09       	ld.w	r9,r9[0x0]
80003372:	b9 c9       	cbr	r9,0x18
80003374:	91 09       	st.w	r8[0x0],r9
	otg_force_device_mode();
80003376:	fe 68 08 00 	mov	r8,-129024
8000337a:	fe 69 08 00 	mov	r9,-129024
8000337e:	72 09       	ld.w	r9,r9[0x0]
80003380:	b9 b9       	sbr	r9,0x19
80003382:	91 09       	st.w	r8[0x0],r9
# endif

	// Enable USB hardware
	otg_enable_pad();
80003384:	fe 68 08 00 	mov	r8,-129024
80003388:	fe 69 08 00 	mov	r9,-129024
8000338c:	72 09       	ld.w	r9,r9[0x0]
8000338e:	ad a9       	sbr	r9,0xc
80003390:	91 09       	st.w	r8[0x0],r9
	otg_enable();
80003392:	fe 68 08 00 	mov	r8,-129024
80003396:	fe 69 08 00 	mov	r9,-129024
8000339a:	72 09       	ld.w	r9,r9[0x0]
8000339c:	af b9       	sbr	r9,0xf
8000339e:	91 09       	st.w	r8[0x0],r9
	otg_unfreeze_clock();
800033a0:	fe 68 08 00 	mov	r8,-129024
800033a4:	fe 69 08 00 	mov	r9,-129024
800033a8:	72 09       	ld.w	r9,r9[0x0]
800033aa:	af c9       	cbr	r9,0xe
800033ac:	91 09       	st.w	r8[0x0],r9
	(void)Is_otg_clock_frozen();
800033ae:	fe 68 08 00 	mov	r8,-129024
800033b2:	70 08       	ld.w	r8,r8[0x0]

	// Reset internal variables
#if (0!=USB_DEVICE_MAX_EP)
	udd_ep_job_table_reset();
800033b4:	f0 1f 00 21 	mcall	80003438 <udd_enable+0x110>

	// Set the USB speed requested by configuration file
#ifdef USB_DEVICE_LOW_SPEED
	udd_low_speed_enable();
#else
	udd_low_speed_disable();
800033b8:	fe 68 00 00 	mov	r8,-131072
800033bc:	fe 69 00 00 	mov	r9,-131072
800033c0:	72 09       	ld.w	r9,r9[0x0]
800033c2:	ad c9       	cbr	r9,0xc
800033c4:	91 09       	st.w	r8[0x0],r9
#  ifdef USB_DEVICE_HS_SUPPORT
	udd_high_speed_enable();
#  else
	udd_high_speed_disable();
800033c6:	fe 68 00 00 	mov	r8,-131072
800033ca:	fe 69 00 00 	mov	r9,-131072
800033ce:	72 09       	ld.w	r9,r9[0x0]
800033d0:	e8 19 0c 00 	orl	r9,0xc00
800033d4:	91 09       	st.w	r8[0x0],r9
#  endif
#endif
	otg_ack_vbus_transition();
800033d6:	fe 68 08 08 	mov	r8,-129016
800033da:	30 29       	mov	r9,2
800033dc:	91 09       	st.w	r8[0x0],r9
	// Force Vbus interrupt in case of Vbus always with a high level
	// This is possible with a short timing between a Host mode stop/start.
	if (Is_otg_vbus_high()) {
800033de:	fe 68 08 04 	mov	r8,-129020
800033e2:	70 08       	ld.w	r8,r8[0x0]
800033e4:	e2 18 08 00 	andl	r8,0x800,COH
800033e8:	c0 50       	breq	800033f2 <udd_enable+0xca>
		otg_raise_vbus_transition();
800033ea:	fe 68 08 0c 	mov	r8,-129012
800033ee:	30 29       	mov	r9,2
800033f0:	91 09       	st.w	r8[0x0],r9
	}
	otg_enable_vbus_interrupt();
800033f2:	fe 68 08 00 	mov	r8,-129024
800033f6:	fe 69 08 00 	mov	r9,-129024
800033fa:	72 09       	ld.w	r9,r9[0x0]
800033fc:	a1 b9       	sbr	r9,0x1
800033fe:	91 09       	st.w	r8[0x0],r9
	otg_freeze_clock();
80003400:	fe 68 08 00 	mov	r8,-129024
80003404:	fe 69 08 00 	mov	r9,-129024
80003408:	72 09       	ld.w	r9,r9[0x0]
8000340a:	af a9       	sbr	r9,0xe
8000340c:	91 09       	st.w	r8[0x0],r9

#ifndef UDD_NO_SLEEP_MGR
	// Initialize the sleep mode authorized for the USB suspend mode
	udd_b_idle = false;
8000340e:	48 c9       	lddpc	r9,8000343c <udd_enable+0x114>
80003410:	30 08       	mov	r8,0
80003412:	b2 88       	st.b	r9[0x0],r8
	sleepmgr_lock_mode(USBB_SLEEP_MODE_USB_SUSPEND);
80003414:	30 3c       	mov	r12,3
80003416:	f0 1f 00 0b 	mcall	80003440 <udd_enable+0x118>
#endif

	cpu_irq_restore(flags);
8000341a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000341e:	f0 1f 00 0a 	mcall	80003444 <udd_enable+0x11c>
}
80003422:	2f ed       	sub	sp,-8
80003424:	e3 cd 80 80 	ldm	sp++,r7,pc
80003428:	80 00       	ld.sh	r0,r0[0x0]
8000342a:	30 06       	mov	r6,0
8000342c:	80 00       	ld.sh	r0,r0[0x0]
8000342e:	54 54       	stdsp	sp[0x114],r4
80003430:	80 00       	ld.sh	r0,r0[0x0]
80003432:	31 54       	mov	r4,21
80003434:	80 00       	ld.sh	r0,r0[0x0]
80003436:	2e 9c       	sub	r12,-23
80003438:	80 00       	ld.sh	r0,r0[0x0]
8000343a:	46 88       	lddsp	r8,sp[0x1a0]
8000343c:	00 00       	add	r0,r0
8000343e:	01 90       	ld.ub	r0,r0[0x1]
80003440:	80 00       	ld.sh	r0,r0[0x0]
80003442:	30 6c       	mov	r12,6
80003444:	80 00       	ld.sh	r0,r0[0x0]
80003446:	30 44       	mov	r4,4

80003448 <udd_attach>:
	cpu_irq_restore(flags);
}


void udd_attach(void)
{
80003448:	eb cd 40 80 	pushm	r7,lr
8000344c:	1a 97       	mov	r7,sp
8000344e:	20 1d       	sub	sp,4
	irqflags_t flags;
	flags = cpu_irq_save();
80003450:	f0 1f 00 27 	mcall	800034ec <udd_attach+0xa4>
80003454:	18 98       	mov	r8,r12
80003456:	ef 48 ff fc 	st.w	r7[-4],r8

	// At startup the USB bus state is unknown,
	// therefore the state is considered IDLE to not miss any USB event
	udd_sleep_mode(true);
8000345a:	30 1c       	mov	r12,1
8000345c:	f0 1f 00 25 	mcall	800034f0 <udd_attach+0xa8>
	otg_unfreeze_clock();
80003460:	fe 68 08 00 	mov	r8,-129024
80003464:	fe 69 08 00 	mov	r9,-129024
80003468:	72 09       	ld.w	r9,r9[0x0]
8000346a:	af c9       	cbr	r9,0xe
8000346c:	91 09       	st.w	r8[0x0],r9
	while( !Is_otg_clock_usable() );
8000346e:	fe 68 08 04 	mov	r8,-129020
80003472:	70 08       	ld.w	r8,r8[0x0]
80003474:	e2 18 40 00 	andl	r8,0x4000,COH
80003478:	cf b0       	breq	8000346e <udd_attach+0x26>

	// Authorize attach if Vbus is present
	udd_attach_device();
8000347a:	fe 68 00 00 	mov	r8,-131072
8000347e:	fe 69 00 00 	mov	r9,-131072
80003482:	72 09       	ld.w	r9,r9[0x0]
80003484:	a9 c9       	cbr	r9,0x8
80003486:	91 09       	st.w	r8[0x0],r9

	// Enable USB line events
	udd_enable_reset_interrupt();
80003488:	fe 68 00 18 	mov	r8,-131048
8000348c:	30 89       	mov	r9,8
8000348e:	91 09       	st.w	r8[0x0],r9
	udd_enable_suspend_interrupt();
80003490:	fe 68 00 18 	mov	r8,-131048
80003494:	30 19       	mov	r9,1
80003496:	91 09       	st.w	r8[0x0],r9
	udd_enable_wake_up_interrupt();
80003498:	fe 68 00 18 	mov	r8,-131048
8000349c:	31 09       	mov	r9,16
8000349e:	91 09       	st.w	r8[0x0],r9
	udd_enable_sof_interrupt();
800034a0:	fe 68 00 18 	mov	r8,-131048
800034a4:	30 49       	mov	r9,4
800034a6:	91 09       	st.w	r8[0x0],r9
#ifdef USB_DEVICE_HS_SUPPORT
	udd_enable_msof_interrupt();
#endif
	// Reset following interrupts flag
	udd_ack_reset();
800034a8:	fe 68 00 08 	mov	r8,-131064
800034ac:	30 89       	mov	r9,8
800034ae:	91 09       	st.w	r8[0x0],r9
	udd_ack_sof();
800034b0:	fe 68 00 08 	mov	r8,-131064
800034b4:	30 49       	mov	r9,4
800034b6:	91 09       	st.w	r8[0x0],r9
	udd_ack_msof();
800034b8:	fe 68 00 08 	mov	r8,-131064
800034bc:	30 29       	mov	r9,2
800034be:	91 09       	st.w	r8[0x0],r9
#if UC3A3
	// With UTMI, the first suspend is detected but must be cleared to reoccur interrupt
	udd_ack_suspend();
#else
	// The first suspend interrupt is not detected else raise it
	udd_raise_suspend();
800034c0:	fe 68 00 0c 	mov	r8,-131060
800034c4:	30 19       	mov	r9,1
800034c6:	91 09       	st.w	r8[0x0],r9
#endif
	udd_ack_wake_up();
800034c8:	fe 68 00 08 	mov	r8,-131064
800034cc:	31 09       	mov	r9,16
800034ce:	91 09       	st.w	r8[0x0],r9
	otg_freeze_clock();
800034d0:	fe 68 08 00 	mov	r8,-129024
800034d4:	fe 69 08 00 	mov	r9,-129024
800034d8:	72 09       	ld.w	r9,r9[0x0]
800034da:	af a9       	sbr	r9,0xe
800034dc:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
800034de:	ee fc ff fc 	ld.w	r12,r7[-4]
800034e2:	f0 1f 00 05 	mcall	800034f4 <udd_attach+0xac>
}
800034e6:	2f fd       	sub	sp,-4
800034e8:	e3 cd 80 80 	ldm	sp++,r7,pc
800034ec:	80 00       	ld.sh	r0,r0[0x0]
800034ee:	30 06       	mov	r6,0
800034f0:	80 00       	ld.sh	r0,r0[0x0]
800034f2:	30 f4       	mov	r4,15
800034f4:	80 00       	ld.sh	r0,r0[0x0]
800034f6:	30 44       	mov	r4,4

800034f8 <udd_detach>:


void udd_detach(void)
{
800034f8:	eb cd 40 80 	pushm	r7,lr
800034fc:	1a 97       	mov	r7,sp
	otg_unfreeze_clock();
800034fe:	fe 68 08 00 	mov	r8,-129024
80003502:	fe 69 08 00 	mov	r9,-129024
80003506:	72 09       	ld.w	r9,r9[0x0]
80003508:	af c9       	cbr	r9,0xe
8000350a:	91 09       	st.w	r8[0x0],r9

	// Detach device from the bus
	udd_detach_device();
8000350c:	fe 68 00 00 	mov	r8,-131072
80003510:	fe 69 00 00 	mov	r9,-131072
80003514:	72 09       	ld.w	r9,r9[0x0]
80003516:	a9 a9       	sbr	r9,0x8
80003518:	91 09       	st.w	r8[0x0],r9
	otg_freeze_clock();
8000351a:	fe 68 08 00 	mov	r8,-129024
8000351e:	fe 69 08 00 	mov	r9,-129024
80003522:	72 09       	ld.w	r9,r9[0x0]
80003524:	af a9       	sbr	r9,0xe
80003526:	91 09       	st.w	r8[0x0],r9
	udd_sleep_mode(false);
80003528:	30 0c       	mov	r12,0
8000352a:	f0 1f 00 03 	mcall	80003534 <udd_detach+0x3c>
}
8000352e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003532:	00 00       	add	r0,r0
80003534:	80 00       	ld.sh	r0,r0[0x0]
80003536:	30 f4       	mov	r4,15

80003538 <udd_is_high_speed>:


bool udd_is_high_speed(void)
{
80003538:	eb cd 40 80 	pushm	r7,lr
8000353c:	1a 97       	mov	r7,sp
#ifdef USB_DEVICE_HS_SUPPORT
	return !Is_udd_full_speed_mode();
#else
	return false;
8000353e:	30 08       	mov	r8,0
#endif
}
80003540:	10 9c       	mov	r12,r8
80003542:	e3 cd 80 80 	ldm	sp++,r7,pc

80003546 <udd_set_address>:


void udd_set_address(uint8_t address)
{
80003546:	eb cd 40 80 	pushm	r7,lr
8000354a:	1a 97       	mov	r7,sp
8000354c:	20 1d       	sub	sp,4
8000354e:	18 98       	mov	r8,r12
80003550:	ef 68 ff fc 	st.b	r7[-4],r8
	udd_disable_address();
80003554:	fe 68 00 00 	mov	r8,-131072
80003558:	fe 69 00 00 	mov	r9,-131072
8000355c:	72 09       	ld.w	r9,r9[0x0]
8000355e:	a7 d9       	cbr	r9,0x7
80003560:	91 09       	st.w	r8[0x0],r9
	udd_configure_address(address);
80003562:	fe 68 00 00 	mov	r8,-131072
80003566:	fe 69 00 00 	mov	r9,-131072
8000356a:	72 09       	ld.w	r9,r9[0x0]
8000356c:	12 9a       	mov	r10,r9
8000356e:	e0 1a ff 80 	andl	r10,0xff80
80003572:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80003576:	f3 d9 c0 07 	bfextu	r9,r9,0x0,0x7
8000357a:	f5 e9 10 09 	or	r9,r10,r9
8000357e:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
80003580:	fe 68 00 00 	mov	r8,-131072
80003584:	fe 69 00 00 	mov	r9,-131072
80003588:	72 09       	ld.w	r9,r9[0x0]
8000358a:	a7 b9       	sbr	r9,0x7
8000358c:	91 09       	st.w	r8[0x0],r9
}
8000358e:	2f fd       	sub	sp,-4
80003590:	e3 cd 80 80 	ldm	sp++,r7,pc

80003594 <udd_getaddress>:


uint8_t udd_getaddress(void)
{
80003594:	eb cd 40 80 	pushm	r7,lr
80003598:	1a 97       	mov	r7,sp
	return udd_get_configured_address();
8000359a:	fe 68 00 00 	mov	r8,-131072
8000359e:	70 08       	ld.w	r8,r8[0x0]
800035a0:	5c 58       	castu.b	r8
800035a2:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
}
800035a6:	10 9c       	mov	r12,r8
800035a8:	e3 cd 80 80 	ldm	sp++,r7,pc

800035ac <udd_get_frame_number>:


uint16_t udd_get_frame_number(void)
{
800035ac:	eb cd 40 80 	pushm	r7,lr
800035b0:	1a 97       	mov	r7,sp
	return udd_frame_number();
800035b2:	fe 68 00 20 	mov	r8,-131040
800035b6:	70 08       	ld.w	r8,r8[0x0]
800035b8:	e2 18 3f f8 	andl	r8,0x3ff8,COH
800035bc:	a3 98       	lsr	r8,0x3
800035be:	5c 88       	casts.h	r8
}
800035c0:	10 9c       	mov	r12,r8
800035c2:	e3 cd 80 80 	ldm	sp++,r7,pc

800035c6 <udd_get_micro_frame_number>:

uint16_t udd_get_micro_frame_number(void)
{
800035c6:	eb cd 40 80 	pushm	r7,lr
800035ca:	1a 97       	mov	r7,sp
	return udd_micro_frame_number();
800035cc:	fe 68 00 00 	mov	r8,-131072
800035d0:	70 88       	ld.w	r8,r8[0x20]
800035d2:	5c 88       	casts.h	r8
800035d4:	5c 88       	casts.h	r8
800035d6:	f1 d8 c0 0e 	bfextu	r8,r8,0x0,0xe
}
800035da:	10 9c       	mov	r12,r8
800035dc:	e3 cd 80 80 	ldm	sp++,r7,pc

800035e0 <udd_set_setup_payload>:
	}
}


void udd_set_setup_payload( uint8_t *payload, uint16_t payload_size )
{
800035e0:	eb cd 40 80 	pushm	r7,lr
800035e4:	1a 97       	mov	r7,sp
800035e6:	20 2d       	sub	sp,8
800035e8:	ef 4c ff fc 	st.w	r7[-4],r12
800035ec:	16 98       	mov	r8,r11
800035ee:	ef 58 ff f8 	st.h	r7[-8],r8
	udd_g_ctrlreq.payload = payload;
800035f2:	48 68       	lddpc	r8,80003608 <udd_set_setup_payload+0x28>
800035f4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800035f8:	91 29       	st.w	r8[0x8],r9
	udd_g_ctrlreq.payload_size = payload_size;
800035fa:	48 49       	lddpc	r9,80003608 <udd_set_setup_payload+0x28>
800035fc:	ef 08 ff f8 	ld.sh	r8,r7[-8]
80003600:	b2 68       	st.h	r9[0xc],r8
}
80003602:	2f ed       	sub	sp,-8
80003604:	e3 cd 80 80 	ldm	sp++,r7,pc
80003608:	00 00       	add	r0,r0
8000360a:	46 48       	lddsp	r8,sp[0x190]

8000360c <udd_ep_alloc>:


#if (0!=USB_DEVICE_MAX_EP)
bool udd_ep_alloc(udd_ep_id_t ep, uint8_t bmAttributes,
		uint16_t MaxEndpointSize)
{
8000360c:	eb cd 40 80 	pushm	r7,lr
80003610:	1a 97       	mov	r7,sp
80003612:	20 dd       	sub	sp,52
80003614:	16 99       	mov	r9,r11
80003616:	14 98       	mov	r8,r10
80003618:	18 9a       	mov	r10,r12
8000361a:	ef 6a ff d4 	st.b	r7[-44],r10
8000361e:	ef 69 ff d0 	st.b	r7[-48],r9
80003622:	ef 58 ff cc 	st.h	r7[-52],r8
	bool b_dir_in;
	uint16_t ep_allocated;
	uint8_t bank, i;

	b_dir_in = ep & USB_EP_DIR_IN;
80003626:	ef 38 ff d4 	ld.ub	r8,r7[-44]
8000362a:	a7 98       	lsr	r8,0x7
8000362c:	ef 68 ff db 	st.b	r7[-37],r8
	ep = ep & USB_EP_ADDR_MASK;
80003630:	ef 38 ff d4 	ld.ub	r8,r7[-44]
80003634:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003638:	ef 68 ff d4 	st.b	r7[-44],r8

	if (ep > USB_DEVICE_MAX_EP) {
8000363c:	ef 39 ff d4 	ld.ub	r9,r7[-44]
80003640:	30 38       	mov	r8,3
80003642:	f0 09 18 00 	cp.b	r9,r8
80003646:	e0 88 00 04 	brls	8000364e <udd_ep_alloc+0x42>
		return false;
8000364a:	30 08       	mov	r8,0
8000364c:	c7 f9       	rjmp	8000394a <udd_ep_alloc+0x33e>
	}
	if (Is_udd_endpoint_enabled(ep)) {
8000364e:	fe 68 00 00 	mov	r8,-131072
80003652:	70 79       	ld.w	r9,r8[0x1c]
80003654:	ef 38 ff d4 	ld.ub	r8,r7[-44]
80003658:	30 1a       	mov	r10,1
8000365a:	f4 08 09 48 	lsl	r8,r10,r8
8000365e:	f3 e8 00 08 	and	r8,r9,r8
80003662:	c0 30       	breq	80003668 <udd_ep_alloc+0x5c>
		return false;
80003664:	30 08       	mov	r8,0
80003666:	c7 29       	rjmp	8000394a <udd_ep_alloc+0x33e>
	}

	// Bank choice
	switch(bmAttributes&USB_EP_TYPE_MASK) {
80003668:	ef 38 ff d0 	ld.ub	r8,r7[-48]
8000366c:	f1 d8 c0 02 	bfextu	r8,r8,0x0,0x2
80003670:	58 28       	cp.w	r8,2
80003672:	c0 d0       	breq	8000368c <udd_ep_alloc+0x80>
80003674:	58 38       	cp.w	r8,3
80003676:	c0 70       	breq	80003684 <udd_ep_alloc+0x78>
80003678:	58 18       	cp.w	r8,1
8000367a:	c0 d1       	brne	80003694 <udd_ep_alloc+0x88>
	case USB_EP_TYPE_ISOCHRONOUS:
		bank = UDD_ISOCHRONOUS_NB_BANK(ep);
8000367c:	30 28       	mov	r8,2
8000367e:	ef 68 ff de 	st.b	r7[-34],r8
		break;
80003682:	c0 b8       	rjmp	80003698 <udd_ep_alloc+0x8c>
	case USB_EP_TYPE_INTERRUPT:
		bank = UDD_INTERRUPT_NB_BANK(ep);
80003684:	30 18       	mov	r8,1
80003686:	ef 68 ff de 	st.b	r7[-34],r8
		break;
8000368a:	c0 78       	rjmp	80003698 <udd_ep_alloc+0x8c>
	case USB_EP_TYPE_BULK:
		bank = UDD_BULK_NB_BANK(ep);
8000368c:	30 28       	mov	r8,2
8000368e:	ef 68 ff de 	st.b	r7[-34],r8
		break;
80003692:	c0 38       	rjmp	80003698 <udd_ep_alloc+0x8c>
	default:
		Assert(false);
		return false;
80003694:	30 08       	mov	r8,0
80003696:	c5 a9       	rjmp	8000394a <udd_ep_alloc+0x33e>
	}
	switch(bank) {
80003698:	ef 38 ff de 	ld.ub	r8,r7[-34]
8000369c:	58 28       	cp.w	r8,2
8000369e:	c0 90       	breq	800036b0 <udd_ep_alloc+0xa4>
800036a0:	58 38       	cp.w	r8,3
800036a2:	c0 b0       	breq	800036b8 <udd_ep_alloc+0xac>
800036a4:	58 18       	cp.w	r8,1
800036a6:	c0 d1       	brne	800036c0 <udd_ep_alloc+0xb4>
	case 1:
		bank = AVR32_USBB_UECFG0_EPBK_SINGLE;
800036a8:	30 08       	mov	r8,0
800036aa:	ef 68 ff de 	st.b	r7[-34],r8
		break;
800036ae:	c0 b8       	rjmp	800036c4 <udd_ep_alloc+0xb8>
	case 2:
		bank = AVR32_USBB_UECFG0_EPBK_DOUBLE;
800036b0:	30 18       	mov	r8,1
800036b2:	ef 68 ff de 	st.b	r7[-34],r8
		break;
800036b6:	c0 78       	rjmp	800036c4 <udd_ep_alloc+0xb8>
	case 3:
		bank = AVR32_USBB_UECFG0_EPBK_TRIPLE;
800036b8:	30 28       	mov	r8,2
800036ba:	ef 68 ff de 	st.b	r7[-34],r8
		break;
800036be:	c0 38       	rjmp	800036c4 <udd_ep_alloc+0xb8>
	default:
		Assert(false);
		return false;
800036c0:	30 08       	mov	r8,0
800036c2:	c4 49       	rjmp	8000394a <udd_ep_alloc+0x33e>
	Assert(MaxEndpointSize < 1024);
	Assert((MaxEndpointSize == 1023) || !(MaxEndpointSize & (MaxEndpointSize - 1)));
	Assert(MaxEndpointSize >= 8);

	// Set configuration of new endpoint
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
800036c4:	ef 38 ff d4 	ld.ub	r8,r7[-44]
800036c8:	a3 68       	lsl	r8,0x2
800036ca:	e0 38 ff 00 	sub	r8,130816
800036ce:	ef 39 ff d4 	ld.ub	r9,r7[-44]
800036d2:	a3 69       	lsl	r9,0x2
800036d4:	e0 39 ff 00 	sub	r9,130816
800036d8:	72 09       	ld.w	r9,r9[0x0]
800036da:	12 9a       	mov	r10,r9
800036dc:	e0 1a e6 83 	andl	r10,0xe683
800036e0:	ef 39 ff d0 	ld.ub	r9,r7[-48]
800036e4:	ab 79       	lsl	r9,0xb
800036e6:	12 9b       	mov	r11,r9
800036e8:	e2 1b 18 00 	andl	r11,0x1800,COH
800036ec:	ef 39 ff db 	ld.ub	r9,r7[-37]
800036f0:	a9 69       	lsl	r9,0x8
800036f2:	e2 19 01 00 	andl	r9,0x100,COH
800036f6:	12 4b       	or	r11,r9
800036f8:	ef 19 ff cc 	ld.uh	r9,r7[-52]
800036fc:	ef 49 ff f0 	st.w	r7[-16],r9
80003700:	30 89       	mov	r9,8
80003702:	ef 49 ff f4 	st.w	r7[-12],r9
80003706:	ee f9 ff f0 	ld.w	r9,r7[-16]
8000370a:	ee fc ff f4 	ld.w	r12,r7[-12]
8000370e:	f2 0c 0c 49 	max	r9,r9,r12
80003712:	ef 49 ff ec 	st.w	r7[-20],r9
80003716:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000371a:	ef 49 ff e4 	st.w	r7[-28],r9
8000371e:	e0 69 04 00 	mov	r9,1024
80003722:	ef 49 ff e8 	st.w	r7[-24],r9
80003726:	ee f9 ff e4 	ld.w	r9,r7[-28]
8000372a:	ee fc ff e8 	ld.w	r12,r7[-24]
8000372e:	f2 0c 0d 49 	min	r9,r9,r12
80003732:	ef 49 ff e0 	st.w	r7[-32],r9
80003736:	ee f9 ff e0 	ld.w	r9,r7[-32]
8000373a:	a1 79       	lsl	r9,0x1
8000373c:	20 19       	sub	r9,1
8000373e:	f2 09 12 00 	clz	r9,r9
80003742:	f2 09 11 1c 	rsub	r9,r9,28
80003746:	a5 69       	lsl	r9,0x4
80003748:	12 4b       	or	r11,r9
8000374a:	ef 39 ff de 	ld.ub	r9,r7[-34]
8000374e:	a3 69       	lsl	r9,0x2
80003750:	e2 19 00 0c 	andl	r9,0xc,COH
80003754:	f7 e9 10 09 	or	r9,r11,r9
80003758:	e2 19 19 7c 	andl	r9,0x197c,COH
8000375c:	f5 e9 10 09 	or	r9,r10,r9
80003760:	91 09       	st.w	r8[0x0],r9
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;
80003762:	ef 38 ff d4 	ld.ub	r8,r7[-44]
80003766:	30 19       	mov	r9,1
80003768:	f2 08 09 48 	lsl	r8,r9,r8
8000376c:	ef 58 ff dc 	st.h	r7[-36],r8

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
80003770:	30 38       	mov	r8,3
80003772:	ef 68 ff df 	st.b	r7[-33],r8
80003776:	c3 a8       	rjmp	800037ea <udd_ep_alloc+0x1de>
		if (Is_udd_endpoint_enabled(i)) {
80003778:	fe 68 00 00 	mov	r8,-131072
8000377c:	70 79       	ld.w	r9,r8[0x1c]
8000377e:	ef 38 ff df 	ld.ub	r8,r7[-33]
80003782:	30 1a       	mov	r10,1
80003784:	f4 08 09 48 	lsl	r8,r10,r8
80003788:	f3 e8 00 08 	and	r8,r9,r8
8000378c:	c2 a0       	breq	800037e0 <udd_ep_alloc+0x1d4>
			ep_allocated |= 1 << i;
8000378e:	ef 38 ff df 	ld.ub	r8,r7[-33]
80003792:	30 19       	mov	r9,1
80003794:	f2 08 09 48 	lsl	r8,r9,r8
80003798:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
8000379c:	ef 08 ff dc 	ld.sh	r8,r7[-36]
800037a0:	f3 e8 10 08 	or	r8,r9,r8
800037a4:	5c 88       	casts.h	r8
800037a6:	ef 58 ff dc 	st.h	r7[-36],r8
			udd_disable_endpoint(i);
800037aa:	fe 68 00 00 	mov	r8,-131072
800037ae:	fe 69 00 00 	mov	r9,-131072
800037b2:	72 7a       	ld.w	r10,r9[0x1c]
800037b4:	ef 39 ff df 	ld.ub	r9,r7[-33]
800037b8:	30 1b       	mov	r11,1
800037ba:	f6 09 09 49 	lsl	r9,r11,r9
800037be:	5c d9       	com	r9
800037c0:	f5 e9 00 09 	and	r9,r10,r9
800037c4:	91 79       	st.w	r8[0x1c],r9
			udd_unallocate_memory(i);
800037c6:	ef 38 ff df 	ld.ub	r8,r7[-33]
800037ca:	a3 68       	lsl	r8,0x2
800037cc:	e0 38 ff 00 	sub	r8,130816
800037d0:	ef 39 ff df 	ld.ub	r9,r7[-33]
800037d4:	a3 69       	lsl	r9,0x2
800037d6:	e0 39 ff 00 	sub	r9,130816
800037da:	72 09       	ld.w	r9,r9[0x0]
800037dc:	a1 d9       	cbr	r9,0x1
800037de:	91 09       	st.w	r8[0x0],r9
	udd_configure_endpoint(ep, bmAttributes, (b_dir_in ? 1 : 0),
			MaxEndpointSize, bank);
	ep_allocated = 1 << ep;

	// Unalloc endpoints superior
	for (i = USB_DEVICE_MAX_EP; i > ep; i--) {
800037e0:	ef 38 ff df 	ld.ub	r8,r7[-33]
800037e4:	20 18       	sub	r8,1
800037e6:	ef 68 ff df 	st.b	r7[-33],r8
800037ea:	ef 39 ff df 	ld.ub	r9,r7[-33]
800037ee:	ef 38 ff d4 	ld.ub	r8,r7[-44]
800037f2:	f0 09 18 00 	cp.b	r9,r8
800037f6:	fe 9b ff c1 	brhi	80003778 <udd_ep_alloc+0x16c>
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
800037fa:	ef 38 ff d4 	ld.ub	r8,r7[-44]
800037fe:	ef 68 ff df 	st.b	r7[-33],r8
80003802:	c9 c8       	rjmp	8000393a <udd_ep_alloc+0x32e>
		if (ep_allocated & (1 << i)) {
80003804:	ef 19 ff dc 	ld.uh	r9,r7[-36]
80003808:	ef 38 ff df 	ld.ub	r8,r7[-33]
8000380c:	f2 08 08 48 	asr	r8,r9,r8
80003810:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80003814:	5c 58       	castu.b	r8
80003816:	e0 80 00 8d 	breq	80003930 <udd_ep_alloc+0x324>
			udd_ep_job_t *ptr_job = &udd_ep_job[i - 1];
8000381a:	ef 38 ff df 	ld.ub	r8,r7[-33]
8000381e:	f0 c9 00 01 	sub	r9,r8,1
80003822:	12 98       	mov	r8,r9
80003824:	a3 68       	lsl	r8,0x2
80003826:	12 08       	add	r8,r9
80003828:	a3 68       	lsl	r8,0x2
8000382a:	10 99       	mov	r9,r8
8000382c:	4c a8       	lddpc	r8,80003954 <udd_ep_alloc+0x348>
8000382e:	f2 08 00 08 	add	r8,r9,r8
80003832:	ef 48 ff f8 	st.w	r7[-8],r8
			bool b_restart = ptr_job->busy;
80003836:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000383a:	70 08       	ld.w	r8,r8[0x0]
8000383c:	e6 18 80 00 	andh	r8,0x8000,COH
80003840:	5f 18       	srne	r8
80003842:	ef 68 ff ff 	st.b	r7[-1],r8
			ptr_job->busy = false;
80003846:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000384a:	72 08       	ld.w	r8,r9[0x0]
8000384c:	30 0a       	mov	r10,0
8000384e:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80003852:	93 08       	st.w	r9[0x0],r8

			udd_allocate_memory(i);
80003854:	ef 38 ff df 	ld.ub	r8,r7[-33]
80003858:	a3 68       	lsl	r8,0x2
8000385a:	e0 38 ff 00 	sub	r8,130816
8000385e:	ef 39 ff df 	ld.ub	r9,r7[-33]
80003862:	a3 69       	lsl	r9,0x2
80003864:	e0 39 ff 00 	sub	r9,130816
80003868:	72 09       	ld.w	r9,r9[0x0]
8000386a:	a1 b9       	sbr	r9,0x1
8000386c:	91 09       	st.w	r8[0x0],r9
			udd_enable_endpoint(i);
8000386e:	fe 68 00 00 	mov	r8,-131072
80003872:	fe 69 00 00 	mov	r9,-131072
80003876:	72 7a       	ld.w	r10,r9[0x1c]
80003878:	ef 39 ff df 	ld.ub	r9,r7[-33]
8000387c:	30 1b       	mov	r11,1
8000387e:	f6 09 09 49 	lsl	r9,r11,r9
80003882:	f5 e9 10 09 	or	r9,r10,r9
80003886:	91 79       	st.w	r8[0x1c],r9
			if (!Is_udd_endpoint_configured(i)) {
80003888:	ef 38 ff df 	ld.ub	r8,r7[-33]
8000388c:	a3 68       	lsl	r8,0x2
8000388e:	e0 38 fe d0 	sub	r8,130768
80003892:	70 08       	ld.w	r8,r8[0x0]
80003894:	e6 18 00 04 	andh	r8,0x4,COH
80003898:	c2 61       	brne	800038e4 <udd_ep_alloc+0x2d8>
				if (NULL == ptr_job->call_trans) {
8000389a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000389e:	70 48       	ld.w	r8,r8[0x10]
800038a0:	58 08       	cp.w	r8,0
800038a2:	c0 31       	brne	800038a8 <udd_ep_alloc+0x29c>
					return false;
800038a4:	30 08       	mov	r8,0
800038a6:	c5 28       	rjmp	8000394a <udd_ep_alloc+0x33e>
				}
				if (Is_udd_endpoint_in(i)) {
800038a8:	ef 38 ff df 	ld.ub	r8,r7[-33]
800038ac:	a3 68       	lsl	r8,0x2
800038ae:	e0 38 ff 00 	sub	r8,130816
800038b2:	70 08       	ld.w	r8,r8[0x0]
800038b4:	e2 18 01 00 	andl	r8,0x100,COH
800038b8:	c0 90       	breq	800038ca <udd_ep_alloc+0x2be>
					i |= USB_EP_DIR_IN;
800038ba:	ef 38 ff df 	ld.ub	r8,r7[-33]
800038be:	ea 18 ff ff 	orh	r8,0xffff
800038c2:	e8 18 ff 80 	orl	r8,0xff80
800038c6:	ef 68 ff df 	st.b	r7[-33],r8
				}				
				ptr_job->call_trans(UDD_EP_TRANSFER_ABORT,
800038ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800038ce:	70 48       	ld.w	r8,r8[0x10]
800038d0:	ef 3a ff df 	ld.ub	r10,r7[-33]
800038d4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800038d8:	72 29       	ld.w	r9,r9[0x8]
800038da:	12 9b       	mov	r11,r9
800038dc:	30 1c       	mov	r12,1
800038de:	5d 18       	icall	r8
						ptr_job->buf_size, i);
				return false;
800038e0:	30 08       	mov	r8,0
800038e2:	c3 48       	rjmp	8000394a <udd_ep_alloc+0x33e>
			}
			udd_enable_endpoint_bank_autoswitch(i);
800038e4:	ef 38 ff df 	ld.ub	r8,r7[-33]
800038e8:	a3 68       	lsl	r8,0x2
800038ea:	e0 38 ff 00 	sub	r8,130816
800038ee:	ef 39 ff df 	ld.ub	r9,r7[-33]
800038f2:	a3 69       	lsl	r9,0x2
800038f4:	e0 39 ff 00 	sub	r9,130816
800038f8:	72 09       	ld.w	r9,r9[0x0]
800038fa:	a9 b9       	sbr	r9,0x9
800038fc:	91 09       	st.w	r8[0x0],r9
			if (b_restart) {
800038fe:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003902:	30 08       	mov	r8,0
80003904:	f0 09 18 00 	cp.b	r9,r8
80003908:	c1 40       	breq	80003930 <udd_ep_alloc+0x324>
				// Re-run the job
				udd_ep_run(i, ptr_job->b_shortpacket,
8000390a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000390e:	70 48       	ld.w	r8,r8[0x10]
80003910:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003914:	72 29       	ld.w	r9,r9[0x8]
80003916:	ee fa ff f8 	ld.w	r10,r7[-8]
8000391a:	74 1a       	ld.w	r10,r10[0x4]
8000391c:	ee fb ff f8 	ld.w	r11,r7[-8]
80003920:	76 0b       	ld.w	r11,r11[0x0]
80003922:	e6 1b 40 00 	andh	r11,0x4000,COH
80003926:	5f 1b       	srne	r11
80003928:	ef 3c ff df 	ld.ub	r12,r7[-33]
8000392c:	f0 1f 00 0b 	mcall	80003958 <udd_ep_alloc+0x34c>
			udd_unallocate_memory(i);
		}
	}

	// Realloc/Enable endpoints
	for (i = ep; i <= USB_DEVICE_MAX_EP; i++) {
80003930:	ef 38 ff df 	ld.ub	r8,r7[-33]
80003934:	2f f8       	sub	r8,-1
80003936:	ef 68 ff df 	st.b	r7[-33],r8
8000393a:	ef 39 ff df 	ld.ub	r9,r7[-33]
8000393e:	30 38       	mov	r8,3
80003940:	f0 09 18 00 	cp.b	r9,r8
80003944:	fe 98 ff 60 	brls	80003804 <udd_ep_alloc+0x1f8>
						ptr_job->buf_size,
						ptr_job->call_trans);
			}
		}
	}
	return true;
80003948:	30 18       	mov	r8,1
}
8000394a:	10 9c       	mov	r12,r8
8000394c:	2f 3d       	sub	sp,-52
8000394e:	e3 cd 80 80 	ldm	sp++,r7,pc
80003952:	00 00       	add	r0,r0
80003954:	00 00       	add	r0,r0
80003956:	01 9c       	ld.ub	r12,r0[0x1]
80003958:	80 00       	ld.sh	r0,r0[0x0]
8000395a:	3c 7c       	mov	r12,-57

8000395c <udd_ep_free>:


void udd_ep_free(udd_ep_id_t ep)
{
8000395c:	eb cd 40 80 	pushm	r7,lr
80003960:	1a 97       	mov	r7,sp
80003962:	20 2d       	sub	sp,8
80003964:	18 98       	mov	r8,r12
80003966:	ef 68 ff f8 	st.b	r7[-8],r8
	uint8_t index = ep & USB_EP_ADDR_MASK;
8000396a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000396e:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003972:	ef 68 ff ff 	st.b	r7[-1],r8

	if (USB_DEVICE_MAX_EP < index) {
80003976:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000397a:	30 38       	mov	r8,3
8000397c:	f0 09 18 00 	cp.b	r9,r8
80003980:	e0 8b 00 33 	brhi	800039e6 <udd_ep_free+0x8a>
		return;
	}
	udd_disable_endpoint(index);
80003984:	fe 68 00 00 	mov	r8,-131072
80003988:	fe 69 00 00 	mov	r9,-131072
8000398c:	72 7a       	ld.w	r10,r9[0x1c]
8000398e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003992:	30 1b       	mov	r11,1
80003994:	f6 09 09 49 	lsl	r9,r11,r9
80003998:	5c d9       	com	r9
8000399a:	f5 e9 00 09 	and	r9,r10,r9
8000399e:	91 79       	st.w	r8[0x1c],r9
	udd_unallocate_memory(index);
800039a0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800039a4:	a3 68       	lsl	r8,0x2
800039a6:	e0 38 ff 00 	sub	r8,130816
800039aa:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800039ae:	a3 69       	lsl	r9,0x2
800039b0:	e0 39 ff 00 	sub	r9,130816
800039b4:	72 09       	ld.w	r9,r9[0x0]
800039b6:	a1 d9       	cbr	r9,0x1
800039b8:	91 09       	st.w	r8[0x0],r9
	udd_ep_abort_job(ep);
800039ba:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800039be:	10 9c       	mov	r12,r8
800039c0:	f0 1f 00 0c 	mcall	800039f0 <udd_ep_free+0x94>
	udd_ep_job[index - 1].stall_requested = false;
800039c4:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800039c8:	f0 c9 00 01 	sub	r9,r8,1
800039cc:	48 aa       	lddpc	r10,800039f4 <udd_ep_free+0x98>
800039ce:	12 98       	mov	r8,r9
800039d0:	a3 68       	lsl	r8,0x2
800039d2:	12 08       	add	r8,r9
800039d4:	a3 68       	lsl	r8,0x2
800039d6:	f4 08 00 09 	add	r9,r10,r8
800039da:	72 08       	ld.w	r8,r9[0x0]
800039dc:	30 0a       	mov	r10,0
800039de:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
800039e2:	93 08       	st.w	r9[0x0],r8
800039e4:	c0 28       	rjmp	800039e8 <udd_ep_free+0x8c>
void udd_ep_free(udd_ep_id_t ep)
{
	uint8_t index = ep & USB_EP_ADDR_MASK;

	if (USB_DEVICE_MAX_EP < index) {
		return;
800039e6:	d7 03       	nop
	}
	udd_disable_endpoint(index);
	udd_unallocate_memory(index);
	udd_ep_abort_job(ep);
	udd_ep_job[index - 1].stall_requested = false;
}
800039e8:	2f ed       	sub	sp,-8
800039ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800039ee:	00 00       	add	r0,r0
800039f0:	80 00       	ld.sh	r0,r0[0x0]
800039f2:	47 50       	lddsp	r0,sp[0x1d4]
800039f4:	00 00       	add	r0,r0
800039f6:	01 9c       	ld.ub	r12,r0[0x1]

800039f8 <udd_ep_is_halted>:


bool udd_ep_is_halted(udd_ep_id_t ep)
{
800039f8:	eb cd 40 80 	pushm	r7,lr
800039fc:	1a 97       	mov	r7,sp
800039fe:	20 1d       	sub	sp,4
80003a00:	18 98       	mov	r8,r12
80003a02:	ef 68 ff fc 	st.b	r7[-4],r8
	return Is_udd_endpoint_stall_requested(ep & USB_EP_ADDR_MASK);
80003a06:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80003a0a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003a0e:	a3 68       	lsl	r8,0x2
80003a10:	e0 38 fe 40 	sub	r8,130624
80003a14:	70 08       	ld.w	r8,r8[0x0]
80003a16:	e6 18 00 08 	andh	r8,0x8,COH
80003a1a:	5f 18       	srne	r8
80003a1c:	5c 58       	castu.b	r8
}
80003a1e:	10 9c       	mov	r12,r8
80003a20:	2f fd       	sub	sp,-4
80003a22:	e3 cd 80 80 	ldm	sp++,r7,pc
80003a26:	d7 03       	nop

80003a28 <udd_ep_set_halt>:


bool udd_ep_set_halt(udd_ep_id_t ep)
{
80003a28:	eb cd 40 80 	pushm	r7,lr
80003a2c:	1a 97       	mov	r7,sp
80003a2e:	20 3d       	sub	sp,12
80003a30:	18 98       	mov	r8,r12
80003a32:	ef 68 ff f4 	st.b	r7[-12],r8
	udd_ep_job_t *ptr_job;
	uint8_t index = ep & USB_EP_ADDR_MASK;
80003a36:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003a3a:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003a3e:	ef 68 ff ff 	st.b	r7[-1],r8

	if (USB_DEVICE_MAX_EP < index) {
80003a42:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003a46:	30 38       	mov	r8,3
80003a48:	f0 09 18 00 	cp.b	r9,r8
80003a4c:	e0 88 00 04 	brls	80003a54 <udd_ep_set_halt+0x2c>
		return false;
80003a50:	30 08       	mov	r8,0
80003a52:	c6 f8       	rjmp	80003b30 <udd_ep_set_halt+0x108>
	}

	ptr_job = &udd_ep_job[index - 1];
80003a54:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003a58:	f0 c9 00 01 	sub	r9,r8,1
80003a5c:	12 98       	mov	r8,r9
80003a5e:	a3 68       	lsl	r8,0x2
80003a60:	12 08       	add	r8,r9
80003a62:	a3 68       	lsl	r8,0x2
80003a64:	10 99       	mov	r9,r8
80003a66:	4b 58       	lddpc	r8,80003b38 <udd_ep_set_halt+0x110>
80003a68:	f2 08 00 08 	add	r8,r9,r8
80003a6c:	ef 48 ff f8 	st.w	r7[-8],r8

	if (Is_udd_endpoint_stall_requested(index) // Endpoint stalled
80003a70:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003a74:	a3 68       	lsl	r8,0x2
80003a76:	e0 38 fe 40 	sub	r8,130624
80003a7a:	70 08       	ld.w	r8,r8[0x0]
80003a7c:	e6 18 00 08 	andh	r8,0x8,COH
80003a80:	c0 71       	brne	80003a8e <udd_ep_set_halt+0x66>
			|| ptr_job->stall_requested) { // Endpoint stall is requested
80003a82:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a86:	70 08       	ld.w	r8,r8[0x0]
80003a88:	e6 18 20 00 	andh	r8,0x2000,COH
		return false;
	}

	ptr_job = &udd_ep_job[index - 1];

	if (Is_udd_endpoint_stall_requested(index) // Endpoint stalled
80003a8c:	c0 30       	breq	80003a92 <udd_ep_set_halt+0x6a>
			|| ptr_job->stall_requested) { // Endpoint stall is requested
		return true; // Already STALL
80003a8e:	30 18       	mov	r8,1
80003a90:	c5 08       	rjmp	80003b30 <udd_ep_set_halt+0x108>
	}

	if (ptr_job->busy == true) {
80003a92:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003a96:	70 08       	ld.w	r8,r8[0x0]
80003a98:	e6 18 80 00 	andh	r8,0x8000,COH
80003a9c:	c0 30       	breq	80003aa2 <udd_ep_set_halt+0x7a>
		return false; // Job on going, stall impossible
80003a9e:	30 08       	mov	r8,0
80003aa0:	c4 88       	rjmp	80003b30 <udd_ep_set_halt+0x108>
	}

	if ((ep & USB_EP_DIR_IN) && (0 != udd_nb_busy_bank(index))) {
80003aa2:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003aa6:	30 08       	mov	r8,0
80003aa8:	f0 09 18 00 	cp.b	r9,r8
80003aac:	c2 54       	brge	80003af6 <udd_ep_set_halt+0xce>
80003aae:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003ab2:	a3 68       	lsl	r8,0x2
80003ab4:	e0 38 fe d0 	sub	r8,130768
80003ab8:	70 08       	ld.w	r8,r8[0x0]
80003aba:	e2 18 30 00 	andl	r8,0x3000,COH
80003abe:	ad 88       	lsr	r8,0xc
80003ac0:	c1 b0       	breq	80003af6 <udd_ep_set_halt+0xce>
			// Delay the stall after the end of IN transfer on USB line
			ptr_job->stall_requested = true;
80003ac2:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003ac6:	72 08       	ld.w	r8,r9[0x0]
80003ac8:	30 1a       	mov	r10,1
80003aca:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
80003ace:	93 08       	st.w	r9[0x0],r8
			udd_enable_bank_interrupt(index);
80003ad0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003ad4:	a3 68       	lsl	r8,0x2
80003ad6:	e0 38 fe 10 	sub	r8,130576
80003ada:	e0 69 10 00 	mov	r9,4096
80003ade:	91 09       	st.w	r8[0x0],r9
			udd_enable_endpoint_interrupt(index);
80003ae0:	fe 68 00 00 	mov	r8,-131072
80003ae4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003ae8:	e0 6a 10 00 	mov	r10,4096
80003aec:	f4 09 09 49 	lsl	r9,r10,r9
80003af0:	91 69       	st.w	r8[0x18],r9
			return true;
80003af2:	30 18       	mov	r8,1
80003af4:	c1 e8       	rjmp	80003b30 <udd_ep_set_halt+0x108>
	}
	
	// Stall endpoint immediately
	udd_disable_endpoint_bank_autoswitch(index);
80003af6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003afa:	a3 68       	lsl	r8,0x2
80003afc:	e0 38 ff 00 	sub	r8,130816
80003b00:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003b04:	a3 69       	lsl	r9,0x2
80003b06:	e0 39 ff 00 	sub	r9,130816
80003b0a:	72 09       	ld.w	r9,r9[0x0]
80003b0c:	a9 d9       	cbr	r9,0x9
80003b0e:	91 09       	st.w	r8[0x0],r9
	udd_ack_stall(index);
80003b10:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003b14:	a3 68       	lsl	r8,0x2
80003b16:	e0 38 fe a0 	sub	r8,130720
80003b1a:	34 09       	mov	r9,64
80003b1c:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(index);
80003b1e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003b22:	a3 68       	lsl	r8,0x2
80003b24:	e0 38 fe 10 	sub	r8,130576
80003b28:	e8 69 00 00 	mov	r9,524288
80003b2c:	91 09       	st.w	r8[0x0],r9
	return true;
80003b2e:	30 18       	mov	r8,1
}
80003b30:	10 9c       	mov	r12,r8
80003b32:	2f dd       	sub	sp,-12
80003b34:	e3 cd 80 80 	ldm	sp++,r7,pc
80003b38:	00 00       	add	r0,r0
80003b3a:	01 9c       	ld.ub	r12,r0[0x1]

80003b3c <udd_ep_clear_halt>:


bool udd_ep_clear_halt(udd_ep_id_t ep)
{
80003b3c:	eb cd 40 80 	pushm	r7,lr
80003b40:	1a 97       	mov	r7,sp
80003b42:	20 3d       	sub	sp,12
80003b44:	18 98       	mov	r8,r12
80003b46:	ef 68 ff f4 	st.b	r7[-12],r8
	bool b_stall_cleared = false;
80003b4a:	30 08       	mov	r8,0
80003b4c:	ef 68 ff fb 	st.b	r7[-5],r8
	udd_ep_job_t *ptr_job;

	ep &= USB_EP_ADDR_MASK;
80003b50:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b54:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003b58:	ef 68 ff f4 	st.b	r7[-12],r8
	if (USB_DEVICE_MAX_EP < ep)
80003b5c:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003b60:	30 38       	mov	r8,3
80003b62:	f0 09 18 00 	cp.b	r9,r8
80003b66:	e0 88 00 04 	brls	80003b6e <udd_ep_clear_halt+0x32>
		return false;
80003b6a:	30 08       	mov	r8,0
80003b6c:	c8 18       	rjmp	80003c6e <udd_ep_clear_halt+0x132>
	ptr_job = &udd_ep_job[ep - 1];
80003b6e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003b72:	f0 c9 00 01 	sub	r9,r8,1
80003b76:	12 98       	mov	r8,r9
80003b78:	a3 68       	lsl	r8,0x2
80003b7a:	12 08       	add	r8,r9
80003b7c:	a3 68       	lsl	r8,0x2
80003b7e:	10 99       	mov	r9,r8
80003b80:	4b e8       	lddpc	r8,80003c78 <udd_ep_clear_halt+0x13c>
80003b82:	f2 08 00 08 	add	r8,r9,r8
80003b86:	ef 48 ff fc 	st.w	r7[-4],r8

	if (ptr_job->stall_requested) {
80003b8a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003b8e:	70 08       	ld.w	r8,r8[0x0]
80003b90:	e6 18 20 00 	andh	r8,0x2000,COH
80003b94:	c1 c0       	breq	80003bcc <udd_ep_clear_halt+0x90>
		// Endpoint stall has been requested but not done
		// Remove stall request
		ptr_job->stall_requested = false;
80003b96:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003b9a:	72 08       	ld.w	r8,r9[0x0]
80003b9c:	30 0a       	mov	r10,0
80003b9e:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
80003ba2:	93 08       	st.w	r9[0x0],r8
		udd_disable_bank_interrupt(ep);
80003ba4:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003ba8:	a3 68       	lsl	r8,0x2
80003baa:	e0 38 fd e0 	sub	r8,130528
80003bae:	e0 69 10 00 	mov	r9,4096
80003bb2:	91 09       	st.w	r8[0x0],r9
		udd_disable_endpoint_interrupt(ep);
80003bb4:	fe 68 00 00 	mov	r8,-131072
80003bb8:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003bbc:	e0 6a 10 00 	mov	r10,4096
80003bc0:	f4 09 09 49 	lsl	r9,r10,r9
80003bc4:	91 59       	st.w	r8[0x14],r9
		b_stall_cleared = true;
80003bc6:	30 18       	mov	r8,1
80003bc8:	ef 68 ff fb 	st.b	r7[-5],r8
	}
	if (Is_udd_endpoint_stall_requested(ep)) { 
80003bcc:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003bd0:	a3 68       	lsl	r8,0x2
80003bd2:	e0 38 fe 40 	sub	r8,130624
80003bd6:	70 08       	ld.w	r8,r8[0x0]
80003bd8:	e6 18 00 08 	andh	r8,0x8,COH
80003bdc:	c3 10       	breq	80003c3e <udd_ep_clear_halt+0x102>
		if (Is_udd_stall(ep)) {
80003bde:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003be2:	a3 68       	lsl	r8,0x2
80003be4:	e0 38 fe d0 	sub	r8,130768
80003be8:	70 08       	ld.w	r8,r8[0x0]
80003bea:	e2 18 00 40 	andl	r8,0x40,COH
80003bee:	c1 00       	breq	80003c0e <udd_ep_clear_halt+0xd2>
			udd_ack_stall(ep);
80003bf0:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003bf4:	a3 68       	lsl	r8,0x2
80003bf6:	e0 38 fe a0 	sub	r8,130720
80003bfa:	34 09       	mov	r9,64
80003bfc:	91 09       	st.w	r8[0x0],r9
			// A packet has been stalled
			// then reset datatoggle
			udd_reset_data_toggle(ep);
80003bfe:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003c02:	a3 68       	lsl	r8,0x2
80003c04:	e0 38 fe 10 	sub	r8,130576
80003c08:	e4 69 00 00 	mov	r9,262144
80003c0c:	91 09       	st.w	r8[0x0],r9
		}
		// Disable stall
		udd_disable_stall_handshake(ep);
80003c0e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003c12:	a3 68       	lsl	r8,0x2
80003c14:	e0 38 fd e0 	sub	r8,130528
80003c18:	e8 69 00 00 	mov	r9,524288
80003c1c:	91 09       	st.w	r8[0x0],r9
		udd_enable_endpoint_bank_autoswitch(ep);
80003c1e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003c22:	a3 68       	lsl	r8,0x2
80003c24:	e0 38 ff 00 	sub	r8,130816
80003c28:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003c2c:	a3 69       	lsl	r9,0x2
80003c2e:	e0 39 ff 00 	sub	r9,130816
80003c32:	72 09       	ld.w	r9,r9[0x0]
80003c34:	a9 b9       	sbr	r9,0x9
80003c36:	91 09       	st.w	r8[0x0],r9
		b_stall_cleared = true;
80003c38:	30 18       	mov	r8,1
80003c3a:	ef 68 ff fb 	st.b	r7[-5],r8
	}
	if (b_stall_cleared) {
80003c3e:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003c42:	30 08       	mov	r8,0
80003c44:	f0 09 18 00 	cp.b	r9,r8
80003c48:	c1 20       	breq	80003c6c <udd_ep_clear_halt+0x130>
		// If a job is register on clear halt action
		// then execute callback
		if (ptr_job->busy == true) {
80003c4a:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c4e:	70 08       	ld.w	r8,r8[0x0]
80003c50:	e6 18 80 00 	andh	r8,0x8000,COH
80003c54:	c0 c0       	breq	80003c6c <udd_ep_clear_halt+0x130>
			ptr_job->busy = false;
80003c56:	ee f9 ff fc 	ld.w	r9,r7[-4]
80003c5a:	72 08       	ld.w	r8,r9[0x0]
80003c5c:	30 0a       	mov	r10,0
80003c5e:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80003c62:	93 08       	st.w	r9[0x0],r8
			ptr_job->call_nohalt();
80003c64:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003c68:	70 48       	ld.w	r8,r8[0x10]
80003c6a:	5d 18       	icall	r8
		}
	}
	return true;
80003c6c:	30 18       	mov	r8,1
}
80003c6e:	10 9c       	mov	r12,r8
80003c70:	2f dd       	sub	sp,-12
80003c72:	e3 cd 80 80 	ldm	sp++,r7,pc
80003c76:	00 00       	add	r0,r0
80003c78:	00 00       	add	r0,r0
80003c7a:	01 9c       	ld.ub	r12,r0[0x1]

80003c7c <udd_ep_run>:


bool udd_ep_run(udd_ep_id_t ep, bool b_shortpacket,
		uint8_t * buf, iram_size_t buf_size,
		udd_callback_trans_t callback)
{
80003c7c:	eb cd 40 80 	pushm	r7,lr
80003c80:	1a 97       	mov	r7,sp
80003c82:	20 7d       	sub	sp,28
80003c84:	ef 4a ff ec 	st.w	r7[-20],r10
80003c88:	ef 49 ff e8 	st.w	r7[-24],r9
80003c8c:	ef 48 ff e4 	st.w	r7[-28],r8
80003c90:	18 98       	mov	r8,r12
80003c92:	ef 68 ff f4 	st.b	r7[-12],r8
80003c96:	16 98       	mov	r8,r11
80003c98:	ef 68 ff f0 	st.b	r7[-16],r8
	udd_ep_job_t *ptr_job;
	irqflags_t flags;

	ep &= USB_EP_ADDR_MASK;
80003c9c:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003ca0:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003ca4:	ef 68 ff f4 	st.b	r7[-12],r8
	if (USB_DEVICE_MAX_EP < ep) {
80003ca8:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80003cac:	30 38       	mov	r8,3
80003cae:	f0 09 18 00 	cp.b	r9,r8
80003cb2:	e0 88 00 04 	brls	80003cba <udd_ep_run+0x3e>
		return false;
80003cb6:	30 08       	mov	r8,0
80003cb8:	c6 88       	rjmp	80003d88 <udd_ep_run+0x10c>
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];
80003cba:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003cbe:	f0 c9 00 01 	sub	r9,r8,1
80003cc2:	12 98       	mov	r8,r9
80003cc4:	a3 68       	lsl	r8,0x2
80003cc6:	12 08       	add	r8,r9
80003cc8:	a3 68       	lsl	r8,0x2
80003cca:	10 99       	mov	r9,r8
80003ccc:	4b 18       	lddpc	r8,80003d90 <udd_ep_run+0x114>
80003cce:	f2 08 00 08 	add	r8,r9,r8
80003cd2:	ef 48 ff f8 	st.w	r7[-8],r8

	if ((!Is_udd_endpoint_enabled(ep))
80003cd6:	fe 68 00 00 	mov	r8,-131072
80003cda:	70 79       	ld.w	r9,r8[0x1c]
80003cdc:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003ce0:	30 1a       	mov	r10,1
80003ce2:	f4 08 09 48 	lsl	r8,r10,r8
80003ce6:	f3 e8 00 08 	and	r8,r9,r8
80003cea:	c1 00       	breq	80003d0a <udd_ep_run+0x8e>
			|| Is_udd_endpoint_stall_requested(ep)
80003cec:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003cf0:	a3 68       	lsl	r8,0x2
80003cf2:	e0 38 fe 40 	sub	r8,130624
80003cf6:	70 08       	ld.w	r8,r8[0x0]
80003cf8:	e6 18 00 08 	andh	r8,0x8,COH
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80003cfc:	c0 71       	brne	80003d0a <udd_ep_run+0x8e>
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested) {
80003cfe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d02:	70 08       	ld.w	r8,r8[0x0]
80003d04:	e6 18 20 00 	andh	r8,0x2000,COH
	}

	// Get job about endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if ((!Is_udd_endpoint_enabled(ep))
80003d08:	c0 30       	breq	80003d0e <udd_ep_run+0x92>
			|| Is_udd_endpoint_stall_requested(ep)
			|| ptr_job->stall_requested) {
		return false; // Endpoint is halted
80003d0a:	30 08       	mov	r8,0
80003d0c:	c3 e8       	rjmp	80003d88 <udd_ep_run+0x10c>
	}

	flags = cpu_irq_save();
80003d0e:	f0 1f 00 22 	mcall	80003d94 <udd_ep_run+0x118>
80003d12:	18 98       	mov	r8,r12
80003d14:	ef 48 ff fc 	st.w	r7[-4],r8
	if (ptr_job->busy == true) {
80003d18:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d1c:	70 08       	ld.w	r8,r8[0x0]
80003d1e:	e6 18 80 00 	andh	r8,0x8000,COH
80003d22:	c0 70       	breq	80003d30 <udd_ep_run+0xb4>
		cpu_irq_restore(flags);
80003d24:	ee fc ff fc 	ld.w	r12,r7[-4]
80003d28:	f0 1f 00 1c 	mcall	80003d98 <udd_ep_run+0x11c>
		return false; // Job already on going
80003d2c:	30 08       	mov	r8,0
80003d2e:	c2 d8       	rjmp	80003d88 <udd_ep_run+0x10c>
	}
	ptr_job->busy = true;
80003d30:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003d34:	72 08       	ld.w	r8,r9[0x0]
80003d36:	30 1a       	mov	r10,1
80003d38:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
80003d3c:	93 08       	st.w	r9[0x0],r8
	cpu_irq_restore(flags);
80003d3e:	ee fc ff fc 	ld.w	r12,r7[-4]
80003d42:	f0 1f 00 16 	mcall	80003d98 <udd_ep_run+0x11c>

	// No job running. Let's setup a new one.
	//
	ptr_job->buf = buf;
80003d46:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d4a:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003d4e:	91 19       	st.w	r8[0x4],r9
	ptr_job->buf_size = buf_size;
80003d50:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d54:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003d58:	91 29       	st.w	r8[0x8],r9
	ptr_job->nb_trans = 0;
80003d5a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d5e:	30 09       	mov	r9,0
80003d60:	91 39       	st.w	r8[0xc],r9
	ptr_job->call_trans = callback;
80003d62:	ee f8 ff f8 	ld.w	r8,r7[-8]
80003d66:	ee f9 ff e4 	ld.w	r9,r7[-28]
80003d6a:	91 49       	st.w	r8[0x10],r9
	ptr_job->b_shortpacket = b_shortpacket;
80003d6c:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003d70:	72 08       	ld.w	r8,r9[0x0]
80003d72:	ef 3a ff f0 	ld.ub	r10,r7[-16]
80003d76:	f1 da d3 c1 	bfins	r8,r10,0x1e,0x1
80003d7a:	93 08       	st.w	r9[0x0],r8


	// Request first transfer
	udd_ep_trans_done(ep);
80003d7c:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80003d80:	10 9c       	mov	r12,r8
80003d82:	f0 1f 00 07 	mcall	80003d9c <udd_ep_run+0x120>
	return true;
80003d86:	30 18       	mov	r8,1
}
80003d88:	10 9c       	mov	r12,r8
80003d8a:	2f 9d       	sub	sp,-28
80003d8c:	e3 cd 80 80 	ldm	sp++,r7,pc
80003d90:	00 00       	add	r0,r0
80003d92:	01 9c       	ld.ub	r12,r0[0x1]
80003d94:	80 00       	ld.sh	r0,r0[0x0]
80003d96:	30 06       	mov	r6,0
80003d98:	80 00       	ld.sh	r0,r0[0x0]
80003d9a:	30 44       	mov	r4,4
80003d9c:	80 00       	ld.sh	r0,r0[0x0]
80003d9e:	48 20       	lddpc	r0,80003da4 <udd_ep_abort+0x4>

80003da0 <udd_ep_abort>:


void udd_ep_abort(udd_ep_id_t ep)
{
80003da0:	eb cd 40 80 	pushm	r7,lr
80003da4:	1a 97       	mov	r7,sp
80003da6:	20 2d       	sub	sp,8
80003da8:	18 98       	mov	r8,r12
80003daa:	ef 68 ff f8 	st.b	r7[-8],r8
	uint8_t index = ep & USB_EP_ADDR_MASK;
80003dae:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003db2:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80003db6:	ef 68 ff ff 	st.b	r7[-1],r8

	// Stop DMA transfer
	udd_disable_endpoint_dma_interrupt(index);
80003dba:	fe 68 00 00 	mov	r8,-131072
80003dbe:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003dc2:	20 19       	sub	r9,1
80003dc4:	30 0a       	mov	r10,0
80003dc6:	ea 1a 02 00 	orh	r10,0x200
80003dca:	f4 09 09 49 	lsl	r9,r10,r9
80003dce:	91 59       	st.w	r8[0x14],r9
	udd_endpoint_dma_set_control(index, 0);
80003dd0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003dd4:	a5 68       	lsl	r8,0x4
80003dd6:	e0 38 fd 00 	sub	r8,130304
80003dda:	30 09       	mov	r9,0
80003ddc:	91 29       	st.w	r8[0x8],r9
	// Kill banks
	udd_disable_endpoint_interrupt(index);
80003dde:	fe 68 00 00 	mov	r8,-131072
80003de2:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80003de6:	e0 6a 10 00 	mov	r10,4096
80003dea:	f4 09 09 49 	lsl	r9,r10,r9
80003dee:	91 59       	st.w	r8[0x14],r9
	while (udd_nb_busy_bank(index)) {
80003df0:	c1 28       	rjmp	80003e14 <udd_ep_abort+0x74>
		udd_kill_last_in_bank(index);
80003df2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003df6:	a3 68       	lsl	r8,0x2
80003df8:	e0 38 fe 10 	sub	r8,130576
80003dfc:	e0 69 20 00 	mov	r9,8192
80003e00:	91 09       	st.w	r8[0x0],r9
		while(Is_udd_killing_last_in_bank(index));
80003e02:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003e06:	a3 68       	lsl	r8,0x2
80003e08:	e0 38 fe 40 	sub	r8,130624
80003e0c:	70 08       	ld.w	r8,r8[0x0]
80003e0e:	e2 18 20 00 	andl	r8,0x2000,COH
80003e12:	cf 81       	brne	80003e02 <udd_ep_abort+0x62>
	// Stop DMA transfer
	udd_disable_endpoint_dma_interrupt(index);
	udd_endpoint_dma_set_control(index, 0);
	// Kill banks
	udd_disable_endpoint_interrupt(index);
	while (udd_nb_busy_bank(index)) {
80003e14:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80003e18:	a3 68       	lsl	r8,0x2
80003e1a:	e0 38 fe d0 	sub	r8,130768
80003e1e:	70 08       	ld.w	r8,r8[0x0]
80003e20:	e2 18 30 00 	andl	r8,0x3000,COH
80003e24:	ad 88       	lsr	r8,0xc
80003e26:	ce 61       	brne	80003df2 <udd_ep_abort+0x52>
		udd_kill_last_in_bank(index);
		while(Is_udd_killing_last_in_bank(index));
	}
	udd_ep_abort_job(ep);
80003e28:	ef 38 ff f8 	ld.ub	r8,r7[-8]
80003e2c:	10 9c       	mov	r12,r8
80003e2e:	f0 1f 00 03 	mcall	80003e38 <udd_ep_abort+0x98>
}
80003e32:	2f ed       	sub	sp,-8
80003e34:	e3 cd 80 80 	ldm	sp++,r7,pc
80003e38:	80 00       	ld.sh	r0,r0[0x0]
80003e3a:	47 50       	lddsp	r0,sp[0x1d4]

80003e3c <udd_reset_ep_ctrl>:

//--------------------------------------------------------
//--- INTERNAL ROUTINES TO MANAGED THE CONTROL ENDPOINT

static void udd_reset_ep_ctrl(void)
{
80003e3c:	eb cd 40 80 	pushm	r7,lr
80003e40:	1a 97       	mov	r7,sp
80003e42:	20 7d       	sub	sp,28
	irqflags_t flags;

	// Reset USB address to 0
	udd_configure_address(0);
80003e44:	fe 68 00 00 	mov	r8,-131072
80003e48:	fe 69 00 00 	mov	r9,-131072
80003e4c:	72 09       	ld.w	r9,r9[0x0]
80003e4e:	e0 19 ff 80 	andl	r9,0xff80
80003e52:	91 09       	st.w	r8[0x0],r9
	udd_enable_address();
80003e54:	fe 68 00 00 	mov	r8,-131072
80003e58:	fe 69 00 00 	mov	r9,-131072
80003e5c:	72 09       	ld.w	r9,r9[0x0]
80003e5e:	a7 b9       	sbr	r9,0x7
80003e60:	91 09       	st.w	r8[0x0],r9

	// Alloc and configure control endpoint
	udd_configure_endpoint(0,
80003e62:	fe 68 01 00 	mov	r8,-130816
80003e66:	fe 69 01 00 	mov	r9,-130816
80003e6a:	72 09       	ld.w	r9,r9[0x0]
80003e6c:	12 9a       	mov	r10,r9
80003e6e:	e0 1a e6 83 	andl	r10,0xe683
80003e72:	34 09       	mov	r9,64
80003e74:	ef 49 ff f8 	st.w	r7[-8],r9
80003e78:	30 89       	mov	r9,8
80003e7a:	ef 49 ff fc 	st.w	r7[-4],r9
80003e7e:	ee f9 ff f8 	ld.w	r9,r7[-8]
80003e82:	ee fb ff fc 	ld.w	r11,r7[-4]
80003e86:	f2 0b 0c 49 	max	r9,r9,r11
80003e8a:	ef 49 ff f4 	st.w	r7[-12],r9
80003e8e:	ee f9 ff f4 	ld.w	r9,r7[-12]
80003e92:	ef 49 ff ec 	st.w	r7[-20],r9
80003e96:	e0 69 04 00 	mov	r9,1024
80003e9a:	ef 49 ff f0 	st.w	r7[-16],r9
80003e9e:	ee f9 ff ec 	ld.w	r9,r7[-20]
80003ea2:	ee fb ff f0 	ld.w	r11,r7[-16]
80003ea6:	f2 0b 0d 49 	min	r9,r9,r11
80003eaa:	ef 49 ff e8 	st.w	r7[-24],r9
80003eae:	ee f9 ff e8 	ld.w	r9,r7[-24]
80003eb2:	a1 79       	lsl	r9,0x1
80003eb4:	20 19       	sub	r9,1
80003eb6:	f2 09 12 00 	clz	r9,r9
80003eba:	f2 09 11 1c 	rsub	r9,r9,28
80003ebe:	a5 69       	lsl	r9,0x4
80003ec0:	e2 19 19 7c 	andl	r9,0x197c,COH
80003ec4:	f5 e9 10 09 	or	r9,r10,r9
80003ec8:	91 09       	st.w	r8[0x0],r9
			USB_EP_TYPE_CONTROL,
			0,
			USB_DEVICE_EP_CTRL_SIZE, AVR32_USBB_UECFG0_EPBK_SINGLE);

	udd_allocate_memory(0);
80003eca:	fe 68 01 00 	mov	r8,-130816
80003ece:	fe 69 01 00 	mov	r9,-130816
80003ed2:	72 09       	ld.w	r9,r9[0x0]
80003ed4:	a1 b9       	sbr	r9,0x1
80003ed6:	91 09       	st.w	r8[0x0],r9
	udd_enable_endpoint(0);
80003ed8:	fe 68 00 00 	mov	r8,-131072
80003edc:	fe 69 00 00 	mov	r9,-131072
80003ee0:	72 79       	ld.w	r9,r9[0x1c]
80003ee2:	a1 a9       	sbr	r9,0x0
80003ee4:	91 79       	st.w	r8[0x1c],r9
	flags = cpu_irq_save();
80003ee6:	f0 1f 00 0d 	mcall	80003f18 <udd_reset_ep_ctrl+0xdc>
80003eea:	18 98       	mov	r8,r12
80003eec:	ef 48 ff e4 	st.w	r7[-28],r8
	udd_enable_setup_received_interrupt(0);
80003ef0:	fe 68 01 f0 	mov	r8,-130576
80003ef4:	30 49       	mov	r9,4
80003ef6:	91 09       	st.w	r8[0x0],r9
	udd_enable_out_received_interrupt(0);
80003ef8:	fe 68 01 f0 	mov	r8,-130576
80003efc:	30 29       	mov	r9,2
80003efe:	91 09       	st.w	r8[0x0],r9
	udd_enable_endpoint_interrupt(0);
80003f00:	fe 68 00 00 	mov	r8,-131072
80003f04:	e0 69 10 00 	mov	r9,4096
80003f08:	91 69       	st.w	r8[0x18],r9
	cpu_irq_restore(flags);
80003f0a:	ee fc ff e4 	ld.w	r12,r7[-28]
80003f0e:	f0 1f 00 04 	mcall	80003f1c <udd_reset_ep_ctrl+0xe0>
}
80003f12:	2f 9d       	sub	sp,-28
80003f14:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f18:	80 00       	ld.sh	r0,r0[0x0]
80003f1a:	30 06       	mov	r6,0
80003f1c:	80 00       	ld.sh	r0,r0[0x0]
80003f1e:	30 44       	mov	r4,4

80003f20 <udd_ctrl_init>:

static void udd_ctrl_init(void)
{
80003f20:	eb cd 40 80 	pushm	r7,lr
80003f24:	1a 97       	mov	r7,sp
80003f26:	20 1d       	sub	sp,4
	irqflags_t flags;
	flags = cpu_irq_save();
80003f28:	f0 1f 00 10 	mcall	80003f68 <udd_ctrl_init+0x48>
80003f2c:	18 98       	mov	r8,r12
80003f2e:	ef 48 ff fc 	st.w	r7[-4],r8
	// In case of abort of IN Data Phase:
	// No need to abort IN transfer (rise TXINI),
	// because it is automatically done by hardware when a Setup packet is received.
	// But the interrupt must be disabled to don't generate interrupt TXINI
	// after SETUP reception.
	udd_disable_in_send_interrupt(0);
80003f32:	fe 68 02 20 	mov	r8,-130528
80003f36:	30 19       	mov	r9,1
80003f38:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
80003f3a:	ee fc ff fc 	ld.w	r12,r7[-4]
80003f3e:	f0 1f 00 0c 	mcall	80003f6c <udd_ctrl_init+0x4c>

	// In case of OUT ZLP event is no processed before Setup event occurs
	udd_ack_out_received(0);
80003f42:	fe 68 01 60 	mov	r8,-130720
80003f46:	30 29       	mov	r9,2
80003f48:	91 09       	st.w	r8[0x0],r9

	udd_g_ctrlreq.callback = NULL;
80003f4a:	48 a8       	lddpc	r8,80003f70 <udd_ctrl_init+0x50>
80003f4c:	30 09       	mov	r9,0
80003f4e:	91 49       	st.w	r8[0x10],r9
	udd_g_ctrlreq.over_under_run = NULL;
80003f50:	48 88       	lddpc	r8,80003f70 <udd_ctrl_init+0x50>
80003f52:	30 09       	mov	r9,0
80003f54:	91 59       	st.w	r8[0x14],r9
	udd_g_ctrlreq.payload_size = 0;
80003f56:	48 79       	lddpc	r9,80003f70 <udd_ctrl_init+0x50>
80003f58:	30 08       	mov	r8,0
80003f5a:	b2 68       	st.h	r9[0xc],r8
	udd_ep_control_state = UDD_EPCTRL_SETUP;
80003f5c:	48 68       	lddpc	r8,80003f74 <udd_ctrl_init+0x54>
80003f5e:	30 09       	mov	r9,0
80003f60:	91 09       	st.w	r8[0x0],r9
}
80003f62:	2f fd       	sub	sp,-4
80003f64:	e3 cd 80 80 	ldm	sp++,r7,pc
80003f68:	80 00       	ld.sh	r0,r0[0x0]
80003f6a:	30 06       	mov	r6,0
80003f6c:	80 00       	ld.sh	r0,r0[0x0]
80003f6e:	30 44       	mov	r4,4
80003f70:	00 00       	add	r0,r0
80003f72:	46 48       	lddsp	r8,sp[0x190]
80003f74:	00 00       	add	r0,r0
80003f76:	01 94       	ld.ub	r4,r0[0x1]

80003f78 <udd_ctrl_setup_received>:


static void udd_ctrl_setup_received(void)
{
80003f78:	eb cd 40 80 	pushm	r7,lr
80003f7c:	1a 97       	mov	r7,sp
80003f7e:	20 3d       	sub	sp,12
	irqflags_t flags;
	uint8_t i;

	if (UDD_EPCTRL_SETUP != udd_ep_control_state) {
80003f80:	4c c8       	lddpc	r8,800040b0 <udd_ctrl_setup_received+0x138>
80003f82:	70 08       	ld.w	r8,r8[0x0]
80003f84:	58 08       	cp.w	r8,0
80003f86:	c0 50       	breq	80003f90 <udd_ctrl_setup_received+0x18>
		// May be a hidden DATA or ZLP phase
		// or protocol abort
		udd_ctrl_endofrequest();
80003f88:	f0 1f 00 4b 	mcall	800040b4 <udd_ctrl_setup_received+0x13c>

		// Reinitializes control endpoint management
		udd_ctrl_init();
80003f8c:	f0 1f 00 4b 	mcall	800040b8 <udd_ctrl_setup_received+0x140>
	}
	// Fill setup request structure
	if (8 != udd_byte_count(0)) {
80003f90:	fe 68 01 30 	mov	r8,-130768
80003f94:	70 08       	ld.w	r8,r8[0x0]
80003f96:	e6 18 7f f0 	andh	r8,0x7ff0,COH
80003f9a:	b5 88       	lsr	r8,0x14
80003f9c:	58 88       	cp.w	r8,8
80003f9e:	c0 80       	breq	80003fae <udd_ctrl_setup_received+0x36>
		udd_ctrl_stall_data();
80003fa0:	f0 1f 00 47 	mcall	800040bc <udd_ctrl_setup_received+0x144>
		udd_ack_setup_received(0);
80003fa4:	fe 68 01 60 	mov	r8,-130720
80003fa8:	30 49       	mov	r9,4
80003faa:	91 09       	st.w	r8[0x0],r9
		return; // Error data number doesn't correspond to SETUP packet
80003fac:	c7 e8       	rjmp	800040a8 <udd_ctrl_setup_received+0x130>
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
80003fae:	30 08       	mov	r8,0
80003fb0:	ea 18 d0 00 	orh	r8,0xd000
80003fb4:	ef 48 ff fc 	st.w	r7[-4],r8
	for (i = 0; i < 8; i++) {
80003fb8:	30 08       	mov	r8,0
80003fba:	ef 68 ff fb 	st.b	r7[-5],r8
80003fbe:	c1 38       	rjmp	80003fe4 <udd_ctrl_setup_received+0x6c>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
80003fc0:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003fc4:	4b f8       	lddpc	r8,800040c0 <udd_ctrl_setup_received+0x148>
80003fc6:	10 09       	add	r9,r8
80003fc8:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fcc:	11 88       	ld.ub	r8,r8[0x0]
80003fce:	b2 88       	st.b	r9[0x0],r8
80003fd0:	ee f8 ff fc 	ld.w	r8,r7[-4]
80003fd4:	2f f8       	sub	r8,-1
80003fd6:	ef 48 ff fc 	st.w	r7[-4],r8
		udd_ctrl_stall_data();
		udd_ack_setup_received(0);
		return; // Error data number doesn't correspond to SETUP packet
	}
	uint8_t *ptr = (uint8_t *) & udd_get_endpoint_fifo_access(0,8);
	for (i = 0; i < 8; i++) {
80003fda:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80003fde:	2f f8       	sub	r8,-1
80003fe0:	ef 68 ff fb 	st.b	r7[-5],r8
80003fe4:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80003fe8:	30 78       	mov	r8,7
80003fea:	f0 09 18 00 	cp.b	r9,r8
80003fee:	fe 98 ff e9 	brls	80003fc0 <udd_ctrl_setup_received+0x48>
		((uint8_t*) &udd_g_ctrlreq.req)[i] = *ptr++;
	}
	// Manage LSB/MSB to fit with CPU usage
	udd_g_ctrlreq.req.wValue = le16_to_cpu(udd_g_ctrlreq.req.wValue);
80003ff2:	4b 48       	lddpc	r8,800040c0 <udd_ctrl_setup_received+0x148>
80003ff4:	90 18       	ld.sh	r8,r8[0x2]
80003ff6:	5c 88       	casts.h	r8
80003ff8:	5c c8       	swap.bh	r8
80003ffa:	5c 88       	casts.h	r8
80003ffc:	4b 19       	lddpc	r9,800040c0 <udd_ctrl_setup_received+0x148>
80003ffe:	b2 18       	st.h	r9[0x2],r8
	udd_g_ctrlreq.req.wIndex = le16_to_cpu(udd_g_ctrlreq.req.wIndex);
80004000:	4b 08       	lddpc	r8,800040c0 <udd_ctrl_setup_received+0x148>
80004002:	90 28       	ld.sh	r8,r8[0x4]
80004004:	5c 88       	casts.h	r8
80004006:	5c c8       	swap.bh	r8
80004008:	5c 88       	casts.h	r8
8000400a:	4a e9       	lddpc	r9,800040c0 <udd_ctrl_setup_received+0x148>
8000400c:	b2 28       	st.h	r9[0x4],r8
	udd_g_ctrlreq.req.wLength = le16_to_cpu(udd_g_ctrlreq.req.wLength);
8000400e:	4a d8       	lddpc	r8,800040c0 <udd_ctrl_setup_received+0x148>
80004010:	90 38       	ld.sh	r8,r8[0x6]
80004012:	5c 88       	casts.h	r8
80004014:	5c c8       	swap.bh	r8
80004016:	5c 88       	casts.h	r8
80004018:	4a a9       	lddpc	r9,800040c0 <udd_ctrl_setup_received+0x148>
8000401a:	b2 38       	st.h	r9[0x6],r8

	// Decode setup request
	if (udc_process_setup() == false) {
8000401c:	f0 1f 00 2a 	mcall	800040c4 <udd_ctrl_setup_received+0x14c>
80004020:	18 98       	mov	r8,r12
80004022:	ec 18 00 01 	eorl	r8,0x1
80004026:	5c 58       	castu.b	r8
80004028:	c0 80       	breq	80004038 <udd_ctrl_setup_received+0xc0>
		// Setup request unknown then stall it
		udd_ctrl_stall_data();
8000402a:	f0 1f 00 25 	mcall	800040bc <udd_ctrl_setup_received+0x144>
		udd_ack_setup_received(0);
8000402e:	fe 68 01 60 	mov	r8,-130720
80004032:	30 49       	mov	r9,4
80004034:	91 09       	st.w	r8[0x0],r9
		return;
80004036:	c3 98       	rjmp	800040a8 <udd_ctrl_setup_received+0x130>
	}
	udd_ack_setup_received(0);
80004038:	fe 68 01 60 	mov	r8,-130720
8000403c:	30 49       	mov	r9,4
8000403e:	91 09       	st.w	r8[0x0],r9

	if (Udd_setup_is_in()) {
80004040:	4a 08       	lddpc	r8,800040c0 <udd_ctrl_setup_received+0x148>
80004042:	11 88       	ld.ub	r8,r8[0x0]
80004044:	10 99       	mov	r9,r8
80004046:	30 08       	mov	r8,0
80004048:	f0 09 18 00 	cp.b	r9,r8
8000404c:	c0 d4       	brge	80004066 <udd_ctrl_setup_received+0xee>
		// IN data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
8000404e:	49 f9       	lddpc	r9,800040c8 <udd_ctrl_setup_received+0x150>
80004050:	30 08       	mov	r8,0
80004052:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
80004054:	49 e9       	lddpc	r9,800040cc <udd_ctrl_setup_received+0x154>
80004056:	30 08       	mov	r8,0
80004058:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_IN;
8000405a:	49 68       	lddpc	r8,800040b0 <udd_ctrl_setup_received+0x138>
8000405c:	30 29       	mov	r9,2
8000405e:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_in_sent(); // Send first data transfer
80004060:	f0 1f 00 1c 	mcall	800040d0 <udd_ctrl_setup_received+0x158>
80004064:	c2 28       	rjmp	800040a8 <udd_ctrl_setup_received+0x130>
	} else {
		if (0 == udd_g_ctrlreq.req.wLength) {
80004066:	49 78       	lddpc	r8,800040c0 <udd_ctrl_setup_received+0x148>
80004068:	90 38       	ld.sh	r8,r8[0x6]
8000406a:	58 08       	cp.w	r8,0
8000406c:	c0 41       	brne	80004074 <udd_ctrl_setup_received+0xfc>
			// No data phase requested
			// Send IN ZLP to ACK setup request
			udd_ctrl_send_zlp_in();
8000406e:	f0 1f 00 1a 	mcall	800040d4 <udd_ctrl_setup_received+0x15c>
			return;
80004072:	c1 b8       	rjmp	800040a8 <udd_ctrl_setup_received+0x130>
		}
		// OUT data phase requested
		udd_ctrl_prev_payload_nb_trans = 0;
80004074:	49 59       	lddpc	r9,800040c8 <udd_ctrl_setup_received+0x150>
80004076:	30 08       	mov	r8,0
80004078:	b2 08       	st.h	r9[0x0],r8
		udd_ctrl_payload_nb_trans = 0;
8000407a:	49 59       	lddpc	r9,800040cc <udd_ctrl_setup_received+0x154>
8000407c:	30 08       	mov	r8,0
8000407e:	b2 08       	st.h	r9[0x0],r8
		udd_ep_control_state = UDD_EPCTRL_DATA_OUT;
80004080:	48 c8       	lddpc	r8,800040b0 <udd_ctrl_setup_received+0x138>
80004082:	30 19       	mov	r9,1
80004084:	91 09       	st.w	r8[0x0],r9
		// To detect a protocol error, enable nak interrupt on data IN phase
		udd_ack_nak_in(0);
80004086:	fe 68 01 60 	mov	r8,-130720
8000408a:	31 09       	mov	r9,16
8000408c:	91 09       	st.w	r8[0x0],r9
		flags = cpu_irq_save();
8000408e:	f0 1f 00 13 	mcall	800040d8 <udd_ctrl_setup_received+0x160>
80004092:	18 98       	mov	r8,r12
80004094:	ef 48 ff f4 	st.w	r7[-12],r8
		udd_enable_nak_in_interrupt(0);
80004098:	fe 68 01 f0 	mov	r8,-130576
8000409c:	31 09       	mov	r9,16
8000409e:	91 09       	st.w	r8[0x0],r9
		cpu_irq_restore(flags);
800040a0:	ee fc ff f4 	ld.w	r12,r7[-12]
800040a4:	f0 1f 00 0e 	mcall	800040dc <udd_ctrl_setup_received+0x164>
	}
}
800040a8:	2f dd       	sub	sp,-12
800040aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800040ae:	00 00       	add	r0,r0
800040b0:	00 00       	add	r0,r0
800040b2:	01 94       	ld.ub	r4,r0[0x1]
800040b4:	80 00       	ld.sh	r0,r0[0x0]
800040b6:	45 a4       	lddsp	r4,sp[0x168]
800040b8:	80 00       	ld.sh	r0,r0[0x0]
800040ba:	3f 20       	mov	r0,-14
800040bc:	80 00       	ld.sh	r0,r0[0x0]
800040be:	44 ec       	lddsp	r12,sp[0x138]
800040c0:	00 00       	add	r0,r0
800040c2:	46 48       	lddsp	r8,sp[0x190]
800040c4:	80 00       	ld.sh	r0,r0[0x0]
800040c6:	72 e4       	ld.w	r4,r9[0x38]
800040c8:	00 00       	add	r0,r0
800040ca:	01 98       	ld.ub	r8,r0[0x1]
800040cc:	00 00       	add	r0,r0
800040ce:	01 9a       	ld.ub	r10,r0[0x1]
800040d0:	80 00       	ld.sh	r0,r0[0x0]
800040d2:	40 e0       	lddsp	r0,sp[0x38]
800040d4:	80 00       	ld.sh	r0,r0[0x0]
800040d6:	45 0c       	lddsp	r12,sp[0x140]
800040d8:	80 00       	ld.sh	r0,r0[0x0]
800040da:	30 06       	mov	r6,0
800040dc:	80 00       	ld.sh	r0,r0[0x0]
800040de:	30 44       	mov	r4,4

800040e0 <udd_ctrl_in_sent>:


static void udd_ctrl_in_sent(void)
{
800040e0:	eb cd 40 80 	pushm	r7,lr
800040e4:	1a 97       	mov	r7,sp
800040e6:	20 4d       	sub	sp,16
	uint16_t nb_remain;
	uint8_t i;
	uint8_t *ptr_dest, *ptr_src;
	irqflags_t flags;

	flags = cpu_irq_save();
800040e8:	f0 1f 00 5c 	mcall	80004258 <udd_ctrl_in_sent+0x178>
800040ec:	18 98       	mov	r8,r12
800040ee:	ef 48 ff fc 	st.w	r7[-4],r8
	udd_disable_in_send_interrupt(0);
800040f2:	fe 68 02 20 	mov	r8,-130528
800040f6:	30 19       	mov	r9,1
800040f8:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
800040fa:	ee fc ff fc 	ld.w	r12,r7[-4]
800040fe:	f0 1f 00 58 	mcall	8000425c <udd_ctrl_in_sent+0x17c>

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
80004102:	4d 88       	lddpc	r8,80004260 <udd_ctrl_in_sent+0x180>
80004104:	70 08       	ld.w	r8,r8[0x0]
80004106:	58 38       	cp.w	r8,3
80004108:	c0 61       	brne	80004114 <udd_ctrl_in_sent+0x34>
		// ZLP on IN is sent, then valid end of setup request
		udd_ctrl_endofrequest();
8000410a:	f0 1f 00 57 	mcall	80004264 <udd_ctrl_in_sent+0x184>
		// Reinitializes control endpoint management
		udd_ctrl_init();
8000410e:	f0 1f 00 57 	mcall	80004268 <udd_ctrl_in_sent+0x188>
		return;
80004112:	ca 08       	rjmp	80004252 <udd_ctrl_in_sent+0x172>
	}
	Assert(udd_ep_control_state == UDD_EPCTRL_DATA_IN);

	nb_remain = udd_g_ctrlreq.payload_size - udd_ctrl_payload_nb_trans;
80004114:	4d 68       	lddpc	r8,8000426c <udd_ctrl_in_sent+0x18c>
80004116:	90 69       	ld.sh	r9,r8[0xc]
80004118:	4d 68       	lddpc	r8,80004270 <udd_ctrl_in_sent+0x190>
8000411a:	90 08       	ld.sh	r8,r8[0x0]
8000411c:	10 19       	sub	r9,r8
8000411e:	ef 59 ff f0 	st.h	r7[-16],r9
	if (0 == nb_remain) {
80004122:	ef 09 ff f0 	ld.sh	r9,r7[-16]
80004126:	30 08       	mov	r8,0
80004128:	f0 09 19 00 	cp.h	r9,r8
8000412c:	c2 b1       	brne	80004182 <udd_ctrl_in_sent+0xa2>
		// All content of current buffer payload are sent
		// Update number of total data sending by previous payload buffer
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
8000412e:	4d 28       	lddpc	r8,80004274 <udd_ctrl_in_sent+0x194>
80004130:	90 09       	ld.sh	r9,r8[0x0]
80004132:	4d 08       	lddpc	r8,80004270 <udd_ctrl_in_sent+0x190>
80004134:	90 08       	ld.sh	r8,r8[0x0]
80004136:	f2 08 00 08 	add	r8,r9,r8
8000413a:	5c 88       	casts.h	r8
8000413c:	4c e9       	lddpc	r9,80004274 <udd_ctrl_in_sent+0x194>
8000413e:	b2 08       	st.h	r9[0x0],r8
		if ((udd_g_ctrlreq.req.wLength == udd_ctrl_prev_payload_nb_trans)
80004140:	4c b8       	lddpc	r8,8000426c <udd_ctrl_in_sent+0x18c>
80004142:	90 39       	ld.sh	r9,r8[0x6]
80004144:	4c c8       	lddpc	r8,80004274 <udd_ctrl_in_sent+0x194>
80004146:	90 08       	ld.sh	r8,r8[0x0]
80004148:	f0 09 19 00 	cp.h	r9,r8
8000414c:	c0 50       	breq	80004156 <udd_ctrl_in_sent+0x76>
8000414e:	4c b8       	lddpc	r8,80004278 <udd_ctrl_in_sent+0x198>
80004150:	11 88       	ld.ub	r8,r8[0x0]
80004152:	58 08       	cp.w	r8,0
80004154:	c0 40       	breq	8000415c <udd_ctrl_in_sent+0x7c>
					|| b_shortpacket) {
			// All data requested are transfered or a short packet has been sent
			// then it is the end of data phase.
			// Generate an OUT ZLP for handshake phase.
			udd_ctrl_send_zlp_out();
80004156:	f0 1f 00 4a 	mcall	8000427c <udd_ctrl_in_sent+0x19c>
			return;
8000415a:	c7 c8       	rjmp	80004252 <udd_ctrl_in_sent+0x172>
		}
		// Need of new buffer because the data phase is not complete
		if ((!udd_g_ctrlreq.over_under_run)
8000415c:	4c 48       	lddpc	r8,8000426c <udd_ctrl_in_sent+0x18c>
8000415e:	70 58       	ld.w	r8,r8[0x14]
80004160:	58 08       	cp.w	r8,0
80004162:	c1 00       	breq	80004182 <udd_ctrl_in_sent+0xa2>
80004164:	4c 28       	lddpc	r8,8000426c <udd_ctrl_in_sent+0x18c>
80004166:	70 58       	ld.w	r8,r8[0x14]
80004168:	5d 18       	icall	r8
8000416a:	18 98       	mov	r8,r12
8000416c:	ec 18 00 01 	eorl	r8,0x1
80004170:	5c 58       	castu.b	r8
80004172:	c0 81       	brne	80004182 <udd_ctrl_in_sent+0xa2>
				|| (!udd_g_ctrlreq.over_under_run())) {
			// Underrun then send zlp on IN
			// Here nb_remain=0 and allows to send a IN ZLP
		} else {
			// A new payload buffer is given
			udd_ctrl_payload_nb_trans = 0;
80004174:	4b f9       	lddpc	r9,80004270 <udd_ctrl_in_sent+0x190>
80004176:	30 08       	mov	r8,0
80004178:	b2 08       	st.h	r9[0x0],r8
			nb_remain = udd_g_ctrlreq.payload_size;
8000417a:	4b d8       	lddpc	r8,8000426c <udd_ctrl_in_sent+0x18c>
8000417c:	90 68       	ld.sh	r8,r8[0xc]
8000417e:	ef 58 ff f0 	st.h	r7[-16],r8
		}
	}
	// Continue transfer and send next data
	if (nb_remain >= USB_DEVICE_EP_CTRL_SIZE) {
80004182:	ef 09 ff f0 	ld.sh	r9,r7[-16]
80004186:	33 f8       	mov	r8,63
80004188:	f0 09 19 00 	cp.h	r9,r8
8000418c:	e0 88 00 09 	brls	8000419e <udd_ctrl_in_sent+0xbe>
		nb_remain = USB_DEVICE_EP_CTRL_SIZE;
80004190:	34 08       	mov	r8,64
80004192:	ef 58 ff f0 	st.h	r7[-16],r8
		b_shortpacket = false;
80004196:	4b 99       	lddpc	r9,80004278 <udd_ctrl_in_sent+0x198>
80004198:	30 08       	mov	r8,0
8000419a:	b2 88       	st.b	r9[0x0],r8
8000419c:	c0 48       	rjmp	800041a4 <udd_ctrl_in_sent+0xc4>
	} else {
		b_shortpacket = true;
8000419e:	4b 79       	lddpc	r9,80004278 <udd_ctrl_in_sent+0x198>
800041a0:	30 18       	mov	r8,1
800041a2:	b2 88       	st.b	r9[0x0],r8
	}
	// Fill buffer of endpoint control
	ptr_dest = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
800041a4:	30 08       	mov	r8,0
800041a6:	ea 18 d0 00 	orh	r8,0xd000
800041aa:	ef 48 ff f4 	st.w	r7[-12],r8
	ptr_src = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
800041ae:	4b 08       	lddpc	r8,8000426c <udd_ctrl_in_sent+0x18c>
800041b0:	70 29       	ld.w	r9,r8[0x8]
800041b2:	4b 08       	lddpc	r8,80004270 <udd_ctrl_in_sent+0x190>
800041b4:	90 08       	ld.sh	r8,r8[0x0]
800041b6:	5c 78       	castu.h	r8
800041b8:	f2 08 00 08 	add	r8,r9,r8
800041bc:	ef 48 ff f8 	st.w	r7[-8],r8
	// The IN data don't must be written in endpoint 0 DPRAM during
	// a next setup reception in same endpoint 0 DPRAM.
	// Thereby, an OUT ZLP reception must check before IN data write
	// and if no OUT ZLP is received the data must be written quickly (800us)
	// before an eventually ZLP OUT and SETUP reception
	flags = cpu_irq_save();
800041c0:	f0 1f 00 26 	mcall	80004258 <udd_ctrl_in_sent+0x178>
800041c4:	18 98       	mov	r8,r12
800041c6:	ef 48 ff fc 	st.w	r7[-4],r8
	if (Is_udd_out_received(0)) {
800041ca:	fe 68 01 30 	mov	r8,-130768
800041ce:	70 08       	ld.w	r8,r8[0x0]
800041d0:	e2 18 00 02 	andl	r8,0x2,COH
800041d4:	c0 90       	breq	800041e6 <udd_ctrl_in_sent+0x106>
		// IN DATA phase aborted by OUT ZLP
		cpu_irq_restore(flags);
800041d6:	ee fc ff fc 	ld.w	r12,r7[-4]
800041da:	f0 1f 00 21 	mcall	8000425c <udd_ctrl_in_sent+0x17c>
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
800041de:	4a 18       	lddpc	r8,80004260 <udd_ctrl_in_sent+0x180>
800041e0:	30 49       	mov	r9,4
800041e2:	91 09       	st.w	r8[0x0],r9
		return; // Exit of IN DATA phase
800041e4:	c3 78       	rjmp	80004252 <udd_ctrl_in_sent+0x172>
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
800041e6:	30 08       	mov	r8,0
800041e8:	ef 68 ff f3 	st.b	r7[-13],r8
800041ec:	c1 68       	rjmp	80004218 <udd_ctrl_in_sent+0x138>
		*ptr_dest++ = *ptr_src++;
800041ee:	ee f8 ff f8 	ld.w	r8,r7[-8]
800041f2:	11 88       	ld.ub	r8,r8[0x0]
800041f4:	ee f9 ff f4 	ld.w	r9,r7[-12]
800041f8:	b2 88       	st.b	r9[0x0],r8
800041fa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800041fe:	2f f8       	sub	r8,-1
80004200:	ef 48 ff f4 	st.w	r7[-12],r8
80004204:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004208:	2f f8       	sub	r8,-1
8000420a:	ef 48 ff f8 	st.w	r7[-8],r8
		cpu_irq_restore(flags);
		udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
		return; // Exit of IN DATA phase
	}
	// Write quickly the IN data
	for (i = 0; i < nb_remain; i++) {
8000420e:	ef 38 ff f3 	ld.ub	r8,r7[-13]
80004212:	2f f8       	sub	r8,-1
80004214:	ef 68 ff f3 	st.b	r7[-13],r8
80004218:	ef 38 ff f3 	ld.ub	r8,r7[-13]
8000421c:	ef 09 ff f0 	ld.sh	r9,r7[-16]
80004220:	f0 09 19 00 	cp.h	r9,r8
80004224:	fe 9b ff e5 	brhi	800041ee <udd_ctrl_in_sent+0x10e>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_remain;
80004228:	49 28       	lddpc	r8,80004270 <udd_ctrl_in_sent+0x190>
8000422a:	90 08       	ld.sh	r8,r8[0x0]
8000422c:	ef 09 ff f0 	ld.sh	r9,r7[-16]
80004230:	f2 08 00 08 	add	r8,r9,r8
80004234:	5c 88       	casts.h	r8
80004236:	48 f9       	lddpc	r9,80004270 <udd_ctrl_in_sent+0x190>
80004238:	b2 08       	st.h	r9[0x0],r8

	// Validate and send the data available in the control endpoint buffer
	udd_ack_in_send(0);
8000423a:	fe 68 01 60 	mov	r8,-130720
8000423e:	30 19       	mov	r9,1
80004240:	91 09       	st.w	r8[0x0],r9
	udd_enable_in_send_interrupt(0);
80004242:	fe 68 01 f0 	mov	r8,-130576
80004246:	30 19       	mov	r9,1
80004248:	91 09       	st.w	r8[0x0],r9
	// In case of abort of DATA IN phase, no need to enable nak OUT interrupt
	// because OUT endpoint is already free and ZLP OUT accepted.
	cpu_irq_restore(flags);
8000424a:	ee fc ff fc 	ld.w	r12,r7[-4]
8000424e:	f0 1f 00 04 	mcall	8000425c <udd_ctrl_in_sent+0x17c>
}
80004252:	2f cd       	sub	sp,-16
80004254:	e3 cd 80 80 	ldm	sp++,r7,pc
80004258:	80 00       	ld.sh	r0,r0[0x0]
8000425a:	30 06       	mov	r6,0
8000425c:	80 00       	ld.sh	r0,r0[0x0]
8000425e:	30 44       	mov	r4,4
80004260:	00 00       	add	r0,r0
80004262:	01 94       	ld.ub	r4,r0[0x1]
80004264:	80 00       	ld.sh	r0,r0[0x0]
80004266:	45 a4       	lddsp	r4,sp[0x168]
80004268:	80 00       	ld.sh	r0,r0[0x0]
8000426a:	3f 20       	mov	r0,-14
8000426c:	00 00       	add	r0,r0
8000426e:	46 48       	lddsp	r8,sp[0x190]
80004270:	00 00       	add	r0,r0
80004272:	01 9a       	ld.ub	r10,r0[0x1]
80004274:	00 00       	add	r0,r0
80004276:	01 98       	ld.ub	r8,r0[0x1]
80004278:	00 00       	add	r0,r0
8000427a:	01 d8       	ld.ub	r8,r0[0x5]
8000427c:	80 00       	ld.sh	r0,r0[0x0]
8000427e:	45 60       	lddsp	r0,sp[0x158]

80004280 <udd_ctrl_out_received>:


static void udd_ctrl_out_received(void)
{
80004280:	eb cd 40 80 	pushm	r7,lr
80004284:	1a 97       	mov	r7,sp
80004286:	20 4d       	sub	sp,16
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
80004288:	4f 18       	lddpc	r8,8000444c <udd_ctrl_out_received+0x1cc>
8000428a:	70 08       	ld.w	r8,r8[0x0]
8000428c:	58 18       	cp.w	r8,1
8000428e:	c1 10       	breq	800042b0 <udd_ctrl_out_received+0x30>
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
80004290:	4e f8       	lddpc	r8,8000444c <udd_ctrl_out_received+0x1cc>
80004292:	70 08       	ld.w	r8,r8[0x0]
80004294:	58 28       	cp.w	r8,2
80004296:	c0 50       	breq	800042a0 <udd_ctrl_out_received+0x20>
				|| (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP ==
80004298:	4e d8       	lddpc	r8,8000444c <udd_ctrl_out_received+0x1cc>
8000429a:	70 08       	ld.w	r8,r8[0x0]
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
8000429c:	58 48       	cp.w	r8,4
8000429e:	c0 41       	brne	800042a6 <udd_ctrl_out_received+0x26>
						udd_ep_control_state)) {
			// End of SETUP request:
			// - Data IN Phase aborted,
			// - or last Data IN Phase hidden by ZLP OUT sending quickly,
			// - or ZLP OUT received normally.
			udd_ctrl_endofrequest();
800042a0:	f0 1f 00 6c 	mcall	80004450 <udd_ctrl_out_received+0x1d0>
	irqflags_t flags;
	uint8_t i;
	uint16_t nb_data;

	if (UDD_EPCTRL_DATA_OUT != udd_ep_control_state) {
		if ((UDD_EPCTRL_DATA_IN == udd_ep_control_state)
800042a4:	c0 38       	rjmp	800042aa <udd_ctrl_out_received+0x2a>
			// - or last Data IN Phase hidden by ZLP OUT sending quickly,
			// - or ZLP OUT received normally.
			udd_ctrl_endofrequest();
		} else {
			// Protocol error during SETUP request
			udd_ctrl_stall_data();
800042a6:	f0 1f 00 6c 	mcall	80004454 <udd_ctrl_out_received+0x1d4>
		}
		// Reinitializes control endpoint management
		udd_ctrl_init();
800042aa:	f0 1f 00 6c 	mcall	80004458 <udd_ctrl_out_received+0x1d8>
		return;
800042ae:	cc c8       	rjmp	80004446 <udd_ctrl_out_received+0x1c6>
	}
	// Read data received during OUT phase
	nb_data = udd_byte_count(0);
800042b0:	fe 68 01 30 	mov	r8,-130768
800042b4:	70 08       	ld.w	r8,r8[0x0]
800042b6:	e6 18 7f f0 	andh	r8,0x7ff0,COH
800042ba:	b5 88       	lsr	r8,0x14
800042bc:	ef 58 ff f6 	st.h	r7[-10],r8
	if (udd_g_ctrlreq.payload_size < (udd_ctrl_payload_nb_trans + nb_data)) {
800042c0:	4e 78       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
800042c2:	90 68       	ld.sh	r8,r8[0xc]
800042c4:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800042c8:	4e 68       	lddpc	r8,80004460 <udd_ctrl_out_received+0x1e0>
800042ca:	90 08       	ld.sh	r8,r8[0x0]
800042cc:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
800042d0:	ef 18 ff f6 	ld.uh	r8,r7[-10]
800042d4:	f4 08 00 08 	add	r8,r10,r8
800042d8:	10 39       	cp.w	r9,r8
800042da:	c0 84       	brge	800042ea <udd_ctrl_out_received+0x6a>
		// Payload buffer too small
		nb_data = udd_g_ctrlreq.payload_size -
800042dc:	4e 08       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
800042de:	90 69       	ld.sh	r9,r8[0xc]
800042e0:	4e 08       	lddpc	r8,80004460 <udd_ctrl_out_received+0x1e0>
800042e2:	90 08       	ld.sh	r8,r8[0x0]
800042e4:	10 19       	sub	r9,r8
800042e6:	ef 59 ff f6 	st.h	r7[-10],r9
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
800042ea:	30 08       	mov	r8,0
800042ec:	ea 18 d0 00 	orh	r8,0xd000
800042f0:	ef 48 ff f8 	st.w	r7[-8],r8
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
800042f4:	4d a8       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
800042f6:	70 29       	ld.w	r9,r8[0x8]
800042f8:	4d a8       	lddpc	r8,80004460 <udd_ctrl_out_received+0x1e0>
800042fa:	90 08       	ld.sh	r8,r8[0x0]
800042fc:	5c 78       	castu.h	r8
800042fe:	f2 08 00 08 	add	r8,r9,r8
80004302:	ef 48 ff fc 	st.w	r7[-4],r8
	for (i = 0; i < nb_data; i++) {
80004306:	30 08       	mov	r8,0
80004308:	ef 68 ff f5 	st.b	r7[-11],r8
8000430c:	c1 68       	rjmp	80004338 <udd_ctrl_out_received+0xb8>
		*ptr_dest++ = *ptr_src++;
8000430e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004312:	11 88       	ld.ub	r8,r8[0x0]
80004314:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004318:	b2 88       	st.b	r9[0x0],r8
8000431a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000431e:	2f f8       	sub	r8,-1
80004320:	ef 48 ff fc 	st.w	r7[-4],r8
80004324:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004328:	2f f8       	sub	r8,-1
8000432a:	ef 48 ff f8 	st.w	r7[-8],r8
		nb_data = udd_g_ctrlreq.payload_size -
				udd_ctrl_payload_nb_trans;
	}
	uint8_t *ptr_src = (uint8_t *) & udd_get_endpoint_fifo_access(0, 8);
	uint8_t *ptr_dest = udd_g_ctrlreq.payload + udd_ctrl_payload_nb_trans;
	for (i = 0; i < nb_data; i++) {
8000432e:	ef 38 ff f5 	ld.ub	r8,r7[-11]
80004332:	2f f8       	sub	r8,-1
80004334:	ef 68 ff f5 	st.b	r7[-11],r8
80004338:	ef 38 ff f5 	ld.ub	r8,r7[-11]
8000433c:	ef 09 ff f6 	ld.sh	r9,r7[-10]
80004340:	f0 09 19 00 	cp.h	r9,r8
80004344:	fe 9b ff e5 	brhi	8000430e <udd_ctrl_out_received+0x8e>
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;
80004348:	4c 68       	lddpc	r8,80004460 <udd_ctrl_out_received+0x1e0>
8000434a:	90 08       	ld.sh	r8,r8[0x0]
8000434c:	ef 09 ff f6 	ld.sh	r9,r7[-10]
80004350:	f2 08 00 08 	add	r8,r9,r8
80004354:	5c 88       	casts.h	r8
80004356:	4c 39       	lddpc	r9,80004460 <udd_ctrl_out_received+0x1e0>
80004358:	b2 08       	st.h	r9[0x0],r8

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
8000435a:	ef 09 ff f6 	ld.sh	r9,r7[-10]
8000435e:	34 08       	mov	r8,64
80004360:	f0 09 19 00 	cp.h	r9,r8
80004364:	c1 11       	brne	80004386 <udd_ctrl_out_received+0x106>
			|| (udd_g_ctrlreq.req.wLength <=
80004366:	4b e8       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
80004368:	90 38       	ld.sh	r8,r8[0x6]
8000436a:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
					(udd_ctrl_prev_payload_nb_trans +
8000436e:	4b e8       	lddpc	r8,80004464 <udd_ctrl_out_received+0x1e4>
80004370:	90 08       	ld.sh	r8,r8[0x0]
80004372:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
80004376:	4b b8       	lddpc	r8,80004460 <udd_ctrl_out_received+0x1e0>
80004378:	90 08       	ld.sh	r8,r8[0x0]
8000437a:	5c 78       	castu.h	r8
8000437c:	f4 08 00 08 	add	r8,r10,r8
	for (i = 0; i < nb_data; i++) {
		*ptr_dest++ = *ptr_src++;
	}
	udd_ctrl_payload_nb_trans += nb_data;

	if ((USB_DEVICE_EP_CTRL_SIZE != nb_data)
80004380:	10 39       	cp.w	r9,r8
80004382:	e0 89 00 20 	brgt	800043c2 <udd_ctrl_out_received+0x142>
							udd_ctrl_payload_nb_trans)))
	{
		// End of reception because it is a short packet
		// Before send ZLP, call intermediate callback
		// in case of data receive generate a stall
		udd_g_ctrlreq.payload_size = udd_ctrl_payload_nb_trans;
80004386:	4b 78       	lddpc	r8,80004460 <udd_ctrl_out_received+0x1e0>
80004388:	90 08       	ld.sh	r8,r8[0x0]
8000438a:	4b 59       	lddpc	r9,8000445c <udd_ctrl_out_received+0x1dc>
8000438c:	b2 68       	st.h	r9[0xc],r8
		if (NULL != udd_g_ctrlreq.over_under_run) {
8000438e:	4b 48       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
80004390:	70 58       	ld.w	r8,r8[0x14]
80004392:	58 08       	cp.w	r8,0
80004394:	c1 00       	breq	800043b4 <udd_ctrl_out_received+0x134>
			if (!udd_g_ctrlreq.over_under_run()) {
80004396:	4b 28       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
80004398:	70 58       	ld.w	r8,r8[0x14]
8000439a:	5d 18       	icall	r8
8000439c:	18 98       	mov	r8,r12
8000439e:	ec 18 00 01 	eorl	r8,0x1
800043a2:	5c 58       	castu.b	r8
800043a4:	c0 80       	breq	800043b4 <udd_ctrl_out_received+0x134>
				// Stall ZLP
				udd_ctrl_stall_data();
800043a6:	f0 1f 00 2c 	mcall	80004454 <udd_ctrl_out_received+0x1d4>
				// Ack reception of OUT to replace NAK by a STALL
				udd_ack_out_received(0);
800043aa:	fe 68 01 60 	mov	r8,-130720
800043ae:	30 29       	mov	r9,2
800043b0:	91 09       	st.w	r8[0x0],r9
				return;
800043b2:	c4 a8       	rjmp	80004446 <udd_ctrl_out_received+0x1c6>
			}
		}
		// Send IN ZLP to ACK setup request
		udd_ack_out_received(0);
800043b4:	fe 68 01 60 	mov	r8,-130720
800043b8:	30 29       	mov	r9,2
800043ba:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_send_zlp_in();
800043bc:	f0 1f 00 2b 	mcall	80004468 <udd_ctrl_out_received+0x1e8>
		return;
800043c0:	c4 38       	rjmp	80004446 <udd_ctrl_out_received+0x1c6>
	}

	if (udd_g_ctrlreq.payload_size == udd_ctrl_payload_nb_trans) {
800043c2:	4a 78       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
800043c4:	90 69       	ld.sh	r9,r8[0xc]
800043c6:	4a 78       	lddpc	r8,80004460 <udd_ctrl_out_received+0x1e0>
800043c8:	90 08       	ld.sh	r8,r8[0x0]
800043ca:	f0 09 19 00 	cp.h	r9,r8
800043ce:	c2 71       	brne	8000441c <udd_ctrl_out_received+0x19c>
		// Overrun then request a new payload buffer
		if (!udd_g_ctrlreq.over_under_run) {
800043d0:	4a 38       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
800043d2:	70 58       	ld.w	r8,r8[0x14]
800043d4:	58 08       	cp.w	r8,0
800043d6:	c0 81       	brne	800043e6 <udd_ctrl_out_received+0x166>
			// No callback available to request a new payload buffer
			udd_ctrl_stall_data();
800043d8:	f0 1f 00 1f 	mcall	80004454 <udd_ctrl_out_received+0x1d4>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
800043dc:	fe 68 01 60 	mov	r8,-130720
800043e0:	30 29       	mov	r9,2
800043e2:	91 09       	st.w	r8[0x0],r9
			return;
800043e4:	c3 18       	rjmp	80004446 <udd_ctrl_out_received+0x1c6>
		}
		if (!udd_g_ctrlreq.over_under_run()) {
800043e6:	49 e8       	lddpc	r8,8000445c <udd_ctrl_out_received+0x1dc>
800043e8:	70 58       	ld.w	r8,r8[0x14]
800043ea:	5d 18       	icall	r8
800043ec:	18 98       	mov	r8,r12
800043ee:	ec 18 00 01 	eorl	r8,0x1
800043f2:	5c 58       	castu.b	r8
800043f4:	c0 80       	breq	80004404 <udd_ctrl_out_received+0x184>
			// No new payload buffer delivered
			udd_ctrl_stall_data();
800043f6:	f0 1f 00 18 	mcall	80004454 <udd_ctrl_out_received+0x1d4>
			// Ack reception of OUT to replace NAK by a STALL
			udd_ack_out_received(0);
800043fa:	fe 68 01 60 	mov	r8,-130720
800043fe:	30 29       	mov	r9,2
80004400:	91 09       	st.w	r8[0x0],r9
			return;
80004402:	c2 28       	rjmp	80004446 <udd_ctrl_out_received+0x1c6>
		}
		// New payload buffer available
		// Update number of total data received
		udd_ctrl_prev_payload_nb_trans += udd_ctrl_payload_nb_trans;
80004404:	49 88       	lddpc	r8,80004464 <udd_ctrl_out_received+0x1e4>
80004406:	90 09       	ld.sh	r9,r8[0x0]
80004408:	49 68       	lddpc	r8,80004460 <udd_ctrl_out_received+0x1e0>
8000440a:	90 08       	ld.sh	r8,r8[0x0]
8000440c:	f2 08 00 08 	add	r8,r9,r8
80004410:	5c 88       	casts.h	r8
80004412:	49 59       	lddpc	r9,80004464 <udd_ctrl_out_received+0x1e4>
80004414:	b2 08       	st.h	r9[0x0],r8
		// Reinit reception on payload buffer
		udd_ctrl_payload_nb_trans = 0;
80004416:	49 39       	lddpc	r9,80004460 <udd_ctrl_out_received+0x1e0>
80004418:	30 08       	mov	r8,0
8000441a:	b2 08       	st.h	r9[0x0],r8
	}
	// Free buffer of control endpoint to authorize next reception
	udd_ack_out_received(0);
8000441c:	fe 68 01 60 	mov	r8,-130720
80004420:	30 29       	mov	r9,2
80004422:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data IN phase
	udd_ack_nak_in(0);
80004424:	fe 68 01 60 	mov	r8,-130720
80004428:	31 09       	mov	r9,16
8000442a:	91 09       	st.w	r8[0x0],r9
	flags = cpu_irq_save();
8000442c:	f0 1f 00 10 	mcall	8000446c <udd_ctrl_out_received+0x1ec>
80004430:	18 98       	mov	r8,r12
80004432:	ef 48 ff f0 	st.w	r7[-16],r8
	udd_enable_nak_in_interrupt(0);
80004436:	fe 68 01 f0 	mov	r8,-130576
8000443a:	31 09       	mov	r9,16
8000443c:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
8000443e:	ee fc ff f0 	ld.w	r12,r7[-16]
80004442:	f0 1f 00 0c 	mcall	80004470 <udd_ctrl_out_received+0x1f0>
}
80004446:	2f cd       	sub	sp,-16
80004448:	e3 cd 80 80 	ldm	sp++,r7,pc
8000444c:	00 00       	add	r0,r0
8000444e:	01 94       	ld.ub	r4,r0[0x1]
80004450:	80 00       	ld.sh	r0,r0[0x0]
80004452:	45 a4       	lddsp	r4,sp[0x168]
80004454:	80 00       	ld.sh	r0,r0[0x0]
80004456:	44 ec       	lddsp	r12,sp[0x138]
80004458:	80 00       	ld.sh	r0,r0[0x0]
8000445a:	3f 20       	mov	r0,-14
8000445c:	00 00       	add	r0,r0
8000445e:	46 48       	lddsp	r8,sp[0x190]
80004460:	00 00       	add	r0,r0
80004462:	01 9a       	ld.ub	r10,r0[0x1]
80004464:	00 00       	add	r0,r0
80004466:	01 98       	ld.ub	r8,r0[0x1]
80004468:	80 00       	ld.sh	r0,r0[0x0]
8000446a:	45 0c       	lddsp	r12,sp[0x140]
8000446c:	80 00       	ld.sh	r0,r0[0x0]
8000446e:	30 06       	mov	r6,0
80004470:	80 00       	ld.sh	r0,r0[0x0]
80004472:	30 44       	mov	r4,4

80004474 <udd_ctrl_underflow>:


static void udd_ctrl_underflow(void)
{
80004474:	eb cd 40 80 	pushm	r7,lr
80004478:	1a 97       	mov	r7,sp
	if (Is_udd_out_received(0))
8000447a:	fe 68 01 30 	mov	r8,-130768
8000447e:	70 08       	ld.w	r8,r8[0x0]
80004480:	e2 18 00 02 	andl	r8,0x2,COH
80004484:	c1 21       	brne	800044a8 <udd_ctrl_underflow+0x34>
		return; // underflow ignored if OUT data is received

	if (UDD_EPCTRL_DATA_OUT == udd_ep_control_state) {
80004486:	48 b8       	lddpc	r8,800044b0 <udd_ctrl_underflow+0x3c>
80004488:	70 08       	ld.w	r8,r8[0x0]
8000448a:	58 18       	cp.w	r8,1
8000448c:	c0 41       	brne	80004494 <udd_ctrl_underflow+0x20>
		// Host want to stop OUT transaction
		// then stop to wait OUT data phase and wait IN ZLP handshake
		udd_ctrl_send_zlp_in();
8000448e:	f0 1f 00 0a 	mcall	800044b4 <udd_ctrl_underflow+0x40>
80004492:	c0 c8       	rjmp	800044aa <udd_ctrl_underflow+0x36>
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
80004494:	48 78       	lddpc	r8,800044b0 <udd_ctrl_underflow+0x3c>
80004496:	70 08       	ld.w	r8,r8[0x0]
80004498:	58 48       	cp.w	r8,4
8000449a:	c0 81       	brne	800044aa <udd_ctrl_underflow+0x36>
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
8000449c:	fe 68 01 f0 	mov	r8,-130576
800044a0:	e8 69 00 00 	mov	r9,524288
800044a4:	91 09       	st.w	r8[0x0],r9
800044a6:	c0 28       	rjmp	800044aa <udd_ctrl_underflow+0x36>


static void udd_ctrl_underflow(void)
{
	if (Is_udd_out_received(0))
		return; // underflow ignored if OUT data is received
800044a8:	d7 03       	nop
	} else if (UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP == udd_ep_control_state) {
		// A OUT handshake is waiting by device,
		// but host want extra IN data then stall extra IN data
		udd_enable_stall_handshake(0);
	}
}
800044aa:	e3 cd 80 80 	ldm	sp++,r7,pc
800044ae:	00 00       	add	r0,r0
800044b0:	00 00       	add	r0,r0
800044b2:	01 94       	ld.ub	r4,r0[0x1]
800044b4:	80 00       	ld.sh	r0,r0[0x0]
800044b6:	45 0c       	lddsp	r12,sp[0x140]

800044b8 <udd_ctrl_overflow>:


static void udd_ctrl_overflow(void)
{
800044b8:	eb cd 40 80 	pushm	r7,lr
800044bc:	1a 97       	mov	r7,sp
	if (Is_udd_in_send(0))
800044be:	fe 68 01 30 	mov	r8,-130768
800044c2:	70 08       	ld.w	r8,r8[0x0]
800044c4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800044c8:	5c 58       	castu.b	r8
800044ca:	c0 b1       	brne	800044e0 <udd_ctrl_overflow+0x28>
		return; // overflow ignored if IN data is received

	// The case of UDD_EPCTRL_DATA_IN is not managed
	// because the OUT endpoint is already free and OUT ZLP accepted

	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
800044cc:	48 78       	lddpc	r8,800044e8 <udd_ctrl_overflow+0x30>
800044ce:	70 08       	ld.w	r8,r8[0x0]
800044d0:	58 38       	cp.w	r8,3
800044d2:	c0 81       	brne	800044e2 <udd_ctrl_overflow+0x2a>
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
800044d4:	fe 68 01 f0 	mov	r8,-130576
800044d8:	e8 69 00 00 	mov	r9,524288
800044dc:	91 09       	st.w	r8[0x0],r9
800044de:	c0 28       	rjmp	800044e2 <udd_ctrl_overflow+0x2a>


static void udd_ctrl_overflow(void)
{
	if (Is_udd_in_send(0))
		return; // overflow ignored if IN data is received
800044e0:	d7 03       	nop
	if (UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP == udd_ep_control_state) {
		// A IN handshake is waiting by device,
		// but host want extra OUT data then stall extra OUT data
		udd_enable_stall_handshake(0);
	}
}
800044e2:	e3 cd 80 80 	ldm	sp++,r7,pc
800044e6:	00 00       	add	r0,r0
800044e8:	00 00       	add	r0,r0
800044ea:	01 94       	ld.ub	r4,r0[0x1]

800044ec <udd_ctrl_stall_data>:


static void udd_ctrl_stall_data(void)
{
800044ec:	eb cd 40 80 	pushm	r7,lr
800044f0:	1a 97       	mov	r7,sp
	// Stall all packets on IN & OUT control endpoint
	udd_ep_control_state = UDD_EPCTRL_STALL_REQ;
800044f2:	48 68       	lddpc	r8,80004508 <udd_ctrl_stall_data+0x1c>
800044f4:	30 59       	mov	r9,5
800044f6:	91 09       	st.w	r8[0x0],r9
	udd_enable_stall_handshake(0);
800044f8:	fe 68 01 f0 	mov	r8,-130576
800044fc:	e8 69 00 00 	mov	r9,524288
80004500:	91 09       	st.w	r8[0x0],r9
}
80004502:	e3 cd 80 80 	ldm	sp++,r7,pc
80004506:	00 00       	add	r0,r0
80004508:	00 00       	add	r0,r0
8000450a:	01 94       	ld.ub	r4,r0[0x1]

8000450c <udd_ctrl_send_zlp_in>:


static void udd_ctrl_send_zlp_in(void)
{
8000450c:	eb cd 40 80 	pushm	r7,lr
80004510:	1a 97       	mov	r7,sp
80004512:	20 1d       	sub	sp,4
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP;
80004514:	49 08       	lddpc	r8,80004554 <udd_ctrl_send_zlp_in+0x48>
80004516:	30 39       	mov	r9,3
80004518:	91 09       	st.w	r8[0x0],r9

	// Validate and send empty IN packet on control endpoint
	flags = cpu_irq_save();
8000451a:	f0 1f 00 10 	mcall	80004558 <udd_ctrl_send_zlp_in+0x4c>
8000451e:	18 98       	mov	r8,r12
80004520:	ef 48 ff fc 	st.w	r7[-4],r8
	// Send ZLP on IN endpoint
	udd_ack_in_send(0);
80004524:	fe 68 01 60 	mov	r8,-130720
80004528:	30 19       	mov	r9,1
8000452a:	91 09       	st.w	r8[0x0],r9
	udd_enable_in_send_interrupt(0);
8000452c:	fe 68 01 f0 	mov	r8,-130576
80004530:	30 19       	mov	r9,1
80004532:	91 09       	st.w	r8[0x0],r9
	// To detect a protocol error, enable nak interrupt on data OUT phase
	udd_ack_nak_out(0);
80004534:	fe 68 01 60 	mov	r8,-130720
80004538:	30 89       	mov	r9,8
8000453a:	91 09       	st.w	r8[0x0],r9
	udd_enable_nak_out_interrupt(0);
8000453c:	fe 68 01 f0 	mov	r8,-130576
80004540:	30 89       	mov	r9,8
80004542:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
80004544:	ee fc ff fc 	ld.w	r12,r7[-4]
80004548:	f0 1f 00 05 	mcall	8000455c <udd_ctrl_send_zlp_in+0x50>
}
8000454c:	2f fd       	sub	sp,-4
8000454e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004552:	00 00       	add	r0,r0
80004554:	00 00       	add	r0,r0
80004556:	01 94       	ld.ub	r4,r0[0x1]
80004558:	80 00       	ld.sh	r0,r0[0x0]
8000455a:	30 06       	mov	r6,0
8000455c:	80 00       	ld.sh	r0,r0[0x0]
8000455e:	30 44       	mov	r4,4

80004560 <udd_ctrl_send_zlp_out>:


static void udd_ctrl_send_zlp_out(void)
{
80004560:	eb cd 40 80 	pushm	r7,lr
80004564:	1a 97       	mov	r7,sp
80004566:	20 1d       	sub	sp,4
	irqflags_t flags;

	udd_ep_control_state = UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP;
80004568:	48 c8       	lddpc	r8,80004598 <udd_ctrl_send_zlp_out+0x38>
8000456a:	30 49       	mov	r9,4
8000456c:	91 09       	st.w	r8[0x0],r9
	// No action is necessary to accept OUT ZLP
	// because the buffer of control endpoint is already free

	// To detect a protocol error, enable nak interrupt on data IN phase
	flags = cpu_irq_save();
8000456e:	f0 1f 00 0c 	mcall	8000459c <udd_ctrl_send_zlp_out+0x3c>
80004572:	18 98       	mov	r8,r12
80004574:	ef 48 ff fc 	st.w	r7[-4],r8
	udd_ack_nak_in(0);
80004578:	fe 68 01 60 	mov	r8,-130720
8000457c:	31 09       	mov	r9,16
8000457e:	91 09       	st.w	r8[0x0],r9
	udd_enable_nak_in_interrupt(0);
80004580:	fe 68 01 f0 	mov	r8,-130576
80004584:	31 09       	mov	r9,16
80004586:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
80004588:	ee fc ff fc 	ld.w	r12,r7[-4]
8000458c:	f0 1f 00 05 	mcall	800045a0 <udd_ctrl_send_zlp_out+0x40>
}
80004590:	2f fd       	sub	sp,-4
80004592:	e3 cd 80 80 	ldm	sp++,r7,pc
80004596:	00 00       	add	r0,r0
80004598:	00 00       	add	r0,r0
8000459a:	01 94       	ld.ub	r4,r0[0x1]
8000459c:	80 00       	ld.sh	r0,r0[0x0]
8000459e:	30 06       	mov	r6,0
800045a0:	80 00       	ld.sh	r0,r0[0x0]
800045a2:	30 44       	mov	r4,4

800045a4 <udd_ctrl_endofrequest>:


static void udd_ctrl_endofrequest(void)
{
800045a4:	eb cd 40 80 	pushm	r7,lr
800045a8:	1a 97       	mov	r7,sp
	// If a callback is registered then call it
	if (udd_g_ctrlreq.callback) {
800045aa:	48 58       	lddpc	r8,800045bc <udd_ctrl_endofrequest+0x18>
800045ac:	70 48       	ld.w	r8,r8[0x10]
800045ae:	58 08       	cp.w	r8,0
800045b0:	c0 40       	breq	800045b8 <udd_ctrl_endofrequest+0x14>
		udd_g_ctrlreq.callback();
800045b2:	48 38       	lddpc	r8,800045bc <udd_ctrl_endofrequest+0x18>
800045b4:	70 48       	ld.w	r8,r8[0x10]
800045b6:	5d 18       	icall	r8
	}
}
800045b8:	e3 cd 80 80 	ldm	sp++,r7,pc
800045bc:	00 00       	add	r0,r0
800045be:	46 48       	lddsp	r8,sp[0x190]

800045c0 <udd_ctrl_interrupt>:


static bool udd_ctrl_interrupt(void)
{
800045c0:	eb cd 40 80 	pushm	r7,lr
800045c4:	1a 97       	mov	r7,sp

	if (!Is_udd_endpoint_interrupt(0))
800045c6:	fe 68 00 00 	mov	r8,-131072
800045ca:	70 18       	ld.w	r8,r8[0x4]
800045cc:	e2 18 10 00 	andl	r8,0x1000,COH
800045d0:	c0 31       	brne	800045d6 <udd_ctrl_interrupt+0x16>
		return false; // No interrupt events on control endpoint
800045d2:	30 08       	mov	r8,0
800045d4:	c4 c8       	rjmp	8000466c <udd_ctrl_interrupt+0xac>

	// By default disable overflow and underflow interrupt
	udd_disable_nak_in_interrupt(0);
800045d6:	fe 68 02 20 	mov	r8,-130528
800045da:	31 09       	mov	r9,16
800045dc:	91 09       	st.w	r8[0x0],r9
	udd_disable_nak_out_interrupt(0);
800045de:	fe 68 02 20 	mov	r8,-130528
800045e2:	30 89       	mov	r9,8
800045e4:	91 09       	st.w	r8[0x0],r9


	// Search event on control endpoint
	if (Is_udd_setup_received(0)) {
800045e6:	fe 68 01 30 	mov	r8,-130768
800045ea:	70 08       	ld.w	r8,r8[0x0]
800045ec:	e2 18 00 04 	andl	r8,0x4,COH
800045f0:	c0 50       	breq	800045fa <udd_ctrl_interrupt+0x3a>
		// SETUP packet received
		udd_ctrl_setup_received();
800045f2:	f0 1f 00 21 	mcall	80004674 <udd_ctrl_interrupt+0xb4>
		return true;
800045f6:	30 18       	mov	r8,1
800045f8:	c3 a8       	rjmp	8000466c <udd_ctrl_interrupt+0xac>
	}
	if (Is_udd_in_send(0) && Is_udd_in_send_interrupt_enabled(0)) {
800045fa:	fe 68 01 30 	mov	r8,-130768
800045fe:	70 08       	ld.w	r8,r8[0x0]
80004600:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004604:	5c 58       	castu.b	r8
80004606:	c0 c0       	breq	8000461e <udd_ctrl_interrupt+0x5e>
80004608:	fe 68 01 c0 	mov	r8,-130624
8000460c:	70 08       	ld.w	r8,r8[0x0]
8000460e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004612:	5c 58       	castu.b	r8
80004614:	c0 50       	breq	8000461e <udd_ctrl_interrupt+0x5e>
		// IN packet sent
		udd_ctrl_in_sent();
80004616:	f0 1f 00 19 	mcall	80004678 <udd_ctrl_interrupt+0xb8>
		return true;
8000461a:	30 18       	mov	r8,1
8000461c:	c2 88       	rjmp	8000466c <udd_ctrl_interrupt+0xac>
	}
	if (Is_udd_out_received(0)) {
8000461e:	fe 68 01 30 	mov	r8,-130768
80004622:	70 08       	ld.w	r8,r8[0x0]
80004624:	e2 18 00 02 	andl	r8,0x2,COH
80004628:	c0 50       	breq	80004632 <udd_ctrl_interrupt+0x72>
		// OUT packet received
		udd_ctrl_out_received();
8000462a:	f0 1f 00 15 	mcall	8000467c <udd_ctrl_interrupt+0xbc>
		return true;
8000462e:	30 18       	mov	r8,1
80004630:	c1 e8       	rjmp	8000466c <udd_ctrl_interrupt+0xac>
	}
	if (Is_udd_nak_out(0)) {
80004632:	fe 68 01 30 	mov	r8,-130768
80004636:	70 08       	ld.w	r8,r8[0x0]
80004638:	e2 18 00 08 	andl	r8,0x8,COH
8000463c:	c0 90       	breq	8000464e <udd_ctrl_interrupt+0x8e>
		// Overflow on OUT packet
		udd_ack_nak_out(0);
8000463e:	fe 68 01 60 	mov	r8,-130720
80004642:	30 89       	mov	r9,8
80004644:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_overflow();
80004646:	f0 1f 00 0f 	mcall	80004680 <udd_ctrl_interrupt+0xc0>
		return true;
8000464a:	30 18       	mov	r8,1
8000464c:	c1 08       	rjmp	8000466c <udd_ctrl_interrupt+0xac>
	}
	if (Is_udd_nak_in(0)) {
8000464e:	fe 68 01 30 	mov	r8,-130768
80004652:	70 08       	ld.w	r8,r8[0x0]
80004654:	e2 18 00 10 	andl	r8,0x10,COH
80004658:	c0 90       	breq	8000466a <udd_ctrl_interrupt+0xaa>
		// Underflow on IN packet
		udd_ack_nak_in(0);
8000465a:	fe 68 01 60 	mov	r8,-130720
8000465e:	31 09       	mov	r9,16
80004660:	91 09       	st.w	r8[0x0],r9
		udd_ctrl_underflow();
80004662:	f0 1f 00 09 	mcall	80004684 <udd_ctrl_interrupt+0xc4>
		return true;
80004666:	30 18       	mov	r8,1
80004668:	c0 28       	rjmp	8000466c <udd_ctrl_interrupt+0xac>
	}
	return false;
8000466a:	30 08       	mov	r8,0
}
8000466c:	10 9c       	mov	r12,r8
8000466e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004672:	00 00       	add	r0,r0
80004674:	80 00       	ld.sh	r0,r0[0x0]
80004676:	3f 78       	mov	r8,-9
80004678:	80 00       	ld.sh	r0,r0[0x0]
8000467a:	40 e0       	lddsp	r0,sp[0x38]
8000467c:	80 00       	ld.sh	r0,r0[0x0]
8000467e:	42 80       	lddsp	r0,sp[0xa0]
80004680:	80 00       	ld.sh	r0,r0[0x0]
80004682:	44 b8       	lddsp	r8,sp[0x12c]
80004684:	80 00       	ld.sh	r0,r0[0x0]
80004686:	44 74       	lddsp	r4,sp[0x11c]

80004688 <udd_ep_job_table_reset>:
//--- INTERNAL ROUTINES TO MANAGED THE BULK/INTERRUPT/ISOCHRONOUS ENDPOINTS

#if (0!=USB_DEVICE_MAX_EP)

static void udd_ep_job_table_reset(void)
{
80004688:	eb cd 40 80 	pushm	r7,lr
8000468c:	1a 97       	mov	r7,sp
8000468e:	20 1d       	sub	sp,4
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
80004690:	30 08       	mov	r8,0
80004692:	ef 68 ff ff 	st.b	r7[-1],r8
80004696:	c2 28       	rjmp	800046da <udd_ep_job_table_reset+0x52>
		udd_ep_job[i].busy = false;
80004698:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000469c:	49 5a       	lddpc	r10,800046f0 <udd_ep_job_table_reset+0x68>
8000469e:	12 98       	mov	r8,r9
800046a0:	a3 68       	lsl	r8,0x2
800046a2:	12 08       	add	r8,r9
800046a4:	a3 68       	lsl	r8,0x2
800046a6:	f4 08 00 09 	add	r9,r10,r8
800046aa:	72 08       	ld.w	r8,r9[0x0]
800046ac:	30 0a       	mov	r10,0
800046ae:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
800046b2:	93 08       	st.w	r9[0x0],r8
		udd_ep_job[i].stall_requested = false;
800046b4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800046b8:	48 ea       	lddpc	r10,800046f0 <udd_ep_job_table_reset+0x68>
800046ba:	12 98       	mov	r8,r9
800046bc:	a3 68       	lsl	r8,0x2
800046be:	12 08       	add	r8,r9
800046c0:	a3 68       	lsl	r8,0x2
800046c2:	f4 08 00 09 	add	r9,r10,r8
800046c6:	72 08       	ld.w	r8,r9[0x0]
800046c8:	30 0a       	mov	r10,0
800046ca:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
800046ce:	93 08       	st.w	r9[0x0],r8
#if (0!=USB_DEVICE_MAX_EP)

static void udd_ep_job_table_reset(void)
{
	uint8_t i;
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
800046d0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800046d4:	2f f8       	sub	r8,-1
800046d6:	ef 68 ff ff 	st.b	r7[-1],r8
800046da:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800046de:	30 28       	mov	r8,2
800046e0:	f0 09 18 00 	cp.b	r9,r8
800046e4:	fe 98 ff da 	brls	80004698 <udd_ep_job_table_reset+0x10>
		udd_ep_job[i].busy = false;
		udd_ep_job[i].stall_requested = false;
	}
}
800046e8:	2f fd       	sub	sp,-4
800046ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800046ee:	00 00       	add	r0,r0
800046f0:	00 00       	add	r0,r0
800046f2:	01 9c       	ld.ub	r12,r0[0x1]

800046f4 <udd_ep_job_table_kill>:


static void udd_ep_job_table_kill(void)
{
800046f4:	eb cd 40 80 	pushm	r7,lr
800046f8:	1a 97       	mov	r7,sp
800046fa:	20 1d       	sub	sp,4
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
800046fc:	30 08       	mov	r8,0
800046fe:	ef 68 ff ff 	st.b	r7[-1],r8
80004702:	c1 98       	rjmp	80004734 <udd_ep_job_table_kill+0x40>
		udd_ep_finish_job(&udd_ep_job[i], true, i + 1);
80004704:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80004708:	2f f8       	sub	r8,-1
8000470a:	5c 58       	castu.b	r8
8000470c:	10 9a       	mov	r10,r8
8000470e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004712:	12 98       	mov	r8,r9
80004714:	a3 68       	lsl	r8,0x2
80004716:	12 08       	add	r8,r9
80004718:	a3 68       	lsl	r8,0x2
8000471a:	10 99       	mov	r9,r8
8000471c:	48 b8       	lddpc	r8,80004748 <udd_ep_job_table_kill+0x54>
8000471e:	f2 08 00 08 	add	r8,r9,r8
80004722:	30 1b       	mov	r11,1
80004724:	10 9c       	mov	r12,r8
80004726:	f0 1f 00 0a 	mcall	8000474c <udd_ep_job_table_kill+0x58>
static void udd_ep_job_table_kill(void)
{
	uint8_t i;

	// For each endpoint, kill job
	for (i = 0; i < USB_DEVICE_MAX_EP; i++) {
8000472a:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000472e:	2f f8       	sub	r8,-1
80004730:	ef 68 ff ff 	st.b	r7[-1],r8
80004734:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80004738:	30 28       	mov	r8,2
8000473a:	f0 09 18 00 	cp.b	r9,r8
8000473e:	fe 98 ff e3 	brls	80004704 <udd_ep_job_table_kill+0x10>
		udd_ep_finish_job(&udd_ep_job[i], true, i + 1);
	}
}
80004742:	2f fd       	sub	sp,-4
80004744:	e3 cd 80 80 	ldm	sp++,r7,pc
80004748:	00 00       	add	r0,r0
8000474a:	01 9c       	ld.ub	r12,r0[0x1]
8000474c:	80 00       	ld.sh	r0,r0[0x0]
8000474e:	47 9c       	lddsp	r12,sp[0x1e4]

80004750 <udd_ep_abort_job>:


static void udd_ep_abort_job(udd_ep_id_t ep)
{
80004750:	eb cd 40 80 	pushm	r7,lr
80004754:	1a 97       	mov	r7,sp
80004756:	20 1d       	sub	sp,4
80004758:	18 98       	mov	r8,r12
8000475a:	ef 68 ff fc 	st.b	r7[-4],r8
	ep &= USB_EP_ADDR_MASK;
8000475e:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80004762:	f1 d8 c0 04 	bfextu	r8,r8,0x0,0x4
80004766:	ef 68 ff fc 	st.b	r7[-4],r8

	// Abort job on endpoint
	udd_ep_finish_job(&udd_ep_job[ep - 1], true, ep);
8000476a:	ef 3a ff fc 	ld.ub	r10,r7[-4]
8000476e:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80004772:	f0 c9 00 01 	sub	r9,r8,1
80004776:	12 98       	mov	r8,r9
80004778:	a3 68       	lsl	r8,0x2
8000477a:	12 08       	add	r8,r9
8000477c:	a3 68       	lsl	r8,0x2
8000477e:	10 99       	mov	r9,r8
80004780:	48 58       	lddpc	r8,80004794 <udd_ep_abort_job+0x44>
80004782:	f2 08 00 08 	add	r8,r9,r8
80004786:	30 1b       	mov	r11,1
80004788:	10 9c       	mov	r12,r8
8000478a:	f0 1f 00 04 	mcall	80004798 <udd_ep_abort_job+0x48>
}
8000478e:	2f fd       	sub	sp,-4
80004790:	e3 cd 80 80 	ldm	sp++,r7,pc
80004794:	00 00       	add	r0,r0
80004796:	01 9c       	ld.ub	r12,r0[0x1]
80004798:	80 00       	ld.sh	r0,r0[0x0]
8000479a:	47 9c       	lddsp	r12,sp[0x1e4]

8000479c <udd_ep_finish_job>:


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num)
{
8000479c:	eb cd 40 80 	pushm	r7,lr
800047a0:	1a 97       	mov	r7,sp
800047a2:	20 3d       	sub	sp,12
800047a4:	ef 4c ff fc 	st.w	r7[-4],r12
800047a8:	16 99       	mov	r9,r11
800047aa:	14 98       	mov	r8,r10
800047ac:	ef 69 ff f8 	st.b	r7[-8],r9
800047b0:	ef 68 ff f4 	st.b	r7[-12],r8
	if (ptr_job->busy == false) {
800047b4:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047b8:	70 08       	ld.w	r8,r8[0x0]
800047ba:	e6 18 80 00 	andh	r8,0x8000,COH
800047be:	c2 b0       	breq	80004814 <udd_ep_finish_job+0x78>
		return; // No on-going job
	}
	ptr_job->busy = false;
800047c0:	ee f9 ff fc 	ld.w	r9,r7[-4]
800047c4:	72 08       	ld.w	r8,r9[0x0]
800047c6:	30 0a       	mov	r10,0
800047c8:	f1 da d3 e1 	bfins	r8,r10,0x1f,0x1
800047cc:	93 08       	st.w	r9[0x0],r8
	if (NULL == ptr_job->call_trans) {
800047ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047d2:	70 48       	ld.w	r8,r8[0x10]
800047d4:	58 08       	cp.w	r8,0
800047d6:	c2 10       	breq	80004818 <udd_ep_finish_job+0x7c>
		return; // No callback linked to job
	}
	if (Is_udd_endpoint_in(ep_num)) {
800047d8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800047dc:	a3 68       	lsl	r8,0x2
800047de:	e0 38 ff 00 	sub	r8,130816
800047e2:	70 08       	ld.w	r8,r8[0x0]
800047e4:	e2 18 01 00 	andl	r8,0x100,COH
800047e8:	c0 90       	breq	800047fa <udd_ep_finish_job+0x5e>
		ep_num |= USB_EP_DIR_IN;
800047ea:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800047ee:	ea 18 ff ff 	orh	r8,0xffff
800047f2:	e8 18 ff 80 	orl	r8,0xff80
800047f6:	ef 68 ff f4 	st.b	r7[-12],r8
	}
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
800047fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800047fe:	70 48       	ld.w	r8,r8[0x10]
80004800:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80004804:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004808:	72 2b       	ld.w	r11,r9[0x8]
8000480a:	ef 39 ff f8 	ld.ub	r9,r7[-8]
8000480e:	12 9c       	mov	r12,r9
80004810:	5d 18       	icall	r8
80004812:	c0 48       	rjmp	8000481a <udd_ep_finish_job+0x7e>


static void udd_ep_finish_job(udd_ep_job_t * ptr_job, bool b_abort, uint8_t ep_num)
{
	if (ptr_job->busy == false) {
		return; // No on-going job
80004814:	d7 03       	nop
80004816:	c0 28       	rjmp	8000481a <udd_ep_finish_job+0x7e>
	}
	ptr_job->busy = false;
	if (NULL == ptr_job->call_trans) {
		return; // No callback linked to job
80004818:	d7 03       	nop
	if (Is_udd_endpoint_in(ep_num)) {
		ep_num |= USB_EP_DIR_IN;
	}
	ptr_job->call_trans((b_abort) ? UDD_EP_TRANSFER_ABORT :
			UDD_EP_TRANSFER_OK, ptr_job->buf_size, ep_num);
}
8000481a:	2f dd       	sub	sp,-12
8000481c:	e3 cd 80 80 	ldm	sp++,r7,pc

80004820 <udd_ep_trans_done>:

static void udd_ep_trans_done(udd_ep_id_t ep)
{
80004820:	eb cd 40 80 	pushm	r7,lr
80004824:	1a 97       	mov	r7,sp
80004826:	20 5d       	sub	sp,20
80004828:	18 98       	mov	r8,r12
8000482a:	ef 68 ff ec 	st.b	r7[-20],r8
	uint32_t udd_dma_ctrl = 0;
8000482e:	30 08       	mov	r8,0
80004830:	ef 48 ff f0 	st.w	r7[-16],r8
	udd_ep_job_t *ptr_job;
	iram_size_t next_trans;
	irqflags_t flags;

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep - 1];
80004834:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004838:	f0 c9 00 01 	sub	r9,r8,1
8000483c:	12 98       	mov	r8,r9
8000483e:	a3 68       	lsl	r8,0x2
80004840:	12 08       	add	r8,r9
80004842:	a3 68       	lsl	r8,0x2
80004844:	10 99       	mov	r9,r8
80004846:	fe f8 02 1e 	ld.w	r8,pc[542]
8000484a:	f2 08 00 08 	add	r8,r9,r8
8000484e:	ef 48 ff f4 	st.w	r7[-12],r8

	if (!ptr_job->busy) {
80004852:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004856:	70 08       	ld.w	r8,r8[0x0]
80004858:	e6 18 80 00 	andh	r8,0x8000,COH
8000485c:	e0 80 00 ff 	breq	80004a5a <udd_ep_trans_done+0x23a>
		return; // No job is running, then ignore it (system error)
	}

	if (ptr_job->nb_trans != ptr_job->buf_size) {
80004860:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004864:	70 39       	ld.w	r9,r8[0xc]
80004866:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000486a:	70 28       	ld.w	r8,r8[0x8]
8000486c:	10 39       	cp.w	r9,r8
8000486e:	e0 80 00 b6 	breq	800049da <udd_ep_trans_done+0x1ba>
		// Need to send or receive other data
		next_trans = ptr_job->buf_size - ptr_job->nb_trans;
80004872:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004876:	70 29       	ld.w	r9,r8[0x8]
80004878:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000487c:	70 38       	ld.w	r8,r8[0xc]
8000487e:	10 19       	sub	r9,r8
80004880:	ef 49 ff f8 	st.w	r7[-8],r9

		if (UDD_ENDPOINT_MAX_TRANS < next_trans) {
80004884:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004888:	e0 58 00 00 	cp.w	r8,65536
8000488c:	e0 88 00 0a 	brls	800048a0 <udd_ep_trans_done+0x80>
			// The USB hardware support a maximum
			// transfer size of UDD_ENDPOINT_MAX_TRANS Bytes
			next_trans = UDD_ENDPOINT_MAX_TRANS;
80004890:	e0 78 00 00 	mov	r8,65536
80004894:	ef 48 ff f8 	st.w	r7[-8],r8

			// Set 0 to transfer the maximum
			udd_dma_ctrl = (0 <<
80004898:	30 08       	mov	r8,0
8000489a:	ef 48 ff f0 	st.w	r7[-16],r8
8000489e:	c0 68       	rjmp	800048aa <udd_ep_trans_done+0x8a>
					AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		} else {
			udd_dma_ctrl = (next_trans <<
800048a0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048a4:	b1 68       	lsl	r8,0x10
800048a6:	ef 48 ff f0 	st.w	r7[-16],r8
					AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_OFFSET)
					& AVR32_USBB_UDDMA1_CONTROL_CH_BYTE_LENGTH_MASK;
		}
		if (Is_udd_endpoint_in(ep)) {
800048aa:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800048ae:	a3 68       	lsl	r8,0x2
800048b0:	e0 38 ff 00 	sub	r8,130816
800048b4:	70 08       	ld.w	r8,r8[0x0]
800048b6:	e2 18 01 00 	andl	r8,0x100,COH
800048ba:	c2 10       	breq	800048fc <udd_ep_trans_done+0xdc>
			if (0 != next_trans % udd_get_endpoint_size(ep)) {
800048bc:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800048c0:	a3 68       	lsl	r8,0x2
800048c2:	e0 38 ff 00 	sub	r8,130816
800048c6:	70 08       	ld.w	r8,r8[0x0]
800048c8:	e2 18 00 70 	andl	r8,0x70,COH
800048cc:	a5 88       	lsr	r8,0x4
800048ce:	30 89       	mov	r9,8
800048d0:	f2 08 09 48 	lsl	r8,r9,r8
800048d4:	20 18       	sub	r8,1
800048d6:	10 99       	mov	r9,r8
800048d8:	ee f8 ff f8 	ld.w	r8,r7[-8]
800048dc:	f3 e8 00 08 	and	r8,r9,r8
800048e0:	c3 00       	breq	80004940 <udd_ep_trans_done+0x120>
				// Enable short packet option
				// else the DMA transfer is accepted
				// and interrupt DMA valid but nothing is sent.
				udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_DMAEND_EN_MASK;
800048e2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800048e6:	a3 b8       	sbr	r8,0x3
800048e8:	ef 48 ff f0 	st.w	r7[-16],r8
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
800048ec:	ee f9 ff f4 	ld.w	r9,r7[-12]
800048f0:	72 08       	ld.w	r8,r9[0x0]
800048f2:	30 0a       	mov	r10,0
800048f4:	f1 da d3 c1 	bfins	r8,r10,0x1e,0x1
800048f8:	93 08       	st.w	r9[0x0],r8
800048fa:	c2 38       	rjmp	80004940 <udd_ep_trans_done+0x120>
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != udd_get_endpoint_type(ep))
800048fc:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004900:	a3 68       	lsl	r8,0x2
80004902:	e0 38 ff 00 	sub	r8,130816
80004906:	70 08       	ld.w	r8,r8[0x0]
80004908:	e2 18 18 00 	andl	r8,0x1800,COH
8000490c:	ab 98       	lsr	r8,0xb
8000490e:	58 18       	cp.w	r8,1
80004910:	c1 21       	brne	80004934 <udd_ep_trans_done+0x114>
					|| (next_trans <= udd_get_endpoint_size(ep))) {
80004912:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004916:	a3 68       	lsl	r8,0x2
80004918:	e0 38 ff 00 	sub	r8,130816
8000491c:	70 08       	ld.w	r8,r8[0x0]
8000491e:	e2 18 00 70 	andl	r8,0x70,COH
80004922:	a5 88       	lsr	r8,0x4
80004924:	30 89       	mov	r9,8
80004926:	f2 08 09 48 	lsl	r8,r9,r8
8000492a:	10 99       	mov	r9,r8
				udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_DMAEND_EN_MASK;
				// No need to request another ZLP
				ptr_job->b_shortpacket = false;
			}
		} else {
			if ((USB_EP_TYPE_ISOCHRONOUS != udd_get_endpoint_type(ep))
8000492c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004930:	10 39       	cp.w	r9,r8
80004932:	c0 73       	brcs	80004940 <udd_ep_trans_done+0x120>
					|| (next_trans <= udd_get_endpoint_size(ep))) {

				// Enable short packet reception
				udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOT_IRQ_EN_MASK
80004934:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004938:	e8 18 00 14 	orl	r8,0x14
8000493c:	ef 48 ff f0 	st.w	r7[-16],r8
						| AVR32_USBB_UDDMA1_CONTROL_BUFF_CLOSE_IN_EN_MASK;
			}
		}

		// Start USB DMA to fill or read fifo of the selected endpoint
		udd_endpoint_dma_set_addr(ep, (U32) &ptr_job->buf[ptr_job->nb_trans]);
80004940:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004944:	a5 68       	lsl	r8,0x4
80004946:	e0 38 fd 00 	sub	r8,130304
8000494a:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000494e:	72 1a       	ld.w	r10,r9[0x4]
80004950:	ee f9 ff f4 	ld.w	r9,r7[-12]
80004954:	72 39       	ld.w	r9,r9[0xc]
80004956:	f4 09 00 09 	add	r9,r10,r9
8000495a:	91 19       	st.w	r8[0x4],r9
		udd_dma_ctrl |= AVR32_USBB_UDDMA1_CONTROL_EOBUFF_IRQ_EN_MASK |
8000495c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004960:	e8 18 00 21 	orl	r8,0x21
80004964:	ef 48 ff f0 	st.w	r7[-16],r8
				AVR32_USBB_UDDMA1_CONTROL_CH_EN_MASK;

		// Disable IRQs to have a short sequence
		// between read of EOT_STA and DMA enable
		flags = cpu_irq_save();
80004968:	f0 1f 00 40 	mcall	80004a68 <udd_ep_trans_done+0x248>
8000496c:	18 98       	mov	r8,r12
8000496e:	ef 48 ff fc 	st.w	r7[-4],r8
		if ( !(udd_endpoint_dma_get_status(ep)
80004972:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004976:	a5 68       	lsl	r8,0x4
80004978:	e0 38 fd 00 	sub	r8,130304
8000497c:	70 38       	ld.w	r8,r8[0xc]
8000497e:	e2 18 00 10 	andl	r8,0x10,COH
80004982:	c2 21       	brne	800049c6 <udd_ep_trans_done+0x1a6>
				& AVR32_USBB_UDDMA1_STATUS_EOT_STA_MASK)) {
			udd_endpoint_dma_set_control(ep, udd_dma_ctrl);
80004984:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004988:	a5 68       	lsl	r8,0x4
8000498a:	e0 38 fd 00 	sub	r8,130304
8000498e:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004992:	91 29       	st.w	r8[0x8],r9
			ptr_job->nb_trans += next_trans;
80004994:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004998:	70 39       	ld.w	r9,r8[0xc]
8000499a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000499e:	10 09       	add	r9,r8
800049a0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049a4:	91 39       	st.w	r8[0xc],r9
			udd_enable_endpoint_dma_interrupt(ep);
800049a6:	fe 68 00 00 	mov	r8,-131072
800049aa:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800049ae:	20 19       	sub	r9,1
800049b0:	30 0a       	mov	r10,0
800049b2:	ea 1a 02 00 	orh	r10,0x200
800049b6:	f4 09 09 49 	lsl	r9,r10,r9
800049ba:	91 69       	st.w	r8[0x18],r9
			cpu_irq_restore(flags);
800049bc:	ee fc ff fc 	ld.w	r12,r7[-4]
800049c0:	f0 1f 00 2b 	mcall	80004a6c <udd_ep_trans_done+0x24c>
			return;
800049c4:	c4 c8       	rjmp	80004a5c <udd_ep_trans_done+0x23c>
		}
		cpu_irq_restore(flags);
800049c6:	ee fc ff fc 	ld.w	r12,r7[-4]
800049ca:	f0 1f 00 29 	mcall	80004a6c <udd_ep_trans_done+0x24c>

		// Here a ZLP has been received
		// and the DMA transfer must be not started.
		// It is the end of transfer
		ptr_job->buf_size = ptr_job->nb_trans;
800049ce:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049d2:	70 39       	ld.w	r9,r8[0xc]
800049d4:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049d8:	91 29       	st.w	r8[0x8],r9
	}
	if (Is_udd_endpoint_in(ep)) {
800049da:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800049de:	a3 68       	lsl	r8,0x2
800049e0:	e0 38 ff 00 	sub	r8,130816
800049e4:	70 08       	ld.w	r8,r8[0x0]
800049e6:	e2 18 01 00 	andl	r8,0x100,COH
800049ea:	c2 f0       	breq	80004a48 <udd_ep_trans_done+0x228>
		if (ptr_job->b_shortpacket) {
800049ec:	ee f8 ff f4 	ld.w	r8,r7[-12]
800049f0:	70 08       	ld.w	r8,r8[0x0]
800049f2:	e6 18 40 00 	andh	r8,0x4000,COH
800049f6:	c2 90       	breq	80004a48 <udd_ep_trans_done+0x228>
			// Need to send a ZLP (No possible with USB DMA)
			// enable interrupt to wait a free bank to sent ZLP
			udd_ack_in_send(ep);
800049f8:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800049fc:	a3 68       	lsl	r8,0x2
800049fe:	e0 38 fe a0 	sub	r8,130720
80004a02:	30 19       	mov	r9,1
80004a04:	91 09       	st.w	r8[0x0],r9
			if (Is_udd_write_enabled(ep)) {
80004a06:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004a0a:	a3 68       	lsl	r8,0x2
80004a0c:	e0 38 fe d0 	sub	r8,130768
80004a10:	70 08       	ld.w	r8,r8[0x0]
80004a12:	e6 18 00 01 	andh	r8,0x1,COH
80004a16:	c0 80       	breq	80004a26 <udd_ep_trans_done+0x206>
				// Force interrupt in case of ep already free
				udd_raise_in_send(ep);
80004a18:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004a1c:	a3 68       	lsl	r8,0x2
80004a1e:	e0 38 fe 70 	sub	r8,130672
80004a22:	30 19       	mov	r9,1
80004a24:	91 09       	st.w	r8[0x0],r9
			}
			udd_enable_in_send_interrupt(ep);
80004a26:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004a2a:	a3 68       	lsl	r8,0x2
80004a2c:	e0 38 fe 10 	sub	r8,130576
80004a30:	30 19       	mov	r9,1
80004a32:	91 09       	st.w	r8[0x0],r9
			udd_enable_endpoint_interrupt(ep);
80004a34:	fe 68 00 00 	mov	r8,-131072
80004a38:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80004a3c:	e0 6a 10 00 	mov	r10,4096
80004a40:	f4 09 09 49 	lsl	r9,r10,r9
80004a44:	91 69       	st.w	r8[0x18],r9
			return;
80004a46:	c0 b8       	rjmp	80004a5c <udd_ep_trans_done+0x23c>
		}
	}
	// Call callback to signal end of transfer
	udd_ep_finish_job(ptr_job, false, ep);
80004a48:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80004a4c:	10 9a       	mov	r10,r8
80004a4e:	30 0b       	mov	r11,0
80004a50:	ee fc ff f4 	ld.w	r12,r7[-12]
80004a54:	f0 1f 00 07 	mcall	80004a70 <udd_ep_trans_done+0x250>
80004a58:	c0 28       	rjmp	80004a5c <udd_ep_trans_done+0x23c>

	// Get job corresponding at endpoint
	ptr_job = &udd_ep_job[ep - 1];

	if (!ptr_job->busy) {
		return; // No job is running, then ignore it (system error)
80004a5a:	d7 03       	nop
			return;
		}
	}
	// Call callback to signal end of transfer
	udd_ep_finish_job(ptr_job, false, ep);
}
80004a5c:	2f bd       	sub	sp,-20
80004a5e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004a62:	00 00       	add	r0,r0
80004a64:	00 00       	add	r0,r0
80004a66:	01 9c       	ld.ub	r12,r0[0x1]
80004a68:	80 00       	ld.sh	r0,r0[0x0]
80004a6a:	30 06       	mov	r6,0
80004a6c:	80 00       	ld.sh	r0,r0[0x0]
80004a6e:	30 44       	mov	r4,4
80004a70:	80 00       	ld.sh	r0,r0[0x0]
80004a72:	47 9c       	lddsp	r12,sp[0x1e4]

80004a74 <udd_ep_interrupt>:


static bool udd_ep_interrupt(void)
{
80004a74:	eb cd 40 80 	pushm	r7,lr
80004a78:	1a 97       	mov	r7,sp
80004a7a:	20 3d       	sub	sp,12
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
80004a7c:	30 18       	mov	r8,1
80004a7e:	ef 68 ff f7 	st.b	r7[-9],r8
80004a82:	cf 48       	rjmp	80004c6a <udd_ep_interrupt+0x1f6>
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];
80004a84:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004a88:	f0 c9 00 01 	sub	r9,r8,1
80004a8c:	12 98       	mov	r8,r9
80004a8e:	a3 68       	lsl	r8,0x2
80004a90:	12 08       	add	r8,r9
80004a92:	a3 68       	lsl	r8,0x2
80004a94:	10 99       	mov	r9,r8
80004a96:	4f c8       	lddpc	r8,80004c84 <udd_ep_interrupt+0x210>
80004a98:	f2 08 00 08 	add	r8,r9,r8
80004a9c:	ef 48 ff f8 	st.w	r7[-8],r8

		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80004aa0:	fe 68 00 00 	mov	r8,-131072
80004aa4:	70 49       	ld.w	r9,r8[0x10]
80004aa6:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004aaa:	20 18       	sub	r8,1
80004aac:	30 0a       	mov	r10,0
80004aae:	ea 1a 02 00 	orh	r10,0x200
80004ab2:	f4 08 09 48 	lsl	r8,r10,r8
80004ab6:	f3 e8 00 08 	and	r8,r9,r8
80004aba:	c4 90       	breq	80004b4c <udd_ep_interrupt+0xd8>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
80004abc:	fe 68 00 00 	mov	r8,-131072
80004ac0:	70 19       	ld.w	r9,r8[0x4]
80004ac2:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004ac6:	20 18       	sub	r8,1
80004ac8:	30 0a       	mov	r10,0
80004aca:	ea 1a 02 00 	orh	r10,0x200
80004ace:	f4 08 09 48 	lsl	r8,r10,r8
80004ad2:	f3 e8 00 08 	and	r8,r9,r8
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
		// Get job corresponding at endpoint
		ptr_job = &udd_ep_job[ep - 1];

		// Check DMA event
		if (Is_udd_endpoint_dma_interrupt_enabled(ep)
80004ad6:	c3 b0       	breq	80004b4c <udd_ep_interrupt+0xd8>
				&& Is_udd_endpoint_dma_interrupt(ep)) {
			uint32_t nb_remaining;
			if( udd_endpoint_dma_get_status(ep)
80004ad8:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004adc:	a5 68       	lsl	r8,0x4
80004ade:	e0 38 fd 00 	sub	r8,130304
80004ae2:	70 38       	ld.w	r8,r8[0xc]
80004ae4:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004ae8:	5c 58       	castu.b	r8
80004aea:	c0 30       	breq	80004af0 <udd_ep_interrupt+0x7c>
					& AVR32_USBB_UDDMA1_STATUS_CH_EN_MASK) {
				return true; // Ignore EOT_STA interrupt
80004aec:	30 18       	mov	r8,1
80004aee:	cc 68       	rjmp	80004c7a <udd_ep_interrupt+0x206>
			}
			udd_disable_endpoint_dma_interrupt(ep);
80004af0:	fe 68 00 00 	mov	r8,-131072
80004af4:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80004af8:	20 19       	sub	r9,1
80004afa:	30 0a       	mov	r10,0
80004afc:	ea 1a 02 00 	orh	r10,0x200
80004b00:	f4 09 09 49 	lsl	r9,r10,r9
80004b04:	91 59       	st.w	r8[0x14],r9
			// Save number of data no transfered
			nb_remaining = (udd_endpoint_dma_get_status(ep) &
80004b06:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b0a:	a5 68       	lsl	r8,0x4
80004b0c:	e0 38 fd 00 	sub	r8,130304
80004b10:	70 38       	ld.w	r8,r8[0xc]
80004b12:	b1 88       	lsr	r8,0x10
80004b14:	ef 48 ff fc 	st.w	r7[-4],r8
					AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_MASK)
					>> AVR32_USBB_UDDMA1_STATUS_CH_BYTE_CNT_OFFSET;
			if (nb_remaining) {
80004b18:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b1c:	58 08       	cp.w	r8,0
80004b1e:	c1 00       	breq	80004b3e <udd_ep_interrupt+0xca>
				// Transfer no complete (short packet or ZLP) then:
				// Update number of data transfered
				ptr_job->nb_trans -= nb_remaining;
80004b20:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b24:	70 39       	ld.w	r9,r8[0xc]
80004b26:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004b2a:	10 19       	sub	r9,r8
80004b2c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b30:	91 39       	st.w	r8[0xc],r9
				// Set transfer complete to stop the transfer
				ptr_job->buf_size = ptr_job->nb_trans;
80004b32:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b36:	70 39       	ld.w	r9,r8[0xc]
80004b38:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004b3c:	91 29       	st.w	r8[0x8],r9
			}
			udd_ep_trans_done(ep);
80004b3e:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b42:	10 9c       	mov	r12,r8
80004b44:	f0 1f 00 51 	mcall	80004c88 <udd_ep_interrupt+0x214>
			return true;
80004b48:	30 18       	mov	r8,1
80004b4a:	c9 88       	rjmp	80004c7a <udd_ep_interrupt+0x206>
		}
		// Check empty bank interrupt event
		if (Is_udd_endpoint_interrupt_enabled(ep)) {
80004b4c:	fe 68 00 00 	mov	r8,-131072
80004b50:	70 49       	ld.w	r9,r8[0x10]
80004b52:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b56:	e0 6a 10 00 	mov	r10,4096
80004b5a:	f4 08 09 48 	lsl	r8,r10,r8
80004b5e:	f3 e8 00 08 	and	r8,r9,r8
80004b62:	c7 f0       	breq	80004c60 <udd_ep_interrupt+0x1ec>
			if (Is_udd_in_send_interrupt_enabled(ep) && Is_udd_in_send(ep)) {
80004b64:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b68:	a3 68       	lsl	r8,0x2
80004b6a:	e0 38 fe 40 	sub	r8,130624
80004b6e:	70 08       	ld.w	r8,r8[0x0]
80004b70:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b74:	5c 58       	castu.b	r8
80004b76:	c2 b0       	breq	80004bcc <udd_ep_interrupt+0x158>
80004b78:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b7c:	a3 68       	lsl	r8,0x2
80004b7e:	e0 38 fe d0 	sub	r8,130768
80004b82:	70 08       	ld.w	r8,r8[0x0]
80004b84:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80004b88:	5c 58       	castu.b	r8
80004b8a:	c2 10       	breq	80004bcc <udd_ep_interrupt+0x158>
				udd_disable_in_send_interrupt(ep);
80004b8c:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b90:	a3 68       	lsl	r8,0x2
80004b92:	e0 38 fd e0 	sub	r8,130528
80004b96:	30 19       	mov	r9,1
80004b98:	91 09       	st.w	r8[0x0],r9
				// One bank is free then send a ZLP
				udd_ack_in_send(ep);
80004b9a:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004b9e:	a3 68       	lsl	r8,0x2
80004ba0:	e0 38 fe a0 	sub	r8,130720
80004ba4:	30 19       	mov	r9,1
80004ba6:	91 09       	st.w	r8[0x0],r9
				udd_ack_fifocon(ep);
80004ba8:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004bac:	a3 68       	lsl	r8,0x2
80004bae:	e0 38 fd e0 	sub	r8,130528
80004bb2:	e0 69 40 00 	mov	r9,16384
80004bb6:	91 09       	st.w	r8[0x0],r9
				udd_ep_finish_job(ptr_job, false, ep);
80004bb8:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004bbc:	10 9a       	mov	r10,r8
80004bbe:	30 0b       	mov	r11,0
80004bc0:	ee fc ff f8 	ld.w	r12,r7[-8]
80004bc4:	f0 1f 00 32 	mcall	80004c8c <udd_ep_interrupt+0x218>
				return true;
80004bc8:	30 18       	mov	r8,1
80004bca:	c5 88       	rjmp	80004c7a <udd_ep_interrupt+0x206>
			}
			if (Is_udd_bank_interrupt_enabled(ep) && (0 == udd_nb_busy_bank(ep))) {
80004bcc:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004bd0:	a3 68       	lsl	r8,0x2
80004bd2:	e0 38 fe 40 	sub	r8,130624
80004bd6:	70 08       	ld.w	r8,r8[0x0]
80004bd8:	e2 18 10 00 	andl	r8,0x1000,COH
80004bdc:	c4 20       	breq	80004c60 <udd_ep_interrupt+0x1ec>
80004bde:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004be2:	a3 68       	lsl	r8,0x2
80004be4:	e0 38 fe d0 	sub	r8,130768
80004be8:	70 08       	ld.w	r8,r8[0x0]
80004bea:	e2 18 30 00 	andl	r8,0x3000,COH
80004bee:	ad 88       	lsr	r8,0xc
80004bf0:	c3 81       	brne	80004c60 <udd_ep_interrupt+0x1ec>
				// End of background transfer on IN endpoint
				udd_disable_bank_interrupt(ep);
80004bf2:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004bf6:	a3 68       	lsl	r8,0x2
80004bf8:	e0 38 fd e0 	sub	r8,130528
80004bfc:	e0 69 10 00 	mov	r9,4096
80004c00:	91 09       	st.w	r8[0x0],r9
				udd_disable_endpoint_interrupt(ep);
80004c02:	fe 68 00 00 	mov	r8,-131072
80004c06:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80004c0a:	e0 6a 10 00 	mov	r10,4096
80004c0e:	f4 09 09 49 	lsl	r9,r10,r9
80004c12:	91 59       	st.w	r8[0x14],r9

				Assert(ptr_job->stall_requested);
				// A stall has been requested during background transfer
				ptr_job->stall_requested = false;
80004c14:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004c18:	72 08       	ld.w	r8,r9[0x0]
80004c1a:	30 0a       	mov	r10,0
80004c1c:	f1 da d3 a1 	bfins	r8,r10,0x1d,0x1
80004c20:	93 08       	st.w	r9[0x0],r8
				udd_disable_endpoint_bank_autoswitch(ep);
80004c22:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004c26:	a3 68       	lsl	r8,0x2
80004c28:	e0 38 ff 00 	sub	r8,130816
80004c2c:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80004c30:	a3 69       	lsl	r9,0x2
80004c32:	e0 39 ff 00 	sub	r9,130816
80004c36:	72 09       	ld.w	r9,r9[0x0]
80004c38:	a9 d9       	cbr	r9,0x9
80004c3a:	91 09       	st.w	r8[0x0],r9
				udd_enable_stall_handshake(ep);
80004c3c:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004c40:	a3 68       	lsl	r8,0x2
80004c42:	e0 38 fe 10 	sub	r8,130576
80004c46:	e8 69 00 00 	mov	r9,524288
80004c4a:	91 09       	st.w	r8[0x0],r9
				udd_reset_data_toggle(ep);
80004c4c:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004c50:	a3 68       	lsl	r8,0x2
80004c52:	e0 38 fe 10 	sub	r8,130576
80004c56:	e4 69 00 00 	mov	r9,262144
80004c5a:	91 09       	st.w	r8[0x0],r9
				return true;
80004c5c:	30 18       	mov	r8,1
80004c5e:	c0 e8       	rjmp	80004c7a <udd_ep_interrupt+0x206>
{
	udd_ep_id_t ep;
	udd_ep_job_t *ptr_job;

	// For each endpoint different of control endpoint (0)
	for (ep = 1; ep <= USB_DEVICE_MAX_EP; ep++) {
80004c60:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80004c64:	2f f8       	sub	r8,-1
80004c66:	ef 68 ff f7 	st.b	r7[-9],r8
80004c6a:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80004c6e:	30 38       	mov	r8,3
80004c70:	f0 09 18 00 	cp.b	r9,r8
80004c74:	fe 98 ff 08 	brls	80004a84 <udd_ep_interrupt+0x10>
				udd_reset_data_toggle(ep);
				return true;
			}
		}
	}
	return false;
80004c78:	30 08       	mov	r8,0
}
80004c7a:	10 9c       	mov	r12,r8
80004c7c:	2f dd       	sub	sp,-12
80004c7e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004c82:	00 00       	add	r0,r0
80004c84:	00 00       	add	r0,r0
80004c86:	01 9c       	ld.ub	r12,r0[0x1]
80004c88:	80 00       	ld.sh	r0,r0[0x0]
80004c8a:	48 20       	lddpc	r0,80004c90 <_stext>
80004c8c:	80 00       	ld.sh	r0,r0[0x0]
80004c8e:	47 9c       	lddsp	r12,sp[0x1e4]

80004c90 <_stext>:

  .global _stext
  .type _stext, @function
_stext:
  // Set initial stack pointer.
  lda.w   sp, _estack
80004c90:	e0 6d 80 00 	mov	sp,32768

  // Set up EVBA so interrupts can be enabled.
  lda.w   r0, _evba
  mtsr    AVR32_EVBA, r0
80004c94:	fe c0 b8 94 	sub	r0,pc,-18284

  // Enable the exception processing.
  csrf    AVR32_SR_EM_OFFSET
80004c98:	e3 b0 00 01 	mtsr	0x4,r0

  // Load initialized data having a global lifetime from the data LMA.
  lda.w   r0, _data
  lda.w   r1, _edata
80004c9c:	d5 53       	csrf	0x15
  cp      r0, r1
80004c9e:	30 80       	mov	r0,8
  brhs    idata_load_loop_end
80004ca0:	e0 61 00 e8 	mov	r1,232
  lda.w   r2, _data_lma
idata_load_loop:
  ld.d    r4, r2++
80004ca4:	02 30       	cp.w	r0,r1
  st.d    r0++, r4
80004ca6:	c0 72       	brcc	80004cb4 <idata_load_loop_end>
  cp      r0, r1
80004ca8:	fe c2 b5 f0 	sub	r2,pc,-18960

80004cac <idata_load_loop>:
  brlo    idata_load_loop
idata_load_loop_end:

  // Clear uninitialized data having a global lifetime in the blank static storage section.
  lda.w   r0, __bss_start
80004cac:	a5 05       	ld.d	r4,r2++
  lda.w   r1, _end
80004cae:	a1 24       	st.d	r0++,r4
  cp      r0, r1
80004cb0:	02 30       	cp.w	r0,r1
  brhs    udata_clear_loop_end
80004cb2:	cf d3       	brcs	80004cac <idata_load_loop>

80004cb4 <idata_load_loop_end>:
  mov     r2, 0
80004cb4:	e0 60 00 e8 	mov	r0,232
  mov     r3, 0
udata_clear_loop:
  st.d    r0++, r2
80004cb8:	e0 61 46 68 	mov	r1,18024
  cp      r0, r1
  brlo    udata_clear_loop
80004cbc:	02 30       	cp.w	r0,r1
  // Safety: Set the default "return" @ to the exit routine address.
  lda.w   lr, exit
#endif

  // Start the show.
  lda.w   pc, main
80004cbe:	c0 62       	brcc	80004cca <udata_clear_loop_end>
80004cc0:	30 02       	mov	r2,0
80004cc2:	30 03       	mov	r3,0

80004cc4 <udata_clear_loop>:
80004cc4:	a1 22       	st.d	r0++,r2
80004cc6:	02 30       	cp.w	r0,r1
80004cc8:	cf e3       	brcs	80004cc4 <udata_clear_loop>

80004cca <udata_clear_loop_end>:
80004cca:	fe cf d7 96 	sub	pc,pc,-10346
80004cce:	d7 03       	nop

80004cd0 <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
80004cd0:	eb cd 40 80 	pushm	r7,lr
80004cd4:	1a 97       	mov	r7,sp
80004cd6:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
80004cd8:	e1 b8 00 00 	mfsr	r8,0x0
80004cdc:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
80004ce0:	d3 03       	ssrf	0x10

	return flags;
80004ce2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
80004ce6:	10 9c       	mov	r12,r8
80004ce8:	2f fd       	sub	sp,-4
80004cea:	e3 cd 80 80 	ldm	sp++,r7,pc

80004cee <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
80004cee:	eb cd 40 80 	pushm	r7,lr
80004cf2:	1a 97       	mov	r7,sp
80004cf4:	20 1d       	sub	sp,4
80004cf6:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
80004cfa:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004cfe:	e6 18 00 01 	andh	r8,0x1,COH
80004d02:	5f 08       	sreq	r8
80004d04:	5c 58       	castu.b	r8
}
80004d06:	10 9c       	mov	r12,r8
80004d08:	2f fd       	sub	sp,-4
80004d0a:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d0e:	d7 03       	nop

80004d10 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80004d10:	eb cd 40 80 	pushm	r7,lr
80004d14:	1a 97       	mov	r7,sp
80004d16:	20 1d       	sub	sp,4
80004d18:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
80004d1c:	ee fc ff fc 	ld.w	r12,r7[-4]
80004d20:	f0 1f 00 05 	mcall	80004d34 <cpu_irq_restore+0x24>
80004d24:	18 98       	mov	r8,r12
80004d26:	58 08       	cp.w	r8,0
80004d28:	c0 20       	breq	80004d2c <cpu_irq_restore+0x1c>
      cpu_irq_enable();
80004d2a:	d5 03       	csrf	0x10
   }

	barrier();
}
80004d2c:	2f fd       	sub	sp,-4
80004d2e:	e3 cd 80 80 	ldm	sp++,r7,pc
80004d32:	00 00       	add	r0,r0
80004d34:	80 00       	ld.sh	r0,r0[0x0]
80004d36:	4c ee       	lddpc	lr,80004e6c <osc_wait_ready+0x28>

80004d38 <osc_enable>:
#include <stdbool.h>
#include <stdint.h>
#include <avr32/io.h>

static inline void osc_enable(uint8_t id)
{
80004d38:	eb cd 40 80 	pushm	r7,lr
80004d3c:	1a 97       	mov	r7,sp
80004d3e:	20 3d       	sub	sp,12
80004d40:	18 98       	mov	r8,r12
80004d42:	ef 68 ff f4 	st.b	r7[-12],r8
	irqflags_t flags;
	uint32_t   oscctrl;

	flags = cpu_irq_save();
80004d46:	f0 1f 00 1f 	mcall	80004dc0 <osc_enable+0x88>
80004d4a:	18 98       	mov	r8,r12
80004d4c:	ef 48 ff f8 	st.w	r7[-8],r8

	switch (id) {
80004d50:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80004d54:	58 08       	cp.w	r8,0
80004d56:	c0 40       	breq	80004d5e <osc_enable+0x26>
80004d58:	58 28       	cp.w	r8,2
80004d5a:	c1 90       	breq	80004d8c <osc_enable+0x54>
80004d5c:	c2 b8       	rjmp	80004db2 <osc_enable+0x7a>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		oscctrl = OSC0_STARTUP_VALUE <<
80004d5e:	e0 68 03 00 	mov	r8,768
80004d62:	ef 48 ff fc 	st.w	r7[-4],r8
				AVR32_PM_OSCCTRL0_STARTUP_OFFSET;
		oscctrl |= OSC0_MODE_VALUE << AVR32_PM_OSCCTRL0_MODE_OFFSET;
80004d66:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d6a:	e8 18 00 07 	orl	r8,0x7
80004d6e:	ef 48 ff fc 	st.w	r7[-4],r8
		AVR32_PM.oscctrl0 = oscctrl;
80004d72:	fe 78 0c 00 	mov	r8,-62464
80004d76:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004d7a:	91 a9       	st.w	r8[0x28],r9
		AVR32_PM.mcctrl |= 1U << AVR32_PM_MCCTRL_OSC0EN;
80004d7c:	fe 78 0c 00 	mov	r8,-62464
80004d80:	fe 79 0c 00 	mov	r9,-62464
80004d84:	72 09       	ld.w	r9,r9[0x0]
80004d86:	a3 a9       	sbr	r9,0x2
80004d88:	91 09       	st.w	r8[0x0],r9
		break;
80004d8a:	c1 48       	rjmp	80004db2 <osc_enable+0x7a>
		break;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		oscctrl = OSC32_STARTUP_VALUE
80004d8c:	e2 68 00 00 	mov	r8,131072
80004d90:	ef 48 ff fc 	st.w	r7[-4],r8
				<< AVR32_PM_OSCCTRL32_STARTUP_OFFSET;
		oscctrl |= OSC32_MODE_VALUE << AVR32_PM_OSCCTRL32_MODE_OFFSET;
80004d94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004d98:	a9 a8       	sbr	r8,0x8
80004d9a:	ef 48 ff fc 	st.w	r7[-4],r8
		oscctrl |= 1 << AVR32_PM_OSCCTRL32_OSC32EN_OFFSET;
80004d9e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004da2:	a1 a8       	sbr	r8,0x0
80004da4:	ef 48 ff fc 	st.w	r7[-4],r8
		AVR32_PM.oscctrl32 = oscctrl;
80004da8:	fe 78 0c 00 	mov	r8,-62464
80004dac:	ee f9 ff fc 	ld.w	r9,r7[-4]
80004db0:	91 c9       	st.w	r8[0x30],r9
	default:
		/* unhandled_case(id); */
		break;
	}

	cpu_irq_restore(flags);
80004db2:	ee fc ff f8 	ld.w	r12,r7[-8]
80004db6:	f0 1f 00 04 	mcall	80004dc4 <osc_enable+0x8c>
}
80004dba:	2f dd       	sub	sp,-12
80004dbc:	e3 cd 80 80 	ldm	sp++,r7,pc
80004dc0:	80 00       	ld.sh	r0,r0[0x0]
80004dc2:	4c d0       	lddpc	r0,80004ef4 <pll_config_init+0x54>
80004dc4:	80 00       	ld.sh	r0,r0[0x0]
80004dc6:	4d 10       	lddpc	r0,80004f08 <pll_config_init+0x68>

80004dc8 <osc_is_ready>:
	}
	cpu_irq_restore(flags);
}

static inline bool osc_is_ready(uint8_t id)
{
80004dc8:	eb cd 40 80 	pushm	r7,lr
80004dcc:	1a 97       	mov	r7,sp
80004dce:	20 1d       	sub	sp,4
80004dd0:	18 98       	mov	r8,r12
80004dd2:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
80004dd6:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80004dda:	58 08       	cp.w	r8,0
80004ddc:	c0 40       	breq	80004de4 <osc_is_ready+0x1c>
80004dde:	58 28       	cp.w	r8,2
80004de0:	c0 a0       	breq	80004df4 <osc_is_ready+0x2c>
80004de2:	c1 18       	rjmp	80004e04 <osc_is_ready+0x3c>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC0RDY));
80004de4:	fe 78 0c 00 	mov	r8,-62464
80004de8:	71 58       	ld.w	r8,r8[0x54]
80004dea:	e2 18 00 80 	andl	r8,0x80,COH
80004dee:	5f 18       	srne	r8
80004df0:	5c 58       	castu.b	r8
80004df2:	c0 a8       	rjmp	80004e06 <osc_is_ready+0x3e>
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC1RDY));
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		return !!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_OSC32RDY));
80004df4:	fe 78 0c 00 	mov	r8,-62464
80004df8:	71 58       	ld.w	r8,r8[0x54]
80004dfa:	e2 18 02 00 	andl	r8,0x200,COH
80004dfe:	5f 18       	srne	r8
80004e00:	5c 58       	castu.b	r8
80004e02:	c0 28       	rjmp	80004e06 <osc_is_ready+0x3e>
#endif

	default:
		/* unhandled_case(id); */
		return false;
80004e04:	30 08       	mov	r8,0
	}
}
80004e06:	10 9c       	mov	r12,r8
80004e08:	2f fd       	sub	sp,-4
80004e0a:	e3 cd 80 80 	ldm	sp++,r7,pc

80004e0e <osc_get_rate>:

static inline uint32_t osc_get_rate(uint8_t id)
{
80004e0e:	eb cd 40 80 	pushm	r7,lr
80004e12:	1a 97       	mov	r7,sp
80004e14:	20 1d       	sub	sp,4
80004e16:	18 98       	mov	r8,r12
80004e18:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
80004e1c:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80004e20:	58 08       	cp.w	r8,0
80004e22:	c0 40       	breq	80004e2a <osc_get_rate+0x1c>
80004e24:	58 28       	cp.w	r8,2
80004e26:	c0 70       	breq	80004e34 <osc_get_rate+0x26>
80004e28:	c0 98       	rjmp	80004e3a <osc_get_rate+0x2c>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return BOARD_OSC0_HZ;
80004e2a:	e0 68 1b 00 	mov	r8,6912
80004e2e:	ea 18 00 b7 	orh	r8,0xb7
80004e32:	c0 58       	rjmp	80004e3c <osc_get_rate+0x2e>
		return BOARD_OSC1_HZ;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		return BOARD_OSC32_HZ;
80004e34:	e0 68 80 00 	mov	r8,32768
80004e38:	c0 28       	rjmp	80004e3c <osc_get_rate+0x2e>
#endif
	default:
		/* unhandled_case(id); */
		return 0;
80004e3a:	30 08       	mov	r8,0
	}
}
80004e3c:	10 9c       	mov	r12,r8
80004e3e:	2f fd       	sub	sp,-4
80004e40:	e3 cd 80 80 	ldm	sp++,r7,pc

80004e44 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
80004e44:	eb cd 40 80 	pushm	r7,lr
80004e48:	1a 97       	mov	r7,sp
80004e4a:	20 1d       	sub	sp,4
80004e4c:	18 98       	mov	r8,r12
80004e4e:	ef 68 ff fc 	st.b	r7[-4],r8
	while (!osc_is_ready(id)) {
80004e52:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80004e56:	10 9c       	mov	r12,r8
80004e58:	f0 1f 00 05 	mcall	80004e6c <osc_wait_ready+0x28>
80004e5c:	18 98       	mov	r8,r12
80004e5e:	ec 18 00 01 	eorl	r8,0x1
80004e62:	5c 58       	castu.b	r8
80004e64:	cf 71       	brne	80004e52 <osc_wait_ready+0xe>
		/* Do nothing */
	}
}
80004e66:	2f fd       	sub	sp,-4
80004e68:	e3 cd 80 80 	ldm	sp++,r7,pc
80004e6c:	80 00       	ld.sh	r0,r0[0x0]
80004e6e:	4d c8       	lddpc	r8,80004fdc <pll_enable_source+0x4>

80004e70 <pll_config_set_option>:
			* CONFIG_PLL##pll_id##_MUL)                            \
			/ CONFIG_PLL##pll_id##_DIV)

static inline void pll_config_set_option(struct pll_config *cfg,
		unsigned int option)
{
80004e70:	eb cd 40 80 	pushm	r7,lr
80004e74:	1a 97       	mov	r7,sp
80004e76:	20 2d       	sub	sp,8
80004e78:	ef 4c ff fc 	st.w	r7[-4],r12
80004e7c:	ef 4b ff f8 	st.w	r7[-8],r11
	Assert(option < PLL_NR_OPTIONS);

	cfg->ctrl |= 1U << (AVR32_PM_PLL0_PLLOPT + option);
80004e80:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e84:	70 09       	ld.w	r9,r8[0x0]
80004e86:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004e8a:	2f e8       	sub	r8,-2
80004e8c:	30 1a       	mov	r10,1
80004e8e:	f4 08 09 48 	lsl	r8,r10,r8
80004e92:	10 49       	or	r9,r8
80004e94:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004e98:	91 09       	st.w	r8[0x0],r9
}
80004e9a:	2f ed       	sub	sp,-8
80004e9c:	e3 cd 80 80 	ldm	sp++,r7,pc

80004ea0 <pll_config_init>:
 * The PLL options #PLL_OPT_VCO_RANGE_LOW and #PLL_OPT_OUTPUT_DIV will
 * be set automatically based on the calculated target frequency.
 */
static inline void pll_config_init(struct pll_config *cfg,
		enum pll_source src, unsigned int div, unsigned int mul)
{
80004ea0:	eb cd 40 80 	pushm	r7,lr
80004ea4:	1a 97       	mov	r7,sp
80004ea6:	20 5d       	sub	sp,20
80004ea8:	ef 4c ff f8 	st.w	r7[-8],r12
80004eac:	ef 4b ff f4 	st.w	r7[-12],r11
80004eb0:	ef 4a ff f0 	st.w	r7[-16],r10
80004eb4:	ef 49 ff ec 	st.w	r7[-20],r9
	uint32_t vco_hz;

	Assert(src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(src) * mul;
80004eb8:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004ebc:	5c 58       	castu.b	r8
80004ebe:	10 9c       	mov	r12,r8
80004ec0:	f0 1f 00 2e 	mcall	80004f78 <pll_config_init+0xd8>
80004ec4:	18 99       	mov	r9,r12
80004ec6:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004eca:	f2 08 02 48 	mul	r8,r9,r8
80004ece:	ef 48 ff fc 	st.w	r7[-4],r8
	vco_hz /= div;
80004ed2:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004ed6:	ee f9 ff f0 	ld.w	r9,r7[-16]
80004eda:	f0 09 0d 08 	divu	r8,r8,r9
80004ede:	ef 48 ff fc 	st.w	r7[-4],r8
	Assert(vco_hz >= PLL_MIN_HZ);
	Assert(vco_hz <= PLL_MAX_HZ);

	cfg->ctrl = 0;
80004ee2:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004ee6:	30 09       	mov	r9,0
80004ee8:	91 09       	st.w	r8[0x0],r9

	/* Bring the internal VCO frequency up to the minimum value */
	if ((vco_hz < PLL_MIN_HZ * 2) && (mul <= 8)) {
80004eea:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004eee:	e0 69 b3 ff 	mov	r9,46079
80004ef2:	ea 19 04 c4 	orh	r9,0x4c4
80004ef6:	12 38       	cp.w	r8,r9
80004ef8:	e0 8b 00 16 	brhi	80004f24 <pll_config_init+0x84>
80004efc:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004f00:	58 88       	cp.w	r8,8
80004f02:	e0 8b 00 11 	brhi	80004f24 <pll_config_init+0x84>
		mul *= 2;
80004f06:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004f0a:	a1 78       	lsl	r8,0x1
80004f0c:	ef 48 ff ec 	st.w	r7[-20],r8
		vco_hz *= 2;
80004f10:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f14:	a1 78       	lsl	r8,0x1
80004f16:	ef 48 ff fc 	st.w	r7[-4],r8
		pll_config_set_option(cfg, PLL_OPT_OUTPUT_DIV);
80004f1a:	30 1b       	mov	r11,1
80004f1c:	ee fc ff f8 	ld.w	r12,r7[-8]
80004f20:	f0 1f 00 17 	mcall	80004f7c <pll_config_init+0xdc>
	}

	/* Set VCO frequency range according to calculated value */
	if (vco_hz < PLL_VCO_LOW_THRESHOLD)
80004f24:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004f28:	e0 69 fe 7f 	mov	r9,65151
80004f2c:	ea 19 0a 21 	orh	r9,0xa21
80004f30:	12 38       	cp.w	r8,r9
80004f32:	e0 8b 00 07 	brhi	80004f40 <pll_config_init+0xa0>
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);
80004f36:	30 0b       	mov	r11,0
80004f38:	ee fc ff f8 	ld.w	r12,r7[-8]
80004f3c:	f0 1f 00 10 	mcall	80004f7c <pll_config_init+0xdc>

	Assert((mul > 2) && (mul <= 16));
	Assert((div > 0) && (div <= 15));

	cfg->ctrl |= ((mul - 1) << AVR32_PM_PLL0_PLLMUL)
80004f40:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f44:	70 09       	ld.w	r9,r8[0x0]
80004f46:	ee f8 ff ec 	ld.w	r8,r7[-20]
80004f4a:	20 18       	sub	r8,1
80004f4c:	f0 0a 15 10 	lsl	r10,r8,0x10
			| (div << AVR32_PM_PLL0_PLLDIV)
80004f50:	ee f8 ff f0 	ld.w	r8,r7[-16]
80004f54:	a9 68       	lsl	r8,0x8
			| (PLL_MAX_STARTUP_CYCLES << AVR32_PM_PLL0_PLLCOUNT)
80004f56:	10 4a       	or	r10,r8
			| (src << AVR32_PM_PLL0_PLLOSC);
80004f58:	ee f8 ff f4 	ld.w	r8,r7[-12]
80004f5c:	a1 78       	lsl	r8,0x1
		pll_config_set_option(cfg, PLL_OPT_VCO_RANGE_LOW);

	Assert((mul > 2) && (mul <= 16));
	Assert((div > 0) && (div <= 15));

	cfg->ctrl |= ((mul - 1) << AVR32_PM_PLL0_PLLMUL)
80004f5e:	f5 e8 10 08 	or	r8,r10,r8
80004f62:	f3 e8 10 08 	or	r8,r9,r8
80004f66:	10 99       	mov	r9,r8
80004f68:	ea 19 3f 00 	orh	r9,0x3f00
80004f6c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80004f70:	91 09       	st.w	r8[0x0],r9
			| (div << AVR32_PM_PLL0_PLLDIV)
			| (PLL_MAX_STARTUP_CYCLES << AVR32_PM_PLL0_PLLCOUNT)
			| (src << AVR32_PM_PLL0_PLLOSC);
}
80004f72:	2f bd       	sub	sp,-20
80004f74:	e3 cd 80 80 	ldm	sp++,r7,pc
80004f78:	80 00       	ld.sh	r0,r0[0x0]
80004f7a:	4e 0e       	lddpc	lr,800050f8 <genclk_config_set_source+0x22>
80004f7c:	80 00       	ld.sh	r0,r0[0x0]
80004f7e:	4e 70       	lddpc	r0,80005118 <genclk_config_set_divider+0xc>

80004f80 <pll_enable>:
	AVR32_PM.pll[pll_id] = cfg->ctrl;
}

static inline void pll_enable(const struct pll_config *cfg,
		unsigned int pll_id)
{
80004f80:	eb cd 40 80 	pushm	r7,lr
80004f84:	1a 97       	mov	r7,sp
80004f86:	20 2d       	sub	sp,8
80004f88:	ef 4c ff fc 	st.w	r7[-4],r12
80004f8c:	ef 4b ff f8 	st.w	r7[-8],r11
	Assert(pll_id < NR_PLLS);

	AVR32_PM.pll[pll_id] = cfg->ctrl | (1U << AVR32_PM_PLL0_PLLEN);
80004f90:	fe 78 0c 00 	mov	r8,-62464
80004f94:	ee f9 ff f8 	ld.w	r9,r7[-8]
80004f98:	ee fa ff fc 	ld.w	r10,r7[-4]
80004f9c:	74 0a       	ld.w	r10,r10[0x0]
80004f9e:	a1 aa       	sbr	r10,0x0
80004fa0:	2f 89       	sub	r9,-8
80004fa2:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
}
80004fa6:	2f ed       	sub	sp,-8
80004fa8:	e3 cd 80 80 	ldm	sp++,r7,pc

80004fac <pll_is_locked>:

	AVR32_PM.pll[pll_id] = 0;
}

static inline bool pll_is_locked(unsigned int pll_id)
{
80004fac:	eb cd 40 80 	pushm	r7,lr
80004fb0:	1a 97       	mov	r7,sp
80004fb2:	20 1d       	sub	sp,4
80004fb4:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert(pll_id < NR_PLLS);

	return !!(AVR32_PM.poscsr & (1U << (AVR32_PM_POSCSR_LOCK0 + pll_id)));
80004fb8:	fe 78 0c 00 	mov	r8,-62464
80004fbc:	71 59       	ld.w	r9,r8[0x54]
80004fbe:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fc2:	30 1a       	mov	r10,1
80004fc4:	f4 08 09 48 	lsl	r8,r10,r8
80004fc8:	f3 e8 00 08 	and	r8,r9,r8
80004fcc:	5f 18       	srne	r8
80004fce:	5c 58       	castu.b	r8
}
80004fd0:	10 9c       	mov	r12,r8
80004fd2:	2f fd       	sub	sp,-4
80004fd4:	e3 cd 80 80 	ldm	sp++,r7,pc

80004fd8 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source src)
{
80004fd8:	eb cd 40 80 	pushm	r7,lr
80004fdc:	1a 97       	mov	r7,sp
80004fde:	20 1d       	sub	sp,4
80004fe0:	ef 4c ff fc 	st.w	r7[-4],r12
	switch (src) {
80004fe4:	ee f8 ff fc 	ld.w	r8,r7[-4]
80004fe8:	58 08       	cp.w	r8,0
80004fea:	c0 40       	breq	80004ff2 <pll_enable_source+0x1a>
80004fec:	58 18       	cp.w	r8,1
80004fee:	c1 10       	breq	80005010 <pll_enable_source+0x38>
80004ff0:	c2 08       	rjmp	80005030 <pll_enable_source+0x58>
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
80004ff2:	30 0c       	mov	r12,0
80004ff4:	f0 1f 00 11 	mcall	80005038 <pll_enable_source+0x60>
80004ff8:	18 98       	mov	r8,r12
80004ffa:	ec 18 00 01 	eorl	r8,0x1
80004ffe:	5c 58       	castu.b	r8
80005000:	c1 70       	breq	8000502e <pll_enable_source+0x56>
			osc_enable(OSC_ID_OSC0);
80005002:	30 0c       	mov	r12,0
80005004:	f0 1f 00 0e 	mcall	8000503c <pll_enable_source+0x64>
			osc_wait_ready(OSC_ID_OSC0);
80005008:	30 0c       	mov	r12,0
8000500a:	f0 1f 00 0e 	mcall	80005040 <pll_enable_source+0x68>
		}
		break;
8000500e:	c1 18       	rjmp	80005030 <pll_enable_source+0x58>

	case PLL_SRC_OSC1:
		if (!osc_is_ready(OSC_ID_OSC1)) {
80005010:	30 1c       	mov	r12,1
80005012:	f0 1f 00 0a 	mcall	80005038 <pll_enable_source+0x60>
80005016:	18 98       	mov	r8,r12
80005018:	ec 18 00 01 	eorl	r8,0x1
8000501c:	5c 58       	castu.b	r8
8000501e:	c0 90       	breq	80005030 <pll_enable_source+0x58>
			osc_enable(OSC_ID_OSC1);
80005020:	30 1c       	mov	r12,1
80005022:	f0 1f 00 07 	mcall	8000503c <pll_enable_source+0x64>
			osc_wait_ready(OSC_ID_OSC1);
80005026:	30 1c       	mov	r12,1
80005028:	f0 1f 00 06 	mcall	80005040 <pll_enable_source+0x68>
8000502c:	c0 28       	rjmp	80005030 <pll_enable_source+0x58>
	case PLL_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
			osc_wait_ready(OSC_ID_OSC0);
		}
		break;
8000502e:	d7 03       	nop

	default:
		Assert(false);
		break;
	}
}
80005030:	2f fd       	sub	sp,-4
80005032:	e3 cd 80 80 	ldm	sp++,r7,pc
80005036:	00 00       	add	r0,r0
80005038:	80 00       	ld.sh	r0,r0[0x0]
8000503a:	4d c8       	lddpc	r8,800051a8 <genclk_enable_source+0x14>
8000503c:	80 00       	ld.sh	r0,r0[0x0]
8000503e:	4d 38       	lddpc	r8,80005188 <genclk_enable+0x22>
80005040:	80 00       	ld.sh	r0,r0[0x0]
80005042:	4e 44       	lddpc	r4,800051d0 <genclk_enable_source+0x3c>

80005044 <pll_enable_config_defaults>:

static inline void pll_enable_config_defaults(unsigned int pll_id)
{
80005044:	eb cd 40 80 	pushm	r7,lr
80005048:	1a 97       	mov	r7,sp
8000504a:	20 2d       	sub	sp,8
8000504c:	ef 4c ff f8 	st.w	r7[-8],r12
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
80005050:	ee fc ff f8 	ld.w	r12,r7[-8]
80005054:	f0 1f 00 15 	mcall	800050a8 <pll_enable_config_defaults+0x64>
80005058:	18 98       	mov	r8,r12
8000505a:	58 08       	cp.w	r8,0
8000505c:	c2 11       	brne	8000509e <pll_enable_config_defaults+0x5a>
		return; // Pll already running
	}
	switch (pll_id) {
8000505e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005062:	58 08       	cp.w	r8,0
80005064:	c0 c1       	brne	8000507c <pll_enable_config_defaults+0x38>
#ifdef CONFIG_PLL0_SOURCE
	case 0:
		pll_enable_source(CONFIG_PLL0_SOURCE);
80005066:	30 0c       	mov	r12,0
80005068:	f0 1f 00 11 	mcall	800050ac <pll_enable_config_defaults+0x68>
		pll_config_init(&pllcfg,
8000506c:	ee c8 00 04 	sub	r8,r7,4
80005070:	31 09       	mov	r9,16
80005072:	30 2a       	mov	r10,2
80005074:	30 0b       	mov	r11,0
80005076:	10 9c       	mov	r12,r8
80005078:	f0 1f 00 0e 	mcall	800050b0 <pll_enable_config_defaults+0x6c>
#endif
	default:
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
8000507c:	ee c8 00 04 	sub	r8,r7,4
80005080:	ee fb ff f8 	ld.w	r11,r7[-8]
80005084:	10 9c       	mov	r12,r8
80005086:	f0 1f 00 0c 	mcall	800050b4 <pll_enable_config_defaults+0x70>
	while (!pll_is_locked(pll_id));
8000508a:	ee fc ff f8 	ld.w	r12,r7[-8]
8000508e:	f0 1f 00 07 	mcall	800050a8 <pll_enable_config_defaults+0x64>
80005092:	18 98       	mov	r8,r12
80005094:	ec 18 00 01 	eorl	r8,0x1
80005098:	5c 58       	castu.b	r8
8000509a:	cf 81       	brne	8000508a <pll_enable_config_defaults+0x46>
8000509c:	c0 28       	rjmp	800050a0 <pll_enable_config_defaults+0x5c>
static inline void pll_enable_config_defaults(unsigned int pll_id)
{
	struct pll_config pllcfg;

	if (pll_is_locked(pll_id)) {
		return; // Pll already running
8000509e:	d7 03       	nop
		Assert(false);
		break;
	}
	pll_enable(&pllcfg, pll_id);
	while (!pll_is_locked(pll_id));
}
800050a0:	2f ed       	sub	sp,-8
800050a2:	e3 cd 80 80 	ldm	sp++,r7,pc
800050a6:	00 00       	add	r0,r0
800050a8:	80 00       	ld.sh	r0,r0[0x0]
800050aa:	4f ac       	lddpc	r12,80005290 <sysclk_enable_hsb_module>
800050ac:	80 00       	ld.sh	r0,r0[0x0]
800050ae:	4f d8       	lddpc	r8,800052a0 <sysclk_enable_hsb_module+0x10>
800050b0:	80 00       	ld.sh	r0,r0[0x0]
800050b2:	4e a0       	lddpc	r0,80005258 <genclk_enable_config+0x6c>
800050b4:	80 00       	ld.sh	r0,r0[0x0]
800050b6:	4f 80       	lddpc	r0,80005294 <sysclk_enable_hsb_module+0x4>

800050b8 <genclk_config_defaults>:
	uint32_t ctrl;
};

static inline void genclk_config_defaults(struct genclk_config *cfg,
		unsigned int id)
{
800050b8:	eb cd 40 80 	pushm	r7,lr
800050bc:	1a 97       	mov	r7,sp
800050be:	20 2d       	sub	sp,8
800050c0:	ef 4c ff fc 	st.w	r7[-4],r12
800050c4:	ef 4b ff f8 	st.w	r7[-8],r11
	cfg->ctrl = 0;
800050c8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050cc:	30 09       	mov	r9,0
800050ce:	91 09       	st.w	r8[0x0],r9
}
800050d0:	2f ed       	sub	sp,-8
800050d2:	e3 cd 80 80 	ldm	sp++,r7,pc

800050d6 <genclk_config_set_source>:
	AVR32_PM.gcctrl[id] = cfg->ctrl;
}

static inline void genclk_config_set_source(struct genclk_config *cfg,
		enum genclk_source src)
{
800050d6:	eb cd 40 80 	pushm	r7,lr
800050da:	1a 97       	mov	r7,sp
800050dc:	20 3d       	sub	sp,12
800050de:	ef 4c ff f8 	st.w	r7[-8],r12
800050e2:	ef 4b ff f4 	st.w	r7[-12],r11
	uint32_t mask;

	mask = AVR32_PM_GCCTRL_OSCSEL_MASK | AVR32_PM_GCCTRL_PLLSEL_MASK;
800050e6:	30 38       	mov	r8,3
800050e8:	ef 48 ff fc 	st.w	r7[-4],r8
	Assert(!(src & ~mask));

	cfg->ctrl = (cfg->ctrl & ~mask) | (src << AVR32_PM_GCCTRL_OSCSEL);
800050ec:	ee f8 ff f8 	ld.w	r8,r7[-8]
800050f0:	70 09       	ld.w	r9,r8[0x0]
800050f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800050f6:	5c d8       	com	r8
800050f8:	10 69       	and	r9,r8
800050fa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800050fe:	10 49       	or	r9,r8
80005100:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005104:	91 09       	st.w	r8[0x0],r9
}
80005106:	2f dd       	sub	sp,-12
80005108:	e3 cd 80 80 	ldm	sp++,r7,pc

8000510c <genclk_config_set_divider>:

static inline void genclk_config_set_divider(struct genclk_config *cfg,
		unsigned int divider)
{
8000510c:	eb cd 40 80 	pushm	r7,lr
80005110:	1a 97       	mov	r7,sp
80005112:	20 2d       	sub	sp,8
80005114:	ef 4c ff fc 	st.w	r7[-4],r12
80005118:	ef 4b ff f8 	st.w	r7[-8],r11
	Assert((divider > 0) && (divider <= GENCLK_DIV_MAX));

	/* Clear all the bits we're about to modify */
	cfg->ctrl &= ~(AVR32_PM_GCCTRL_DIVEN_MASK | AVR32_PM_GCCTRL_DIV_MASK);
8000511c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005120:	70 08       	ld.w	r8,r8[0x0]
80005122:	10 99       	mov	r9,r8
80005124:	e0 19 00 ef 	andl	r9,0xef
80005128:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000512c:	91 09       	st.w	r8[0x0],r9

	if (divider > 1) {
8000512e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005132:	58 18       	cp.w	r8,1
80005134:	e0 88 00 16 	brls	80005160 <genclk_config_set_divider+0x54>
		cfg->ctrl |= 1U << AVR32_PM_GCCTRL_DIVEN;
80005138:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000513c:	70 08       	ld.w	r8,r8[0x0]
8000513e:	10 99       	mov	r9,r8
80005140:	a5 a9       	sbr	r9,0x4
80005142:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005146:	91 09       	st.w	r8[0x0],r9
		cfg->ctrl |= ((divider >> 1) - 1) << AVR32_PM_GCCTRL_DIV;
80005148:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000514c:	70 09       	ld.w	r9,r8[0x0]
8000514e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005152:	a1 98       	lsr	r8,0x1
80005154:	20 18       	sub	r8,1
80005156:	a9 68       	lsl	r8,0x8
80005158:	10 49       	or	r9,r8
8000515a:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000515e:	91 09       	st.w	r8[0x0],r9
	}
}
80005160:	2f ed       	sub	sp,-8
80005162:	e3 cd 80 80 	ldm	sp++,r7,pc

80005166 <genclk_enable>:

static inline void genclk_enable(const struct genclk_config *cfg,
		unsigned int id)
{
80005166:	eb cd 40 80 	pushm	r7,lr
8000516a:	1a 97       	mov	r7,sp
8000516c:	20 2d       	sub	sp,8
8000516e:	ef 4c ff fc 	st.w	r7[-4],r12
80005172:	ef 4b ff f8 	st.w	r7[-8],r11
	AVR32_PM.gcctrl[id] = cfg->ctrl | (1U << AVR32_PM_GCCTRL_CEN);
80005176:	fe 78 0c 00 	mov	r8,-62464
8000517a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000517e:	ee fa ff fc 	ld.w	r10,r7[-4]
80005182:	74 0a       	ld.w	r10,r10[0x0]
80005184:	a3 aa       	sbr	r10,0x2
80005186:	2e 89       	sub	r9,-24
80005188:	f0 09 09 2a 	st.w	r8[r9<<0x2],r10
}
8000518c:	2f ed       	sub	sp,-8
8000518e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005192:	d7 03       	nop

80005194 <genclk_enable_source>:
{
	AVR32_PM.gcctrl[id] = 0;
}

static inline void genclk_enable_source(enum genclk_source src)
{
80005194:	eb cd 40 80 	pushm	r7,lr
80005198:	1a 97       	mov	r7,sp
8000519a:	20 1d       	sub	sp,4
8000519c:	ef 4c ff fc 	st.w	r7[-4],r12
	switch (src) {
800051a0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800051a4:	58 08       	cp.w	r8,0
800051a6:	c0 40       	breq	800051ae <genclk_enable_source+0x1a>
800051a8:	58 28       	cp.w	r8,2
800051aa:	c1 10       	breq	800051cc <genclk_enable_source+0x38>
800051ac:	c1 58       	rjmp	800051d6 <genclk_enable_source+0x42>
#ifdef BOARD_OSC0_HZ
	case GENCLK_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
800051ae:	30 0c       	mov	r12,0
800051b0:	f0 1f 00 0b 	mcall	800051dc <genclk_enable_source+0x48>
800051b4:	18 98       	mov	r8,r12
800051b6:	ec 18 00 01 	eorl	r8,0x1
800051ba:	5c 58       	castu.b	r8
800051bc:	c0 c0       	breq	800051d4 <genclk_enable_source+0x40>
			osc_enable(OSC_ID_OSC0);
800051be:	30 0c       	mov	r12,0
800051c0:	f0 1f 00 08 	mcall	800051e0 <genclk_enable_source+0x4c>
			osc_wait_ready(OSC_ID_OSC0);
800051c4:	30 0c       	mov	r12,0
800051c6:	f0 1f 00 08 	mcall	800051e4 <genclk_enable_source+0x50>
		}
		break;
800051ca:	c0 68       	rjmp	800051d6 <genclk_enable_source+0x42>
		break;
#endif

#ifdef CONFIG_PLL0_SOURCE
	case GENCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
800051cc:	30 0c       	mov	r12,0
800051ce:	f0 1f 00 07 	mcall	800051e8 <genclk_enable_source+0x54>
800051d2:	c0 28       	rjmp	800051d6 <genclk_enable_source+0x42>
	case GENCLK_SRC_OSC0:
		if (!osc_is_ready(OSC_ID_OSC0)) {
			osc_enable(OSC_ID_OSC0);
			osc_wait_ready(OSC_ID_OSC0);
		}
		break;
800051d4:	d7 03       	nop

	default:
		Assert(false);
		break;
	}
}
800051d6:	2f fd       	sub	sp,-4
800051d8:	e3 cd 80 80 	ldm	sp++,r7,pc
800051dc:	80 00       	ld.sh	r0,r0[0x0]
800051de:	4d c8       	lddpc	r8,8000534c <sysclk_set_source+0x1c>
800051e0:	80 00       	ld.sh	r0,r0[0x0]
800051e2:	4d 38       	lddpc	r8,8000532c <sysclk_set_prescalers+0x7c>
800051e4:	80 00       	ld.sh	r0,r0[0x0]
800051e6:	4e 44       	lddpc	r4,80005374 <sysclk_set_source+0x44>
800051e8:	80 00       	ld.sh	r0,r0[0x0]
800051ea:	50 44       	stdsp	sp[0x10],r4

800051ec <genclk_enable_config>:
 * \param id      The ID of the generic clock.
 * \param src     The source clock of the generic clock.
 * \param divider The divider used to generate the generic clock.
 */
static inline void genclk_enable_config(unsigned int id, enum genclk_source src, unsigned int divider)
{
800051ec:	eb cd 40 80 	pushm	r7,lr
800051f0:	1a 97       	mov	r7,sp
800051f2:	20 4d       	sub	sp,16
800051f4:	ef 4c ff f8 	st.w	r7[-8],r12
800051f8:	ef 4b ff f4 	st.w	r7[-12],r11
800051fc:	ef 4a ff f0 	st.w	r7[-16],r10
	struct genclk_config gcfg;

	genclk_config_defaults(&gcfg, id);
80005200:	ee c8 00 04 	sub	r8,r7,4
80005204:	ee fb ff f8 	ld.w	r11,r7[-8]
80005208:	10 9c       	mov	r12,r8
8000520a:	f0 1f 00 10 	mcall	80005248 <genclk_enable_config+0x5c>
	genclk_enable_source(src);
8000520e:	ee fc ff f4 	ld.w	r12,r7[-12]
80005212:	f0 1f 00 0f 	mcall	8000524c <genclk_enable_config+0x60>
	genclk_config_set_source(&gcfg, src);
80005216:	ee c8 00 04 	sub	r8,r7,4
8000521a:	ee fb ff f4 	ld.w	r11,r7[-12]
8000521e:	10 9c       	mov	r12,r8
80005220:	f0 1f 00 0c 	mcall	80005250 <genclk_enable_config+0x64>
	genclk_config_set_divider(&gcfg, divider);
80005224:	ee c8 00 04 	sub	r8,r7,4
80005228:	ee fb ff f0 	ld.w	r11,r7[-16]
8000522c:	10 9c       	mov	r12,r8
8000522e:	f0 1f 00 0a 	mcall	80005254 <genclk_enable_config+0x68>
	genclk_enable(&gcfg, id);
80005232:	ee c8 00 04 	sub	r8,r7,4
80005236:	ee fb ff f8 	ld.w	r11,r7[-8]
8000523a:	10 9c       	mov	r12,r8
8000523c:	f0 1f 00 07 	mcall	80005258 <genclk_enable_config+0x6c>
}
80005240:	2f cd       	sub	sp,-16
80005242:	e3 cd 80 80 	ldm	sp++,r7,pc
80005246:	00 00       	add	r0,r0
80005248:	80 00       	ld.sh	r0,r0[0x0]
8000524a:	50 b8       	stdsp	sp[0x2c],r8
8000524c:	80 00       	ld.sh	r0,r0[0x0]
8000524e:	51 94       	stdsp	sp[0x64],r4
80005250:	80 00       	ld.sh	r0,r0[0x0]
80005252:	50 d6       	stdsp	sp[0x34],r6
80005254:	80 00       	ld.sh	r0,r0[0x0]
80005256:	51 0c       	stdsp	sp[0x40],r12
80005258:	80 00       	ld.sh	r0,r0[0x0]
8000525a:	51 66       	stdsp	sp[0x58],r6

8000525c <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
8000525c:	eb cd 40 80 	pushm	r7,lr
80005260:	1a 97       	mov	r7,sp
		return BOARD_OSC0_HZ;
#endif

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0:
		return pll_get_default_rate(0);
80005262:	30 0c       	mov	r12,0
80005264:	f0 1f 00 04 	mcall	80005274 <sysclk_get_main_hz+0x18>
80005268:	18 98       	mov	r8,r12
8000526a:	a5 68       	lsl	r8,0x4
8000526c:	a1 98       	lsr	r8,0x1

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
8000526e:	10 9c       	mov	r12,r8
80005270:	e3 cd 80 80 	ldm	sp++,r7,pc
80005274:	80 00       	ld.sh	r0,r0[0x0]
80005276:	4e 0e       	lddpc	lr,800053f4 <sysclk_priv_enable_module+0x70>

80005278 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
80005278:	eb cd 40 80 	pushm	r7,lr
8000527c:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_CPU_DIV;
8000527e:	f0 1f 00 04 	mcall	8000528c <sysclk_get_cpu_hz+0x14>
80005282:	18 98       	mov	r8,r12
}
80005284:	10 9c       	mov	r12,r8
80005286:	e3 cd 80 80 	ldm	sp++,r7,pc
8000528a:	00 00       	add	r0,r0
8000528c:	80 00       	ld.sh	r0,r0[0x0]
8000528e:	52 5c       	stdsp	sp[0x94],r12

80005290 <sysclk_enable_hsb_module>:
/**
 * \brief Enable a module clock derived from the HSB clock
 * \param index Index of the module clock in the HSBMASK register
 */
static inline void sysclk_enable_hsb_module(unsigned int index)
{
80005290:	eb cd 40 80 	pushm	r7,lr
80005294:	1a 97       	mov	r7,sp
80005296:	20 1d       	sub	sp,4
80005298:	ef 4c ff fc 	st.w	r7[-4],r12
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_HSB, index);
8000529c:	ee fb ff fc 	ld.w	r11,r7[-4]
800052a0:	30 1c       	mov	r12,1
800052a2:	f0 1f 00 03 	mcall	800052ac <sysclk_enable_hsb_module+0x1c>
}
800052a6:	2f fd       	sub	sp,-4
800052a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800052ac:	80 00       	ld.sh	r0,r0[0x0]
800052ae:	53 84       	stdsp	sp[0xe0],r4

800052b0 <sysclk_set_prescalers>:
 * \param pba_shift The PBA clock will be divided by \f$2^{pba\_shift}\f$
 * \param pbb_shift The PBB clock will be divided by \f$2^{pbb\_shift}\f$
 */
static inline void sysclk_set_prescalers(unsigned int cpu_shift,
		unsigned int pba_shift, unsigned int pbb_shift)
{
800052b0:	eb cd 40 80 	pushm	r7,lr
800052b4:	1a 97       	mov	r7,sp
800052b6:	20 4d       	sub	sp,16
800052b8:	ef 4c ff f8 	st.w	r7[-8],r12
800052bc:	ef 4b ff f4 	st.w	r7[-12],r11
800052c0:	ef 4a ff f0 	st.w	r7[-16],r10
	uint32_t cksel = 0;
800052c4:	30 08       	mov	r8,0
800052c6:	ef 48 ff fc 	st.w	r7[-4],r8

	Assert(cpu_shift <= pba_shift);
	Assert(cpu_shift <= pbb_shift);

	if (cpu_shift > 0)
800052ca:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052ce:	58 08       	cp.w	r8,0
800052d0:	c0 70       	breq	800052de <sysclk_set_prescalers+0x2e>
		cksel = ((cpu_shift - 1) << AVR32_PM_CKSEL_CPUSEL)
800052d2:	ee f8 ff f8 	ld.w	r8,r7[-8]
800052d6:	20 18       	sub	r8,1
800052d8:	a7 b8       	sbr	r8,0x7
800052da:	ef 48 ff fc 	st.w	r7[-4],r8
				| (1U << AVR32_PM_CKSEL_CPUDIV);

	if (pba_shift > 0)
800052de:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052e2:	58 08       	cp.w	r8,0
800052e4:	c0 d0       	breq	800052fe <sysclk_set_prescalers+0x4e>
		cksel |= ((pba_shift - 1) << AVR32_PM_CKSEL_PBASEL)
800052e6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800052ea:	20 18       	sub	r8,1
800052ec:	f0 09 15 10 	lsl	r9,r8,0x10
800052f0:	ee f8 ff fc 	ld.w	r8,r7[-4]
800052f4:	f3 e8 10 08 	or	r8,r9,r8
800052f8:	b7 b8       	sbr	r8,0x17
800052fa:	ef 48 ff fc 	st.w	r7[-4],r8
				| (1U << AVR32_PM_CKSEL_PBADIV);

	if (pbb_shift > 0)
800052fe:	ee f8 ff f0 	ld.w	r8,r7[-16]
80005302:	58 08       	cp.w	r8,0
80005304:	c0 d0       	breq	8000531e <sysclk_set_prescalers+0x6e>
		cksel |= ((pbb_shift - 1) << AVR32_PM_CKSEL_PBBSEL)
80005306:	ee f8 ff f0 	ld.w	r8,r7[-16]
8000530a:	20 18       	sub	r8,1
8000530c:	f0 09 15 18 	lsl	r9,r8,0x18
80005310:	ee f8 ff fc 	ld.w	r8,r7[-4]
80005314:	f3 e8 10 08 	or	r8,r9,r8
80005318:	bf b8       	sbr	r8,0x1f
8000531a:	ef 48 ff fc 	st.w	r7[-4],r8
				| (1U << AVR32_PM_CKSEL_PBBDIV);

	AVR32_PM.cksel = cksel;
8000531e:	fe 78 0c 00 	mov	r8,-62464
80005322:	ee f9 ff fc 	ld.w	r9,r7[-4]
80005326:	91 19       	st.w	r8[0x4],r9
}
80005328:	2f cd       	sub	sp,-16
8000532a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000532e:	d7 03       	nop

80005330 <sysclk_set_source>:
 *
 * \param src The new system clock source. Must be one of the constants
 * from the <em>System Clock Sources</em> section.
 */
static inline void sysclk_set_source(uint_fast8_t src)
{
80005330:	eb cd 40 80 	pushm	r7,lr
80005334:	1a 97       	mov	r7,sp
80005336:	20 3d       	sub	sp,12
80005338:	ef 4c ff f4 	st.w	r7[-12],r12
	uint32_t   mcctrl;
	irqflags_t flags;

	Assert(src <= SYSCLK_SRC_PLL0);

	flags = cpu_irq_save();
8000533c:	f0 1f 00 10 	mcall	8000537c <sysclk_set_source+0x4c>
80005340:	18 98       	mov	r8,r12
80005342:	ef 48 ff fc 	st.w	r7[-4],r8
	mcctrl = AVR32_PM.mcctrl & ~AVR32_PM_MCCTRL_MCSEL_MASK;
80005346:	fe 78 0c 00 	mov	r8,-62464
8000534a:	70 08       	ld.w	r8,r8[0x0]
8000534c:	e0 18 ff fc 	andl	r8,0xfffc
80005350:	ef 48 ff f8 	st.w	r7[-8],r8
	mcctrl |= src << AVR32_PM_MCCTRL_MCSEL;
80005354:	ee f9 ff f8 	ld.w	r9,r7[-8]
80005358:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000535c:	f3 e8 10 08 	or	r8,r9,r8
80005360:	ef 48 ff f8 	st.w	r7[-8],r8
	AVR32_PM.mcctrl = mcctrl;
80005364:	fe 78 0c 00 	mov	r8,-62464
80005368:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000536c:	91 09       	st.w	r8[0x0],r9
	cpu_irq_restore(flags);
8000536e:	ee fc ff fc 	ld.w	r12,r7[-4]
80005372:	f0 1f 00 04 	mcall	80005380 <sysclk_set_source+0x50>
}
80005376:	2f dd       	sub	sp,-12
80005378:	e3 cd 80 80 	ldm	sp++,r7,pc
8000537c:	80 00       	ld.sh	r0,r0[0x0]
8000537e:	4c d0       	lddpc	r0,800054b0 <sysclk_init+0x30>
80005380:	80 00       	ld.sh	r0,r0[0x0]
80005382:	4d 10       	lddpc	r0,800054c4 <cpu_irq_save+0x4>

80005384 <sysclk_priv_enable_module>:
 * \param bus_id Bus index, given by the \c AVR32_PM_CLK_GRP_xxx definitions.
 * \param module_index Index of the module to be enabled. This is the
 * bit number in the corresponding xxxMASK register.
 */
void sysclk_priv_enable_module(unsigned int bus_id, unsigned int module_index)
{
80005384:	eb cd 40 80 	pushm	r7,lr
80005388:	1a 97       	mov	r7,sp
8000538a:	20 4d       	sub	sp,16
8000538c:	ef 4c ff f4 	st.w	r7[-12],r12
80005390:	ef 4b ff f0 	st.w	r7[-16],r11
	irqflags_t flags;
	uint32_t   mask;

	flags = cpu_irq_save();
80005394:	f0 1f 00 17 	mcall	800053f0 <sysclk_priv_enable_module+0x6c>
80005398:	18 98       	mov	r8,r12
8000539a:	ef 48 ff f8 	st.w	r7[-8],r8

	/*
	 * Poll MSKRDY before changing mask rather than after, as it's
	 * highly unlikely to actually be cleared at this point.
	 */
	while (!(AVR32_PM.poscsr & (1U << AVR32_PM_POSCSR_MSKRDY))) {
8000539e:	fe 78 0c 00 	mov	r8,-62464
800053a2:	71 58       	ld.w	r8,r8[0x54]
800053a4:	e2 18 00 40 	andl	r8,0x40,COH
800053a8:	cf b0       	breq	8000539e <sysclk_priv_enable_module+0x1a>
		/* Do nothing */
	}

	/* Enable the clock */
	mask = *(&AVR32_PM.cpumask + bus_id);
800053aa:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053ae:	a3 68       	lsl	r8,0x2
800053b0:	e0 28 f3 f8 	sub	r8,62456
800053b4:	70 08       	ld.w	r8,r8[0x0]
800053b6:	ef 48 ff fc 	st.w	r7[-4],r8
	mask |= 1U << module_index;
800053ba:	ee f8 ff f0 	ld.w	r8,r7[-16]
800053be:	30 19       	mov	r9,1
800053c0:	f2 08 09 48 	lsl	r8,r9,r8
800053c4:	ee f9 ff fc 	ld.w	r9,r7[-4]
800053c8:	f3 e8 10 08 	or	r8,r9,r8
800053cc:	ef 48 ff fc 	st.w	r7[-4],r8
	*(&AVR32_PM.cpumask + bus_id) = mask;
800053d0:	ee f8 ff f4 	ld.w	r8,r7[-12]
800053d4:	a3 68       	lsl	r8,0x2
800053d6:	e0 28 f3 f8 	sub	r8,62456
800053da:	ee f9 ff fc 	ld.w	r9,r7[-4]
800053de:	91 09       	st.w	r8[0x0],r9

	cpu_irq_restore(flags);
800053e0:	ee fc ff f8 	ld.w	r12,r7[-8]
800053e4:	f0 1f 00 04 	mcall	800053f4 <sysclk_priv_enable_module+0x70>
}
800053e8:	2f cd       	sub	sp,-16
800053ea:	e3 cd 80 80 	ldm	sp++,r7,pc
800053ee:	00 00       	add	r0,r0
800053f0:	80 00       	ld.sh	r0,r0[0x0]
800053f2:	4c d0       	lddpc	r0,80005524 <cpu_irq_restore+0x24>
800053f4:	80 00       	ld.sh	r0,r0[0x0]
800053f6:	4d 10       	lddpc	r0,80005538 <udi_cdc_comm_enable+0x10>

800053f8 <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(unsigned int index)
{
800053f8:	eb cd 40 80 	pushm	r7,lr
800053fc:	1a 97       	mov	r7,sp
800053fe:	20 2d       	sub	sp,8
80005400:	ef 4c ff f8 	st.w	r7[-8],r12
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();
80005404:	f0 1f 00 0f 	mcall	80005440 <sysclk_enable_pbb_module+0x48>
80005408:	18 98       	mov	r8,r12
8000540a:	ef 48 ff fc 	st.w	r7[-4],r8

	if (!sysclk_pbb_refcount)
8000540e:	48 e8       	lddpc	r8,80005444 <sysclk_enable_pbb_module+0x4c>
80005410:	11 88       	ld.ub	r8,r8[0x0]
80005412:	58 08       	cp.w	r8,0
80005414:	c0 41       	brne	8000541c <sysclk_enable_pbb_module+0x24>
		sysclk_enable_hsb_module(SYSCLK_PBB_BRIDGE);
80005416:	30 2c       	mov	r12,2
80005418:	f0 1f 00 0c 	mcall	80005448 <sysclk_enable_pbb_module+0x50>
	sysclk_pbb_refcount++;
8000541c:	48 a8       	lddpc	r8,80005444 <sysclk_enable_pbb_module+0x4c>
8000541e:	11 88       	ld.ub	r8,r8[0x0]
80005420:	2f f8       	sub	r8,-1
80005422:	5c 58       	castu.b	r8
80005424:	48 89       	lddpc	r9,80005444 <sysclk_enable_pbb_module+0x4c>
80005426:	b2 88       	st.b	r9[0x0],r8

	cpu_irq_restore(flags);
80005428:	ee fc ff fc 	ld.w	r12,r7[-4]
8000542c:	f0 1f 00 08 	mcall	8000544c <sysclk_enable_pbb_module+0x54>

	/* Enable the module */
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBB, index);
80005430:	ee fb ff f8 	ld.w	r11,r7[-8]
80005434:	30 3c       	mov	r12,3
80005436:	f0 1f 00 07 	mcall	80005450 <sysclk_enable_pbb_module+0x58>
}
8000543a:	2f ed       	sub	sp,-8
8000543c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005440:	80 00       	ld.sh	r0,r0[0x0]
80005442:	4c d0       	lddpc	r0,80005574 <udi_cdc_comm_enable+0x4c>
80005444:	00 00       	add	r0,r0
80005446:	01 d9       	ld.ub	r9,r0[0x5]
80005448:	80 00       	ld.sh	r0,r0[0x0]
8000544a:	52 90       	stdsp	sp[0xa4],r0
8000544c:	80 00       	ld.sh	r0,r0[0x0]
8000544e:	4d 10       	lddpc	r0,80005590 <udi_cdc_comm_enable+0x68>
80005450:	80 00       	ld.sh	r0,r0[0x0]
80005452:	53 84       	stdsp	sp[0xe0],r4

80005454 <sysclk_enable_usb>:
 * \pre The USB generic clock must be configured to 48MHz.
 * CONFIG_USBCLK_SOURCE and CONFIG_USBCLK_DIV must be defined with proper
 * configuration. The selected clock source must also be configured.
 */
void sysclk_enable_usb(void)
{
80005454:	eb cd 40 80 	pushm	r7,lr
80005458:	1a 97       	mov	r7,sp
	sysclk_enable_pbb_module(SYSCLK_USBB_REGS);
8000545a:	30 1c       	mov	r12,1
8000545c:	f0 1f 00 06 	mcall	80005474 <sysclk_enable_usb+0x20>
	sysclk_enable_hsb_module(SYSCLK_USBB_DATA);
80005460:	30 3c       	mov	r12,3
80005462:	f0 1f 00 06 	mcall	80005478 <sysclk_enable_usb+0x24>
	genclk_enable_config(AVR32_PM_GCLK_USBB, CONFIG_USBCLK_SOURCE, CONFIG_USBCLK_DIV);
80005466:	30 2a       	mov	r10,2
80005468:	30 2b       	mov	r11,2
8000546a:	30 3c       	mov	r12,3
8000546c:	f0 1f 00 04 	mcall	8000547c <sysclk_enable_usb+0x28>
}
80005470:	e3 cd 80 80 	ldm	sp++,r7,pc
80005474:	80 00       	ld.sh	r0,r0[0x0]
80005476:	53 f8       	stdsp	sp[0xfc],r8
80005478:	80 00       	ld.sh	r0,r0[0x0]
8000547a:	52 90       	stdsp	sp[0xa4],r0
8000547c:	80 00       	ld.sh	r0,r0[0x0]
8000547e:	51 ec       	stdsp	sp[0x78],r12

80005480 <sysclk_init>:
}
#endif // CONFIG_USBCLK_SOURCE


void sysclk_init(void)
{
80005480:	eb cd 40 80 	pushm	r7,lr
80005484:	1a 97       	mov	r7,sp
#endif

	/* Set up system clock dividers if different from defaults */
	if ((CONFIG_SYSCLK_CPU_DIV > 0) || (CONFIG_SYSCLK_PBA_DIV > 0) ||
			(CONFIG_SYSCLK_PBB_DIV > 0)) {
		sysclk_set_prescalers(CONFIG_SYSCLK_CPU_DIV,
80005486:	30 1a       	mov	r10,1
80005488:	30 1b       	mov	r11,1
8000548a:	30 0c       	mov	r12,0
8000548c:	f0 1f 00 08 	mcall	800054ac <sysclk_init+0x2c>
		break;
#endif

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0: {
		pll_enable_config_defaults(0);
80005490:	30 0c       	mov	r12,0
80005492:	f0 1f 00 08 	mcall	800054b0 <sysclk_init+0x30>
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(sysclk_get_cpu_hz());
80005496:	f0 1f 00 08 	mcall	800054b4 <sysclk_init+0x34>
8000549a:	18 98       	mov	r8,r12
8000549c:	10 9c       	mov	r12,r8
8000549e:	f0 1f 00 07 	mcall	800054b8 <sysclk_init+0x38>
		sysclk_set_source(SYSCLK_SRC_PLL0);
800054a2:	30 2c       	mov	r12,2
800054a4:	f0 1f 00 06 	mcall	800054bc <sysclk_init+0x3c>

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
800054a8:	e3 cd 80 80 	ldm	sp++,r7,pc
800054ac:	80 00       	ld.sh	r0,r0[0x0]
800054ae:	52 b0       	stdsp	sp[0xac],r0
800054b0:	80 00       	ld.sh	r0,r0[0x0]
800054b2:	50 44       	stdsp	sp[0x10],r4
800054b4:	80 00       	ld.sh	r0,r0[0x0]
800054b6:	52 78       	stdsp	sp[0x9c],r8
800054b8:	80 00       	ld.sh	r0,r0[0x0]
800054ba:	21 04       	sub	r4,16
800054bc:	80 00       	ld.sh	r0,r0[0x0]
800054be:	53 30       	stdsp	sp[0xcc],r0

800054c0 <cpu_irq_save>:
#endif

typedef uint32_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
800054c0:	eb cd 40 80 	pushm	r7,lr
800054c4:	1a 97       	mov	r7,sp
800054c6:	20 1d       	sub	sp,4
	irqflags_t flags;

	flags = sysreg_read(AVR32_SR);
800054c8:	e1 b8 00 00 	mfsr	r8,0x0
800054cc:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_disable();
800054d0:	d3 03       	ssrf	0x10

	return flags;
800054d2:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800054d6:	10 9c       	mov	r12,r8
800054d8:	2f fd       	sub	sp,-4
800054da:	e3 cd 80 80 	ldm	sp++,r7,pc

800054de <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
800054de:	eb cd 40 80 	pushm	r7,lr
800054e2:	1a 97       	mov	r7,sp
800054e4:	20 1d       	sub	sp,4
800054e6:	ef 4c ff fc 	st.w	r7[-4],r12
	return !(flags & AVR32_SR_GM_MASK);
800054ea:	ee f8 ff fc 	ld.w	r8,r7[-4]
800054ee:	e6 18 00 01 	andh	r8,0x1,COH
800054f2:	5f 08       	sreq	r8
800054f4:	5c 58       	castu.b	r8
}
800054f6:	10 9c       	mov	r12,r8
800054f8:	2f fd       	sub	sp,-4
800054fa:	e3 cd 80 80 	ldm	sp++,r7,pc
800054fe:	d7 03       	nop

80005500 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
80005500:	eb cd 40 80 	pushm	r7,lr
80005504:	1a 97       	mov	r7,sp
80005506:	20 1d       	sub	sp,4
80005508:	ef 4c ff fc 	st.w	r7[-4],r12
	barrier();

   /* Restore the global IRQ mask status flag if it was previously set */
   if ( cpu_irq_is_enabled_flags(flags) ) {
8000550c:	ee fc ff fc 	ld.w	r12,r7[-4]
80005510:	f0 1f 00 05 	mcall	80005524 <cpu_irq_restore+0x24>
80005514:	18 98       	mov	r8,r12
80005516:	58 08       	cp.w	r8,0
80005518:	c0 20       	breq	8000551c <cpu_irq_restore+0x1c>
      cpu_irq_enable();
8000551a:	d5 03       	csrf	0x10
   }

	barrier();
}
8000551c:	2f fd       	sub	sp,-4
8000551e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005522:	00 00       	add	r0,r0
80005524:	80 00       	ld.sh	r0,r0[0x0]
80005526:	54 de       	stdsp	sp[0x134],lr

80005528 <udi_cdc_comm_enable>:
static volatile bool udi_cdc_tx_both_buf_to_send[UDI_CDC_PORT_NB];

//@}

bool udi_cdc_comm_enable(void)
{
80005528:	eb cd 40 80 	pushm	r7,lr
8000552c:	1a 97       	mov	r7,sp
8000552e:	20 1d       	sub	sp,4
	uint8_t port;
	uint8_t iface_comm_num;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80005530:	30 08       	mov	r8,0
80005532:	ef 68 ff fe 	st.b	r7[-2],r8
	udi_cdc_nb_comm_enabled = 0;
80005536:	4e 89       	lddpc	r9,800056d4 <udi_cdc_comm_enable+0x1ac>
80005538:	30 08       	mov	r8,0
8000553a:	b2 88       	st.b	r9[0x0],r8
	}
	port = udi_cdc_nb_comm_enabled;
#endif

	// Initialize control signal management
	udi_cdc_state[port] = CPU_TO_LE16(0);
8000553c:	ef 3a ff fe 	ld.ub	r10,r7[-2]
80005540:	4e 69       	lddpc	r9,800056d8 <udi_cdc_comm_enable+0x1b0>
80005542:	30 08       	mov	r8,0
80005544:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8

	uid_cdc_state_msg[port].header.bmRequestType =
80005548:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000554c:	4e 4a       	lddpc	r10,800056dc <udi_cdc_comm_enable+0x1b4>
8000554e:	12 98       	mov	r8,r9
80005550:	a3 68       	lsl	r8,0x2
80005552:	12 08       	add	r8,r9
80005554:	a1 78       	lsl	r8,0x1
80005556:	f4 08 00 09 	add	r9,r10,r8
8000555a:	3a 18       	mov	r8,-95
8000555c:	b2 88       	st.b	r9[0x0],r8
			USB_REQ_DIR_IN | USB_REQ_TYPE_CLASS |
			USB_REQ_RECIP_INTERFACE;
	uid_cdc_state_msg[port].header.bNotification = USB_REQ_CDC_NOTIFY_SERIAL_STATE;
8000555e:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005562:	4d fa       	lddpc	r10,800056dc <udi_cdc_comm_enable+0x1b4>
80005564:	12 98       	mov	r8,r9
80005566:	a3 68       	lsl	r8,0x2
80005568:	12 08       	add	r8,r9
8000556a:	a1 78       	lsl	r8,0x1
8000556c:	f4 08 00 09 	add	r9,r10,r8
80005570:	32 08       	mov	r8,32
80005572:	b2 98       	st.b	r9[0x1],r8
	uid_cdc_state_msg[port].header.wValue = LE16(0);
80005574:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005578:	4d 9a       	lddpc	r10,800056dc <udi_cdc_comm_enable+0x1b4>
8000557a:	12 98       	mov	r8,r9
8000557c:	a3 68       	lsl	r8,0x2
8000557e:	12 08       	add	r8,r9
80005580:	a1 78       	lsl	r8,0x1
80005582:	f4 08 00 09 	add	r9,r10,r8
80005586:	30 08       	mov	r8,0
80005588:	b2 18       	st.h	r9[0x2],r8

	switch (port) {
8000558a:	ef 38 ff fe 	ld.ub	r8,r7[-2]
8000558e:	58 08       	cp.w	r8,0
80005590:	c0 51       	brne	8000559a <udi_cdc_comm_enable+0x72>
#define UDI_CDC_PORT_TO_IFACE_COMM(index, unused) \
	case index: \
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_IFACE_COMM, ~)
80005592:	30 08       	mov	r8,0
80005594:	ef 68 ff ff 	st.b	r7[-1],r8
80005598:	c0 48       	rjmp	800055a0 <udi_cdc_comm_enable+0x78>
#undef UDI_CDC_PORT_TO_IFACE_COMM
	default:
		iface_comm_num = UDI_CDC_COMM_IFACE_NUMBER_0;
8000559a:	30 08       	mov	r8,0
8000559c:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}

	uid_cdc_state_msg[port].header.wIndex = LE16(iface_comm_num);
800055a0:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800055a4:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800055a8:	a9 48       	asr	r8,0x8
800055aa:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
800055ae:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800055b2:	a9 68       	lsl	r8,0x8
800055b4:	5c 88       	casts.h	r8
800055b6:	f5 e8 10 08 	or	r8,r10,r8
800055ba:	5c 88       	casts.h	r8
800055bc:	10 9a       	mov	r10,r8
800055be:	4c 8b       	lddpc	r11,800056dc <udi_cdc_comm_enable+0x1b4>
800055c0:	12 98       	mov	r8,r9
800055c2:	a3 68       	lsl	r8,0x2
800055c4:	12 08       	add	r8,r9
800055c6:	a1 78       	lsl	r8,0x1
800055c8:	f6 08 00 08 	add	r8,r11,r8
800055cc:	f0 c9 ff fc 	sub	r9,r8,-4
800055d0:	14 98       	mov	r8,r10
800055d2:	b2 08       	st.h	r9[0x0],r8
	uid_cdc_state_msg[port].header.wLength = LE16(2);
800055d4:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800055d8:	4c 1a       	lddpc	r10,800056dc <udi_cdc_comm_enable+0x1b4>
800055da:	12 98       	mov	r8,r9
800055dc:	a3 68       	lsl	r8,0x2
800055de:	12 08       	add	r8,r9
800055e0:	a1 78       	lsl	r8,0x1
800055e2:	f4 08 00 08 	add	r8,r10,r8
800055e6:	f0 c9 ff fc 	sub	r9,r8,-4
800055ea:	e0 68 02 00 	mov	r8,512
800055ee:	b2 18       	st.h	r9[0x2],r8
	uid_cdc_state_msg[port].value = CPU_TO_LE16(0);
800055f0:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800055f4:	4b aa       	lddpc	r10,800056dc <udi_cdc_comm_enable+0x1b4>
800055f6:	12 98       	mov	r8,r9
800055f8:	a3 68       	lsl	r8,0x2
800055fa:	12 08       	add	r8,r9
800055fc:	a1 78       	lsl	r8,0x1
800055fe:	f4 08 00 08 	add	r8,r10,r8
80005602:	f0 c9 ff f8 	sub	r9,r8,-8
80005606:	30 08       	mov	r8,0
80005608:	b2 08       	st.h	r9[0x0],r8

	udi_cdc_line_coding[port].dwDTERate = CPU_TO_LE32(UDI_CDC_DEFAULT_RATE);
8000560a:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000560e:	4b 5a       	lddpc	r10,800056e0 <udi_cdc_comm_enable+0x1b8>
80005610:	12 98       	mov	r8,r9
80005612:	a3 78       	lsl	r8,0x3
80005614:	12 18       	sub	r8,r9
80005616:	f4 08 00 08 	add	r8,r10,r8
8000561a:	11 89       	ld.ub	r9,r8[0x0]
8000561c:	e2 19 00 00 	andl	r9,0x0,COH
80005620:	b0 89       	st.b	r8[0x0],r9
80005622:	11 99       	ld.ub	r9,r8[0x1]
80005624:	e2 19 00 00 	andl	r9,0x0,COH
80005628:	a5 a9       	sbr	r9,0x4
8000562a:	b0 99       	st.b	r8[0x1],r9
8000562c:	11 a9       	ld.ub	r9,r8[0x2]
8000562e:	e2 19 00 00 	andl	r9,0x0,COH
80005632:	e8 19 00 0e 	orl	r9,0xe
80005636:	b0 a9       	st.b	r8[0x2],r9
80005638:	11 b9       	ld.ub	r9,r8[0x3]
8000563a:	e2 19 00 00 	andl	r9,0x0,COH
8000563e:	b0 b9       	st.b	r8[0x3],r9
	udi_cdc_line_coding[port].bCharFormat = UDI_CDC_DEFAULT_STOPBITS;
80005640:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005644:	4a 7a       	lddpc	r10,800056e0 <udi_cdc_comm_enable+0x1b8>
80005646:	12 98       	mov	r8,r9
80005648:	a3 78       	lsl	r8,0x3
8000564a:	12 18       	sub	r8,r9
8000564c:	f4 08 00 08 	add	r8,r10,r8
80005650:	f0 c9 ff fc 	sub	r9,r8,-4
80005654:	30 08       	mov	r8,0
80005656:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_line_coding[port].bParityType = UDI_CDC_DEFAULT_PARITY;
80005658:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000565c:	4a 1a       	lddpc	r10,800056e0 <udi_cdc_comm_enable+0x1b8>
8000565e:	12 98       	mov	r8,r9
80005660:	a3 78       	lsl	r8,0x3
80005662:	12 18       	sub	r8,r9
80005664:	f4 08 00 08 	add	r8,r10,r8
80005668:	f0 c9 ff fb 	sub	r9,r8,-5
8000566c:	30 08       	mov	r8,0
8000566e:	b2 88       	st.b	r9[0x0],r8
	udi_cdc_line_coding[port].bDataBits = UDI_CDC_DEFAULT_DATABITS;
80005670:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005674:	49 ba       	lddpc	r10,800056e0 <udi_cdc_comm_enable+0x1b8>
80005676:	12 98       	mov	r8,r9
80005678:	a3 78       	lsl	r8,0x3
8000567a:	12 18       	sub	r8,r9
8000567c:	f4 08 00 08 	add	r8,r10,r8
80005680:	f0 c9 ff fa 	sub	r9,r8,-6
80005684:	30 88       	mov	r8,8
80005686:	b2 88       	st.b	r9[0x0],r8
	// Call application callback
	// to initialize memories or indicate that interface is enabled
	UDI_CDC_SET_CODING_EXT(port,(&udi_cdc_line_coding[port]));
80005688:	ef 39 ff fe 	ld.ub	r9,r7[-2]
8000568c:	12 98       	mov	r8,r9
8000568e:	a3 78       	lsl	r8,0x3
80005690:	f0 09 01 09 	sub	r9,r8,r9
80005694:	49 38       	lddpc	r8,800056e0 <udi_cdc_comm_enable+0x1b8>
80005696:	10 09       	add	r9,r8
80005698:	ef 38 ff fe 	ld.ub	r8,r7[-2]
8000569c:	12 9b       	mov	r11,r9
8000569e:	10 9c       	mov	r12,r8
800056a0:	f0 1f 00 11 	mcall	800056e4 <udi_cdc_comm_enable+0x1bc>
	if (!UDI_CDC_ENABLE_EXT(port)) {
800056a4:	ef 38 ff fe 	ld.ub	r8,r7[-2]
800056a8:	10 9c       	mov	r12,r8
800056aa:	f0 1f 00 10 	mcall	800056e8 <udi_cdc_comm_enable+0x1c0>
800056ae:	18 98       	mov	r8,r12
800056b0:	ec 18 00 01 	eorl	r8,0x1
800056b4:	5c 58       	castu.b	r8
800056b6:	c0 30       	breq	800056bc <udi_cdc_comm_enable+0x194>
		return false;
800056b8:	30 08       	mov	r8,0
800056ba:	c0 98       	rjmp	800056cc <udi_cdc_comm_enable+0x1a4>
	}
	udi_cdc_nb_comm_enabled++;
800056bc:	48 68       	lddpc	r8,800056d4 <udi_cdc_comm_enable+0x1ac>
800056be:	11 88       	ld.ub	r8,r8[0x0]
800056c0:	5c 58       	castu.b	r8
800056c2:	2f f8       	sub	r8,-1
800056c4:	5c 58       	castu.b	r8
800056c6:	48 49       	lddpc	r9,800056d4 <udi_cdc_comm_enable+0x1ac>
800056c8:	b2 88       	st.b	r9[0x0],r8
	return true;
800056ca:	30 18       	mov	r8,1
}
800056cc:	10 9c       	mov	r12,r8
800056ce:	2f fd       	sub	sp,-4
800056d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800056d4:	00 00       	add	r0,r0
800056d6:	01 f8       	ld.ub	r8,r0[0x7]
800056d8:	00 00       	add	r0,r0
800056da:	01 e8       	ld.ub	r8,r0[0x6]
800056dc:	00 00       	add	r0,r0
800056de:	01 ec       	ld.ub	r12,r0[0x6]
800056e0:	00 00       	add	r0,r0
800056e2:	01 da       	ld.ub	r10,r0[0x5]
800056e4:	80 00       	ld.sh	r0,r0[0x0]
800056e6:	8b 68       	st.w	r5[0x18],r8
800056e8:	80 00       	ld.sh	r0,r0[0x0]
800056ea:	76 14       	ld.w	r4,r11[0x4]

800056ec <udi_cdc_data_enable>:

bool udi_cdc_data_enable(void)
{
800056ec:	eb cd 40 80 	pushm	r7,lr
800056f0:	1a 97       	mov	r7,sp
800056f2:	20 1d       	sub	sp,4
	uint8_t port;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
800056f4:	30 08       	mov	r8,0
800056f6:	ef 68 ff ff 	st.b	r7[-1],r8
	udi_cdc_nb_data_enabled = 0;
800056fa:	4b 69       	lddpc	r9,800057d0 <udi_cdc_data_enable+0xe4>
800056fc:	30 08       	mov	r8,0
800056fe:	b2 88       	st.b	r9[0x0],r8
	}
	port = udi_cdc_nb_data_enabled;
#endif

	// Initialize TX management
	udi_cdc_tx_trans_ongoing[port] = false;
80005700:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005704:	4b 4a       	lddpc	r10,800057d4 <udi_cdc_data_enable+0xe8>
80005706:	30 08       	mov	r8,0
80005708:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_tx_both_buf_to_send[port] = false;
8000570c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005710:	4b 2a       	lddpc	r10,800057d8 <udi_cdc_data_enable+0xec>
80005712:	30 08       	mov	r8,0
80005714:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_tx_buf_sel[port] = 0;
80005718:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000571c:	4b 0a       	lddpc	r10,800057dc <udi_cdc_data_enable+0xf0>
8000571e:	30 08       	mov	r8,0
80005720:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_tx_buf_nb[port][0] = 0;
80005724:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005728:	4a e9       	lddpc	r9,800057e0 <udi_cdc_data_enable+0xf4>
8000572a:	30 08       	mov	r8,0
8000572c:	f2 0a 0a 28 	st.h	r9[r10<<0x2],r8
	udi_cdc_tx_buf_nb[port][1] = 0;
80005730:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005734:	4a b9       	lddpc	r9,800057e0 <udi_cdc_data_enable+0xf4>
80005736:	a1 78       	lsl	r8,0x1
80005738:	f0 ca ff ff 	sub	r10,r8,-1
8000573c:	30 08       	mov	r8,0
8000573e:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_tx_sof_num[port] = 0;
80005742:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005746:	4a 89       	lddpc	r9,800057e4 <udi_cdc_data_enable+0xf8>
80005748:	30 08       	mov	r8,0
8000574a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_tx_send(port);
8000574e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005752:	10 9c       	mov	r12,r8
80005754:	f0 1f 00 25 	mcall	800057e8 <udi_cdc_data_enable+0xfc>

	// Initialize RX management
	udi_cdc_rx_trans_ongoing[port] = false;
80005758:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000575c:	4a 4a       	lddpc	r10,800057ec <udi_cdc_data_enable+0x100>
8000575e:	30 08       	mov	r8,0
80005760:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_rx_buf_sel[port] = 0;
80005764:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005768:	4a 2a       	lddpc	r10,800057f0 <udi_cdc_data_enable+0x104>
8000576a:	30 08       	mov	r8,0
8000576c:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_rx_buf_nb[port][0] = 0;
80005770:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005774:	4a 09       	lddpc	r9,800057f4 <udi_cdc_data_enable+0x108>
80005776:	30 08       	mov	r8,0
80005778:	f2 0a 0a 28 	st.h	r9[r10<<0x2],r8
	udi_cdc_rx_pos[port] = 0;
8000577c:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005780:	49 e9       	lddpc	r9,800057f8 <udi_cdc_data_enable+0x10c>
80005782:	30 08       	mov	r8,0
80005784:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	if (!udi_cdc_rx_start(port)) {
80005788:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000578c:	10 9c       	mov	r12,r8
8000578e:	f0 1f 00 1c 	mcall	800057fc <udi_cdc_data_enable+0x110>
80005792:	18 98       	mov	r8,r12
80005794:	ec 18 00 01 	eorl	r8,0x1
80005798:	5c 58       	castu.b	r8
8000579a:	c0 30       	breq	800057a0 <udi_cdc_data_enable+0xb4>
		return false;
8000579c:	30 08       	mov	r8,0
8000579e:	c1 48       	rjmp	800057c6 <udi_cdc_data_enable+0xda>
	}
	udi_cdc_nb_data_enabled++;
800057a0:	48 c8       	lddpc	r8,800057d0 <udi_cdc_data_enable+0xe4>
800057a2:	11 88       	ld.ub	r8,r8[0x0]
800057a4:	5c 58       	castu.b	r8
800057a6:	2f f8       	sub	r8,-1
800057a8:	5c 58       	castu.b	r8
800057aa:	48 a9       	lddpc	r9,800057d0 <udi_cdc_data_enable+0xe4>
800057ac:	b2 88       	st.b	r9[0x0],r8
	if (udi_cdc_nb_data_enabled == UDI_CDC_PORT_NB) {
800057ae:	48 98       	lddpc	r8,800057d0 <udi_cdc_data_enable+0xe4>
800057b0:	11 88       	ld.ub	r8,r8[0x0]
800057b2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800057b6:	30 18       	mov	r8,1
800057b8:	f0 09 18 00 	cp.b	r9,r8
800057bc:	c0 41       	brne	800057c4 <udi_cdc_data_enable+0xd8>
		udi_cdc_data_running = true;
800057be:	49 19       	lddpc	r9,80005800 <udi_cdc_data_enable+0x114>
800057c0:	30 18       	mov	r8,1
800057c2:	b2 88       	st.b	r9[0x0],r8
	}
	return true;
800057c4:	30 18       	mov	r8,1
}
800057c6:	10 9c       	mov	r12,r8
800057c8:	2f fd       	sub	sp,-4
800057ca:	e3 cd 80 80 	ldm	sp++,r7,pc
800057ce:	00 00       	add	r0,r0
800057d0:	00 00       	add	r0,r0
800057d2:	01 f9       	ld.ub	r9,r0[0x7]
800057d4:	00 00       	add	r0,r0
800057d6:	07 18       	ld.sh	r8,r3++
800057d8:	00 00       	add	r0,r0
800057da:	07 1c       	ld.sh	r12,r3++
800057dc:	00 00       	add	r0,r0
800057de:	07 10       	ld.sh	r0,r3++
800057e0:	00 00       	add	r0,r0
800057e2:	07 0c       	ld.w	r12,r3++
800057e4:	00 00       	add	r0,r0
800057e6:	07 14       	ld.sh	r4,r3++
800057e8:	80 00       	ld.sh	r0,r0[0x0]
800057ea:	5f 08       	sreq	r8
800057ec:	00 00       	add	r0,r0
800057ee:	04 88       	andn	r8,r2
800057f0:	00 00       	add	r0,r0
800057f2:	04 80       	andn	r0,r2
800057f4:	00 00       	add	r0,r0
800057f6:	04 7c       	tst	r12,r2
800057f8:	00 00       	add	r0,r0
800057fa:	04 84       	andn	r4,r2
800057fc:	80 00       	ld.sh	r0,r0[0x0]
800057fe:	5c 50       	castu.b	r0
80005800:	00 00       	add	r0,r0
80005802:	01 fa       	ld.ub	r10,r0[0x7]

80005804 <udi_cdc_comm_disable>:

void udi_cdc_comm_disable(void)
{
80005804:	eb cd 40 80 	pushm	r7,lr
80005808:	1a 97       	mov	r7,sp
	Assert(udi_cdc_nb_comm_enabled != 0);
	udi_cdc_nb_comm_enabled--;
8000580a:	48 58       	lddpc	r8,8000581c <udi_cdc_comm_disable+0x18>
8000580c:	11 88       	ld.ub	r8,r8[0x0]
8000580e:	5c 58       	castu.b	r8
80005810:	20 18       	sub	r8,1
80005812:	5c 58       	castu.b	r8
80005814:	48 29       	lddpc	r9,8000581c <udi_cdc_comm_disable+0x18>
80005816:	b2 88       	st.b	r9[0x0],r8
}
80005818:	e3 cd 80 80 	ldm	sp++,r7,pc
8000581c:	00 00       	add	r0,r0
8000581e:	01 f8       	ld.ub	r8,r0[0x7]

80005820 <udi_cdc_data_disable>:

void udi_cdc_data_disable(void)
{
80005820:	eb cd 40 80 	pushm	r7,lr
80005824:	1a 97       	mov	r7,sp
80005826:	20 1d       	sub	sp,4
	uint8_t port;
	UNUSED(port);

	Assert(udi_cdc_nb_data_enabled != 0);
	udi_cdc_nb_data_enabled--;
80005828:	48 b8       	lddpc	r8,80005854 <udi_cdc_data_disable+0x34>
8000582a:	11 88       	ld.ub	r8,r8[0x0]
8000582c:	5c 58       	castu.b	r8
8000582e:	20 18       	sub	r8,1
80005830:	5c 58       	castu.b	r8
80005832:	48 99       	lddpc	r9,80005854 <udi_cdc_data_disable+0x34>
80005834:	b2 88       	st.b	r9[0x0],r8
	port = udi_cdc_nb_data_enabled;
80005836:	48 88       	lddpc	r8,80005854 <udi_cdc_data_disable+0x34>
80005838:	11 88       	ld.ub	r8,r8[0x0]
8000583a:	ef 68 ff ff 	st.b	r7[-1],r8
	UDI_CDC_DISABLE_EXT(port);
8000583e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005842:	10 9c       	mov	r12,r8
80005844:	f0 1f 00 05 	mcall	80005858 <udi_cdc_data_disable+0x38>
	udi_cdc_data_running = false;
80005848:	48 59       	lddpc	r9,8000585c <udi_cdc_data_disable+0x3c>
8000584a:	30 08       	mov	r8,0
8000584c:	b2 88       	st.b	r9[0x0],r8
}
8000584e:	2f fd       	sub	sp,-4
80005850:	e3 cd 80 80 	ldm	sp++,r7,pc
80005854:	00 00       	add	r0,r0
80005856:	01 f9       	ld.ub	r9,r0[0x7]
80005858:	80 00       	ld.sh	r0,r0[0x0]
8000585a:	76 44       	ld.w	r4,r11[0x10]
8000585c:	00 00       	add	r0,r0
8000585e:	01 fa       	ld.ub	r10,r0[0x7]

80005860 <udi_cdc_comm_setup>:

bool udi_cdc_comm_setup(void)
{
80005860:	eb cd 40 80 	pushm	r7,lr
80005864:	1a 97       	mov	r7,sp
80005866:	20 1d       	sub	sp,4
	uint8_t port = udi_cdc_setup_to_port();
80005868:	f0 1f 00 3a 	mcall	80005950 <udi_cdc_comm_setup+0xf0>
8000586c:	18 98       	mov	r8,r12
8000586e:	ef 68 ff ff 	st.b	r7[-1],r8

	if (Udd_setup_is_in()) {
80005872:	4b 98       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
80005874:	11 88       	ld.ub	r8,r8[0x0]
80005876:	10 99       	mov	r9,r8
80005878:	30 08       	mov	r8,0
8000587a:	f0 09 18 00 	cp.b	r9,r8
8000587e:	c2 44       	brge	800058c6 <udi_cdc_comm_setup+0x66>
		// GET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
80005880:	4b 58       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
80005882:	11 88       	ld.ub	r8,r8[0x0]
80005884:	e2 18 00 60 	andl	r8,0x60,COH
80005888:	e0 48 00 20 	cp.w	r8,32
8000588c:	c1 d1       	brne	800058c6 <udi_cdc_comm_setup+0x66>
			// Requests Class Interface Get
			switch (udd_g_ctrlreq.req.bRequest) {
8000588e:	4b 28       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
80005890:	11 98       	ld.ub	r8,r8[0x1]
80005892:	e0 48 00 21 	cp.w	r8,33
80005896:	c1 81       	brne	800058c6 <udi_cdc_comm_setup+0x66>
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
80005898:	4a f8       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
8000589a:	90 39       	ld.sh	r9,r8[0x6]
8000589c:	30 78       	mov	r8,7
8000589e:	f0 09 19 00 	cp.h	r9,r8
800058a2:	c0 30       	breq	800058a8 <udi_cdc_comm_setup+0x48>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
800058a4:	30 08       	mov	r8,0
800058a6:	c5 18       	rjmp	80005948 <udi_cdc_comm_setup+0xe8>
				udd_g_ctrlreq.payload =
						(uint8_t *) &
800058a8:	4a ca       	lddpc	r10,80005958 <udi_cdc_comm_setup+0xf8>
800058aa:	ef 39 ff ff 	ld.ub	r9,r7[-1]
						udi_cdc_line_coding[port];
800058ae:	12 98       	mov	r8,r9
800058b0:	a3 78       	lsl	r8,0x3
800058b2:	12 18       	sub	r8,r9
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.payload =
						(uint8_t *) &
800058b4:	f4 08 00 09 	add	r9,r10,r8
			case USB_REQ_CDC_GET_LINE_CODING:
				// Get configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.payload =
800058b8:	4a 78       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
800058ba:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding[port];
				udd_g_ctrlreq.payload_size =
800058bc:	4a 69       	lddpc	r9,80005954 <udi_cdc_comm_setup+0xf4>
800058be:	30 78       	mov	r8,7
800058c0:	b2 68       	st.h	r9[0xc],r8
						sizeof(usb_cdc_line_coding_t);
				return true;
800058c2:	30 18       	mov	r8,1
800058c4:	c4 28       	rjmp	80005948 <udi_cdc_comm_setup+0xe8>
			}
		}
	}
	if (Udd_setup_is_out()) {
800058c6:	4a 48       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
800058c8:	11 88       	ld.ub	r8,r8[0x0]
800058ca:	10 99       	mov	r9,r8
800058cc:	30 08       	mov	r8,0
800058ce:	f0 09 18 00 	cp.b	r9,r8
800058d2:	c3 a5       	brlt	80005946 <udi_cdc_comm_setup+0xe6>
		// SET Interface Requests
		if (Udd_setup_type() == USB_REQ_TYPE_CLASS) {
800058d4:	4a 08       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
800058d6:	11 88       	ld.ub	r8,r8[0x0]
800058d8:	e2 18 00 60 	andl	r8,0x60,COH
800058dc:	e0 48 00 20 	cp.w	r8,32
800058e0:	c3 31       	brne	80005946 <udi_cdc_comm_setup+0xe6>
			// Requests Class Interface Set
			switch (udd_g_ctrlreq.req.bRequest) {
800058e2:	49 d8       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
800058e4:	11 98       	ld.ub	r8,r8[0x1]
800058e6:	e0 48 00 20 	cp.w	r8,32
800058ea:	c0 50       	breq	800058f4 <udi_cdc_comm_setup+0x94>
800058ec:	e0 48 00 22 	cp.w	r8,34
800058f0:	c1 c0       	breq	80005928 <udi_cdc_comm_setup+0xc8>
800058f2:	c2 a8       	rjmp	80005946 <udi_cdc_comm_setup+0xe6>
			case USB_REQ_CDC_SET_LINE_CODING:
				// Change configuration of CDC line
				if (sizeof(usb_cdc_line_coding_t) !=
800058f4:	49 88       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
800058f6:	90 39       	ld.sh	r9,r8[0x6]
800058f8:	30 78       	mov	r8,7
800058fa:	f0 09 19 00 	cp.h	r9,r8
800058fe:	c0 30       	breq	80005904 <udi_cdc_comm_setup+0xa4>
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
80005900:	30 08       	mov	r8,0
80005902:	c2 38       	rjmp	80005948 <udi_cdc_comm_setup+0xe8>
				udd_g_ctrlreq.callback =
80005904:	49 48       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
80005906:	49 69       	lddpc	r9,8000595c <udi_cdc_comm_setup+0xfc>
80005908:	91 49       	st.w	r8[0x10],r9
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
						(uint8_t *) &
8000590a:	49 4a       	lddpc	r10,80005958 <udi_cdc_comm_setup+0xf8>
8000590c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
						udi_cdc_line_coding[port];
80005910:	12 98       	mov	r8,r9
80005912:	a3 78       	lsl	r8,0x3
80005914:	12 18       	sub	r8,r9
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.callback =
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
						(uint8_t *) &
80005916:	f4 08 00 09 	add	r9,r10,r8
				if (sizeof(usb_cdc_line_coding_t) !=
						udd_g_ctrlreq.req.wLength)
					return false; // Error for USB host
				udd_g_ctrlreq.callback =
						udi_cdc_line_coding_received;
				udd_g_ctrlreq.payload =
8000591a:	48 f8       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
8000591c:	91 29       	st.w	r8[0x8],r9
						(uint8_t *) &
						udi_cdc_line_coding[port];
				udd_g_ctrlreq.payload_size =
8000591e:	48 e9       	lddpc	r9,80005954 <udi_cdc_comm_setup+0xf4>
80005920:	30 78       	mov	r8,7
80005922:	b2 68       	st.h	r9[0xc],r8
						sizeof(usb_cdc_line_coding_t);
				return true;
80005924:	30 18       	mov	r8,1
80005926:	c1 18       	rjmp	80005948 <udi_cdc_comm_setup+0xe8>
			case USB_REQ_CDC_SET_CONTROL_LINE_STATE:
				// According cdc spec 1.1 chapter 6.2.14
				UDI_CDC_SET_DTR_EXT(port, (0 !=
80005928:	48 b8       	lddpc	r8,80005954 <udi_cdc_comm_setup+0xf4>
8000592a:	90 18       	ld.sh	r8,r8[0x2]
8000592c:	5c 78       	castu.h	r8
8000592e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80005932:	5c 58       	castu.b	r8
80005934:	10 99       	mov	r9,r8
80005936:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000593a:	12 9b       	mov	r11,r9
8000593c:	10 9c       	mov	r12,r8
8000593e:	f0 1f 00 09 	mcall	80005960 <udi_cdc_comm_setup+0x100>
						(udd_g_ctrlreq.req.wValue
						 & CDC_CTRL_SIGNAL_DTE_PRESENT)));
				UDI_CDC_SET_RTS_EXT(port, (0 !=
						(udd_g_ctrlreq.req.wValue
						 & CDC_CTRL_SIGNAL_ACTIVATE_CARRIER)));
				return true;
80005942:	30 18       	mov	r8,1
80005944:	c0 28       	rjmp	80005948 <udi_cdc_comm_setup+0xe8>
			}
		}
	}
	return false;  // request Not supported
80005946:	30 08       	mov	r8,0
}
80005948:	10 9c       	mov	r12,r8
8000594a:	2f fd       	sub	sp,-4
8000594c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005950:	80 00       	ld.sh	r0,r0[0x0]
80005952:	59 9c       	cp.w	r12,25
80005954:	00 00       	add	r0,r0
80005956:	46 48       	lddsp	r8,sp[0x190]
80005958:	00 00       	add	r0,r0
8000595a:	01 da       	ld.ub	r10,r0[0x5]
8000595c:	80 00       	ld.sh	r0,r0[0x0]
8000595e:	59 d0       	cp.w	r0,29
80005960:	80 00       	ld.sh	r0,r0[0x0]
80005962:	76 70       	ld.w	r0,r11[0x1c]

80005964 <udi_cdc_data_setup>:

bool udi_cdc_data_setup(void)
{
80005964:	eb cd 40 80 	pushm	r7,lr
80005968:	1a 97       	mov	r7,sp
	return false;  // request Not supported
8000596a:	30 08       	mov	r8,0
}
8000596c:	10 9c       	mov	r12,r8
8000596e:	e3 cd 80 80 	ldm	sp++,r7,pc

80005972 <udi_cdc_getsetting>:

uint8_t udi_cdc_getsetting(void)
{
80005972:	eb cd 40 80 	pushm	r7,lr
80005976:	1a 97       	mov	r7,sp
	return 0;      // CDC don't have multiple alternate setting
80005978:	30 08       	mov	r8,0
}
8000597a:	10 9c       	mov	r12,r8
8000597c:	e3 cd 80 80 	ldm	sp++,r7,pc

80005980 <udi_cdc_data_sof_notify>:

void udi_cdc_data_sof_notify(void)
{
80005980:	eb cd 40 80 	pushm	r7,lr
80005984:	1a 97       	mov	r7,sp
	static uint8_t port_notify = 0;

	// A call of udi_cdc_data_sof_notify() is done for each port
	udi_cdc_tx_send(port_notify);
80005986:	48 48       	lddpc	r8,80005994 <udi_cdc_data_sof_notify+0x14>
80005988:	11 88       	ld.ub	r8,r8[0x0]
8000598a:	10 9c       	mov	r12,r8
8000598c:	f0 1f 00 03 	mcall	80005998 <udi_cdc_data_sof_notify+0x18>
	port_notify++;
	if (port_notify >= UDI_CDC_PORT_NB) {
		port_notify = 0;
	}
#endif
}
80005990:	e3 cd 80 80 	ldm	sp++,r7,pc
80005994:	00 00       	add	r0,r0
80005996:	07 22       	ld.uh	r2,r3++
80005998:	80 00       	ld.sh	r0,r0[0x0]
8000599a:	5f 08       	sreq	r8

8000599c <udi_cdc_setup_to_port>:

//-------------------------------------------------
//------- Internal routines to control serial line

static uint8_t udi_cdc_setup_to_port(void)
{
8000599c:	eb cd 40 80 	pushm	r7,lr
800059a0:	1a 97       	mov	r7,sp
800059a2:	20 1d       	sub	sp,4
	uint8_t port;

	switch (udd_g_ctrlreq.req.wIndex & 0xFF) {
800059a4:	48 a8       	lddpc	r8,800059cc <udi_cdc_setup_to_port+0x30>
800059a6:	90 28       	ld.sh	r8,r8[0x4]
800059a8:	5c 78       	castu.h	r8
800059aa:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
800059ae:	c0 51       	brne	800059b8 <udi_cdc_setup_to_port+0x1c>
#define UDI_CDC_IFACE_COMM_TO_PORT(iface, unused) \
	case UDI_CDC_COMM_IFACE_NUMBER_##iface: \
		port = iface; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_IFACE_COMM_TO_PORT, ~)
800059b0:	30 08       	mov	r8,0
800059b2:	ef 68 ff ff 	st.b	r7[-1],r8
800059b6:	c0 48       	rjmp	800059be <udi_cdc_setup_to_port+0x22>
#undef UDI_CDC_IFACE_COMM_TO_PORT
	default:
		port = 0;
800059b8:	30 08       	mov	r8,0
800059ba:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}
	return port;
800059be:	ef 38 ff ff 	ld.ub	r8,r7[-1]
}
800059c2:	10 9c       	mov	r12,r8
800059c4:	2f fd       	sub	sp,-4
800059c6:	e3 cd 80 80 	ldm	sp++,r7,pc
800059ca:	00 00       	add	r0,r0
800059cc:	00 00       	add	r0,r0
800059ce:	46 48       	lddsp	r8,sp[0x190]

800059d0 <udi_cdc_line_coding_received>:

static void udi_cdc_line_coding_received(void)
{
800059d0:	eb cd 40 80 	pushm	r7,lr
800059d4:	1a 97       	mov	r7,sp
800059d6:	20 1d       	sub	sp,4
	uint8_t port = udi_cdc_setup_to_port();
800059d8:	f0 1f 00 0b 	mcall	80005a04 <udi_cdc_line_coding_received+0x34>
800059dc:	18 98       	mov	r8,r12
800059de:	ef 68 ff ff 	st.b	r7[-1],r8
	UNUSED(port);

	UDI_CDC_SET_CODING_EXT(port, (&udi_cdc_line_coding[port]));
800059e2:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800059e6:	12 98       	mov	r8,r9
800059e8:	a3 78       	lsl	r8,0x3
800059ea:	f0 09 01 09 	sub	r9,r8,r9
800059ee:	48 78       	lddpc	r8,80005a08 <udi_cdc_line_coding_received+0x38>
800059f0:	10 09       	add	r9,r8
800059f2:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800059f6:	12 9b       	mov	r11,r9
800059f8:	10 9c       	mov	r12,r8
800059fa:	f0 1f 00 05 	mcall	80005a0c <udi_cdc_line_coding_received+0x3c>
}
800059fe:	2f fd       	sub	sp,-4
80005a00:	e3 cd 80 80 	ldm	sp++,r7,pc
80005a04:	80 00       	ld.sh	r0,r0[0x0]
80005a06:	59 9c       	cp.w	r12,25
80005a08:	00 00       	add	r0,r0
80005a0a:	01 da       	ld.ub	r10,r0[0x5]
80005a0c:	80 00       	ld.sh	r0,r0[0x0]
80005a0e:	8b 68       	st.w	r5[0x18],r8

80005a10 <udi_cdc_ctrl_state_change>:

static void udi_cdc_ctrl_state_change(uint8_t port, bool b_set, le16_t bit_mask)
{
80005a10:	eb cd 40 80 	pushm	r7,lr
80005a14:	1a 97       	mov	r7,sp
80005a16:	20 5d       	sub	sp,20
80005a18:	16 99       	mov	r9,r11
80005a1a:	14 98       	mov	r8,r10
80005a1c:	18 9a       	mov	r10,r12
80005a1e:	ef 6a ff f4 	st.b	r7[-12],r10
80005a22:	ef 69 ff f0 	st.b	r7[-16],r9
80005a26:	ef 58 ff ec 	st.h	r7[-20],r8
	irqflags_t flags;
	udd_ep_id_t ep_comm;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80005a2a:	30 08       	mov	r8,0
80005a2c:	ef 68 ff f4 	st.b	r7[-12],r8
#endif

	// Update state
	flags = cpu_irq_save(); // Protect udi_cdc_state
80005a30:	f0 1f 00 25 	mcall	80005ac4 <udi_cdc_ctrl_state_change+0xb4>
80005a34:	18 98       	mov	r8,r12
80005a36:	ef 48 ff f8 	st.w	r7[-8],r8
	if (b_set) {
80005a3a:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80005a3e:	30 08       	mov	r8,0
80005a40:	f0 09 18 00 	cp.b	r9,r8
80005a44:	c1 30       	breq	80005a6a <udi_cdc_ctrl_state_change+0x5a>
		udi_cdc_state[port] |= bit_mask;
80005a46:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005a4a:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005a4e:	49 f8       	lddpc	r8,80005ac8 <udi_cdc_ctrl_state_change+0xb8>
80005a50:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005a54:	5c 88       	casts.h	r8
80005a56:	10 99       	mov	r9,r8
80005a58:	ef 08 ff ec 	ld.sh	r8,r7[-20]
80005a5c:	f3 e8 10 08 	or	r8,r9,r8
80005a60:	5c 88       	casts.h	r8
80005a62:	49 a9       	lddpc	r9,80005ac8 <udi_cdc_ctrl_state_change+0xb8>
80005a64:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
80005a68:	c1 48       	rjmp	80005a90 <udi_cdc_ctrl_state_change+0x80>
	} else {
		udi_cdc_state[port] &= ~(unsigned)bit_mask;
80005a6a:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005a6e:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005a72:	49 68       	lddpc	r8,80005ac8 <udi_cdc_ctrl_state_change+0xb8>
80005a74:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005a78:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005a7c:	ef 08 ff ec 	ld.sh	r8,r7[-20]
80005a80:	5c d8       	com	r8
80005a82:	5c 88       	casts.h	r8
80005a84:	f3 e8 00 08 	and	r8,r9,r8
80005a88:	5c 88       	casts.h	r8
80005a8a:	49 09       	lddpc	r9,80005ac8 <udi_cdc_ctrl_state_change+0xb8>
80005a8c:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	}
	cpu_irq_restore(flags);
80005a90:	ee fc ff f8 	ld.w	r12,r7[-8]
80005a94:	f0 1f 00 0e 	mcall	80005acc <udi_cdc_ctrl_state_change+0xbc>

	// Send it if possible and state changed
	switch (port) {
80005a98:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005a9c:	58 08       	cp.w	r8,0
80005a9e:	c0 51       	brne	80005aa8 <udi_cdc_ctrl_state_change+0x98>
#define UDI_CDC_PORT_TO_COMM_EP(index, unused) \
	case index: \
		ep_comm = UDI_CDC_COMM_EP_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_COMM_EP, ~)
80005aa0:	38 38       	mov	r8,-125
80005aa2:	ef 68 ff ff 	st.b	r7[-1],r8
80005aa6:	c0 48       	rjmp	80005aae <udi_cdc_ctrl_state_change+0x9e>
#undef UDI_CDC_PORT_TO_COMM_EP
	default:
		ep_comm = UDI_CDC_COMM_EP_0;
80005aa8:	38 38       	mov	r8,-125
80005aaa:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}
	udi_cdc_ctrl_state_notify(port, ep_comm);
80005aae:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005ab2:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005ab6:	12 9b       	mov	r11,r9
80005ab8:	10 9c       	mov	r12,r8
80005aba:	f0 1f 00 06 	mcall	80005ad0 <udi_cdc_ctrl_state_change+0xc0>
}
80005abe:	2f bd       	sub	sp,-20
80005ac0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ac4:	80 00       	ld.sh	r0,r0[0x0]
80005ac6:	54 c0       	stdsp	sp[0x130],r0
80005ac8:	00 00       	add	r0,r0
80005aca:	01 e8       	ld.ub	r8,r0[0x6]
80005acc:	80 00       	ld.sh	r0,r0[0x0]
80005ace:	55 00       	stdsp	sp[0x140],r0
80005ad0:	80 00       	ld.sh	r0,r0[0x0]
80005ad2:	5a d4       	cp.w	r4,-19

80005ad4 <udi_cdc_ctrl_state_notify>:


static void udi_cdc_ctrl_state_notify(uint8_t port, udd_ep_id_t ep)
{
80005ad4:	eb cd 40 c0 	pushm	r6-r7,lr
80005ad8:	1a 97       	mov	r7,sp
80005ada:	20 2d       	sub	sp,8
80005adc:	18 99       	mov	r9,r12
80005ade:	16 98       	mov	r8,r11
80005ae0:	ef 69 ff fc 	st.b	r7[-4],r9
80005ae4:	ef 68 ff f8 	st.b	r7[-8],r8
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80005ae8:	30 08       	mov	r8,0
80005aea:	ef 68 ff fc 	st.b	r7[-4],r8
#endif

	// Send it if possible and state changed
	if ((!udi_cdc_serial_state_msg_ongoing[port])
80005aee:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80005af2:	4a 59       	lddpc	r9,80005b84 <udi_cdc_ctrl_state_notify+0xb0>
80005af4:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005af8:	ec 18 00 01 	eorl	r8,0x1
80005afc:	5c 58       	castu.b	r8
80005afe:	c4 00       	breq	80005b7e <udi_cdc_ctrl_state_notify+0xaa>
			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
80005b00:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80005b04:	4a 18       	lddpc	r8,80005b88 <udi_cdc_ctrl_state_notify+0xb4>
80005b06:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005b0a:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
80005b0e:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80005b12:	49 fb       	lddpc	r11,80005b8c <udi_cdc_ctrl_state_notify+0xb8>
80005b14:	12 98       	mov	r8,r9
80005b16:	a3 68       	lsl	r8,0x2
80005b18:	12 08       	add	r8,r9
80005b1a:	a1 78       	lsl	r8,0x1
80005b1c:	f6 08 00 08 	add	r8,r11,r8
80005b20:	2f 88       	sub	r8,-8
80005b22:	90 08       	ld.sh	r8,r8[0x0]
80005b24:	5c 88       	casts.h	r8
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	// Send it if possible and state changed
	if ((!udi_cdc_serial_state_msg_ongoing[port])
80005b26:	f0 0a 19 00 	cp.h	r10,r8
80005b2a:	c2 a0       	breq	80005b7e <udi_cdc_ctrl_state_notify+0xaa>
			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
		// Fill notification message
		uid_cdc_state_msg[port].value = udi_cdc_state[port];
80005b2c:	ef 39 ff fc 	ld.ub	r9,r7[-4]
80005b30:	ef 3a ff fc 	ld.ub	r10,r7[-4]
80005b34:	49 58       	lddpc	r8,80005b88 <udi_cdc_ctrl_state_notify+0xb4>
80005b36:	f0 0a 04 18 	ld.sh	r8,r8[r10<<0x1]
80005b3a:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
80005b3e:	49 4b       	lddpc	r11,80005b8c <udi_cdc_ctrl_state_notify+0xb8>
80005b40:	12 98       	mov	r8,r9
80005b42:	a3 68       	lsl	r8,0x2
80005b44:	12 08       	add	r8,r9
80005b46:	a1 78       	lsl	r8,0x1
80005b48:	f6 08 00 08 	add	r8,r11,r8
80005b4c:	f0 c9 ff f8 	sub	r9,r8,-8
80005b50:	14 98       	mov	r8,r10
80005b52:	b2 08       	st.h	r9[0x0],r8
		// Send notification message
		udi_cdc_serial_state_msg_ongoing[port] =
80005b54:	ef 36 ff fc 	ld.ub	r6,r7[-4]
				udd_ep_run(ep,
80005b58:	48 da       	lddpc	r10,80005b8c <udi_cdc_ctrl_state_notify+0xb8>
80005b5a:	ef 39 ff fc 	ld.ub	r9,r7[-4]
				false,
				(uint8_t *) & uid_cdc_state_msg[port],
80005b5e:	12 98       	mov	r8,r9
80005b60:	a3 68       	lsl	r8,0x2
80005b62:	12 08       	add	r8,r9
80005b64:	a1 78       	lsl	r8,0x1
			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
		// Fill notification message
		uid_cdc_state_msg[port].value = udi_cdc_state[port];
		// Send notification message
		udi_cdc_serial_state_msg_ongoing[port] =
				udd_ep_run(ep,
80005b66:	10 0a       	add	r10,r8
80005b68:	ef 3c ff f8 	ld.ub	r12,r7[-8]
80005b6c:	48 98       	lddpc	r8,80005b90 <udi_cdc_ctrl_state_notify+0xbc>
80005b6e:	30 a9       	mov	r9,10
80005b70:	30 0b       	mov	r11,0
80005b72:	f0 1f 00 09 	mcall	80005b94 <udi_cdc_ctrl_state_notify+0xc0>
80005b76:	18 98       	mov	r8,r12
	if ((!udi_cdc_serial_state_msg_ongoing[port])
			&& (udi_cdc_state[port] != uid_cdc_state_msg[port].value)) {
		// Fill notification message
		uid_cdc_state_msg[port].value = udi_cdc_state[port];
		// Send notification message
		udi_cdc_serial_state_msg_ongoing[port] =
80005b78:	48 39       	lddpc	r9,80005b84 <udi_cdc_ctrl_state_notify+0xb0>
80005b7a:	f2 06 0b 08 	st.b	r9[r6],r8
				false,
				(uint8_t *) & uid_cdc_state_msg[port],
				sizeof(uid_cdc_state_msg[0]),
				udi_cdc_serial_state_msg_sent);
	}
}
80005b7e:	2f ed       	sub	sp,-8
80005b80:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80005b84:	00 00       	add	r0,r0
80005b86:	01 e4       	ld.ub	r4,r0[0x6]
80005b88:	00 00       	add	r0,r0
80005b8a:	01 e8       	ld.ub	r8,r0[0x6]
80005b8c:	00 00       	add	r0,r0
80005b8e:	01 ec       	ld.ub	r12,r0[0x6]
80005b90:	80 00       	ld.sh	r0,r0[0x0]
80005b92:	5b 98       	cp.w	r8,-7
80005b94:	80 00       	ld.sh	r0,r0[0x0]
80005b96:	3c 7c       	mov	r12,-57

80005b98 <udi_cdc_serial_state_msg_sent>:


static void udi_cdc_serial_state_msg_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
80005b98:	eb cd 40 80 	pushm	r7,lr
80005b9c:	1a 97       	mov	r7,sp
80005b9e:	20 4d       	sub	sp,16
80005ba0:	ef 4c ff f8 	st.w	r7[-8],r12
80005ba4:	ef 4b ff f4 	st.w	r7[-12],r11
80005ba8:	14 98       	mov	r8,r10
80005baa:	ef 68 ff f0 	st.b	r7[-16],r8
	uint8_t port;
	UNUSED(n);
	UNUSED(status);

	switch (ep) {
80005bae:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80005bb2:	e0 48 00 83 	cp.w	r8,131
80005bb6:	c0 51       	brne	80005bc0 <udi_cdc_serial_state_msg_sent+0x28>
#define UDI_CDC_GET_PORT_FROM_COMM_EP(iface, unused) \
	case UDI_CDC_COMM_EP_##iface: \
		port = iface; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_GET_PORT_FROM_COMM_EP, ~)
80005bb8:	30 08       	mov	r8,0
80005bba:	ef 68 ff ff 	st.b	r7[-1],r8
80005bbe:	c0 48       	rjmp	80005bc6 <udi_cdc_serial_state_msg_sent+0x2e>
#undef UDI_CDC_GET_PORT_FROM_COMM_EP
	default:
		port = 0;
80005bc0:	30 08       	mov	r8,0
80005bc2:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}

	udi_cdc_serial_state_msg_ongoing[port] = false;
80005bc6:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005bca:	49 ea       	lddpc	r10,80005c40 <udi_cdc_serial_state_msg_sent+0xa8>
80005bcc:	30 08       	mov	r8,0
80005bce:	f4 09 0b 08 	st.b	r10[r9],r8

	// For the irregular signals like break, the incoming ring signal,
	// or the overrun error state, this will reset their values to zero
	// and again will not send another notification until their state changes.
	udi_cdc_state[port] &= ~(CDC_SERIAL_STATE_BREAK |
80005bd2:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005bd6:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005bda:	49 b8       	lddpc	r8,80005c44 <udi_cdc_serial_state_msg_sent+0xac>
80005bdc:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005be0:	5c 88       	casts.h	r8
80005be2:	e0 18 83 ff 	andl	r8,0x83ff
80005be6:	5c 88       	casts.h	r8
80005be8:	49 79       	lddpc	r9,80005c44 <udi_cdc_serial_state_msg_sent+0xac>
80005bea:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			CDC_SERIAL_STATE_RING |
			CDC_SERIAL_STATE_FRAMING |
			CDC_SERIAL_STATE_PARITY | CDC_SERIAL_STATE_OVERRUN);
	uid_cdc_state_msg[port].value &= ~(CDC_SERIAL_STATE_BREAK |
80005bee:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005bf2:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005bf6:	49 5b       	lddpc	r11,80005c48 <udi_cdc_serial_state_msg_sent+0xb0>
80005bf8:	14 98       	mov	r8,r10
80005bfa:	a3 68       	lsl	r8,0x2
80005bfc:	14 08       	add	r8,r10
80005bfe:	a1 78       	lsl	r8,0x1
80005c00:	f6 08 00 08 	add	r8,r11,r8
80005c04:	2f 88       	sub	r8,-8
80005c06:	90 08       	ld.sh	r8,r8[0x0]
80005c08:	5c 88       	casts.h	r8
80005c0a:	e0 18 83 ff 	andl	r8,0x83ff
80005c0e:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
80005c12:	48 eb       	lddpc	r11,80005c48 <udi_cdc_serial_state_msg_sent+0xb0>
80005c14:	12 98       	mov	r8,r9
80005c16:	a3 68       	lsl	r8,0x2
80005c18:	12 08       	add	r8,r9
80005c1a:	a1 78       	lsl	r8,0x1
80005c1c:	f6 08 00 08 	add	r8,r11,r8
80005c20:	f0 c9 ff f8 	sub	r9,r8,-8
80005c24:	14 98       	mov	r8,r10
80005c26:	b2 08       	st.h	r9[0x0],r8
			CDC_SERIAL_STATE_RING |
			CDC_SERIAL_STATE_FRAMING |
			CDC_SERIAL_STATE_PARITY | CDC_SERIAL_STATE_OVERRUN);
	// Send it if possible and state changed
	udi_cdc_ctrl_state_notify(port, ep);
80005c28:	ef 39 ff f0 	ld.ub	r9,r7[-16]
80005c2c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005c30:	12 9b       	mov	r11,r9
80005c32:	10 9c       	mov	r12,r8
80005c34:	f0 1f 00 06 	mcall	80005c4c <udi_cdc_serial_state_msg_sent+0xb4>
}
80005c38:	2f cd       	sub	sp,-16
80005c3a:	e3 cd 80 80 	ldm	sp++,r7,pc
80005c3e:	00 00       	add	r0,r0
80005c40:	00 00       	add	r0,r0
80005c42:	01 e4       	ld.ub	r4,r0[0x6]
80005c44:	00 00       	add	r0,r0
80005c46:	01 e8       	ld.ub	r8,r0[0x6]
80005c48:	00 00       	add	r0,r0
80005c4a:	01 ec       	ld.ub	r12,r0[0x6]
80005c4c:	80 00       	ld.sh	r0,r0[0x0]
80005c4e:	5a d4       	cp.w	r4,-19

80005c50 <udi_cdc_rx_start>:
//-------------------------------------------------
//------- Internal routines to process data transfer


static bool udi_cdc_rx_start(uint8_t port)
{
80005c50:	eb cd 40 80 	pushm	r7,lr
80005c54:	1a 97       	mov	r7,sp
80005c56:	20 3d       	sub	sp,12
80005c58:	18 98       	mov	r8,r12
80005c5a:	ef 68 ff f4 	st.b	r7[-12],r8
	irqflags_t flags;
	uint8_t buf_sel_trans;
	udd_ep_id_t ep;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80005c5e:	30 08       	mov	r8,0
80005c60:	ef 68 ff f4 	st.b	r7[-12],r8
#endif

	flags = cpu_irq_save();
80005c64:	f0 1f 00 3f 	mcall	80005d60 <udi_cdc_rx_start+0x110>
80005c68:	18 98       	mov	r8,r12
80005c6a:	ef 48 ff f8 	st.w	r7[-8],r8
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
80005c6e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005c72:	4b d9       	lddpc	r9,80005d64 <udi_cdc_rx_start+0x114>
80005c74:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005c78:	ef 68 ff fe 	st.b	r7[-2],r8
	if (udi_cdc_rx_trans_ongoing[port] ||
80005c7c:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005c80:	4b a9       	lddpc	r9,80005d68 <udi_cdc_rx_start+0x118>
80005c82:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005c86:	5c 58       	castu.b	r8
80005c88:	c1 51       	brne	80005cb2 <udi_cdc_rx_start+0x62>
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
80005c8a:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005c8e:	4b 88       	lddpc	r8,80005d6c <udi_cdc_rx_start+0x11c>
80005c90:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005c94:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80005c98:	ef 3b ff f4 	ld.ub	r11,r7[-12]
80005c9c:	ef 3a ff fe 	ld.ub	r10,r7[-2]
80005ca0:	4b 48       	lddpc	r8,80005d70 <udi_cdc_rx_start+0x120>
80005ca2:	a1 7b       	lsl	r11,0x1
80005ca4:	f6 0a 00 0a 	add	r10,r11,r10
80005ca8:	f0 0a 04 18 	ld.sh	r8,r8[r10<<0x1]
	port = 0;
#endif

	flags = cpu_irq_save();
	buf_sel_trans = udi_cdc_rx_buf_sel[port];
	if (udi_cdc_rx_trans_ongoing[port] ||
80005cac:	f0 09 19 00 	cp.h	r9,r8
80005cb0:	c0 72       	brcc	80005cbe <udi_cdc_rx_start+0x6e>
		(udi_cdc_rx_pos[port] < udi_cdc_rx_buf_nb[port][buf_sel_trans])) {
		// Transfer already on-going or current buffer no empty
		cpu_irq_restore(flags);
80005cb2:	ee fc ff f8 	ld.w	r12,r7[-8]
80005cb6:	f0 1f 00 30 	mcall	80005d74 <udi_cdc_rx_start+0x124>
		return false;
80005cba:	30 08       	mov	r8,0
80005cbc:	c4 e8       	rjmp	80005d58 <udi_cdc_rx_start+0x108>
	}

	// Change current buffer
	udi_cdc_rx_pos[port] = 0;
80005cbe:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005cc2:	4a b9       	lddpc	r9,80005d6c <udi_cdc_rx_start+0x11c>
80005cc4:	30 08       	mov	r8,0
80005cc6:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_rx_buf_sel[port] = (buf_sel_trans==0)?1:0;
80005cca:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005cce:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80005cd2:	30 08       	mov	r8,0
80005cd4:	f0 09 18 00 	cp.b	r9,r8
80005cd8:	5f 08       	sreq	r8
80005cda:	4a 39       	lddpc	r9,80005d64 <udi_cdc_rx_start+0x114>
80005cdc:	f2 0a 0b 08 	st.b	r9[r10],r8

	// Start transfer on RX
	udi_cdc_rx_trans_ongoing[port] = true;
80005ce0:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005ce4:	4a 1a       	lddpc	r10,80005d68 <udi_cdc_rx_start+0x118>
80005ce6:	30 18       	mov	r8,1
80005ce8:	f4 09 0b 08 	st.b	r10[r9],r8
	cpu_irq_restore(flags);
80005cec:	ee fc ff f8 	ld.w	r12,r7[-8]
80005cf0:	f0 1f 00 21 	mcall	80005d74 <udi_cdc_rx_start+0x124>

	if (udi_cdc_multi_is_rx_ready(port)) {
80005cf4:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005cf8:	10 9c       	mov	r12,r8
80005cfa:	f0 1f 00 20 	mcall	80005d78 <udi_cdc_rx_start+0x128>
80005cfe:	18 98       	mov	r8,r12
80005d00:	58 08       	cp.w	r8,0
80005d02:	c0 60       	breq	80005d0e <udi_cdc_rx_start+0xbe>
		UDI_CDC_RX_NOTIFY(port);
80005d04:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005d08:	10 9c       	mov	r12,r8
80005d0a:	f0 1f 00 1d 	mcall	80005d7c <udi_cdc_rx_start+0x12c>
	}
	// Send the buffer with enable of short packet
	switch (port) {
80005d0e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005d12:	58 08       	cp.w	r8,0
80005d14:	c0 51       	brne	80005d1e <udi_cdc_rx_start+0xce>
#define UDI_CDC_PORT_TO_DATA_EP_OUT(index, unused) \
	case index: \
		ep = UDI_CDC_DATA_EP_OUT_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_OUT, ~)
80005d16:	30 28       	mov	r8,2
80005d18:	ef 68 ff ff 	st.b	r7[-1],r8
80005d1c:	c0 48       	rjmp	80005d24 <udi_cdc_rx_start+0xd4>
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
80005d1e:	30 28       	mov	r8,2
80005d20:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}
	return udd_ep_run(ep,
80005d24:	49 7a       	lddpc	r10,80005d80 <udi_cdc_rx_start+0x130>
80005d26:	ef 39 ff f4 	ld.ub	r9,r7[-12]
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
80005d2a:	12 98       	mov	r8,r9
80005d2c:	a3 68       	lsl	r8,0x2
80005d2e:	12 08       	add	r8,r9
80005d30:	a7 78       	lsl	r8,0x7
80005d32:	10 9b       	mov	r11,r8
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
		break;
	}
	return udd_ep_run(ep,
80005d34:	ef 39 ff fe 	ld.ub	r9,r7[-2]
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
80005d38:	12 98       	mov	r8,r9
80005d3a:	a3 68       	lsl	r8,0x2
80005d3c:	12 08       	add	r8,r9
80005d3e:	a7 68       	lsl	r8,0x6
#undef UDI_CDC_PORT_TO_DATA_EP_OUT
	default:
		ep = UDI_CDC_DATA_EP_OUT_0;
		break;
	}
	return udd_ep_run(ep,
80005d40:	f6 08 00 08 	add	r8,r11,r8
80005d44:	10 0a       	add	r10,r8
80005d46:	ef 3c ff ff 	ld.ub	r12,r7[-1]
80005d4a:	48 f8       	lddpc	r8,80005d84 <udi_cdc_rx_start+0x134>
80005d4c:	e0 69 01 40 	mov	r9,320
80005d50:	30 1b       	mov	r11,1
80005d52:	f0 1f 00 0e 	mcall	80005d88 <udi_cdc_rx_start+0x138>
80005d56:	18 98       	mov	r8,r12
			true,
			udi_cdc_rx_buf[port][buf_sel_trans],
			UDI_CDC_RX_BUFFERS,
			udi_cdc_data_received);
}
80005d58:	10 9c       	mov	r12,r8
80005d5a:	2f dd       	sub	sp,-12
80005d5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80005d60:	80 00       	ld.sh	r0,r0[0x0]
80005d62:	54 c0       	stdsp	sp[0x130],r0
80005d64:	00 00       	add	r0,r0
80005d66:	04 80       	andn	r0,r2
80005d68:	00 00       	add	r0,r0
80005d6a:	04 88       	andn	r8,r2
80005d6c:	00 00       	add	r0,r0
80005d6e:	04 84       	andn	r4,r2
80005d70:	00 00       	add	r0,r0
80005d72:	04 7c       	tst	r12,r2
80005d74:	80 00       	ld.sh	r0,r0[0x0]
80005d76:	55 00       	stdsp	sp[0x140],r0
80005d78:	80 00       	ld.sh	r0,r0[0x0]
80005d7a:	61 f0       	ld.w	r0,r0[0x7c]
80005d7c:	80 00       	ld.sh	r0,r0[0x0]
80005d7e:	8a b8       	ld.uh	r8,r5[0x6]
80005d80:	00 00       	add	r0,r0
80005d82:	01 fc       	ld.ub	r12,r0[0x7]
80005d84:	80 00       	ld.sh	r0,r0[0x0]
80005d86:	5d 8c       	*unknown*
80005d88:	80 00       	ld.sh	r0,r0[0x0]
80005d8a:	3c 7c       	mov	r12,-57

80005d8c <udi_cdc_data_received>:


static void udi_cdc_data_received(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
80005d8c:	eb cd 40 80 	pushm	r7,lr
80005d90:	1a 97       	mov	r7,sp
80005d92:	20 4d       	sub	sp,16
80005d94:	ef 4c ff f8 	st.w	r7[-8],r12
80005d98:	ef 4b ff f4 	st.w	r7[-12],r11
80005d9c:	14 98       	mov	r8,r10
80005d9e:	ef 68 ff f0 	st.b	r7[-16],r8
	uint8_t buf_sel_trans;
	uint8_t port;

	switch (ep) {
80005da2:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80005da6:	58 28       	cp.w	r8,2
80005da8:	c0 51       	brne	80005db2 <udi_cdc_data_received+0x26>
#define UDI_CDC_DATA_EP_OUT_TO_PORT(index, unused) \
	case UDI_CDC_DATA_EP_OUT_##index: \
		port = index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_OUT_TO_PORT, ~)
80005daa:	30 08       	mov	r8,0
80005dac:	ef 68 ff ff 	st.b	r7[-1],r8
80005db0:	c0 48       	rjmp	80005db8 <udi_cdc_data_received+0x2c>
#undef UDI_CDC_DATA_EP_OUT_TO_PORT
	default:
		port = 0;
80005db2:	30 08       	mov	r8,0
80005db4:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
80005db8:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005dbc:	58 08       	cp.w	r8,0
80005dbe:	c4 61       	brne	80005e4a <udi_cdc_data_received+0xbe>
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
80005dc0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005dc4:	4a 49       	lddpc	r9,80005e54 <udi_cdc_data_received+0xc8>
80005dc6:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005dca:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005dce:	30 08       	mov	r8,0
80005dd0:	f0 09 18 00 	cp.b	r9,r8
80005dd4:	5f 08       	sreq	r8
80005dd6:	ef 68 ff fe 	st.b	r7[-2],r8
	if (!n) {
80005dda:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005dde:	58 08       	cp.w	r8,0
80005de0:	c1 c1       	brne	80005e18 <udi_cdc_data_received+0x8c>
		udd_ep_run( ep,
80005de2:	49 ea       	lddpc	r10,80005e58 <udi_cdc_data_received+0xcc>
80005de4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
80005de8:	12 98       	mov	r8,r9
80005dea:	a3 68       	lsl	r8,0x2
80005dec:	12 08       	add	r8,r9
80005dee:	a7 78       	lsl	r8,0x7
80005df0:	10 9b       	mov	r11,r8
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
	if (!n) {
		udd_ep_run( ep,
80005df2:	ef 39 ff fe 	ld.ub	r9,r7[-2]
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
80005df6:	12 98       	mov	r8,r9
80005df8:	a3 68       	lsl	r8,0x2
80005dfa:	12 08       	add	r8,r9
80005dfc:	a7 68       	lsl	r8,0x6
		// Abort reception
		return;
	}
	buf_sel_trans = (udi_cdc_rx_buf_sel[port]==0)?1:0;
	if (!n) {
		udd_ep_run( ep,
80005dfe:	f6 08 00 08 	add	r8,r11,r8
80005e02:	10 0a       	add	r10,r8
80005e04:	ef 3c ff f0 	ld.ub	r12,r7[-16]
80005e08:	fe c8 00 7c 	sub	r8,pc,124
80005e0c:	e0 69 01 40 	mov	r9,320
80005e10:	30 1b       	mov	r11,1
80005e12:	f0 1f 00 13 	mcall	80005e5c <udi_cdc_data_received+0xd0>
				true,
				udi_cdc_rx_buf[port][buf_sel_trans],
				UDI_CDC_RX_BUFFERS,
				udi_cdc_data_received);
		return;
80005e16:	c1 b8       	rjmp	80005e4c <udi_cdc_data_received+0xc0>
	}
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
80005e18:	ef 3b ff ff 	ld.ub	r11,r7[-1]
80005e1c:	ef 3a ff fe 	ld.ub	r10,r7[-2]
80005e20:	ee f8 ff f4 	ld.w	r8,r7[-12]
80005e24:	5c 88       	casts.h	r8
80005e26:	48 f9       	lddpc	r9,80005e60 <udi_cdc_data_received+0xd4>
80005e28:	a1 7b       	lsl	r11,0x1
80005e2a:	f6 0a 00 0a 	add	r10,r11,r10
80005e2e:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_rx_trans_ongoing[port] = false;
80005e32:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005e36:	48 ca       	lddpc	r10,80005e64 <udi_cdc_data_received+0xd8>
80005e38:	30 08       	mov	r8,0
80005e3a:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_rx_start(port);
80005e3e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005e42:	10 9c       	mov	r12,r8
80005e44:	f0 1f 00 09 	mcall	80005e68 <udi_cdc_data_received+0xdc>
80005e48:	c0 28       	rjmp	80005e4c <udi_cdc_data_received+0xc0>
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
		// Abort reception
		return;
80005e4a:	d7 03       	nop
		return;
	}
	udi_cdc_rx_buf_nb[port][buf_sel_trans] = n;
	udi_cdc_rx_trans_ongoing[port] = false;
	udi_cdc_rx_start(port);
}
80005e4c:	2f cd       	sub	sp,-16
80005e4e:	e3 cd 80 80 	ldm	sp++,r7,pc
80005e52:	00 00       	add	r0,r0
80005e54:	00 00       	add	r0,r0
80005e56:	04 80       	andn	r0,r2
80005e58:	00 00       	add	r0,r0
80005e5a:	01 fc       	ld.ub	r12,r0[0x7]
80005e5c:	80 00       	ld.sh	r0,r0[0x0]
80005e5e:	3c 7c       	mov	r12,-57
80005e60:	00 00       	add	r0,r0
80005e62:	04 7c       	tst	r12,r2
80005e64:	00 00       	add	r0,r0
80005e66:	04 88       	andn	r8,r2
80005e68:	80 00       	ld.sh	r0,r0[0x0]
80005e6a:	5c 50       	castu.b	r0

80005e6c <udi_cdc_data_sent>:


static void udi_cdc_data_sent(udd_ep_status_t status, iram_size_t n, udd_ep_id_t ep)
{
80005e6c:	eb cd 40 80 	pushm	r7,lr
80005e70:	1a 97       	mov	r7,sp
80005e72:	20 4d       	sub	sp,16
80005e74:	ef 4c ff f8 	st.w	r7[-8],r12
80005e78:	ef 4b ff f4 	st.w	r7[-12],r11
80005e7c:	14 98       	mov	r8,r10
80005e7e:	ef 68 ff f0 	st.b	r7[-16],r8
	uint8_t port;
	UNUSED(n);

	switch (ep) {
80005e82:	ef 38 ff f0 	ld.ub	r8,r7[-16]
80005e86:	e0 48 00 81 	cp.w	r8,129
80005e8a:	c0 51       	brne	80005e94 <udi_cdc_data_sent+0x28>
#define UDI_CDC_DATA_EP_IN_TO_PORT(index, unused) \
	case UDI_CDC_DATA_EP_IN_##index: \
		port = index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_DATA_EP_IN_TO_PORT, ~)
80005e8c:	30 08       	mov	r8,0
80005e8e:	ef 68 ff ff 	st.b	r7[-1],r8
80005e92:	c0 48       	rjmp	80005e9a <udi_cdc_data_sent+0x2e>
#undef UDI_CDC_DATA_EP_IN_TO_PORT
	default:
		port = 0;
80005e94:	30 08       	mov	r8,0
80005e96:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
80005e9a:	ee f8 ff f8 	ld.w	r8,r7[-8]
80005e9e:	58 08       	cp.w	r8,0
80005ea0:	c2 61       	brne	80005eec <udi_cdc_data_sent+0x80>
		// Abort transfer
		return;
	}
	udi_cdc_tx_buf_nb[port][(udi_cdc_tx_buf_sel[port]==0)?1:0] = 0;
80005ea2:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80005ea6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005eaa:	49 39       	lddpc	r9,80005ef4 <udi_cdc_data_sent+0x88>
80005eac:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005eb0:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80005eb4:	30 08       	mov	r8,0
80005eb6:	f0 09 18 00 	cp.b	r9,r8
80005eba:	5f 08       	sreq	r8
80005ebc:	48 f9       	lddpc	r9,80005ef8 <udi_cdc_data_sent+0x8c>
80005ebe:	a1 7a       	lsl	r10,0x1
80005ec0:	10 0a       	add	r10,r8
80005ec2:	30 08       	mov	r8,0
80005ec4:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	udi_cdc_tx_both_buf_to_send[port] = false;
80005ec8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005ecc:	48 ca       	lddpc	r10,80005efc <udi_cdc_data_sent+0x90>
80005ece:	30 08       	mov	r8,0
80005ed0:	f4 09 0b 08 	st.b	r10[r9],r8
	udi_cdc_tx_trans_ongoing[port] = false;
80005ed4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80005ed8:	48 aa       	lddpc	r10,80005f00 <udi_cdc_data_sent+0x94>
80005eda:	30 08       	mov	r8,0
80005edc:	f4 09 0b 08 	st.b	r10[r9],r8

	if (n != 0) {
		UDI_CDC_TX_EMPTY_NOTIFY(port);
	}
	udi_cdc_tx_send(port);
80005ee0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80005ee4:	10 9c       	mov	r12,r8
80005ee6:	f0 1f 00 08 	mcall	80005f04 <udi_cdc_data_sent+0x98>
80005eea:	c0 28       	rjmp	80005eee <udi_cdc_data_sent+0x82>
		break;
	}

	if (UDD_EP_TRANSFER_OK != status) {
		// Abort transfer
		return;
80005eec:	d7 03       	nop

	if (n != 0) {
		UDI_CDC_TX_EMPTY_NOTIFY(port);
	}
	udi_cdc_tx_send(port);
}
80005eee:	2f cd       	sub	sp,-16
80005ef0:	e3 cd 80 80 	ldm	sp++,r7,pc
80005ef4:	00 00       	add	r0,r0
80005ef6:	07 10       	ld.sh	r0,r3++
80005ef8:	00 00       	add	r0,r0
80005efa:	07 0c       	ld.w	r12,r3++
80005efc:	00 00       	add	r0,r0
80005efe:	07 1c       	ld.sh	r12,r3++
80005f00:	00 00       	add	r0,r0
80005f02:	07 18       	ld.sh	r8,r3++
80005f04:	80 00       	ld.sh	r0,r0[0x0]
80005f06:	5f 08       	sreq	r8

80005f08 <udi_cdc_tx_send>:


static void udi_cdc_tx_send(uint8_t port)
{
80005f08:	eb cd 40 c0 	pushm	r6-r7,lr
80005f0c:	1a 97       	mov	r7,sp
80005f0e:	20 3d       	sub	sp,12
80005f10:	18 98       	mov	r8,r12
80005f12:	ef 68 ff f4 	st.b	r7[-12],r8
	bool b_short_packet;
	udd_ep_id_t ep;
	static uint16_t sof_zlp_counter = 0;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80005f16:	30 08       	mov	r8,0
80005f18:	ef 68 ff f4 	st.b	r7[-12],r8
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
80005f1c:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005f20:	4f e9       	lddpc	r9,80006118 <udi_cdc_tx_send+0x210>
80005f22:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005f26:	5c 58       	castu.b	r8
80005f28:	e0 81 00 f1 	brne	8000610a <udi_cdc_tx_send+0x202>
		return; // Already on going or wait next SOF to send next data
	}
	if (udd_is_high_speed()) {
80005f2c:	f0 1f 00 7c 	mcall	8000611c <udi_cdc_tx_send+0x214>
80005f30:	18 98       	mov	r8,r12
80005f32:	58 08       	cp.w	r8,0
80005f34:	c0 e0       	breq	80005f50 <udi_cdc_tx_send+0x48>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
80005f36:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005f3a:	4f a8       	lddpc	r8,80006120 <udi_cdc_tx_send+0x218>
80005f3c:	f0 09 04 16 	ld.sh	r6,r8[r9<<0x1]
80005f40:	f0 1f 00 79 	mcall	80006124 <udi_cdc_tx_send+0x21c>
80005f44:	18 98       	mov	r8,r12
80005f46:	5c 88       	casts.h	r8
80005f48:	f0 06 19 00 	cp.h	r6,r8
80005f4c:	c0 f1       	brne	80005f6a <udi_cdc_tx_send+0x62>
			return; // Wait next SOF to send next data
80005f4e:	ce 18       	rjmp	80006110 <udi_cdc_tx_send+0x208>
		}
	}else{
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
80005f50:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80005f54:	4f 38       	lddpc	r8,80006120 <udi_cdc_tx_send+0x218>
80005f56:	f0 09 04 16 	ld.sh	r6,r8[r9<<0x1]
80005f5a:	f0 1f 00 74 	mcall	80006128 <udi_cdc_tx_send+0x220>
80005f5e:	18 98       	mov	r8,r12
80005f60:	5c 88       	casts.h	r8
80005f62:	f0 06 19 00 	cp.h	r6,r8
80005f66:	e0 80 00 d4 	breq	8000610e <udi_cdc_tx_send+0x206>
			return; // Wait next SOF to send next data
		}
	}

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
80005f6a:	f0 1f 00 71 	mcall	8000612c <udi_cdc_tx_send+0x224>
80005f6e:	18 98       	mov	r8,r12
80005f70:	ef 48 ff f8 	st.w	r7[-8],r8
	buf_sel_trans = udi_cdc_tx_buf_sel[port];
80005f74:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005f78:	4e e9       	lddpc	r9,80006130 <udi_cdc_tx_send+0x228>
80005f7a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005f7e:	ef 68 ff fd 	st.b	r7[-3],r8
	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
80005f82:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80005f86:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80005f8a:	4e b8       	lddpc	r8,80006134 <udi_cdc_tx_send+0x22c>
80005f8c:	a1 7a       	lsl	r10,0x1
80005f8e:	f4 09 00 09 	add	r9,r10,r9
80005f92:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80005f96:	58 08       	cp.w	r8,0
80005f98:	c2 71       	brne	80005fe6 <udi_cdc_tx_send+0xde>
		sof_zlp_counter++;
80005f9a:	4e 88       	lddpc	r8,80006138 <udi_cdc_tx_send+0x230>
80005f9c:	90 08       	ld.sh	r8,r8[0x0]
80005f9e:	2f f8       	sub	r8,-1
80005fa0:	5c 88       	casts.h	r8
80005fa2:	4e 69       	lddpc	r9,80006138 <udi_cdc_tx_send+0x230>
80005fa4:	b2 08       	st.h	r9[0x0],r8
		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
80005fa6:	f0 1f 00 5e 	mcall	8000611c <udi_cdc_tx_send+0x214>
80005faa:	18 98       	mov	r8,r12
80005fac:	ec 18 00 01 	eorl	r8,0x1
80005fb0:	5c 58       	castu.b	r8
80005fb2:	c0 80       	breq	80005fc2 <udi_cdc_tx_send+0xba>
80005fb4:	4e 18       	lddpc	r8,80006138 <udi_cdc_tx_send+0x230>
80005fb6:	90 09       	ld.sh	r9,r8[0x0]
80005fb8:	36 38       	mov	r8,99
80005fba:	f0 09 19 00 	cp.h	r9,r8
80005fbe:	e0 88 00 0f 	brls	80005fdc <udi_cdc_tx_send+0xd4>
80005fc2:	f0 1f 00 57 	mcall	8000611c <udi_cdc_tx_send+0x214>
80005fc6:	18 98       	mov	r8,r12
80005fc8:	58 08       	cp.w	r8,0
80005fca:	c0 e0       	breq	80005fe6 <udi_cdc_tx_send+0xde>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
80005fcc:	4d b8       	lddpc	r8,80006138 <udi_cdc_tx_send+0x230>
80005fce:	90 09       	ld.sh	r9,r8[0x0]

	flags = cpu_irq_save(); // to protect udi_cdc_tx_buf_sel
	buf_sel_trans = udi_cdc_tx_buf_sel[port];
	if (udi_cdc_tx_buf_nb[port][buf_sel_trans] == 0) {
		sof_zlp_counter++;
		if (((!udd_is_high_speed()) && (sof_zlp_counter < 100))
80005fd0:	e0 68 03 1f 	mov	r8,799
80005fd4:	f0 09 19 00 	cp.h	r9,r8
80005fd8:	e0 8b 00 07 	brhi	80005fe6 <udi_cdc_tx_send+0xde>
				|| (udd_is_high_speed() && (sof_zlp_counter < 800))) {
			cpu_irq_restore(flags);
80005fdc:	ee fc ff f8 	ld.w	r12,r7[-8]
80005fe0:	f0 1f 00 57 	mcall	8000613c <udi_cdc_tx_send+0x234>
			return;
80005fe4:	c9 68       	rjmp	80006110 <udi_cdc_tx_send+0x208>
		}
	}
	sof_zlp_counter = 0;
80005fe6:	4d 59       	lddpc	r9,80006138 <udi_cdc_tx_send+0x230>
80005fe8:	30 08       	mov	r8,0
80005fea:	b2 08       	st.h	r9[0x0],r8

	if (!udi_cdc_tx_both_buf_to_send[port]) {
80005fec:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80005ff0:	4d 49       	lddpc	r9,80006140 <udi_cdc_tx_send+0x238>
80005ff2:	f2 08 07 08 	ld.ub	r8,r9[r8]
80005ff6:	5c 58       	castu.b	r8
80005ff8:	ec 18 00 01 	eorl	r8,0x1
80005ffc:	5c 58       	castu.b	r8
80005ffe:	c0 d0       	breq	80006018 <udi_cdc_tx_send+0x110>
		// Send current Buffer
		// and switch the current buffer
		udi_cdc_tx_buf_sel[port] = (buf_sel_trans==0)?1:0;
80006000:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80006004:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80006008:	30 08       	mov	r8,0
8000600a:	f0 09 18 00 	cp.b	r9,r8
8000600e:	5f 08       	sreq	r8
80006010:	4c 89       	lddpc	r9,80006130 <udi_cdc_tx_send+0x228>
80006012:	f2 0a 0b 08 	st.b	r9[r10],r8
80006016:	c0 98       	rjmp	80006028 <udi_cdc_tx_send+0x120>
	}else{
		// Send the other Buffer
		// and no switch the current buffer
		buf_sel_trans = (buf_sel_trans==0)?1:0;
80006018:	ef 39 ff fd 	ld.ub	r9,r7[-3]
8000601c:	30 08       	mov	r8,0
8000601e:	f0 09 18 00 	cp.b	r9,r8
80006022:	5f 08       	sreq	r8
80006024:	ef 68 ff fd 	st.b	r7[-3],r8
	}
	udi_cdc_tx_trans_ongoing[port] = true;
80006028:	ef 39 ff f4 	ld.ub	r9,r7[-12]
8000602c:	4b ba       	lddpc	r10,80006118 <udi_cdc_tx_send+0x210>
8000602e:	30 18       	mov	r8,1
80006030:	f4 09 0b 08 	st.b	r10[r9],r8
	cpu_irq_restore(flags);
80006034:	ee fc ff f8 	ld.w	r12,r7[-8]
80006038:	f0 1f 00 41 	mcall	8000613c <udi_cdc_tx_send+0x234>

	b_short_packet = (udi_cdc_tx_buf_nb[port][buf_sel_trans] != UDI_CDC_TX_BUFFERS);
8000603c:	ef 3a ff f4 	ld.ub	r10,r7[-12]
80006040:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80006044:	4b c8       	lddpc	r8,80006134 <udi_cdc_tx_send+0x22c>
80006046:	a1 7a       	lsl	r10,0x1
80006048:	f4 09 00 09 	add	r9,r10,r9
8000604c:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
80006050:	e0 68 01 40 	mov	r8,320
80006054:	f0 09 19 00 	cp.h	r9,r8
80006058:	5f 18       	srne	r8
8000605a:	ef 68 ff fe 	st.b	r7[-2],r8
	if (b_short_packet) {
8000605e:	ef 39 ff fe 	ld.ub	r9,r7[-2]
80006062:	30 08       	mov	r8,0
80006064:	f0 09 18 00 	cp.b	r9,r8
80006068:	c1 a0       	breq	8000609c <udi_cdc_tx_send+0x194>
		if (udd_is_high_speed()) {
8000606a:	f0 1f 00 2d 	mcall	8000611c <udi_cdc_tx_send+0x214>
8000606e:	18 98       	mov	r8,r12
80006070:	58 08       	cp.w	r8,0
80006072:	c0 b0       	breq	80006088 <udi_cdc_tx_send+0x180>
			udi_cdc_tx_sof_num[port] = udd_get_micro_frame_number();
80006074:	ef 36 ff f4 	ld.ub	r6,r7[-12]
80006078:	f0 1f 00 2b 	mcall	80006124 <udi_cdc_tx_send+0x21c>
8000607c:	18 98       	mov	r8,r12
8000607e:	5c 88       	casts.h	r8
80006080:	4a 89       	lddpc	r9,80006120 <udi_cdc_tx_send+0x218>
80006082:	f2 06 0a 18 	st.h	r9[r6<<0x1],r8
80006086:	c1 18       	rjmp	800060a8 <udi_cdc_tx_send+0x1a0>
		}else{
			udi_cdc_tx_sof_num[port] = udd_get_frame_number();
80006088:	ef 36 ff f4 	ld.ub	r6,r7[-12]
8000608c:	f0 1f 00 27 	mcall	80006128 <udi_cdc_tx_send+0x220>
80006090:	18 98       	mov	r8,r12
80006092:	5c 88       	casts.h	r8
80006094:	4a 39       	lddpc	r9,80006120 <udi_cdc_tx_send+0x218>
80006096:	f2 06 0a 18 	st.h	r9[r6<<0x1],r8
8000609a:	c0 78       	rjmp	800060a8 <udi_cdc_tx_send+0x1a0>
		}
	}else{
		udi_cdc_tx_sof_num[port] = 0; // Force next transfer without wait SOF
8000609c:	ef 3a ff f4 	ld.ub	r10,r7[-12]
800060a0:	4a 09       	lddpc	r9,80006120 <udi_cdc_tx_send+0x218>
800060a2:	30 08       	mov	r8,0
800060a4:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	}

	// Send the buffer with enable of short packet
	switch (port) {
800060a8:	ef 38 ff f4 	ld.ub	r8,r7[-12]
800060ac:	58 08       	cp.w	r8,0
800060ae:	c0 51       	brne	800060b8 <udi_cdc_tx_send+0x1b0>
#define UDI_CDC_PORT_TO_DATA_EP_IN(index, unused) \
	case index: \
		ep = UDI_CDC_DATA_EP_IN_##index; \
		break;
	MREPEAT(UDI_CDC_PORT_NB, UDI_CDC_PORT_TO_DATA_EP_IN, ~)
800060b0:	38 18       	mov	r8,-127
800060b2:	ef 68 ff ff 	st.b	r7[-1],r8
800060b6:	c0 48       	rjmp	800060be <udi_cdc_tx_send+0x1b6>
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
800060b8:	38 18       	mov	r8,-127
800060ba:	ef 68 ff ff 	st.b	r7[-1],r8
		break;
	}
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
800060be:	ef 3a ff f4 	ld.ub	r10,r7[-12]
800060c2:	ef 39 ff fd 	ld.ub	r9,r7[-3]
800060c6:	49 c8       	lddpc	r8,80006134 <udi_cdc_tx_send+0x22c>
800060c8:	a1 7a       	lsl	r10,0x1
800060ca:	f4 09 00 09 	add	r9,r10,r9
800060ce:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
		break;
	}
	udd_ep_run( ep,
800060d2:	fd d8 c0 10 	bfextu	lr,r8,0x0,0x10
800060d6:	49 ca       	lddpc	r10,80006144 <udi_cdc_tx_send+0x23c>
800060d8:	ef 39 ff f4 	ld.ub	r9,r7[-12]
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
800060dc:	12 98       	mov	r8,r9
800060de:	a3 68       	lsl	r8,0x2
800060e0:	12 08       	add	r8,r9
800060e2:	a7 78       	lsl	r8,0x7
800060e4:	10 9b       	mov	r11,r8
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
		break;
	}
	udd_ep_run( ep,
800060e6:	ef 39 ff fd 	ld.ub	r9,r7[-3]
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
800060ea:	12 98       	mov	r8,r9
800060ec:	a3 68       	lsl	r8,0x2
800060ee:	12 08       	add	r8,r9
800060f0:	a7 68       	lsl	r8,0x6
#undef UDI_CDC_PORT_TO_DATA_EP_IN
	default:
		ep = UDI_CDC_DATA_EP_IN_0;
		break;
	}
	udd_ep_run( ep,
800060f2:	f6 08 00 08 	add	r8,r11,r8
800060f6:	10 0a       	add	r10,r8
800060f8:	ef 3b ff fe 	ld.ub	r11,r7[-2]
800060fc:	ef 3c ff ff 	ld.ub	r12,r7[-1]
80006100:	49 28       	lddpc	r8,80006148 <udi_cdc_tx_send+0x240>
80006102:	1c 99       	mov	r9,lr
80006104:	f0 1f 00 12 	mcall	8000614c <udi_cdc_tx_send+0x244>
80006108:	c0 48       	rjmp	80006110 <udi_cdc_tx_send+0x208>
#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
#endif

	if (udi_cdc_tx_trans_ongoing[port]) {
		return; // Already on going or wait next SOF to send next data
8000610a:	d7 03       	nop
8000610c:	c0 28       	rjmp	80006110 <udi_cdc_tx_send+0x208>
		if (udi_cdc_tx_sof_num[port] == udd_get_micro_frame_number()) {
			return; // Wait next SOF to send next data
		}
	}else{
		if (udi_cdc_tx_sof_num[port] == udd_get_frame_number()) {
			return; // Wait next SOF to send next data
8000610e:	d7 03       	nop
	udd_ep_run( ep,
			b_short_packet,
			udi_cdc_tx_buf[port][buf_sel_trans],
			udi_cdc_tx_buf_nb[port][buf_sel_trans],
			udi_cdc_data_sent);
}
80006110:	2f dd       	sub	sp,-12
80006112:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80006116:	00 00       	add	r0,r0
80006118:	00 00       	add	r0,r0
8000611a:	07 18       	ld.sh	r8,r3++
8000611c:	80 00       	ld.sh	r0,r0[0x0]
8000611e:	35 38       	mov	r8,83
80006120:	00 00       	add	r0,r0
80006122:	07 14       	ld.sh	r4,r3++
80006124:	80 00       	ld.sh	r0,r0[0x0]
80006126:	35 c6       	mov	r6,92
80006128:	80 00       	ld.sh	r0,r0[0x0]
8000612a:	35 ac       	mov	r12,90
8000612c:	80 00       	ld.sh	r0,r0[0x0]
8000612e:	54 c0       	stdsp	sp[0x130],r0
80006130:	00 00       	add	r0,r0
80006132:	07 10       	ld.sh	r0,r3++
80006134:	00 00       	add	r0,r0
80006136:	07 0c       	ld.w	r12,r3++
80006138:	00 00       	add	r0,r0
8000613a:	07 20       	ld.uh	r0,r3++
8000613c:	80 00       	ld.sh	r0,r0[0x0]
8000613e:	55 00       	stdsp	sp[0x140],r0
80006140:	00 00       	add	r0,r0
80006142:	07 1c       	ld.sh	r12,r3++
80006144:	00 00       	add	r0,r0
80006146:	04 8c       	andn	r12,r2
80006148:	80 00       	ld.sh	r0,r0[0x0]
8000614a:	5e 6c       	retmi	r12
8000614c:	80 00       	ld.sh	r0,r0[0x0]
8000614e:	3c 7c       	mov	r12,-57

80006150 <udi_cdc_signal_framing_error>:
{
	udi_cdc_ctrl_state_change(0, b_set, CDC_SERIAL_STATE_DSR);
}

void udi_cdc_signal_framing_error(void)
{
80006150:	eb cd 40 80 	pushm	r7,lr
80006154:	1a 97       	mov	r7,sp
	udi_cdc_ctrl_state_change(0, true, CDC_SERIAL_STATE_FRAMING);
80006156:	e0 6a 10 00 	mov	r10,4096
8000615a:	30 1b       	mov	r11,1
8000615c:	30 0c       	mov	r12,0
8000615e:	f0 1f 00 03 	mcall	80006168 <udi_cdc_signal_framing_error+0x18>
}
80006162:	e3 cd 80 80 	ldm	sp++,r7,pc
80006166:	00 00       	add	r0,r0
80006168:	80 00       	ld.sh	r0,r0[0x0]
8000616a:	5a 10       	cp.w	r0,-31

8000616c <udi_cdc_multi_get_nb_received_data>:
{
	udi_cdc_ctrl_state_change(port, true, CDC_SERIAL_STATE_OVERRUN);
}

iram_size_t udi_cdc_multi_get_nb_received_data(uint8_t port)
{
8000616c:	eb cd 40 80 	pushm	r7,lr
80006170:	1a 97       	mov	r7,sp
80006172:	20 4d       	sub	sp,16
80006174:	18 98       	mov	r8,r12
80006176:	ef 68 ff f0 	st.b	r7[-16],r8
	irqflags_t flags;
	uint16_t pos;
	iram_size_t nb_received;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
8000617a:	30 08       	mov	r8,0
8000617c:	ef 68 ff f0 	st.b	r7[-16],r8
#endif
	flags = cpu_irq_save();
80006180:	f0 1f 00 17 	mcall	800061dc <udi_cdc_multi_get_nb_received_data+0x70>
80006184:	18 98       	mov	r8,r12
80006186:	ef 48 ff f4 	st.w	r7[-12],r8
	pos = udi_cdc_rx_pos[port];
8000618a:	ef 39 ff f0 	ld.ub	r9,r7[-16]
8000618e:	49 58       	lddpc	r8,800061e0 <udi_cdc_multi_get_nb_received_data+0x74>
80006190:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006194:	ef 58 ff fa 	st.h	r7[-6],r8
	nb_received = udi_cdc_rx_buf_nb[port][udi_cdc_rx_buf_sel[port]] - pos;
80006198:	ef 3a ff f0 	ld.ub	r10,r7[-16]
8000619c:	ef 38 ff f0 	ld.ub	r8,r7[-16]
800061a0:	49 19       	lddpc	r9,800061e4 <udi_cdc_multi_get_nb_received_data+0x78>
800061a2:	f2 08 07 08 	ld.ub	r8,r9[r8]
800061a6:	5c 58       	castu.b	r8
800061a8:	10 99       	mov	r9,r8
800061aa:	49 08       	lddpc	r8,800061e8 <udi_cdc_multi_get_nb_received_data+0x7c>
800061ac:	a1 7a       	lsl	r10,0x1
800061ae:	f4 09 00 09 	add	r9,r10,r9
800061b2:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800061b6:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800061ba:	ef 18 ff fa 	ld.uh	r8,r7[-6]
800061be:	f2 08 01 08 	sub	r8,r9,r8
800061c2:	ef 48 ff fc 	st.w	r7[-4],r8
	cpu_irq_restore(flags);
800061c6:	ee fc ff f4 	ld.w	r12,r7[-12]
800061ca:	f0 1f 00 09 	mcall	800061ec <udi_cdc_multi_get_nb_received_data+0x80>
	return nb_received;
800061ce:	ee f8 ff fc 	ld.w	r8,r7[-4]
}
800061d2:	10 9c       	mov	r12,r8
800061d4:	2f cd       	sub	sp,-16
800061d6:	e3 cd 80 80 	ldm	sp++,r7,pc
800061da:	00 00       	add	r0,r0
800061dc:	80 00       	ld.sh	r0,r0[0x0]
800061de:	54 c0       	stdsp	sp[0x130],r0
800061e0:	00 00       	add	r0,r0
800061e2:	04 84       	andn	r4,r2
800061e4:	00 00       	add	r0,r0
800061e6:	04 80       	andn	r0,r2
800061e8:	00 00       	add	r0,r0
800061ea:	04 7c       	tst	r12,r2
800061ec:	80 00       	ld.sh	r0,r0[0x0]
800061ee:	55 00       	stdsp	sp[0x140],r0

800061f0 <udi_cdc_multi_is_rx_ready>:
{
	return udi_cdc_multi_get_nb_received_data(0);
}

bool udi_cdc_multi_is_rx_ready(uint8_t port)
{
800061f0:	eb cd 40 80 	pushm	r7,lr
800061f4:	1a 97       	mov	r7,sp
800061f6:	20 1d       	sub	sp,4
800061f8:	18 98       	mov	r8,r12
800061fa:	ef 68 ff fc 	st.b	r7[-4],r8
	return (udi_cdc_multi_get_nb_received_data(port) > 0);
800061fe:	ef 38 ff fc 	ld.ub	r8,r7[-4]
80006202:	10 9c       	mov	r12,r8
80006204:	f0 1f 00 05 	mcall	80006218 <udi_cdc_multi_is_rx_ready+0x28>
80006208:	18 98       	mov	r8,r12
8000620a:	58 08       	cp.w	r8,0
8000620c:	5f 18       	srne	r8
8000620e:	5c 58       	castu.b	r8
}
80006210:	10 9c       	mov	r12,r8
80006212:	2f fd       	sub	sp,-4
80006214:	e3 cd 80 80 	ldm	sp++,r7,pc
80006218:	80 00       	ld.sh	r0,r0[0x0]
8000621a:	61 6c       	ld.w	r12,r0[0x58]

8000621c <udi_cdc_is_rx_ready>:

bool udi_cdc_is_rx_ready(void)
{
8000621c:	eb cd 40 80 	pushm	r7,lr
80006220:	1a 97       	mov	r7,sp
	return udi_cdc_multi_is_rx_ready(0);
80006222:	30 0c       	mov	r12,0
80006224:	f0 1f 00 03 	mcall	80006230 <udi_cdc_is_rx_ready+0x14>
80006228:	18 98       	mov	r8,r12
}
8000622a:	10 9c       	mov	r12,r8
8000622c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006230:	80 00       	ld.sh	r0,r0[0x0]
80006232:	61 f0       	ld.w	r0,r0[0x7c]

80006234 <udi_cdc_multi_read_buf>:
{
	return udi_cdc_multi_getc(0);
}

iram_size_t udi_cdc_multi_read_buf(uint8_t port, void* buf, iram_size_t size)
{
80006234:	eb cd 40 80 	pushm	r7,lr
80006238:	1a 97       	mov	r7,sp
8000623a:	20 7d       	sub	sp,28
8000623c:	18 98       	mov	r8,r12
8000623e:	ef 4b ff e8 	st.w	r7[-24],r11
80006242:	ef 4a ff e4 	st.w	r7[-28],r10
80006246:	ef 68 ff ec 	st.b	r7[-20],r8
	irqflags_t flags;
	uint8_t *ptr_buf = (uint8_t *)buf;
8000624a:	ee f8 ff e8 	ld.w	r8,r7[-24]
8000624e:	ef 48 ff f4 	st.w	r7[-12],r8
	iram_size_t copy_nb;
	uint16_t pos;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
80006252:	30 08       	mov	r8,0
80006254:	ef 68 ff ec 	st.b	r7[-20],r8
80006258:	c0 48       	rjmp	80006260 <udi_cdc_multi_read_buf+0x2c>
	cpu_irq_restore(flags);
	while (pos >= udi_cdc_rx_buf_nb[port][buf_sel]) {
		if (!udi_cdc_data_running) {
			return size;
		}
		goto udi_cdc_read_buf_loop_wait;
8000625a:	d7 03       	nop
8000625c:	c0 28       	rjmp	80006260 <udi_cdc_multi_read_buf+0x2c>
	ptr_buf += copy_nb;
	size -= copy_nb;
	udi_cdc_rx_start(port);

	if (size) {
		goto udi_cdc_read_buf_loop_wait;
8000625e:	d7 03       	nop
	port = 0;
#endif

udi_cdc_read_buf_loop_wait:
	// Check available data
	flags = cpu_irq_save();
80006260:	f0 1f 00 4d 	mcall	80006394 <udi_cdc_multi_read_buf+0x160>
80006264:	18 98       	mov	r8,r12
80006266:	ef 48 ff f0 	st.w	r7[-16],r8
	pos = udi_cdc_rx_pos[port];
8000626a:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000626e:	4c b8       	lddpc	r8,80006398 <udi_cdc_multi_read_buf+0x164>
80006270:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006274:	ef 58 ff fc 	st.h	r7[-4],r8
	buf_sel = udi_cdc_rx_buf_sel[port];
80006278:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000627c:	4c 89       	lddpc	r9,8000639c <udi_cdc_multi_read_buf+0x168>
8000627e:	f2 08 07 08 	ld.ub	r8,r9[r8]
80006282:	ef 68 ff ff 	st.b	r7[-1],r8
	cpu_irq_restore(flags);
80006286:	ee fc ff f0 	ld.w	r12,r7[-16]
8000628a:	f0 1f 00 46 	mcall	800063a0 <udi_cdc_multi_read_buf+0x16c>
	while (pos >= udi_cdc_rx_buf_nb[port][buf_sel]) {
8000628e:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80006292:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006296:	4c 48       	lddpc	r8,800063a4 <udi_cdc_multi_read_buf+0x170>
80006298:	a1 7a       	lsl	r10,0x1
8000629a:	f4 09 00 09 	add	r9,r10,r9
8000629e:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800062a2:	ef 09 ff fc 	ld.sh	r9,r7[-4]
800062a6:	f0 09 19 00 	cp.h	r9,r8
800062aa:	c0 b3       	brcs	800062c0 <udi_cdc_multi_read_buf+0x8c>
		if (!udi_cdc_data_running) {
800062ac:	4b f8       	lddpc	r8,800063a8 <udi_cdc_multi_read_buf+0x174>
800062ae:	11 88       	ld.ub	r8,r8[0x0]
800062b0:	5c 58       	castu.b	r8
800062b2:	ec 18 00 01 	eorl	r8,0x1
800062b6:	5c 58       	castu.b	r8
800062b8:	cd 10       	breq	8000625a <udi_cdc_multi_read_buf+0x26>
			return size;
800062ba:	ee f8 ff e4 	ld.w	r8,r7[-28]
800062be:	c6 78       	rjmp	8000638c <udi_cdc_multi_read_buf+0x158>
		}
		goto udi_cdc_read_buf_loop_wait;
	}

	// Read data
	copy_nb = udi_cdc_rx_buf_nb[port][buf_sel] - pos;
800062c0:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800062c4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800062c8:	4b 78       	lddpc	r8,800063a4 <udi_cdc_multi_read_buf+0x170>
800062ca:	a1 7a       	lsl	r10,0x1
800062cc:	f4 09 00 09 	add	r9,r10,r9
800062d0:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800062d4:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800062d8:	ef 18 ff fc 	ld.uh	r8,r7[-4]
800062dc:	f2 08 01 08 	sub	r8,r9,r8
800062e0:	ef 48 ff f8 	st.w	r7[-8],r8
	if (copy_nb>size) {
800062e4:	ee f9 ff f8 	ld.w	r9,r7[-8]
800062e8:	ee f8 ff e4 	ld.w	r8,r7[-28]
800062ec:	10 39       	cp.w	r9,r8
800062ee:	e0 88 00 06 	brls	800062fa <udi_cdc_multi_read_buf+0xc6>
		copy_nb = size;
800062f2:	ee f8 ff e4 	ld.w	r8,r7[-28]
800062f6:	ef 48 ff f8 	st.w	r7[-8],r8
	}
	memcpy(ptr_buf, &udi_cdc_rx_buf[port][buf_sel][pos], copy_nb);
800062fa:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800062fe:	12 98       	mov	r8,r9
80006300:	a3 68       	lsl	r8,0x2
80006302:	12 08       	add	r8,r9
80006304:	a7 78       	lsl	r8,0x7
80006306:	10 9a       	mov	r10,r8
80006308:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000630c:	12 98       	mov	r8,r9
8000630e:	a3 68       	lsl	r8,0x2
80006310:	12 08       	add	r8,r9
80006312:	a7 68       	lsl	r8,0x6
80006314:	f4 08 00 09 	add	r9,r10,r8
80006318:	ef 18 ff fc 	ld.uh	r8,r7[-4]
8000631c:	10 09       	add	r9,r8
8000631e:	4a 48       	lddpc	r8,800063ac <udi_cdc_multi_read_buf+0x178>
80006320:	f2 08 00 08 	add	r8,r9,r8
80006324:	ee fa ff f8 	ld.w	r10,r7[-8]
80006328:	10 9b       	mov	r11,r8
8000632a:	ee fc ff f4 	ld.w	r12,r7[-12]
8000632e:	f0 1f 00 21 	mcall	800063b0 <udi_cdc_multi_read_buf+0x17c>
	udi_cdc_rx_pos[port] += copy_nb;
80006332:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80006336:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000633a:	49 88       	lddpc	r8,80006398 <udi_cdc_multi_read_buf+0x164>
8000633c:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006340:	f3 d8 b0 10 	bfexts	r9,r8,0x0,0x10
80006344:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006348:	5c 88       	casts.h	r8
8000634a:	f2 08 00 08 	add	r8,r9,r8
8000634e:	5c 88       	casts.h	r8
80006350:	49 29       	lddpc	r9,80006398 <udi_cdc_multi_read_buf+0x164>
80006352:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	ptr_buf += copy_nb;
80006356:	ee f9 ff f4 	ld.w	r9,r7[-12]
8000635a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000635e:	f2 08 00 08 	add	r8,r9,r8
80006362:	ef 48 ff f4 	st.w	r7[-12],r8
	size -= copy_nb;
80006366:	ee f9 ff e4 	ld.w	r9,r7[-28]
8000636a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000636e:	f2 08 01 08 	sub	r8,r9,r8
80006372:	ef 48 ff e4 	st.w	r7[-28],r8
	udi_cdc_rx_start(port);
80006376:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000637a:	10 9c       	mov	r12,r8
8000637c:	f0 1f 00 0e 	mcall	800063b4 <udi_cdc_multi_read_buf+0x180>

	if (size) {
80006380:	ee f8 ff e4 	ld.w	r8,r7[-28]
80006384:	58 08       	cp.w	r8,0
80006386:	fe 91 ff 6c 	brne	8000625e <udi_cdc_multi_read_buf+0x2a>
		goto udi_cdc_read_buf_loop_wait;
	}
	return 0;
8000638a:	30 08       	mov	r8,0
}
8000638c:	10 9c       	mov	r12,r8
8000638e:	2f 9d       	sub	sp,-28
80006390:	e3 cd 80 80 	ldm	sp++,r7,pc
80006394:	80 00       	ld.sh	r0,r0[0x0]
80006396:	54 c0       	stdsp	sp[0x130],r0
80006398:	00 00       	add	r0,r0
8000639a:	04 84       	andn	r4,r2
8000639c:	00 00       	add	r0,r0
8000639e:	04 80       	andn	r0,r2
800063a0:	80 00       	ld.sh	r0,r0[0x0]
800063a2:	55 00       	stdsp	sp[0x140],r0
800063a4:	00 00       	add	r0,r0
800063a6:	04 7c       	tst	r12,r2
800063a8:	00 00       	add	r0,r0
800063aa:	01 fa       	ld.ub	r10,r0[0x7]
800063ac:	00 00       	add	r0,r0
800063ae:	01 fc       	ld.ub	r12,r0[0x7]
800063b0:	80 00       	ld.sh	r0,r0[0x0]
800063b2:	91 28       	st.w	r8[0x8],r8
800063b4:	80 00       	ld.sh	r0,r0[0x0]
800063b6:	5c 50       	castu.b	r0

800063b8 <udi_cdc_read_buf>:

iram_size_t udi_cdc_read_buf(void* buf, iram_size_t size)
{
800063b8:	eb cd 40 80 	pushm	r7,lr
800063bc:	1a 97       	mov	r7,sp
800063be:	20 2d       	sub	sp,8
800063c0:	ef 4c ff fc 	st.w	r7[-4],r12
800063c4:	ef 4b ff f8 	st.w	r7[-8],r11
	return udi_cdc_multi_read_buf(0, buf, size);
800063c8:	ee fa ff f8 	ld.w	r10,r7[-8]
800063cc:	ee fb ff fc 	ld.w	r11,r7[-4]
800063d0:	30 0c       	mov	r12,0
800063d2:	f0 1f 00 04 	mcall	800063e0 <udi_cdc_read_buf+0x28>
800063d6:	18 98       	mov	r8,r12
}
800063d8:	10 9c       	mov	r12,r8
800063da:	2f ed       	sub	sp,-8
800063dc:	e3 cd 80 80 	ldm	sp++,r7,pc
800063e0:	80 00       	ld.sh	r0,r0[0x0]
800063e2:	62 34       	ld.w	r4,r1[0xc]

800063e4 <udi_cdc_multi_get_free_tx_buffer>:

iram_size_t udi_cdc_multi_get_free_tx_buffer(uint8_t port)
{
800063e4:	eb cd 40 80 	pushm	r7,lr
800063e8:	1a 97       	mov	r7,sp
800063ea:	20 5d       	sub	sp,20
800063ec:	18 98       	mov	r8,r12
800063ee:	ef 68 ff ec 	st.b	r7[-20],r8
	irqflags_t flags;
	iram_size_t buf_sel_nb, buf_nosel_nb;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
800063f2:	30 08       	mov	r8,0
800063f4:	ef 68 ff ec 	st.b	r7[-20],r8
#endif

	flags = cpu_irq_save();
800063f8:	f0 1f 00 37 	mcall	800064d4 <udi_cdc_multi_get_free_tx_buffer+0xf0>
800063fc:	18 98       	mov	r8,r12
800063fe:	ef 48 ff f0 	st.w	r7[-16],r8
	buf_sel = udi_cdc_tx_buf_sel[port];
80006402:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80006406:	4b 59       	lddpc	r9,800064d8 <udi_cdc_multi_get_free_tx_buffer+0xf4>
80006408:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000640c:	ef 68 ff ff 	st.b	r7[-1],r8
	buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
80006410:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80006414:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006418:	4b 18       	lddpc	r8,800064dc <udi_cdc_multi_get_free_tx_buffer+0xf8>
8000641a:	a1 7a       	lsl	r10,0x1
8000641c:	f4 09 00 09 	add	r9,r10,r9
80006420:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006424:	5c 78       	castu.h	r8
80006426:	ef 48 ff f4 	st.w	r7[-12],r8
	buf_nosel_nb = udi_cdc_tx_buf_nb[port][(buf_sel == 0)? 1 : 0];
8000642a:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000642e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006432:	30 08       	mov	r8,0
80006434:	f0 09 18 00 	cp.b	r9,r8
80006438:	5f 09       	sreq	r9
8000643a:	4a 98       	lddpc	r8,800064dc <udi_cdc_multi_get_free_tx_buffer+0xf8>
8000643c:	a1 7a       	lsl	r10,0x1
8000643e:	f4 09 00 09 	add	r9,r10,r9
80006442:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80006446:	5c 78       	castu.h	r8
80006448:	ef 48 ff f8 	st.w	r7[-8],r8
	if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
8000644c:	ee f8 ff f4 	ld.w	r8,r7[-12]
80006450:	e0 48 01 40 	cp.w	r8,320
80006454:	c2 d1       	brne	800064ae <udi_cdc_multi_get_free_tx_buffer+0xca>
		if ((!udi_cdc_tx_trans_ongoing[port])
80006456:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000645a:	4a 29       	lddpc	r9,800064e0 <udi_cdc_multi_get_free_tx_buffer+0xfc>
8000645c:	f2 08 07 08 	ld.ub	r8,r9[r8]
80006460:	5c 58       	castu.b	r8
80006462:	ec 18 00 01 	eorl	r8,0x1
80006466:	5c 58       	castu.b	r8
80006468:	c2 30       	breq	800064ae <udi_cdc_multi_get_free_tx_buffer+0xca>
8000646a:	ef 38 ff ec 	ld.ub	r8,r7[-20]
			&& (!udi_cdc_tx_both_buf_to_send[port])) {
8000646e:	49 e9       	lddpc	r9,800064e4 <udi_cdc_multi_get_free_tx_buffer+0x100>
80006470:	f2 08 07 08 	ld.ub	r8,r9[r8]
80006474:	5c 58       	castu.b	r8
	flags = cpu_irq_save();
	buf_sel = udi_cdc_tx_buf_sel[port];
	buf_sel_nb = udi_cdc_tx_buf_nb[port][buf_sel];
	buf_nosel_nb = udi_cdc_tx_buf_nb[port][(buf_sel == 0)? 1 : 0];
	if (buf_sel_nb == UDI_CDC_TX_BUFFERS) {
		if ((!udi_cdc_tx_trans_ongoing[port])
80006476:	ec 18 00 01 	eorl	r8,0x1
8000647a:	5c 58       	castu.b	r8
8000647c:	c1 90       	breq	800064ae <udi_cdc_multi_get_free_tx_buffer+0xca>
			&& (!udi_cdc_tx_both_buf_to_send[port])) {
			/* One buffer is full, but the other buffer is not used.
			 * (not used = transfer on-going)
			 * then move to the other buffer to store data */
			udi_cdc_tx_both_buf_to_send[port] = true;
8000647e:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80006482:	49 9a       	lddpc	r10,800064e4 <udi_cdc_multi_get_free_tx_buffer+0x100>
80006484:	30 18       	mov	r8,1
80006486:	f4 09 0b 08 	st.b	r10[r9],r8
			udi_cdc_tx_buf_sel[port] = (buf_sel == 0)? 1 : 0;
8000648a:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000648e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006492:	30 08       	mov	r8,0
80006494:	f0 09 18 00 	cp.b	r9,r8
80006498:	5f 08       	sreq	r8
8000649a:	49 09       	lddpc	r9,800064d8 <udi_cdc_multi_get_free_tx_buffer+0xf4>
8000649c:	f2 0a 0b 08 	st.b	r9[r10],r8
			buf_sel_nb = 0;
800064a0:	30 08       	mov	r8,0
800064a2:	ef 48 ff f4 	st.w	r7[-12],r8
			buf_nosel_nb = UDI_CDC_TX_BUFFERS;
800064a6:	e0 68 01 40 	mov	r8,320
800064aa:	ef 48 ff f8 	st.w	r7[-8],r8
		}
	}
	cpu_irq_restore(flags);
800064ae:	ee fc ff f0 	ld.w	r12,r7[-16]
800064b2:	f0 1f 00 0e 	mcall	800064e8 <udi_cdc_multi_get_free_tx_buffer+0x104>

	return (UDI_CDC_TX_BUFFERS - buf_sel_nb) + (UDI_CDC_TX_BUFFERS - buf_nosel_nb);
800064b6:	ee f8 ff f4 	ld.w	r8,r7[-12]
800064ba:	f0 09 11 00 	rsub	r9,r8,0
800064be:	ee f8 ff f8 	ld.w	r8,r7[-8]
800064c2:	f2 08 01 08 	sub	r8,r9,r8
800064c6:	f0 c8 fd 80 	sub	r8,r8,-640
}
800064ca:	10 9c       	mov	r12,r8
800064cc:	2f bd       	sub	sp,-20
800064ce:	e3 cd 80 80 	ldm	sp++,r7,pc
800064d2:	00 00       	add	r0,r0
800064d4:	80 00       	ld.sh	r0,r0[0x0]
800064d6:	54 c0       	stdsp	sp[0x130],r0
800064d8:	00 00       	add	r0,r0
800064da:	07 10       	ld.sh	r0,r3++
800064dc:	00 00       	add	r0,r0
800064de:	07 0c       	ld.w	r12,r3++
800064e0:	00 00       	add	r0,r0
800064e2:	07 18       	ld.sh	r8,r3++
800064e4:	00 00       	add	r0,r0
800064e6:	07 1c       	ld.sh	r12,r3++
800064e8:	80 00       	ld.sh	r0,r0[0x0]
800064ea:	55 00       	stdsp	sp[0x140],r0

800064ec <udi_cdc_multi_is_tx_ready>:
{
	return udi_cdc_multi_get_free_tx_buffer(0);
}

bool udi_cdc_multi_is_tx_ready(uint8_t port)
{
800064ec:	eb cd 40 80 	pushm	r7,lr
800064f0:	1a 97       	mov	r7,sp
800064f2:	20 1d       	sub	sp,4
800064f4:	18 98       	mov	r8,r12
800064f6:	ef 68 ff fc 	st.b	r7[-4],r8
	return (udi_cdc_multi_get_free_tx_buffer(port) != 0);
800064fa:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800064fe:	10 9c       	mov	r12,r8
80006500:	f0 1f 00 05 	mcall	80006514 <udi_cdc_multi_is_tx_ready+0x28>
80006504:	18 98       	mov	r8,r12
80006506:	58 08       	cp.w	r8,0
80006508:	5f 18       	srne	r8
8000650a:	5c 58       	castu.b	r8
}
8000650c:	10 9c       	mov	r12,r8
8000650e:	2f fd       	sub	sp,-4
80006510:	e3 cd 80 80 	ldm	sp++,r7,pc
80006514:	80 00       	ld.sh	r0,r0[0x0]
80006516:	63 e4       	ld.w	r4,r1[0x78]

80006518 <udi_cdc_multi_putc>:
{
	return udi_cdc_multi_is_tx_ready(0);
}

int udi_cdc_multi_putc(uint8_t port, int value)
{
80006518:	eb cd 40 e8 	pushm	r3,r5-r7,lr
8000651c:	1a 97       	mov	r7,sp
8000651e:	20 4d       	sub	sp,16
80006520:	18 98       	mov	r8,r12
80006522:	ef 4b ff f0 	st.w	r7[-16],r11
80006526:	ef 68 ff f4 	st.b	r7[-12],r8
	irqflags_t flags;
	bool b_databit_9;
	uint8_t buf_sel;

#if UDI_CDC_PORT_NB == 1 // To optimize code
	port = 0;
8000652a:	30 08       	mov	r8,0
8000652c:	ef 68 ff f4 	st.b	r7[-12],r8
#endif

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);
80006530:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80006534:	4b ca       	lddpc	r10,80006624 <udi_cdc_multi_putc+0x10c>
80006536:	12 98       	mov	r8,r9
80006538:	a3 78       	lsl	r8,0x3
8000653a:	12 18       	sub	r8,r9
8000653c:	f4 08 00 08 	add	r8,r10,r8
80006540:	2f a8       	sub	r8,-6
80006542:	11 89       	ld.ub	r9,r8[0x0]
80006544:	30 98       	mov	r8,9
80006546:	f0 09 18 00 	cp.b	r9,r8
8000654a:	5f 08       	sreq	r8
8000654c:	ef 68 ff fe 	st.b	r7[-2],r8
80006550:	c0 28       	rjmp	80006554 <udi_cdc_multi_putc+0x3c>
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
		if (!udi_cdc_data_running) {
			return false;
		}
		goto udi_cdc_putc_process_one_byte;
80006552:	d7 03       	nop

	b_databit_9 = (9 == udi_cdc_line_coding[port].bDataBits);

udi_cdc_putc_process_one_byte:
	// Check available space
	if (!udi_cdc_multi_is_tx_ready(port)) {
80006554:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006558:	10 9c       	mov	r12,r8
8000655a:	f0 1f 00 34 	mcall	80006628 <udi_cdc_multi_putc+0x110>
8000655e:	18 98       	mov	r8,r12
80006560:	ec 18 00 01 	eorl	r8,0x1
80006564:	5c 58       	castu.b	r8
80006566:	c0 a0       	breq	8000657a <udi_cdc_multi_putc+0x62>
		if (!udi_cdc_data_running) {
80006568:	4b 18       	lddpc	r8,8000662c <udi_cdc_multi_putc+0x114>
8000656a:	11 88       	ld.ub	r8,r8[0x0]
8000656c:	5c 58       	castu.b	r8
8000656e:	ec 18 00 01 	eorl	r8,0x1
80006572:	5c 58       	castu.b	r8
80006574:	ce f0       	breq	80006552 <udi_cdc_multi_putc+0x3a>
			return false;
80006576:	30 08       	mov	r8,0
80006578:	c5 18       	rjmp	8000661a <udi_cdc_multi_putc+0x102>
		}
		goto udi_cdc_putc_process_one_byte;
	}

	// Write value
	flags = cpu_irq_save();
8000657a:	f0 1f 00 2e 	mcall	80006630 <udi_cdc_multi_putc+0x118>
8000657e:	18 98       	mov	r8,r12
80006580:	ef 48 ff f8 	st.w	r7[-8],r8
	buf_sel = udi_cdc_tx_buf_sel[port];
80006584:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006588:	4a b9       	lddpc	r9,80006634 <udi_cdc_multi_putc+0x11c>
8000658a:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000658e:	ef 68 ff ff 	st.b	r7[-1],r8
	udi_cdc_tx_buf[port][buf_sel][udi_cdc_tx_buf_nb[port][buf_sel]++] = value;
80006592:	ef 3e ff f4 	ld.ub	lr,r7[-12]
80006596:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000659a:	ef 3c ff f4 	ld.ub	r12,r7[-12]
8000659e:	ef 3b ff ff 	ld.ub	r11,r7[-1]
800065a2:	4a 69       	lddpc	r9,80006638 <udi_cdc_multi_putc+0x120>
800065a4:	f8 0a 15 01 	lsl	r10,r12,0x1
800065a8:	16 0a       	add	r10,r11
800065aa:	f2 0a 04 1a 	ld.sh	r10,r9[r10<<0x1]
800065ae:	eb da c0 10 	bfextu	r5,r10,0x0,0x10
800065b2:	ee f9 ff f0 	ld.w	r9,r7[-16]
800065b6:	ed d9 c0 08 	bfextu	r6,r9,0x0,0x8
800065ba:	4a 13       	lddpc	r3,8000663c <udi_cdc_multi_putc+0x124>
800065bc:	10 99       	mov	r9,r8
800065be:	a3 69       	lsl	r9,0x2
800065c0:	10 09       	add	r9,r8
800065c2:	f2 08 15 06 	lsl	r8,r9,0x6
800065c6:	10 99       	mov	r9,r8
800065c8:	1c 98       	mov	r8,lr
800065ca:	a3 68       	lsl	r8,0x2
800065cc:	1c 08       	add	r8,lr
800065ce:	a7 78       	lsl	r8,0x7
800065d0:	f2 08 00 08 	add	r8,r9,r8
800065d4:	e6 08 00 08 	add	r8,r3,r8
800065d8:	f0 05 00 09 	add	r9,r8,r5
800065dc:	0c 98       	mov	r8,r6
800065de:	b2 88       	st.b	r9[0x0],r8
800065e0:	f4 c8 ff ff 	sub	r8,r10,-1
800065e4:	5c 88       	casts.h	r8
800065e6:	49 59       	lddpc	r9,80006638 <udi_cdc_multi_putc+0x120>
800065e8:	f8 0a 15 01 	lsl	r10,r12,0x1
800065ec:	16 0a       	add	r10,r11
800065ee:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
	cpu_irq_restore(flags);
800065f2:	ee fc ff f8 	ld.w	r12,r7[-8]
800065f6:	f0 1f 00 13 	mcall	80006640 <udi_cdc_multi_putc+0x128>

	if (b_databit_9) {
800065fa:	ef 39 ff fe 	ld.ub	r9,r7[-2]
800065fe:	30 08       	mov	r8,0
80006600:	f0 09 18 00 	cp.b	r9,r8
80006604:	c0 a0       	breq	80006618 <udi_cdc_multi_putc+0x100>
		// Send MSB
		b_databit_9 = false;
80006606:	30 08       	mov	r8,0
80006608:	ef 68 ff fe 	st.b	r7[-2],r8
		value = value >> 8;
8000660c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80006610:	a9 48       	asr	r8,0x8
80006612:	ef 48 ff f0 	st.w	r7[-16],r8
		goto udi_cdc_putc_process_one_byte;
80006616:	c9 fb       	rjmp	80006554 <udi_cdc_multi_putc+0x3c>
	}
	return true;
80006618:	30 18       	mov	r8,1
}
8000661a:	10 9c       	mov	r12,r8
8000661c:	2f cd       	sub	sp,-16
8000661e:	e3 cd 80 e8 	ldm	sp++,r3,r5-r7,pc
80006622:	00 00       	add	r0,r0
80006624:	00 00       	add	r0,r0
80006626:	01 da       	ld.ub	r10,r0[0x5]
80006628:	80 00       	ld.sh	r0,r0[0x0]
8000662a:	64 ec       	ld.w	r12,r2[0x38]
8000662c:	00 00       	add	r0,r0
8000662e:	01 fa       	ld.ub	r10,r0[0x7]
80006630:	80 00       	ld.sh	r0,r0[0x0]
80006632:	54 c0       	stdsp	sp[0x130],r0
80006634:	00 00       	add	r0,r0
80006636:	07 10       	ld.sh	r0,r3++
80006638:	00 00       	add	r0,r0
8000663a:	07 0c       	ld.w	r12,r3++
8000663c:	00 00       	add	r0,r0
8000663e:	04 8c       	andn	r12,r2
80006640:	80 00       	ld.sh	r0,r0[0x0]
80006642:	55 00       	stdsp	sp[0x140],r0

80006644 <udi_cdc_putc>:

int udi_cdc_putc(int value)
{
80006644:	eb cd 40 80 	pushm	r7,lr
80006648:	1a 97       	mov	r7,sp
8000664a:	20 1d       	sub	sp,4
8000664c:	ef 4c ff fc 	st.w	r7[-4],r12
	return udi_cdc_multi_putc(0, value);
80006650:	ee fb ff fc 	ld.w	r11,r7[-4]
80006654:	30 0c       	mov	r12,0
80006656:	f0 1f 00 04 	mcall	80006664 <udi_cdc_putc+0x20>
8000665a:	18 98       	mov	r8,r12
}
8000665c:	10 9c       	mov	r12,r8
8000665e:	2f fd       	sub	sp,-4
80006660:	e3 cd 80 80 	ldm	sp++,r7,pc
80006664:	80 00       	ld.sh	r0,r0[0x0]
80006666:	65 18       	ld.w	r8,r2[0x44]
80006668:	54 41       	stdsp	sp[0x110],r1
8000666a:	4a 33       	lddpc	r3,800066f4 <udc_next_desc_in_iface+0x34>
8000666c:	38 35       	mov	r5,-125
8000666e:	30 5f       	mov	pc,5
80006670:	30 78       	mov	r8,7
80006672:	30 30       	mov	r0,3
80006674:	00 00       	add	r0,r0
	...

80006678 <udc_get_string_serial_name>:
	}
#  define USB_DEVICE_SERIAL_NAME_SIZE \
	USB_DEVICE_GET_SERIAL_NAME_LENGTH
#elif defined USB_DEVICE_SERIAL_NAME
	static const uint8_t *udc_get_string_serial_name(void)
	{
80006678:	eb cd 40 80 	pushm	r7,lr
8000667c:	1a 97       	mov	r7,sp
		return (const uint8_t *)USB_DEVICE_SERIAL_NAME;
8000667e:	48 38       	lddpc	r8,80006688 <udc_get_string_serial_name+0x10>
	}
80006680:	10 9c       	mov	r12,r8
80006682:	e3 cd 80 80 	ldm	sp++,r7,pc
80006686:	00 00       	add	r0,r0
80006688:	80 00       	ld.sh	r0,r0[0x0]
8000668a:	66 68       	ld.w	r8,r3[0x18]

8000668c <udc_get_eof_conf>:
 * \brief Returns a value to check the end of USB Configuration descriptor
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
8000668c:	eb cd 40 80 	pushm	r7,lr
80006690:	1a 97       	mov	r7,sp
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
			udc_ptr_conf->desc +
80006692:	48 b8       	lddpc	r8,800066bc <udc_get_eof_conf+0x30>
80006694:	70 08       	ld.w	r8,r8[0x0]
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
80006696:	70 09       	ld.w	r9,r8[0x0]
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
80006698:	48 98       	lddpc	r8,800066bc <udc_get_eof_conf+0x30>
8000669a:	70 08       	ld.w	r8,r8[0x0]
8000669c:	70 08       	ld.w	r8,r8[0x0]
8000669e:	11 aa       	ld.ub	r10,r8[0x2]
800066a0:	a9 6a       	lsl	r10,0x8
800066a2:	11 b8       	ld.ub	r8,r8[0x3]
800066a4:	14 48       	or	r8,r10
800066a6:	5c 88       	casts.h	r8
800066a8:	5c 88       	casts.h	r8
800066aa:	5c c8       	swap.bh	r8
800066ac:	5c 88       	casts.h	r8
 *
 * \return address after the last byte of USB Configuration descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_get_eof_conf(void)
{
	return (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *)
800066ae:	5c 78       	castu.h	r8
800066b0:	f2 08 00 08 	add	r8,r9,r8
			udc_ptr_conf->desc +
			le16_to_cpu(udc_ptr_conf->desc->wTotalLength));
}
800066b4:	10 9c       	mov	r12,r8
800066b6:	e3 cd 80 80 	ldm	sp++,r7,pc
800066ba:	00 00       	add	r0,r0
800066bc:	00 00       	add	r0,r0
800066be:	07 28       	ld.uh	r8,r3++

800066c0 <udc_next_desc_in_iface>:
 * \return address of specific descriptor found
 * \return NULL if it is the end of global interface descriptor
 */
static usb_conf_desc_t UDC_DESC_STORAGE *udc_next_desc_in_iface(usb_conf_desc_t
		UDC_DESC_STORAGE * desc, uint8_t desc_id)
{
800066c0:	eb cd 40 80 	pushm	r7,lr
800066c4:	1a 97       	mov	r7,sp
800066c6:	20 3d       	sub	sp,12
800066c8:	ef 4c ff f8 	st.w	r7[-8],r12
800066cc:	16 98       	mov	r8,r11
800066ce:	ef 68 ff f4 	st.b	r7[-12],r8
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_eof_desc;

	ptr_eof_desc = udc_get_eof_conf();
800066d2:	f0 1f 00 1d 	mcall	80006744 <udc_next_desc_in_iface+0x84>
800066d6:	18 98       	mov	r8,r12
800066d8:	ef 48 ff fc 	st.w	r7[-4],r8
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
800066dc:	ee f8 ff f8 	ld.w	r8,r7[-8]
800066e0:	11 88       	ld.ub	r8,r8[0x0]
800066e2:	ee f9 ff f8 	ld.w	r9,r7[-8]
800066e6:	f2 08 00 08 	add	r8,r9,r8
800066ea:	ef 48 ff f8 	st.w	r7[-8],r8
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
800066ee:	c1 c8       	rjmp	80006726 <udc_next_desc_in_iface+0x66>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
800066f0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800066f4:	11 99       	ld.ub	r9,r8[0x1]
800066f6:	30 48       	mov	r8,4
800066f8:	f0 09 18 00 	cp.b	r9,r8
800066fc:	c1 d0       	breq	80006736 <udc_next_desc_in_iface+0x76>
			break; // End of global interface descriptor
		}
		if (desc_id == desc->bDescriptorType) {
800066fe:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006702:	11 98       	ld.ub	r8,r8[0x1]
80006704:	ef 39 ff f4 	ld.ub	r9,r7[-12]
80006708:	f0 09 18 00 	cp.b	r9,r8
8000670c:	c0 41       	brne	80006714 <udc_next_desc_in_iface+0x54>
			return desc; // Specific descriptor found
8000670e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006712:	c1 48       	rjmp	8000673a <udc_next_desc_in_iface+0x7a>
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
80006714:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006718:	11 88       	ld.ub	r8,r8[0x0]
8000671a:	ee f9 ff f8 	ld.w	r9,r7[-8]
8000671e:	f2 08 00 08 	add	r8,r9,r8
80006722:	ef 48 ff f8 	st.w	r7[-8],r8
	ptr_eof_desc = udc_get_eof_conf();
	// Go to next descriptor
	desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
			desc->bLength);
	// Check the end of configuration descriptor
	while (ptr_eof_desc > desc) {
80006726:	ee f9 ff fc 	ld.w	r9,r7[-4]
8000672a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000672e:	10 39       	cp.w	r9,r8
80006730:	fe 9b ff e0 	brhi	800066f0 <udc_next_desc_in_iface+0x30>
80006734:	c0 28       	rjmp	80006738 <udc_next_desc_in_iface+0x78>
		// If new interface descriptor is found,
		// then it is the end of the current global interface descriptor
		if (USB_DT_INTERFACE == desc->bDescriptorType) {
			break; // End of global interface descriptor
80006736:	d7 03       	nop
		}
		// Go to next descriptor
		desc = (UDC_DESC_STORAGE usb_conf_desc_t *) ((uint8_t *) desc +
				desc->bLength);
	}
	return NULL; // No specific descriptor found
80006738:	30 08       	mov	r8,0
}
8000673a:	10 9c       	mov	r12,r8
8000673c:	2f dd       	sub	sp,-12
8000673e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006742:	00 00       	add	r0,r0
80006744:	80 00       	ld.sh	r0,r0[0x0]
80006746:	66 8c       	ld.w	r12,r3[0x20]

80006748 <udc_update_iface_desc>:
 * \param setting_num   Setting number of interface to find
 *
 * \return 1 if found or 0 if not found
 */
static bool udc_update_iface_desc(uint8_t iface_num, uint8_t setting_num)
{
80006748:	eb cd 40 80 	pushm	r7,lr
8000674c:	1a 97       	mov	r7,sp
8000674e:	20 3d       	sub	sp,12
80006750:	18 99       	mov	r9,r12
80006752:	16 98       	mov	r8,r11
80006754:	ef 69 ff f8 	st.b	r7[-8],r9
80006758:	ef 68 ff f4 	st.b	r7[-12],r8
	usb_conf_desc_t UDC_DESC_STORAGE *ptr_end_desc;

	if (0 == udc_num_configuration) {
8000675c:	4a 58       	lddpc	r8,800067f0 <udc_update_iface_desc+0xa8>
8000675e:	11 88       	ld.ub	r8,r8[0x0]
80006760:	58 08       	cp.w	r8,0
80006762:	c0 31       	brne	80006768 <udc_update_iface_desc+0x20>
		return false;
80006764:	30 08       	mov	r8,0
80006766:	c4 18       	rjmp	800067e8 <udc_update_iface_desc+0xa0>
	}

	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
80006768:	4a 38       	lddpc	r8,800067f4 <udc_update_iface_desc+0xac>
8000676a:	70 08       	ld.w	r8,r8[0x0]
8000676c:	70 08       	ld.w	r8,r8[0x0]
8000676e:	11 c8       	ld.ub	r8,r8[0x4]
80006770:	ef 39 ff f8 	ld.ub	r9,r7[-8]
80006774:	f0 09 18 00 	cp.b	r9,r8
80006778:	c0 33       	brcs	8000677e <udc_update_iface_desc+0x36>
		return false;
8000677a:	30 08       	mov	r8,0
8000677c:	c3 68       	rjmp	800067e8 <udc_update_iface_desc+0xa0>
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;
8000677e:	49 e8       	lddpc	r8,800067f4 <udc_update_iface_desc+0xac>
80006780:	70 08       	ld.w	r8,r8[0x0]
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
		return false;
	}

	// Start at the beginning of configuration descriptor
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
80006782:	70 08       	ld.w	r8,r8[0x0]
80006784:	10 99       	mov	r9,r8
80006786:	49 d8       	lddpc	r8,800067f8 <udc_update_iface_desc+0xb0>
80006788:	91 09       	st.w	r8[0x0],r9
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
8000678a:	f0 1f 00 1d 	mcall	800067fc <udc_update_iface_desc+0xb4>
8000678e:	18 98       	mov	r8,r12
80006790:	ef 48 ff fc 	st.w	r7[-4],r8
	while (ptr_end_desc >
80006794:	c2 28       	rjmp	800067d8 <udc_update_iface_desc+0x90>
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
80006796:	49 98       	lddpc	r8,800067f8 <udc_update_iface_desc+0xb0>
80006798:	70 08       	ld.w	r8,r8[0x0]
8000679a:	11 99       	ld.ub	r9,r8[0x1]
8000679c:	30 48       	mov	r8,4
8000679e:	f0 09 18 00 	cp.b	r9,r8
800067a2:	c1 31       	brne	800067c8 <udc_update_iface_desc+0x80>
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
800067a4:	49 58       	lddpc	r8,800067f8 <udc_update_iface_desc+0xb0>
800067a6:	70 08       	ld.w	r8,r8[0x0]
800067a8:	11 a8       	ld.ub	r8,r8[0x2]
800067aa:	ef 39 ff f8 	ld.ub	r9,r7[-8]
800067ae:	f0 09 18 00 	cp.b	r9,r8
800067b2:	c0 b1       	brne	800067c8 <udc_update_iface_desc+0x80>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
800067b4:	49 18       	lddpc	r8,800067f8 <udc_update_iface_desc+0xb0>
800067b6:	70 08       	ld.w	r8,r8[0x0]
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
					(setting_num ==
800067b8:	11 b8       	ld.ub	r8,r8[0x3]
	while (ptr_end_desc >
			(UDC_DESC_STORAGE usb_conf_desc_t *) udc_ptr_iface) {
		if (USB_DT_INTERFACE == udc_ptr_iface->bDescriptorType) {
			// A interface descriptor is found
			// Check interface and alternate setting number
			if ((iface_num == udc_ptr_iface->bInterfaceNumber) &&
800067ba:	ef 39 ff f4 	ld.ub	r9,r7[-12]
800067be:	f0 09 18 00 	cp.b	r9,r8
800067c2:	c0 31       	brne	800067c8 <udc_update_iface_desc+0x80>
					(setting_num ==
					udc_ptr_iface->bAlternateSetting)) {
				return true; // Interface found
800067c4:	30 18       	mov	r8,1
800067c6:	c1 18       	rjmp	800067e8 <udc_update_iface_desc+0xa0>
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
800067c8:	48 c8       	lddpc	r8,800067f8 <udc_update_iface_desc+0xb0>
800067ca:	70 09       	ld.w	r9,r8[0x0]
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
800067cc:	48 b8       	lddpc	r8,800067f8 <udc_update_iface_desc+0xb0>
800067ce:	70 08       	ld.w	r8,r8[0x0]
					udc_ptr_iface->bAlternateSetting)) {
				return true; // Interface found
			}
		}
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
800067d0:	11 88       	ld.ub	r8,r8[0x0]
800067d2:	10 09       	add	r9,r8
800067d4:	48 98       	lddpc	r8,800067f8 <udc_update_iface_desc+0xb0>
800067d6:	91 09       	st.w	r8[0x0],r9
	udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *)
			udc_ptr_conf->desc;

	// Check the end of configuration descriptor
	ptr_end_desc = udc_get_eof_conf();
	while (ptr_end_desc >
800067d8:	48 88       	lddpc	r8,800067f8 <udc_update_iface_desc+0xb0>
800067da:	70 08       	ld.w	r8,r8[0x0]
800067dc:	ee f9 ff fc 	ld.w	r9,r7[-4]
800067e0:	10 39       	cp.w	r9,r8
800067e2:	fe 9b ff da 	brhi	80006796 <udc_update_iface_desc+0x4e>
		// Go to next descriptor
		udc_ptr_iface = (UDC_DESC_STORAGE usb_iface_desc_t *) (
				(uint8_t *) udc_ptr_iface +
				udc_ptr_iface->bLength);
	}
	return false; // Interface not found
800067e6:	30 08       	mov	r8,0
}
800067e8:	10 9c       	mov	r12,r8
800067ea:	2f dd       	sub	sp,-12
800067ec:	e3 cd 80 80 	ldm	sp++,r7,pc
800067f0:	00 00       	add	r0,r0
800067f2:	07 26       	ld.uh	r6,r3++
800067f4:	00 00       	add	r0,r0
800067f6:	07 28       	ld.uh	r8,r3++
800067f8:	00 00       	add	r0,r0
800067fa:	07 2c       	ld.uh	r12,r3++
800067fc:	80 00       	ld.sh	r0,r0[0x0]
800067fe:	66 8c       	ld.w	r12,r3[0x20]

80006800 <udc_iface_disable>:
 * \param iface_num     Interface number to disable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_disable(uint8_t iface_num)
{
80006800:	eb cd 40 80 	pushm	r7,lr
80006804:	1a 97       	mov	r7,sp
80006806:	20 3d       	sub	sp,12
80006808:	18 98       	mov	r8,r12
8000680a:	ef 68 ff f4 	st.b	r7[-12],r8
	udi_api_t UDC_DESC_STORAGE *udi_api;

	// Select first alternate setting of the interface
	// to update udc_ptr_iface before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
8000680e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006812:	30 0b       	mov	r11,0
80006814:	10 9c       	mov	r12,r8
80006816:	f0 1f 00 25 	mcall	800068a8 <udc_iface_disable+0xa8>
8000681a:	18 98       	mov	r8,r12
8000681c:	ec 18 00 01 	eorl	r8,0x1
80006820:	5c 58       	castu.b	r8
80006822:	c0 30       	breq	80006828 <udc_iface_disable+0x28>
		return false;
80006824:	30 08       	mov	r8,0
80006826:	c3 d8       	rjmp	800068a0 <udc_iface_disable+0xa0>
	}

	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80006828:	4a 18       	lddpc	r8,800068ac <udc_iface_disable+0xac>
8000682a:	70 08       	ld.w	r8,r8[0x0]
8000682c:	70 19       	ld.w	r9,r8[0x4]
8000682e:	ef 38 ff f4 	ld.ub	r8,r7[-12]
80006832:	a3 68       	lsl	r8,0x2
80006834:	f2 08 00 08 	add	r8,r9,r8
80006838:	70 08       	ld.w	r8,r8[0x0]
8000683a:	ef 48 ff f8 	st.w	r7[-8],r8

#if (0!=USB_DEVICE_MAX_EP)
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
8000683e:	ee f8 ff f8 	ld.w	r8,r7[-8]
80006842:	70 38       	ld.w	r8,r8[0xc]
80006844:	5d 18       	icall	r8
80006846:	18 98       	mov	r8,r12
80006848:	10 99       	mov	r9,r8
8000684a:	ef 38 ff f4 	ld.ub	r8,r7[-12]
8000684e:	12 9b       	mov	r11,r9
80006850:	10 9c       	mov	r12,r8
80006852:	f0 1f 00 16 	mcall	800068a8 <udc_iface_disable+0xa8>
80006856:	18 98       	mov	r8,r12
80006858:	ec 18 00 01 	eorl	r8,0x1
8000685c:	5c 58       	castu.b	r8
8000685e:	c0 30       	breq	80006864 <udc_iface_disable+0x64>
		return false;
80006860:	30 08       	mov	r8,0
80006862:	c1 f8       	rjmp	800068a0 <udc_iface_disable+0xa0>
	}

	// Start at the beginning of interface descriptor
	{
		usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
80006864:	49 38       	lddpc	r8,800068b0 <udc_iface_disable+0xb0>
80006866:	70 08       	ld.w	r8,r8[0x0]
80006868:	ef 48 ff fc 	st.w	r7[-4],r8
		while (1) {
			// Search Endpoint descriptor included in global interface descriptor
			ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
8000686c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006870:	30 5b       	mov	r11,5
80006872:	10 9c       	mov	r12,r8
80006874:	f0 1f 00 10 	mcall	800068b4 <udc_iface_disable+0xb4>
80006878:	18 98       	mov	r8,r12
8000687a:	ef 48 ff fc 	st.w	r7[-4],r8
					udc_next_desc_in_iface((UDC_DESC_STORAGE
					usb_conf_desc_t *)
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
8000687e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006882:	58 08       	cp.w	r8,0
80006884:	c0 71       	brne	80006892 <udc_iface_disable+0x92>
		}
	}
#endif

	// Disable interface
	udi_api->disable();
80006886:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000688a:	70 18       	ld.w	r8,r8[0x4]
8000688c:	5d 18       	icall	r8
	return true;
8000688e:	30 18       	mov	r8,1
80006890:	c0 88       	rjmp	800068a0 <udc_iface_disable+0xa0>
					ep_desc, USB_DT_ENDPOINT);
			if (NULL == ep_desc) {
				break;
			}
			// Free the endpoint used by the interface
			udd_ep_free(ep_desc->bEndpointAddress);
80006892:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006896:	11 a8       	ld.ub	r8,r8[0x2]
80006898:	10 9c       	mov	r12,r8
8000689a:	f0 1f 00 08 	mcall	800068b8 <udc_iface_disable+0xb8>
		}
8000689e:	ce 7b       	rjmp	8000686c <udc_iface_disable+0x6c>
#endif

	// Disable interface
	udi_api->disable();
	return true;
}
800068a0:	10 9c       	mov	r12,r8
800068a2:	2f dd       	sub	sp,-12
800068a4:	e3 cd 80 80 	ldm	sp++,r7,pc
800068a8:	80 00       	ld.sh	r0,r0[0x0]
800068aa:	67 48       	ld.w	r8,r3[0x50]
800068ac:	00 00       	add	r0,r0
800068ae:	07 28       	ld.uh	r8,r3++
800068b0:	00 00       	add	r0,r0
800068b2:	07 2c       	ld.uh	r12,r3++
800068b4:	80 00       	ld.sh	r0,r0[0x0]
800068b6:	66 c0       	ld.w	r0,r3[0x30]
800068b8:	80 00       	ld.sh	r0,r0[0x0]
800068ba:	39 5c       	mov	r12,-107

800068bc <udc_iface_enable>:
 * \param setting_num   Setting number to enable
 *
 * \return 1 if it is done or 0 if interface is not found
 */
static bool udc_iface_enable(uint8_t iface_num, uint8_t setting_num)
{
800068bc:	eb cd 40 80 	pushm	r7,lr
800068c0:	1a 97       	mov	r7,sp
800068c2:	20 3d       	sub	sp,12
800068c4:	18 99       	mov	r9,r12
800068c6:	16 98       	mov	r8,r11
800068c8:	ef 69 ff f8 	st.b	r7[-8],r9
800068cc:	ef 68 ff f4 	st.b	r7[-12],r8
	// Select the interface descriptor
	if (!udc_update_iface_desc(iface_num, setting_num)) {
800068d0:	ef 39 ff f4 	ld.ub	r9,r7[-12]
800068d4:	ef 38 ff f8 	ld.ub	r8,r7[-8]
800068d8:	12 9b       	mov	r11,r9
800068da:	10 9c       	mov	r12,r8
800068dc:	f0 1f 00 25 	mcall	80006970 <udc_iface_enable+0xb4>
800068e0:	18 98       	mov	r8,r12
800068e2:	ec 18 00 01 	eorl	r8,0x1
800068e6:	5c 58       	castu.b	r8
800068e8:	c0 30       	breq	800068ee <udc_iface_enable+0x32>
		return false;
800068ea:	30 08       	mov	r8,0
800068ec:	c3 e8       	rjmp	80006968 <udc_iface_enable+0xac>

#if (0!=USB_DEVICE_MAX_EP)
	usb_ep_desc_t UDC_DESC_STORAGE *ep_desc;

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
800068ee:	4a 28       	lddpc	r8,80006974 <udc_iface_enable+0xb8>
800068f0:	70 08       	ld.w	r8,r8[0x0]
800068f2:	ef 48 ff fc 	st.w	r7[-4],r8
800068f6:	c0 28       	rjmp	800068fa <udc_iface_enable+0x3e>
				ep_desc->bmAttributes,
				le16_to_cpu
				(ep_desc->wMaxPacketSize))) {
			return false;
		}
	}
800068f8:	d7 03       	nop

	// Start at the beginning of the global interface descriptor
	ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *) udc_ptr_iface;
	while (1) {
		// Search Endpoint descriptor included in the global interface descriptor
		ep_desc = (UDC_DESC_STORAGE usb_ep_desc_t *)
800068fa:	ee f8 ff fc 	ld.w	r8,r7[-4]
800068fe:	30 5b       	mov	r11,5
80006900:	10 9c       	mov	r12,r8
80006902:	f0 1f 00 1e 	mcall	80006978 <udc_iface_enable+0xbc>
80006906:	18 98       	mov	r8,r12
80006908:	ef 48 ff fc 	st.w	r7[-4],r8
				udc_next_desc_in_iface((UDC_DESC_STORAGE
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
8000690c:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006910:	58 08       	cp.w	r8,0
80006912:	c0 e1       	brne	8000692e <udc_iface_enable+0x72>
			return false;
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
80006914:	49 a8       	lddpc	r8,8000697c <udc_iface_enable+0xc0>
80006916:	70 08       	ld.w	r8,r8[0x0]
80006918:	70 19       	ld.w	r9,r8[0x4]
8000691a:	ef 38 ff f8 	ld.ub	r8,r7[-8]
8000691e:	a3 68       	lsl	r8,0x2
80006920:	f2 08 00 08 	add	r8,r9,r8
80006924:	70 08       	ld.w	r8,r8[0x0]
80006926:	70 08       	ld.w	r8,r8[0x0]
80006928:	5d 18       	icall	r8
8000692a:	18 98       	mov	r8,r12
8000692c:	c1 e8       	rjmp	80006968 <udc_iface_enable+0xac>
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
				ep_desc->bmAttributes,
				le16_to_cpu
8000692e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006932:	11 c9       	ld.ub	r9,r8[0x4]
80006934:	a9 69       	lsl	r9,0x8
80006936:	11 d8       	ld.ub	r8,r8[0x5]
80006938:	12 48       	or	r8,r9
8000693a:	5c 88       	casts.h	r8
8000693c:	5c 88       	casts.h	r8
8000693e:	5c c8       	swap.bh	r8
80006940:	5c 88       	casts.h	r8
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
80006942:	f5 d8 c0 10 	bfextu	r10,r8,0x0,0x10
				ep_desc->bmAttributes,
80006946:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000694a:	11 b8       	ld.ub	r8,r8[0x3]
						usb_conf_desc_t *) ep_desc,
				USB_DT_ENDPOINT);
		if (NULL == ep_desc)
			break;
		// Alloc the endpoint used by the interface
		if (!udd_ep_alloc(ep_desc->bEndpointAddress,
8000694c:	10 99       	mov	r9,r8
8000694e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006952:	11 a8       	ld.ub	r8,r8[0x2]
80006954:	12 9b       	mov	r11,r9
80006956:	10 9c       	mov	r12,r8
80006958:	f0 1f 00 0a 	mcall	80006980 <udc_iface_enable+0xc4>
8000695c:	18 98       	mov	r8,r12
8000695e:	ec 18 00 01 	eorl	r8,0x1
80006962:	5c 58       	castu.b	r8
80006964:	cc a0       	breq	800068f8 <udc_iface_enable+0x3c>
				ep_desc->bmAttributes,
				le16_to_cpu
				(ep_desc->wMaxPacketSize))) {
			return false;
80006966:	30 08       	mov	r8,0
		}
	}
#endif
	// Enable the interface
	return udc_ptr_conf->udi_apis[iface_num]->enable();
}
80006968:	10 9c       	mov	r12,r8
8000696a:	2f dd       	sub	sp,-12
8000696c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006970:	80 00       	ld.sh	r0,r0[0x0]
80006972:	67 48       	ld.w	r8,r3[0x50]
80006974:	00 00       	add	r0,r0
80006976:	07 2c       	ld.uh	r12,r3++
80006978:	80 00       	ld.sh	r0,r0[0x0]
8000697a:	66 c0       	ld.w	r0,r3[0x30]
8000697c:	00 00       	add	r0,r0
8000697e:	07 28       	ld.uh	r8,r3++
80006980:	80 00       	ld.sh	r0,r0[0x0]
80006982:	36 0c       	mov	r12,96

80006984 <udc_start>:

/*! \brief Start the USB Device stack
 */
void udc_start(void)
{
80006984:	eb cd 40 80 	pushm	r7,lr
80006988:	1a 97       	mov	r7,sp
	udd_enable();
8000698a:	f0 1f 00 03 	mcall	80006994 <udc_start+0x10>
}
8000698e:	e3 cd 80 80 	ldm	sp++,r7,pc
80006992:	00 00       	add	r0,r0
80006994:	80 00       	ld.sh	r0,r0[0x0]
80006996:	33 28       	mov	r8,50

80006998 <udc_reset>:
/**
 * \brief Reset the current configuration of the USB device,
 * This routines can be called by UDD when a RESET on the USB line occurs.
 */
void udc_reset(void)
{
80006998:	eb cd 40 80 	pushm	r7,lr
8000699c:	1a 97       	mov	r7,sp
8000699e:	20 1d       	sub	sp,4
	uint8_t iface_num;

	if (udc_num_configuration) {
800069a0:	49 28       	lddpc	r8,800069e8 <udc_reset+0x50>
800069a2:	11 88       	ld.ub	r8,r8[0x0]
800069a4:	58 08       	cp.w	r8,0
800069a6:	c1 80       	breq	800069d6 <udc_reset+0x3e>
		for (iface_num = 0;
800069a8:	30 08       	mov	r8,0
800069aa:	ef 68 ff ff 	st.b	r7[-1],r8
800069ae:	c0 b8       	rjmp	800069c4 <udc_reset+0x2c>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
800069b0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800069b4:	10 9c       	mov	r12,r8
800069b6:	f0 1f 00 0e 	mcall	800069ec <udc_reset+0x54>
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
800069ba:	ef 38 ff ff 	ld.ub	r8,r7[-1]
800069be:	2f f8       	sub	r8,-1
800069c0:	ef 68 ff ff 	st.b	r7[-1],r8
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
800069c4:	48 b8       	lddpc	r8,800069f0 <udc_reset+0x58>
800069c6:	70 08       	ld.w	r8,r8[0x0]
800069c8:	70 08       	ld.w	r8,r8[0x0]
800069ca:	11 c8       	ld.ub	r8,r8[0x4]
void udc_reset(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
800069cc:	ef 39 ff ff 	ld.ub	r9,r7[-1]
800069d0:	f0 09 18 00 	cp.b	r9,r8
800069d4:	ce e3       	brcs	800069b0 <udc_reset+0x18>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			udc_iface_disable(iface_num);
		}
	}
	udc_num_configuration = 0;
800069d6:	48 59       	lddpc	r9,800069e8 <udc_reset+0x50>
800069d8:	30 08       	mov	r8,0
800069da:	b2 88       	st.b	r9[0x0],r8
	if (CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP) & udc_device_status) {
		// Remote wakeup is enabled then disable it
		UDC_REMOTEWAKEUP_DISABLE();
	}
#endif
	udc_device_status =
800069dc:	48 69       	lddpc	r9,800069f4 <udc_reset+0x5c>
800069de:	30 08       	mov	r8,0
800069e0:	b2 08       	st.h	r9[0x0],r8
#if (USB_DEVICE_ATTR & USB_CONFIG_ATTR_SELF_POWERED)
			CPU_TO_LE16(USB_DEV_STATUS_SELF_POWERED);
#else
			CPU_TO_LE16(USB_DEV_STATUS_BUS_POWERED);
#endif
}
800069e2:	2f fd       	sub	sp,-4
800069e4:	e3 cd 80 80 	ldm	sp++,r7,pc
800069e8:	00 00       	add	r0,r0
800069ea:	07 26       	ld.uh	r6,r3++
800069ec:	80 00       	ld.sh	r0,r0[0x0]
800069ee:	68 00       	ld.w	r0,r4[0x0]
800069f0:	00 00       	add	r0,r0
800069f2:	07 28       	ld.uh	r8,r3++
800069f4:	00 00       	add	r0,r0
800069f6:	07 24       	ld.uh	r4,r3++

800069f8 <udc_sof_notify>:

void udc_sof_notify(void)
{
800069f8:	eb cd 40 80 	pushm	r7,lr
800069fc:	1a 97       	mov	r7,sp
800069fe:	20 1d       	sub	sp,4
	uint8_t iface_num;

	if (udc_num_configuration) {
80006a00:	49 88       	lddpc	r8,80006a60 <udc_sof_notify+0x68>
80006a02:	11 88       	ld.ub	r8,r8[0x0]
80006a04:	58 08       	cp.w	r8,0
80006a06:	c2 a0       	breq	80006a5a <udc_sof_notify+0x62>
		for (iface_num = 0;
80006a08:	30 08       	mov	r8,0
80006a0a:	ef 68 ff ff 	st.b	r7[-1],r8
80006a0e:	c1 d8       	rjmp	80006a48 <udc_sof_notify+0x50>
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
80006a10:	49 58       	lddpc	r8,80006a64 <udc_sof_notify+0x6c>
80006a12:	70 08       	ld.w	r8,r8[0x0]
80006a14:	70 19       	ld.w	r9,r8[0x4]
80006a16:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006a1a:	a3 68       	lsl	r8,0x2
80006a1c:	f2 08 00 08 	add	r8,r9,r8
80006a20:	70 08       	ld.w	r8,r8[0x0]
80006a22:	70 48       	ld.w	r8,r8[0x10]
80006a24:	58 08       	cp.w	r8,0
80006a26:	c0 c0       	breq	80006a3e <udc_sof_notify+0x46>
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
80006a28:	48 f8       	lddpc	r8,80006a64 <udc_sof_notify+0x6c>
80006a2a:	70 08       	ld.w	r8,r8[0x0]
80006a2c:	70 19       	ld.w	r9,r8[0x4]
80006a2e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006a32:	a3 68       	lsl	r8,0x2
80006a34:	f2 08 00 08 	add	r8,r9,r8
80006a38:	70 08       	ld.w	r8,r8[0x0]
80006a3a:	70 48       	ld.w	r8,r8[0x10]
80006a3c:	5d 18       	icall	r8
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
				iface_num++) {
80006a3e:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006a42:	2f f8       	sub	r8,-1
80006a44:	ef 68 ff ff 	st.b	r7[-1],r8
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
				iface_num < udc_ptr_conf->desc->bNumInterfaces;
80006a48:	48 78       	lddpc	r8,80006a64 <udc_sof_notify+0x6c>
80006a4a:	70 08       	ld.w	r8,r8[0x0]
80006a4c:	70 08       	ld.w	r8,r8[0x0]
80006a4e:	11 c8       	ld.ub	r8,r8[0x4]
void udc_sof_notify(void)
{
	uint8_t iface_num;

	if (udc_num_configuration) {
		for (iface_num = 0;
80006a50:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006a54:	f0 09 18 00 	cp.b	r9,r8
80006a58:	cd c3       	brcs	80006a10 <udc_sof_notify+0x18>
			if (udc_ptr_conf->udi_apis[iface_num]->sof_notify != NULL) {
				udc_ptr_conf->udi_apis[iface_num]->sof_notify();
			}
		}
	}
}
80006a5a:	2f fd       	sub	sp,-4
80006a5c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a60:	00 00       	add	r0,r0
80006a62:	07 26       	ld.uh	r6,r3++
80006a64:	00 00       	add	r0,r0
80006a66:	07 28       	ld.uh	r8,r3++

80006a68 <udc_req_std_dev_get_status>:
 * \brief Standard device request to get device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_status(void)
{
80006a68:	eb cd 40 80 	pushm	r7,lr
80006a6c:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength != sizeof(udc_device_status)) {
80006a6e:	48 98       	lddpc	r8,80006a90 <udc_req_std_dev_get_status+0x28>
80006a70:	90 39       	ld.sh	r9,r8[0x6]
80006a72:	30 28       	mov	r8,2
80006a74:	f0 09 19 00 	cp.h	r9,r8
80006a78:	c0 30       	breq	80006a7e <udc_req_std_dev_get_status+0x16>
		return false;
80006a7a:	30 08       	mov	r8,0
80006a7c:	c0 78       	rjmp	80006a8a <udc_req_std_dev_get_status+0x22>
	}

	udd_set_setup_payload( (uint8_t *) & udc_device_status,
80006a7e:	48 68       	lddpc	r8,80006a94 <udc_req_std_dev_get_status+0x2c>
80006a80:	30 2b       	mov	r11,2
80006a82:	10 9c       	mov	r12,r8
80006a84:	f0 1f 00 05 	mcall	80006a98 <udc_req_std_dev_get_status+0x30>
			sizeof(udc_device_status));
	return true;
80006a88:	30 18       	mov	r8,1
}
80006a8a:	10 9c       	mov	r12,r8
80006a8c:	e3 cd 80 80 	ldm	sp++,r7,pc
80006a90:	00 00       	add	r0,r0
80006a92:	46 48       	lddsp	r8,sp[0x190]
80006a94:	00 00       	add	r0,r0
80006a96:	07 24       	ld.uh	r4,r3++
80006a98:	80 00       	ld.sh	r0,r0[0x0]
80006a9a:	35 e0       	mov	r0,94

80006a9c <udc_req_std_ep_get_status>:
 * \brief Standard endpoint request to get endpoint status
 *
 * \return true if success
 */
static bool udc_req_std_ep_get_status(void)
{
80006a9c:	eb cd 40 80 	pushm	r7,lr
80006aa0:	1a 97       	mov	r7,sp
	static le16_t udc_ep_status;

	if (udd_g_ctrlreq.req.wLength != sizeof(udc_ep_status)) {
80006aa2:	49 18       	lddpc	r8,80006ae4 <udc_req_std_ep_get_status+0x48>
80006aa4:	90 39       	ld.sh	r9,r8[0x6]
80006aa6:	30 28       	mov	r8,2
80006aa8:	f0 09 19 00 	cp.h	r9,r8
80006aac:	c0 30       	breq	80006ab2 <udc_req_std_ep_get_status+0x16>
		return false;
80006aae:	30 08       	mov	r8,0
80006ab0:	c1 68       	rjmp	80006adc <udc_req_std_ep_get_status+0x40>
	}

	udc_ep_status = udd_ep_is_halted(udd_g_ctrlreq.req.
80006ab2:	48 d8       	lddpc	r8,80006ae4 <udc_req_std_ep_get_status+0x48>
80006ab4:	90 28       	ld.sh	r8,r8[0x4]
80006ab6:	5c 58       	castu.b	r8
80006ab8:	10 9c       	mov	r12,r8
80006aba:	f0 1f 00 0c 	mcall	80006ae8 <udc_req_std_ep_get_status+0x4c>
80006abe:	18 98       	mov	r8,r12
80006ac0:	58 08       	cp.w	r8,0
80006ac2:	c0 40       	breq	80006aca <udc_req_std_ep_get_status+0x2e>
80006ac4:	e0 68 01 00 	mov	r8,256
80006ac8:	c0 28       	rjmp	80006acc <udc_req_std_ep_get_status+0x30>
80006aca:	30 08       	mov	r8,0
80006acc:	48 89       	lddpc	r9,80006aec <udc_req_std_ep_get_status+0x50>
80006ace:	b2 08       	st.h	r9[0x0],r8
			wIndex & 0xFF) ? CPU_TO_LE16(USB_EP_STATUS_HALTED) : 0;

	udd_set_setup_payload( (uint8_t *) & udc_ep_status,
80006ad0:	48 78       	lddpc	r8,80006aec <udc_req_std_ep_get_status+0x50>
80006ad2:	30 2b       	mov	r11,2
80006ad4:	10 9c       	mov	r12,r8
80006ad6:	f0 1f 00 07 	mcall	80006af0 <udc_req_std_ep_get_status+0x54>
			sizeof(udc_ep_status));
	return true;
80006ada:	30 18       	mov	r8,1
}
80006adc:	10 9c       	mov	r12,r8
80006ade:	e3 cd 80 80 	ldm	sp++,r7,pc
80006ae2:	00 00       	add	r0,r0
80006ae4:	00 00       	add	r0,r0
80006ae6:	46 48       	lddsp	r8,sp[0x190]
80006ae8:	80 00       	ld.sh	r0,r0[0x0]
80006aea:	39 f8       	mov	r8,-97
80006aec:	00 00       	add	r0,r0
80006aee:	07 32       	ld.ub	r2,r3++
80006af0:	80 00       	ld.sh	r0,r0[0x0]
80006af2:	35 e0       	mov	r0,94

80006af4 <udc_req_std_dev_clear_feature>:
 * \brief Standard device request to change device status
 *
 * \return true if success
 */
static bool udc_req_std_dev_clear_feature(void)
{
80006af4:	eb cd 40 80 	pushm	r7,lr
80006af8:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006afa:	48 d8       	lddpc	r8,80006b2c <udc_req_std_dev_clear_feature+0x38>
80006afc:	90 38       	ld.sh	r8,r8[0x6]
80006afe:	58 08       	cp.w	r8,0
80006b00:	c0 30       	breq	80006b06 <udc_req_std_dev_clear_feature+0x12>
		return false;
80006b02:	30 08       	mov	r8,0
80006b04:	c1 08       	rjmp	80006b24 <udc_req_std_dev_clear_feature+0x30>
	}

	if (udd_g_ctrlreq.req.wValue == USB_DEV_FEATURE_REMOTE_WAKEUP) {
80006b06:	48 a8       	lddpc	r8,80006b2c <udc_req_std_dev_clear_feature+0x38>
80006b08:	90 19       	ld.sh	r9,r8[0x2]
80006b0a:	30 18       	mov	r8,1
80006b0c:	f0 09 19 00 	cp.h	r9,r8
80006b10:	c0 91       	brne	80006b22 <udc_req_std_dev_clear_feature+0x2e>
		udc_device_status &= CPU_TO_LE16(~(uint32_t)USB_DEV_STATUS_REMOTEWAKEUP);
80006b12:	48 88       	lddpc	r8,80006b30 <udc_req_std_dev_clear_feature+0x3c>
80006b14:	90 08       	ld.sh	r8,r8[0x0]
80006b16:	a9 d8       	cbr	r8,0x9
80006b18:	5c 88       	casts.h	r8
80006b1a:	48 69       	lddpc	r9,80006b30 <udc_req_std_dev_clear_feature+0x3c>
80006b1c:	b2 08       	st.h	r9[0x0],r8
#if (USB_CONFIG_ATTR_REMOTE_WAKEUP \
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		UDC_REMOTEWAKEUP_DISABLE();
#endif
		return true;
80006b1e:	30 18       	mov	r8,1
80006b20:	c0 28       	rjmp	80006b24 <udc_req_std_dev_clear_feature+0x30>
	}
	return false;
80006b22:	30 08       	mov	r8,0
}
80006b24:	10 9c       	mov	r12,r8
80006b26:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b2a:	00 00       	add	r0,r0
80006b2c:	00 00       	add	r0,r0
80006b2e:	46 48       	lddsp	r8,sp[0x190]
80006b30:	00 00       	add	r0,r0
80006b32:	07 24       	ld.uh	r4,r3++

80006b34 <udc_req_std_ep_clear_feature>:
 * \brief Standard endpoint request to clear endpoint feature
 *
 * \return true if success
 */
static bool udc_req_std_ep_clear_feature(void)
{
80006b34:	eb cd 40 80 	pushm	r7,lr
80006b38:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006b3a:	48 c8       	lddpc	r8,80006b68 <udc_req_std_ep_clear_feature+0x34>
80006b3c:	90 38       	ld.sh	r8,r8[0x6]
80006b3e:	58 08       	cp.w	r8,0
80006b40:	c0 30       	breq	80006b46 <udc_req_std_ep_clear_feature+0x12>
		return false;
80006b42:	30 08       	mov	r8,0
80006b44:	c0 e8       	rjmp	80006b60 <udc_req_std_ep_clear_feature+0x2c>
	}

	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80006b46:	48 98       	lddpc	r8,80006b68 <udc_req_std_ep_clear_feature+0x34>
80006b48:	90 18       	ld.sh	r8,r8[0x2]
80006b4a:	58 08       	cp.w	r8,0
80006b4c:	c0 91       	brne	80006b5e <udc_req_std_ep_clear_feature+0x2a>
		return udd_ep_clear_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80006b4e:	48 78       	lddpc	r8,80006b68 <udc_req_std_ep_clear_feature+0x34>
80006b50:	90 28       	ld.sh	r8,r8[0x4]
80006b52:	5c 58       	castu.b	r8
80006b54:	10 9c       	mov	r12,r8
80006b56:	f0 1f 00 06 	mcall	80006b6c <udc_req_std_ep_clear_feature+0x38>
80006b5a:	18 98       	mov	r8,r12
80006b5c:	c0 28       	rjmp	80006b60 <udc_req_std_ep_clear_feature+0x2c>
	}
	return false;
80006b5e:	30 08       	mov	r8,0
}
80006b60:	10 9c       	mov	r12,r8
80006b62:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b66:	00 00       	add	r0,r0
80006b68:	00 00       	add	r0,r0
80006b6a:	46 48       	lddsp	r8,sp[0x190]
80006b6c:	80 00       	ld.sh	r0,r0[0x0]
80006b6e:	3b 3c       	mov	r12,-77

80006b70 <udc_req_std_dev_set_feature>:
 * \brief Standard device request to set a feature
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_feature(void)
{
80006b70:	eb cd 40 80 	pushm	r7,lr
80006b74:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006b76:	48 98       	lddpc	r8,80006b98 <udc_req_std_dev_set_feature+0x28>
80006b78:	90 38       	ld.sh	r8,r8[0x6]
80006b7a:	58 08       	cp.w	r8,0
80006b7c:	c0 30       	breq	80006b82 <udc_req_std_dev_set_feature+0x12>
		return false;
80006b7e:	30 08       	mov	r8,0
80006b80:	c0 98       	rjmp	80006b92 <udc_req_std_dev_set_feature+0x22>
	}

	switch (udd_g_ctrlreq.req.wValue) {
80006b82:	48 68       	lddpc	r8,80006b98 <udc_req_std_dev_set_feature+0x28>
80006b84:	90 18       	ld.sh	r8,r8[0x2]
80006b86:	5c 78       	castu.h	r8
80006b88:	58 18       	cp.w	r8,1
80006b8a:	c0 31       	brne	80006b90 <udc_req_std_dev_set_feature+0x20>
	== (USB_DEVICE_ATTR & USB_CONFIG_ATTR_REMOTE_WAKEUP))
		udc_device_status |= CPU_TO_LE16(USB_DEV_STATUS_REMOTEWAKEUP);
		UDC_REMOTEWAKEUP_ENABLE();
		return true;
#else
		return false;
80006b8c:	30 08       	mov	r8,0
80006b8e:	c0 28       	rjmp	80006b92 <udc_req_std_dev_set_feature+0x22>
		break;
#endif
	default:
		break;
	}
	return false;
80006b90:	30 08       	mov	r8,0
}
80006b92:	10 9c       	mov	r12,r8
80006b94:	e3 cd 80 80 	ldm	sp++,r7,pc
80006b98:	00 00       	add	r0,r0
80006b9a:	46 48       	lddsp	r8,sp[0x190]

80006b9c <udc_req_std_ep_set_feature>:
 *
 * \return true if success
 */
#if (0!=USB_DEVICE_MAX_EP)
static bool udc_req_std_ep_set_feature(void)
{
80006b9c:	eb cd 40 80 	pushm	r7,lr
80006ba0:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006ba2:	48 f8       	lddpc	r8,80006bdc <udc_req_std_ep_set_feature+0x40>
80006ba4:	90 38       	ld.sh	r8,r8[0x6]
80006ba6:	58 08       	cp.w	r8,0
80006ba8:	c0 30       	breq	80006bae <udc_req_std_ep_set_feature+0x12>
		return false;
80006baa:	30 08       	mov	r8,0
80006bac:	c1 48       	rjmp	80006bd4 <udc_req_std_ep_set_feature+0x38>
	}
	if (udd_g_ctrlreq.req.wValue == USB_EP_FEATURE_HALT) {
80006bae:	48 c8       	lddpc	r8,80006bdc <udc_req_std_ep_set_feature+0x40>
80006bb0:	90 18       	ld.sh	r8,r8[0x2]
80006bb2:	58 08       	cp.w	r8,0
80006bb4:	c0 f1       	brne	80006bd2 <udc_req_std_ep_set_feature+0x36>
		udd_ep_abort(udd_g_ctrlreq.req.wIndex & 0xFF);
80006bb6:	48 a8       	lddpc	r8,80006bdc <udc_req_std_ep_set_feature+0x40>
80006bb8:	90 28       	ld.sh	r8,r8[0x4]
80006bba:	5c 58       	castu.b	r8
80006bbc:	10 9c       	mov	r12,r8
80006bbe:	f0 1f 00 09 	mcall	80006be0 <udc_req_std_ep_set_feature+0x44>
		return udd_ep_set_halt(udd_g_ctrlreq.req.wIndex & 0xFF);
80006bc2:	48 78       	lddpc	r8,80006bdc <udc_req_std_ep_set_feature+0x40>
80006bc4:	90 28       	ld.sh	r8,r8[0x4]
80006bc6:	5c 58       	castu.b	r8
80006bc8:	10 9c       	mov	r12,r8
80006bca:	f0 1f 00 07 	mcall	80006be4 <udc_req_std_ep_set_feature+0x48>
80006bce:	18 98       	mov	r8,r12
80006bd0:	c0 28       	rjmp	80006bd4 <udc_req_std_ep_set_feature+0x38>
	}
	return false;
80006bd2:	30 08       	mov	r8,0
}
80006bd4:	10 9c       	mov	r12,r8
80006bd6:	e3 cd 80 80 	ldm	sp++,r7,pc
80006bda:	00 00       	add	r0,r0
80006bdc:	00 00       	add	r0,r0
80006bde:	46 48       	lddsp	r8,sp[0x190]
80006be0:	80 00       	ld.sh	r0,r0[0x0]
80006be2:	3d a0       	mov	r0,-38
80006be4:	80 00       	ld.sh	r0,r0[0x0]
80006be6:	3a 28       	mov	r8,-94

80006be8 <udc_valid_address>:
/**
 * \brief Change the address of device
 * Callback called at the end of request set address
 */
static void udc_valid_address(void)
{
80006be8:	eb cd 40 80 	pushm	r7,lr
80006bec:	1a 97       	mov	r7,sp
	udd_set_address(udd_g_ctrlreq.req.wValue & 0x7F);
80006bee:	48 68       	lddpc	r8,80006c04 <udc_valid_address+0x1c>
80006bf0:	90 18       	ld.sh	r8,r8[0x2]
80006bf2:	5c 58       	castu.b	r8
80006bf4:	f1 d8 c0 07 	bfextu	r8,r8,0x0,0x7
80006bf8:	10 9c       	mov	r12,r8
80006bfa:	f0 1f 00 04 	mcall	80006c08 <udc_valid_address+0x20>
}
80006bfe:	e3 cd 80 80 	ldm	sp++,r7,pc
80006c02:	00 00       	add	r0,r0
80006c04:	00 00       	add	r0,r0
80006c06:	46 48       	lddsp	r8,sp[0x190]
80006c08:	80 00       	ld.sh	r0,r0[0x0]
80006c0a:	35 46       	mov	r6,84

80006c0c <udc_req_std_dev_set_address>:
 * \brief Standard device request to set device address
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_address(void)
{
80006c0c:	eb cd 40 80 	pushm	r7,lr
80006c10:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength) {
80006c12:	48 78       	lddpc	r8,80006c2c <udc_req_std_dev_set_address+0x20>
80006c14:	90 38       	ld.sh	r8,r8[0x6]
80006c16:	58 08       	cp.w	r8,0
80006c18:	c0 30       	breq	80006c1e <udc_req_std_dev_set_address+0x12>
		return false;
80006c1a:	30 08       	mov	r8,0
80006c1c:	c0 58       	rjmp	80006c26 <udc_req_std_dev_set_address+0x1a>
	}

	// The address must be changed at the end of setup request after the handshake
	// then we use a callback to change address
	udd_g_ctrlreq.callback = udc_valid_address;
80006c1e:	48 48       	lddpc	r8,80006c2c <udc_req_std_dev_set_address+0x20>
80006c20:	48 49       	lddpc	r9,80006c30 <udc_req_std_dev_set_address+0x24>
80006c22:	91 49       	st.w	r8[0x10],r9
	return true;
80006c24:	30 18       	mov	r8,1
}
80006c26:	10 9c       	mov	r12,r8
80006c28:	e3 cd 80 80 	ldm	sp++,r7,pc
80006c2c:	00 00       	add	r0,r0
80006c2e:	46 48       	lddsp	r8,sp[0x190]
80006c30:	80 00       	ld.sh	r0,r0[0x0]
80006c32:	6b e8       	ld.w	r8,r5[0x78]

80006c34 <udc_req_std_dev_get_str_desc>:
 * \brief Standard device request to get device string descriptor
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_str_desc(void)
{
80006c34:	eb cd 40 80 	pushm	r7,lr
80006c38:	1a 97       	mov	r7,sp
80006c3a:	20 3d       	sub	sp,12
	uint8_t i;
	const uint8_t *str;
	uint8_t str_length = 0;
80006c3c:	30 08       	mov	r8,0
80006c3e:	ef 68 ff ff 	st.b	r7[-1],r8

	// Link payload pointer to the string corresponding at request
	switch (udd_g_ctrlreq.req.wValue & 0xff) {
80006c42:	4b 68       	lddpc	r8,80006d18 <udc_req_std_dev_get_str_desc+0xe4>
80006c44:	90 18       	ld.sh	r8,r8[0x2]
80006c46:	5c 78       	castu.h	r8
80006c48:	f1 d8 c0 08 	bfextu	r8,r8,0x0,0x8
80006c4c:	58 18       	cp.w	r8,1
80006c4e:	c1 00       	breq	80006c6e <udc_req_std_dev_get_str_desc+0x3a>
80006c50:	e0 89 00 05 	brgt	80006c5a <udc_req_std_dev_get_str_desc+0x26>
80006c54:	58 08       	cp.w	r8,0
80006c56:	c0 70       	breq	80006c64 <udc_req_std_dev_get_str_desc+0x30>
80006c58:	c2 28       	rjmp	80006c9c <udc_req_std_dev_get_str_desc+0x68>
80006c5a:	58 28       	cp.w	r8,2
80006c5c:	c1 00       	breq	80006c7c <udc_req_std_dev_get_str_desc+0x48>
80006c5e:	58 38       	cp.w	r8,3
80006c60:	c1 50       	breq	80006c8a <udc_req_std_dev_get_str_desc+0x56>
80006c62:	c1 d8       	rjmp	80006c9c <udc_req_std_dev_get_str_desc+0x68>
	case 0:
		udd_set_setup_payload((uint8_t *) &udc_string_desc_languageid,
80006c64:	30 4b       	mov	r11,4
80006c66:	4a ec       	lddpc	r12,80006d1c <udc_req_std_dev_get_str_desc+0xe8>
80006c68:	f0 1f 00 2e 	mcall	80006d20 <udc_req_std_dev_get_str_desc+0xec>
				sizeof(udc_string_desc_languageid));
		break;
80006c6c:	c1 a8       	rjmp	80006ca0 <udc_req_std_dev_get_str_desc+0x6c>

#ifdef USB_DEVICE_MANUFACTURE_NAME
	case 1:
		str_length = USB_DEVICE_MANUFACTURE_NAME_SIZE;
80006c6e:	30 98       	mov	r8,9
80006c70:	ef 68 ff ff 	st.b	r7[-1],r8
		str = udc_string_manufacturer_name;
80006c74:	4a c8       	lddpc	r8,80006d24 <udc_req_std_dev_get_str_desc+0xf0>
80006c76:	ef 48 ff f8 	st.w	r7[-8],r8
		break;
80006c7a:	c1 38       	rjmp	80006ca0 <udc_req_std_dev_get_str_desc+0x6c>
#endif
#ifdef USB_DEVICE_PRODUCT_NAME
	case 2:
		str_length = USB_DEVICE_PRODUCT_NAME_SIZE;
80006c7c:	30 f8       	mov	r8,15
80006c7e:	ef 68 ff ff 	st.b	r7[-1],r8
		str = udc_string_product_name;
80006c82:	4a a8       	lddpc	r8,80006d28 <udc_req_std_dev_get_str_desc+0xf4>
80006c84:	ef 48 ff f8 	st.w	r7[-8],r8
		break;
80006c88:	c0 c8       	rjmp	80006ca0 <udc_req_std_dev_get_str_desc+0x6c>
#endif
#if defined USB_DEVICE_SERIAL_NAME || defined USB_DEVICE_GET_SERIAL_NAME_POINTER
	case 3:
		str_length = USB_DEVICE_SERIAL_NAME_SIZE;
80006c8a:	30 c8       	mov	r8,12
80006c8c:	ef 68 ff ff 	st.b	r7[-1],r8
		str = udc_get_string_serial_name();
80006c90:	f0 1f 00 27 	mcall	80006d2c <udc_req_std_dev_get_str_desc+0xf8>
80006c94:	18 98       	mov	r8,r12
80006c96:	ef 48 ff f8 	st.w	r7[-8],r8
		break;
80006c9a:	c0 38       	rjmp	80006ca0 <udc_req_std_dev_get_str_desc+0x6c>
#ifdef UDC_GET_EXTRA_STRING
		if (UDC_GET_EXTRA_STRING()) {
			break;
		}
#endif
		return false;
80006c9c:	30 08       	mov	r8,0
80006c9e:	c3 88       	rjmp	80006d0e <udc_req_std_dev_get_str_desc+0xda>
	}

	if (str_length) {
80006ca0:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006ca4:	30 08       	mov	r8,0
80006ca6:	f0 09 18 00 	cp.b	r9,r8
80006caa:	c3 10       	breq	80006d0c <udc_req_std_dev_get_str_desc+0xd8>
		for(i = 0; i < str_length; i++) {
80006cac:	30 08       	mov	r8,0
80006cae:	ef 68 ff f7 	st.b	r7[-9],r8
80006cb2:	c1 88       	rjmp	80006ce2 <udc_req_std_dev_get_str_desc+0xae>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
80006cb4:	ef 3b ff f7 	ld.ub	r11,r7[-9]
80006cb8:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80006cbc:	ee f9 ff f8 	ld.w	r9,r7[-8]
80006cc0:	f2 08 00 08 	add	r8,r9,r8
80006cc4:	11 88       	ld.ub	r8,r8[0x0]
80006cc6:	5c c8       	swap.bh	r8
80006cc8:	5c 88       	casts.h	r8
80006cca:	10 99       	mov	r9,r8
80006ccc:	49 9a       	lddpc	r10,80006d30 <udc_req_std_dev_get_str_desc+0xfc>
80006cce:	f6 08 15 01 	lsl	r8,r11,0x1
80006cd2:	f4 08 00 08 	add	r8,r10,r8
80006cd6:	b0 19       	st.h	r8[0x2],r9
#endif
		return false;
	}

	if (str_length) {
		for(i = 0; i < str_length; i++) {
80006cd8:	ef 38 ff f7 	ld.ub	r8,r7[-9]
80006cdc:	2f f8       	sub	r8,-1
80006cde:	ef 68 ff f7 	st.b	r7[-9],r8
80006ce2:	ef 39 ff f7 	ld.ub	r9,r7[-9]
80006ce6:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006cea:	f0 09 18 00 	cp.b	r9,r8
80006cee:	ce 33       	brcs	80006cb4 <udc_req_std_dev_get_str_desc+0x80>
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
80006cf0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006cf4:	2f f8       	sub	r8,-1
80006cf6:	5c 58       	castu.b	r8
80006cf8:	a1 78       	lsl	r8,0x1
80006cfa:	5c 58       	castu.b	r8
80006cfc:	48 d9       	lddpc	r9,80006d30 <udc_req_std_dev_get_str_desc+0xfc>
80006cfe:	b2 88       	st.b	r9[0x0],r8
		udd_set_setup_payload(
			(uint8_t *) &udc_string_desc,
			udc_string_desc.header.bLength);
80006d00:	48 c8       	lddpc	r8,80006d30 <udc_req_std_dev_get_str_desc+0xfc>
80006d02:	11 88       	ld.ub	r8,r8[0x0]
		for(i = 0; i < str_length; i++) {
			udc_string_desc.string[i] = cpu_to_le16((le16_t)str[i]);
		}

		udc_string_desc.header.bLength = 2 + (str_length) * 2;
		udd_set_setup_payload(
80006d04:	10 9b       	mov	r11,r8
80006d06:	48 bc       	lddpc	r12,80006d30 <udc_req_std_dev_get_str_desc+0xfc>
80006d08:	f0 1f 00 06 	mcall	80006d20 <udc_req_std_dev_get_str_desc+0xec>
			(uint8_t *) &udc_string_desc,
			udc_string_desc.header.bLength);
	}

	return true;
80006d0c:	30 18       	mov	r8,1
}
80006d0e:	10 9c       	mov	r12,r8
80006d10:	2f dd       	sub	sp,-12
80006d12:	e3 cd 80 80 	ldm	sp++,r7,pc
80006d16:	00 00       	add	r0,r0
80006d18:	00 00       	add	r0,r0
80006d1a:	46 48       	lddsp	r8,sp[0x190]
80006d1c:	00 00       	add	r0,r0
80006d1e:	00 a4       	st.w	r0++,r4
80006d20:	80 00       	ld.sh	r0,r0[0x0]
80006d22:	35 e0       	mov	r0,94
80006d24:	00 00       	add	r0,r0
80006d26:	00 a8       	st.w	r0++,r8
80006d28:	00 00       	add	r0,r0
80006d2a:	00 b4       	st.h	r0++,r4
80006d2c:	80 00       	ld.sh	r0,r0[0x0]
80006d2e:	66 78       	ld.w	r8,r3[0x1c]
80006d30:	00 00       	add	r0,r0
80006d32:	00 c4       	st.b	r0++,r4

80006d34 <udc_req_std_dev_get_descriptor>:
 * \brief Standard device request to get descriptors about USB device
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_descriptor(void)
{
80006d34:	eb cd 40 80 	pushm	r7,lr
80006d38:	1a 97       	mov	r7,sp
80006d3a:	20 1d       	sub	sp,4
	uint8_t conf_num;

	conf_num = udd_g_ctrlreq.req.wValue & 0xff;
80006d3c:	4b 38       	lddpc	r8,80006e08 <udc_req_std_dev_get_descriptor+0xd4>
80006d3e:	90 18       	ld.sh	r8,r8[0x2]
80006d40:	ef 68 ff ff 	st.b	r7[-1],r8

	// Check descriptor ID
	switch ((uint8_t) (udd_g_ctrlreq.req.wValue >> 8)) {
80006d44:	4b 18       	lddpc	r8,80006e08 <udc_req_std_dev_get_descriptor+0xd4>
80006d46:	90 18       	ld.sh	r8,r8[0x2]
80006d48:	5c 78       	castu.h	r8
80006d4a:	a9 88       	lsr	r8,0x8
80006d4c:	5c 88       	casts.h	r8
80006d4e:	5c 58       	castu.b	r8
80006d50:	58 28       	cp.w	r8,2
80006d52:	c1 00       	breq	80006d72 <udc_req_std_dev_get_descriptor+0x3e>
80006d54:	58 38       	cp.w	r8,3
80006d56:	c3 d0       	breq	80006dd0 <udc_req_std_dev_get_descriptor+0x9c>
80006d58:	58 18       	cp.w	r8,1
80006d5a:	c4 41       	brne	80006de2 <udc_req_std_dev_get_descriptor+0xae>
		} else
#endif
		{
			udd_set_setup_payload(
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
80006d5c:	4a c8       	lddpc	r8,80006e0c <udc_req_std_dev_get_descriptor+0xd8>
80006d5e:	70 08       	ld.w	r8,r8[0x0]
80006d60:	11 88       	ld.ub	r8,r8[0x0]
				(uint8_t *) udc_config.confdev_hs,
				udc_config.confdev_hs->bLength);
		} else
#endif
		{
			udd_set_setup_payload(
80006d62:	10 99       	mov	r9,r8
80006d64:	4a a8       	lddpc	r8,80006e0c <udc_req_std_dev_get_descriptor+0xd8>
80006d66:	70 08       	ld.w	r8,r8[0x0]
80006d68:	12 9b       	mov	r11,r9
80006d6a:	10 9c       	mov	r12,r8
80006d6c:	f0 1f 00 29 	mcall	80006e10 <udc_req_std_dev_get_descriptor+0xdc>
				(uint8_t *) udc_config.confdev_lsfs,
				udc_config.confdev_lsfs->bLength);
		}
		break;
80006d70:	c3 c8       	rjmp	80006de8 <udc_req_std_dev_get_descriptor+0xb4>
				le16_to_cpu(udc_config.conf_hs[conf_num].desc->wTotalLength));
		} else
#endif
		{
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
80006d72:	4a 78       	lddpc	r8,80006e0c <udc_req_std_dev_get_descriptor+0xd8>
80006d74:	70 08       	ld.w	r8,r8[0x0]
80006d76:	f1 38 00 11 	ld.ub	r8,r8[17]
80006d7a:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006d7e:	f0 09 18 00 	cp.b	r9,r8
80006d82:	c0 33       	brcs	80006d88 <udc_req_std_dev_get_descriptor+0x54>
					bNumConfigurations) {
				return false;
80006d84:	30 08       	mov	r8,0
80006d86:	c3 d8       	rjmp	80006e00 <udc_req_std_dev_get_descriptor+0xcc>
			}
			udd_set_setup_payload(
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
80006d88:	4a 18       	lddpc	r8,80006e0c <udc_req_std_dev_get_descriptor+0xd8>
80006d8a:	70 19       	ld.w	r9,r8[0x4]
80006d8c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006d90:	a3 78       	lsl	r8,0x3
80006d92:	f2 08 00 08 	add	r8,r9,r8
80006d96:	70 08       	ld.w	r8,r8[0x0]
80006d98:	11 a9       	ld.ub	r9,r8[0x2]
80006d9a:	a9 69       	lsl	r9,0x8
80006d9c:	11 b8       	ld.ub	r8,r8[0x3]
80006d9e:	12 48       	or	r8,r9
80006da0:	5c 88       	casts.h	r8
80006da2:	5c 88       	casts.h	r8
80006da4:	5c c8       	swap.bh	r8
80006da6:	5c 88       	casts.h	r8
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
80006da8:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
80006dac:	49 88       	lddpc	r8,80006e0c <udc_req_std_dev_get_descriptor+0xd8>
80006dae:	70 1a       	ld.w	r10,r8[0x4]
80006db0:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006db4:	a3 78       	lsl	r8,0x3
80006db6:	f4 08 00 08 	add	r8,r10,r8
			// FS descriptor
			if (conf_num >= udc_config.confdev_lsfs->
					bNumConfigurations) {
				return false;
			}
			udd_set_setup_payload(
80006dba:	70 08       	ld.w	r8,r8[0x0]
80006dbc:	12 9b       	mov	r11,r9
80006dbe:	10 9c       	mov	r12,r8
80006dc0:	f0 1f 00 14 	mcall	80006e10 <udc_req_std_dev_get_descriptor+0xdc>
				(uint8_t *)udc_config.conf_lsfs[conf_num].desc,
				le16_to_cpu(udc_config.conf_lsfs[conf_num].desc->wTotalLength));
		}
		((usb_conf_desc_t *) udd_g_ctrlreq.payload)->bDescriptorType =
80006dc4:	49 18       	lddpc	r8,80006e08 <udc_req_std_dev_get_descriptor+0xd4>
80006dc6:	70 28       	ld.w	r8,r8[0x8]
80006dc8:	10 99       	mov	r9,r8
80006dca:	30 28       	mov	r8,2
80006dcc:	b2 98       	st.b	r9[0x1],r8
				USB_DT_CONFIGURATION;
		break;
80006dce:	c0 d8       	rjmp	80006de8 <udc_req_std_dev_get_descriptor+0xb4>
		break;
#endif

	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
80006dd0:	f0 1f 00 11 	mcall	80006e14 <udc_req_std_dev_get_descriptor+0xe0>
80006dd4:	18 98       	mov	r8,r12
80006dd6:	ec 18 00 01 	eorl	r8,0x1
80006dda:	5c 58       	castu.b	r8
80006ddc:	c0 50       	breq	80006de6 <udc_req_std_dev_get_descriptor+0xb2>
			return false;
80006dde:	30 08       	mov	r8,0
80006de0:	c1 08       	rjmp	80006e00 <udc_req_std_dev_get_descriptor+0xcc>
		}
		break;

	default:
		// Unknown descriptor requested
		return false;
80006de2:	30 08       	mov	r8,0
80006de4:	c0 e8       	rjmp	80006e00 <udc_req_std_dev_get_descriptor+0xcc>
	case USB_DT_STRING:
		// String descriptor requested
		if (!udc_req_std_dev_get_str_desc()) {
			return false;
		}
		break;
80006de6:	d7 03       	nop
	default:
		// Unknown descriptor requested
		return false;
	}
	// if the descriptor is larger than length requested, then reduce it
	if (udd_g_ctrlreq.req.wLength < udd_g_ctrlreq.payload_size) {
80006de8:	48 88       	lddpc	r8,80006e08 <udc_req_std_dev_get_descriptor+0xd4>
80006dea:	90 39       	ld.sh	r9,r8[0x6]
80006dec:	48 78       	lddpc	r8,80006e08 <udc_req_std_dev_get_descriptor+0xd4>
80006dee:	90 68       	ld.sh	r8,r8[0xc]
80006df0:	f0 09 19 00 	cp.h	r9,r8
80006df4:	c0 52       	brcc	80006dfe <udc_req_std_dev_get_descriptor+0xca>
		udd_g_ctrlreq.payload_size = udd_g_ctrlreq.req.wLength;
80006df6:	48 58       	lddpc	r8,80006e08 <udc_req_std_dev_get_descriptor+0xd4>
80006df8:	90 38       	ld.sh	r8,r8[0x6]
80006dfa:	48 49       	lddpc	r9,80006e08 <udc_req_std_dev_get_descriptor+0xd4>
80006dfc:	b2 68       	st.h	r9[0xc],r8
	}
	return true;
80006dfe:	30 18       	mov	r8,1
}
80006e00:	10 9c       	mov	r12,r8
80006e02:	2f fd       	sub	sp,-4
80006e04:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e08:	00 00       	add	r0,r0
80006e0a:	46 48       	lddsp	r8,sp[0x190]
80006e0c:	00 00       	add	r0,r0
80006e0e:	00 9c       	mov	r12,r0
80006e10:	80 00       	ld.sh	r0,r0[0x0]
80006e12:	35 e0       	mov	r0,94
80006e14:	80 00       	ld.sh	r0,r0[0x0]
80006e16:	6c 34       	ld.w	r4,r6[0xc]

80006e18 <udc_req_std_dev_get_configuration>:
 * \brief Standard device request to get configuration number
 *
 * \return true if success
 */
static bool udc_req_std_dev_get_configuration(void)
{
80006e18:	eb cd 40 80 	pushm	r7,lr
80006e1c:	1a 97       	mov	r7,sp
	if (udd_g_ctrlreq.req.wLength != 1) {
80006e1e:	48 98       	lddpc	r8,80006e40 <udc_req_std_dev_get_configuration+0x28>
80006e20:	90 39       	ld.sh	r9,r8[0x6]
80006e22:	30 18       	mov	r8,1
80006e24:	f0 09 19 00 	cp.h	r9,r8
80006e28:	c0 30       	breq	80006e2e <udc_req_std_dev_get_configuration+0x16>
		return false;
80006e2a:	30 08       	mov	r8,0
80006e2c:	c0 68       	rjmp	80006e38 <udc_req_std_dev_get_configuration+0x20>
	}

	udd_set_setup_payload(&udc_num_configuration,1);
80006e2e:	30 1b       	mov	r11,1
80006e30:	48 5c       	lddpc	r12,80006e44 <udc_req_std_dev_get_configuration+0x2c>
80006e32:	f0 1f 00 06 	mcall	80006e48 <udc_req_std_dev_get_configuration+0x30>
	return true;
80006e36:	30 18       	mov	r8,1
}
80006e38:	10 9c       	mov	r12,r8
80006e3a:	e3 cd 80 80 	ldm	sp++,r7,pc
80006e3e:	00 00       	add	r0,r0
80006e40:	00 00       	add	r0,r0
80006e42:	46 48       	lddsp	r8,sp[0x190]
80006e44:	00 00       	add	r0,r0
80006e46:	07 26       	ld.uh	r6,r3++
80006e48:	80 00       	ld.sh	r0,r0[0x0]
80006e4a:	35 e0       	mov	r0,94

80006e4c <udc_req_std_dev_set_configuration>:
 * \brief Standard device request to enable a configuration
 *
 * \return true if success
 */
static bool udc_req_std_dev_set_configuration(void)
{
80006e4c:	eb cd 40 80 	pushm	r7,lr
80006e50:	1a 97       	mov	r7,sp
80006e52:	20 1d       	sub	sp,4
	uint8_t iface_num;

	// Check request length
	if (udd_g_ctrlreq.req.wLength) {
80006e54:	4a b8       	lddpc	r8,80006f00 <udc_req_std_dev_set_configuration+0xb4>
80006e56:	90 38       	ld.sh	r8,r8[0x6]
80006e58:	58 08       	cp.w	r8,0
80006e5a:	c0 30       	breq	80006e60 <udc_req_std_dev_set_configuration+0x14>
		return false;
80006e5c:	30 08       	mov	r8,0
80006e5e:	c4 c8       	rjmp	80006ef6 <udc_req_std_dev_set_configuration+0xaa>
	}
	// Authorize configuration only if the address is valid
	if (!udd_getaddress()) {
80006e60:	f0 1f 00 29 	mcall	80006f04 <udc_req_std_dev_set_configuration+0xb8>
80006e64:	18 98       	mov	r8,r12
80006e66:	58 08       	cp.w	r8,0
80006e68:	c0 31       	brne	80006e6e <udc_req_std_dev_set_configuration+0x22>
		return false;
80006e6a:	30 08       	mov	r8,0
80006e6c:	c4 58       	rjmp	80006ef6 <udc_req_std_dev_set_configuration+0xaa>
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80006e6e:	4a 58       	lddpc	r8,80006f00 <udc_req_std_dev_set_configuration+0xb4>
80006e70:	90 18       	ld.sh	r8,r8[0x2]
80006e72:	5c 78       	castu.h	r8
80006e74:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
				udc_config.confdev_lsfs->bNumConfigurations) {
80006e78:	4a 48       	lddpc	r8,80006f08 <udc_req_std_dev_set_configuration+0xbc>
80006e7a:	70 08       	ld.w	r8,r8[0x0]
		}
	} else
#endif
	{
		// FS descriptor
		if ((udd_g_ctrlreq.req.wValue & 0xFF) >
80006e7c:	f1 38 00 11 	ld.ub	r8,r8[17]
80006e80:	10 39       	cp.w	r9,r8
80006e82:	e0 8a 00 04 	brle	80006e8a <udc_req_std_dev_set_configuration+0x3e>
				udc_config.confdev_lsfs->bNumConfigurations) {
			return false;
80006e86:	30 08       	mov	r8,0
80006e88:	c3 78       	rjmp	80006ef6 <udc_req_std_dev_set_configuration+0xaa>
		}
	}

	// Reset current configuration
	udc_reset();
80006e8a:	f0 1f 00 21 	mcall	80006f0c <udc_req_std_dev_set_configuration+0xc0>

	// Enable new configuration
	udc_num_configuration = udd_g_ctrlreq.req.wValue & 0xFF;
80006e8e:	49 d8       	lddpc	r8,80006f00 <udc_req_std_dev_set_configuration+0xb4>
80006e90:	90 18       	ld.sh	r8,r8[0x2]
80006e92:	5c 58       	castu.b	r8
80006e94:	49 f9       	lddpc	r9,80006f10 <udc_req_std_dev_set_configuration+0xc4>
80006e96:	b2 88       	st.b	r9[0x0],r8
	if (udc_num_configuration == 0) {
80006e98:	49 e8       	lddpc	r8,80006f10 <udc_req_std_dev_set_configuration+0xc4>
80006e9a:	11 88       	ld.ub	r8,r8[0x0]
80006e9c:	58 08       	cp.w	r8,0
80006e9e:	c0 31       	brne	80006ea4 <udc_req_std_dev_set_configuration+0x58>
		return true; // Default empty configuration requested
80006ea0:	30 18       	mov	r8,1
80006ea2:	c2 a8       	rjmp	80006ef6 <udc_req_std_dev_set_configuration+0xaa>
		udc_ptr_conf = &udc_config.conf_hs[udc_num_configuration - 1];
	} else
#endif
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
80006ea4:	49 98       	lddpc	r8,80006f08 <udc_req_std_dev_set_configuration+0xbc>
80006ea6:	70 19       	ld.w	r9,r8[0x4]
80006ea8:	49 a8       	lddpc	r8,80006f10 <udc_req_std_dev_set_configuration+0xc4>
80006eaa:	11 88       	ld.ub	r8,r8[0x0]
80006eac:	20 18       	sub	r8,1
80006eae:	a3 78       	lsl	r8,0x3
80006eb0:	10 09       	add	r9,r8
80006eb2:	49 98       	lddpc	r8,80006f14 <udc_req_std_dev_set_configuration+0xc8>
80006eb4:	91 09       	st.w	r8[0x0],r9
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80006eb6:	30 08       	mov	r8,0
80006eb8:	ef 68 ff ff 	st.b	r7[-1],r8
80006ebc:	c1 38       	rjmp	80006ee2 <udc_req_std_dev_set_configuration+0x96>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
80006ebe:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006ec2:	30 0b       	mov	r11,0
80006ec4:	10 9c       	mov	r12,r8
80006ec6:	f0 1f 00 15 	mcall	80006f18 <udc_req_std_dev_set_configuration+0xcc>
80006eca:	18 98       	mov	r8,r12
80006ecc:	ec 18 00 01 	eorl	r8,0x1
80006ed0:	5c 58       	castu.b	r8
80006ed2:	c0 30       	breq	80006ed8 <udc_req_std_dev_set_configuration+0x8c>
			return false;
80006ed4:	30 08       	mov	r8,0
80006ed6:	c1 08       	rjmp	80006ef6 <udc_req_std_dev_set_configuration+0xaa>
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
80006ed8:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80006edc:	2f f8       	sub	r8,-1
80006ede:	ef 68 ff ff 	st.b	r7[-1],r8
	{
		// FS descriptor
		udc_ptr_conf = &udc_config.conf_lsfs[udc_num_configuration - 1];
	}
	// Enable all interfaces of the selected configuration
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80006ee2:	48 d8       	lddpc	r8,80006f14 <udc_req_std_dev_set_configuration+0xc8>
80006ee4:	70 08       	ld.w	r8,r8[0x0]
80006ee6:	70 08       	ld.w	r8,r8[0x0]
80006ee8:	11 c8       	ld.ub	r8,r8[0x4]
80006eea:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80006eee:	f0 09 18 00 	cp.b	r9,r8
80006ef2:	ce 63       	brcs	80006ebe <udc_req_std_dev_set_configuration+0x72>
			iface_num++) {
		if (!udc_iface_enable(iface_num, 0)) {
			return false;
		}
	}
	return true;
80006ef4:	30 18       	mov	r8,1
}
80006ef6:	10 9c       	mov	r12,r8
80006ef8:	2f fd       	sub	sp,-4
80006efa:	e3 cd 80 80 	ldm	sp++,r7,pc
80006efe:	00 00       	add	r0,r0
80006f00:	00 00       	add	r0,r0
80006f02:	46 48       	lddsp	r8,sp[0x190]
80006f04:	80 00       	ld.sh	r0,r0[0x0]
80006f06:	35 94       	mov	r4,89
80006f08:	00 00       	add	r0,r0
80006f0a:	00 9c       	mov	r12,r0
80006f0c:	80 00       	ld.sh	r0,r0[0x0]
80006f0e:	69 98       	ld.w	r8,r4[0x64]
80006f10:	00 00       	add	r0,r0
80006f12:	07 26       	ld.uh	r6,r3++
80006f14:	00 00       	add	r0,r0
80006f16:	07 28       	ld.uh	r8,r3++
80006f18:	80 00       	ld.sh	r0,r0[0x0]
80006f1a:	68 bc       	ld.w	r12,r4[0x2c]

80006f1c <udc_req_std_iface_get_setting>:
 * to get the alternate setting number of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_get_setting(void)
{
80006f1c:	eb cd 40 80 	pushm	r7,lr
80006f20:	1a 97       	mov	r7,sp
80006f22:	20 2d       	sub	sp,8
	static uint8_t udc_iface_setting;
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (udd_g_ctrlreq.req.wLength != 1) {
80006f24:	4a 38       	lddpc	r8,80006fb0 <udc_req_std_iface_get_setting+0x94>
80006f26:	90 39       	ld.sh	r9,r8[0x6]
80006f28:	30 18       	mov	r8,1
80006f2a:	f0 09 19 00 	cp.h	r9,r8
80006f2e:	c0 30       	breq	80006f34 <udc_req_std_iface_get_setting+0x18>
		return false; // Error in request
80006f30:	30 08       	mov	r8,0
80006f32:	c3 a8       	rjmp	80006fa6 <udc_req_std_iface_get_setting+0x8a>
	}
	if (!udc_num_configuration) {
80006f34:	4a 08       	lddpc	r8,80006fb4 <udc_req_std_iface_get_setting+0x98>
80006f36:	11 88       	ld.ub	r8,r8[0x0]
80006f38:	58 08       	cp.w	r8,0
80006f3a:	c0 31       	brne	80006f40 <udc_req_std_iface_get_setting+0x24>
		return false; // The device is not is configured state yet
80006f3c:	30 08       	mov	r8,0
80006f3e:	c3 48       	rjmp	80006fa6 <udc_req_std_iface_get_setting+0x8a>
	}

	// Check the interface number included in the request
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80006f40:	49 c8       	lddpc	r8,80006fb0 <udc_req_std_iface_get_setting+0x94>
80006f42:	90 28       	ld.sh	r8,r8[0x4]
80006f44:	ef 68 ff fb 	st.b	r7[-5],r8
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
80006f48:	49 c8       	lddpc	r8,80006fb8 <udc_req_std_iface_get_setting+0x9c>
80006f4a:	70 08       	ld.w	r8,r8[0x0]
80006f4c:	70 08       	ld.w	r8,r8[0x0]
80006f4e:	11 c8       	ld.ub	r8,r8[0x4]
80006f50:	ef 39 ff fb 	ld.ub	r9,r7[-5]
80006f54:	f0 09 18 00 	cp.b	r9,r8
80006f58:	c0 33       	brcs	80006f5e <udc_req_std_iface_get_setting+0x42>
		return false;
80006f5a:	30 08       	mov	r8,0
80006f5c:	c2 58       	rjmp	80006fa6 <udc_req_std_iface_get_setting+0x8a>
	}

	// Select first alternate setting of the interface to update udc_ptr_iface
	// before call iface->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
80006f5e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006f62:	30 0b       	mov	r11,0
80006f64:	10 9c       	mov	r12,r8
80006f66:	f0 1f 00 16 	mcall	80006fbc <udc_req_std_iface_get_setting+0xa0>
80006f6a:	18 98       	mov	r8,r12
80006f6c:	ec 18 00 01 	eorl	r8,0x1
80006f70:	5c 58       	castu.b	r8
80006f72:	c0 30       	breq	80006f78 <udc_req_std_iface_get_setting+0x5c>
		return false;
80006f74:	30 08       	mov	r8,0
80006f76:	c1 88       	rjmp	80006fa6 <udc_req_std_iface_get_setting+0x8a>
	}
	// Get alternate setting from UDI
	udi_api = udc_ptr_conf->udi_apis[iface_num];
80006f78:	49 08       	lddpc	r8,80006fb8 <udc_req_std_iface_get_setting+0x9c>
80006f7a:	70 08       	ld.w	r8,r8[0x0]
80006f7c:	70 19       	ld.w	r9,r8[0x4]
80006f7e:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80006f82:	a3 68       	lsl	r8,0x2
80006f84:	f2 08 00 08 	add	r8,r9,r8
80006f88:	70 08       	ld.w	r8,r8[0x0]
80006f8a:	ef 48 ff fc 	st.w	r7[-4],r8
	udc_iface_setting = udi_api->getsetting();
80006f8e:	ee f8 ff fc 	ld.w	r8,r7[-4]
80006f92:	70 38       	ld.w	r8,r8[0xc]
80006f94:	5d 18       	icall	r8
80006f96:	18 98       	mov	r8,r12
80006f98:	48 a9       	lddpc	r9,80006fc0 <udc_req_std_iface_get_setting+0xa4>
80006f9a:	b2 88       	st.b	r9[0x0],r8

	// Link value to payload pointer of request
	udd_set_setup_payload(&udc_iface_setting,1);
80006f9c:	30 1b       	mov	r11,1
80006f9e:	48 9c       	lddpc	r12,80006fc0 <udc_req_std_iface_get_setting+0xa4>
80006fa0:	f0 1f 00 09 	mcall	80006fc4 <udc_req_std_iface_get_setting+0xa8>
	return true;
80006fa4:	30 18       	mov	r8,1
}
80006fa6:	10 9c       	mov	r12,r8
80006fa8:	2f ed       	sub	sp,-8
80006faa:	e3 cd 80 80 	ldm	sp++,r7,pc
80006fae:	00 00       	add	r0,r0
80006fb0:	00 00       	add	r0,r0
80006fb2:	46 48       	lddsp	r8,sp[0x190]
80006fb4:	00 00       	add	r0,r0
80006fb6:	07 26       	ld.uh	r6,r3++
80006fb8:	00 00       	add	r0,r0
80006fba:	07 28       	ld.uh	r8,r3++
80006fbc:	80 00       	ld.sh	r0,r0[0x0]
80006fbe:	67 48       	ld.w	r8,r3[0x50]
80006fc0:	00 00       	add	r0,r0
80006fc2:	07 30       	ld.ub	r0,r3++
80006fc4:	80 00       	ld.sh	r0,r0[0x0]
80006fc6:	35 e0       	mov	r0,94

80006fc8 <udc_req_std_iface_set_setting>:
 * to set an alternate setting of an interface
 *
 * \return true if success
 */
static bool udc_req_std_iface_set_setting(void)
{
80006fc8:	eb cd 40 80 	pushm	r7,lr
80006fcc:	1a 97       	mov	r7,sp
80006fce:	20 1d       	sub	sp,4
	uint8_t iface_num, setting_num;

	if (udd_g_ctrlreq.req.wLength) {
80006fd0:	49 78       	lddpc	r8,8000702c <udc_req_std_iface_set_setting+0x64>
80006fd2:	90 38       	ld.sh	r8,r8[0x6]
80006fd4:	58 08       	cp.w	r8,0
80006fd6:	c0 30       	breq	80006fdc <udc_req_std_iface_set_setting+0x14>
		return false; // Error in request
80006fd8:	30 08       	mov	r8,0
80006fda:	c2 48       	rjmp	80007022 <udc_req_std_iface_set_setting+0x5a>
	}
	if (!udc_num_configuration) {
80006fdc:	49 58       	lddpc	r8,80007030 <udc_req_std_iface_set_setting+0x68>
80006fde:	11 88       	ld.ub	r8,r8[0x0]
80006fe0:	58 08       	cp.w	r8,0
80006fe2:	c0 31       	brne	80006fe8 <udc_req_std_iface_set_setting+0x20>
		return false; // The device is not is configured state yet
80006fe4:	30 08       	mov	r8,0
80006fe6:	c1 e8       	rjmp	80007022 <udc_req_std_iface_set_setting+0x5a>
	}

	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80006fe8:	49 18       	lddpc	r8,8000702c <udc_req_std_iface_set_setting+0x64>
80006fea:	90 28       	ld.sh	r8,r8[0x4]
80006fec:	ef 68 ff fe 	st.b	r7[-2],r8
	setting_num = udd_g_ctrlreq.req.wValue & 0xFF;
80006ff0:	48 f8       	lddpc	r8,8000702c <udc_req_std_iface_set_setting+0x64>
80006ff2:	90 18       	ld.sh	r8,r8[0x2]
80006ff4:	ef 68 ff ff 	st.b	r7[-1],r8

	// Disable current setting
	if (!udc_iface_disable(iface_num)) {
80006ff8:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80006ffc:	10 9c       	mov	r12,r8
80006ffe:	f0 1f 00 0e 	mcall	80007034 <udc_req_std_iface_set_setting+0x6c>
80007002:	18 98       	mov	r8,r12
80007004:	ec 18 00 01 	eorl	r8,0x1
80007008:	5c 58       	castu.b	r8
8000700a:	c0 30       	breq	80007010 <udc_req_std_iface_set_setting+0x48>
		return false;
8000700c:	30 08       	mov	r8,0
8000700e:	c0 a8       	rjmp	80007022 <udc_req_std_iface_set_setting+0x5a>
	}

	// Enable new setting
	return udc_iface_enable(iface_num, setting_num);
80007010:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007014:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80007018:	12 9b       	mov	r11,r9
8000701a:	10 9c       	mov	r12,r8
8000701c:	f0 1f 00 07 	mcall	80007038 <udc_req_std_iface_set_setting+0x70>
80007020:	18 98       	mov	r8,r12
}
80007022:	10 9c       	mov	r12,r8
80007024:	2f fd       	sub	sp,-4
80007026:	e3 cd 80 80 	ldm	sp++,r7,pc
8000702a:	00 00       	add	r0,r0
8000702c:	00 00       	add	r0,r0
8000702e:	46 48       	lddsp	r8,sp[0x190]
80007030:	00 00       	add	r0,r0
80007032:	07 26       	ld.uh	r6,r3++
80007034:	80 00       	ld.sh	r0,r0[0x0]
80007036:	68 00       	ld.w	r0,r4[0x0]
80007038:	80 00       	ld.sh	r0,r0[0x0]
8000703a:	68 bc       	ld.w	r12,r4[0x2c]

8000703c <udc_reqstd>:
 * \brief Main routine to manage the standard USB SETUP request
 *
 * \return true if the request is supported
 */
static bool udc_reqstd(void)
{
8000703c:	eb cd 40 80 	pushm	r7,lr
80007040:	1a 97       	mov	r7,sp
	if (Udd_setup_is_in()) {
80007042:	4c 78       	lddpc	r8,8000715c <udc_reqstd+0x120>
80007044:	11 88       	ld.ub	r8,r8[0x0]
80007046:	10 99       	mov	r9,r8
80007048:	30 08       	mov	r8,0
8000704a:	f0 09 18 00 	cp.b	r9,r8
8000704e:	c3 c4       	brge	800070c6 <udc_reqstd+0x8a>
		// GET Standard Requests
		if (udd_g_ctrlreq.req.wLength == 0) {
80007050:	4c 38       	lddpc	r8,8000715c <udc_reqstd+0x120>
80007052:	90 38       	ld.sh	r8,r8[0x6]
80007054:	58 08       	cp.w	r8,0
80007056:	c0 31       	brne	8000705c <udc_reqstd+0x20>
			return false; // Error for USB host
80007058:	30 08       	mov	r8,0
8000705a:	c7 d8       	rjmp	80007154 <udc_reqstd+0x118>
		}

		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
8000705c:	4c 08       	lddpc	r8,8000715c <udc_reqstd+0x120>
8000705e:	11 88       	ld.ub	r8,r8[0x0]
80007060:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80007064:	c1 51       	brne	8000708e <udc_reqstd+0x52>
			// Standard Get Device request
			switch (udd_g_ctrlreq.req.bRequest) {
80007066:	4b e8       	lddpc	r8,8000715c <udc_reqstd+0x120>
80007068:	11 98       	ld.ub	r8,r8[0x1]
8000706a:	58 68       	cp.w	r8,6
8000706c:	c0 90       	breq	8000707e <udc_reqstd+0x42>
8000706e:	58 88       	cp.w	r8,8
80007070:	c0 b0       	breq	80007086 <udc_reqstd+0x4a>
80007072:	58 08       	cp.w	r8,0
80007074:	c0 d1       	brne	8000708e <udc_reqstd+0x52>
			case USB_REQ_GET_STATUS:
				return udc_req_std_dev_get_status();
80007076:	f0 1f 00 3b 	mcall	80007160 <udc_reqstd+0x124>
8000707a:	18 98       	mov	r8,r12
8000707c:	c6 c8       	rjmp	80007154 <udc_reqstd+0x118>
			case USB_REQ_GET_DESCRIPTOR:
				return udc_req_std_dev_get_descriptor();
8000707e:	f0 1f 00 3a 	mcall	80007164 <udc_reqstd+0x128>
80007082:	18 98       	mov	r8,r12
80007084:	c6 88       	rjmp	80007154 <udc_reqstd+0x118>
			case USB_REQ_GET_CONFIGURATION:
				return udc_req_std_dev_get_configuration();
80007086:	f0 1f 00 39 	mcall	80007168 <udc_reqstd+0x12c>
8000708a:	18 98       	mov	r8,r12
8000708c:	c6 48       	rjmp	80007154 <udc_reqstd+0x118>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
8000708e:	4b 48       	lddpc	r8,8000715c <udc_reqstd+0x120>
80007090:	11 88       	ld.ub	r8,r8[0x0]
80007092:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80007096:	58 18       	cp.w	r8,1
80007098:	c0 91       	brne	800070aa <udc_reqstd+0x6e>
			// Standard Get Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
8000709a:	4b 18       	lddpc	r8,8000715c <udc_reqstd+0x120>
8000709c:	11 98       	ld.ub	r8,r8[0x1]
8000709e:	58 a8       	cp.w	r8,10
800070a0:	c0 51       	brne	800070aa <udc_reqstd+0x6e>
			case USB_REQ_GET_INTERFACE:
				return udc_req_std_iface_get_setting();
800070a2:	f0 1f 00 33 	mcall	8000716c <udc_reqstd+0x130>
800070a6:	18 98       	mov	r8,r12
800070a8:	c5 68       	rjmp	80007154 <udc_reqstd+0x118>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
800070aa:	4a d8       	lddpc	r8,8000715c <udc_reqstd+0x120>
800070ac:	11 88       	ld.ub	r8,r8[0x0]
800070ae:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800070b2:	58 28       	cp.w	r8,2
800070b4:	c4 f1       	brne	80007152 <udc_reqstd+0x116>
			// Standard Get Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
800070b6:	4a a8       	lddpc	r8,8000715c <udc_reqstd+0x120>
800070b8:	11 98       	ld.ub	r8,r8[0x1]
800070ba:	58 08       	cp.w	r8,0
800070bc:	c4 b1       	brne	80007152 <udc_reqstd+0x116>
			case USB_REQ_GET_STATUS:
				return udc_req_std_ep_get_status();
800070be:	f0 1f 00 2d 	mcall	80007170 <udc_reqstd+0x134>
800070c2:	18 98       	mov	r8,r12
800070c4:	c4 88       	rjmp	80007154 <udc_reqstd+0x118>
			}
		}
#endif
	} else {
		// SET Standard Requests
		if (USB_REQ_RECIP_DEVICE == Udd_setup_recipient()) {
800070c6:	4a 68       	lddpc	r8,8000715c <udc_reqstd+0x120>
800070c8:	11 88       	ld.ub	r8,r8[0x0]
800070ca:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
800070ce:	c1 f1       	brne	8000710c <udc_reqstd+0xd0>
			// Standard Set Device request
			switch (udd_g_ctrlreq.req.bRequest) {
800070d0:	4a 38       	lddpc	r8,8000715c <udc_reqstd+0x120>
800070d2:	11 98       	ld.ub	r8,r8[0x1]
800070d4:	58 38       	cp.w	r8,3
800070d6:	c1 30       	breq	800070fc <udc_reqstd+0xc0>
800070d8:	e0 89 00 05 	brgt	800070e2 <udc_reqstd+0xa6>
800070dc:	58 18       	cp.w	r8,1
800070de:	c0 b0       	breq	800070f4 <udc_reqstd+0xb8>
800070e0:	c1 68       	rjmp	8000710c <udc_reqstd+0xd0>
800070e2:	58 58       	cp.w	r8,5
800070e4:	c0 40       	breq	800070ec <udc_reqstd+0xb0>
800070e6:	58 98       	cp.w	r8,9
800070e8:	c0 e0       	breq	80007104 <udc_reqstd+0xc8>
800070ea:	c1 18       	rjmp	8000710c <udc_reqstd+0xd0>
			case USB_REQ_SET_ADDRESS:
				return udc_req_std_dev_set_address();
800070ec:	f0 1f 00 22 	mcall	80007174 <udc_reqstd+0x138>
800070f0:	18 98       	mov	r8,r12
800070f2:	c3 18       	rjmp	80007154 <udc_reqstd+0x118>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_dev_clear_feature();
800070f4:	f0 1f 00 21 	mcall	80007178 <udc_reqstd+0x13c>
800070f8:	18 98       	mov	r8,r12
800070fa:	c2 d8       	rjmp	80007154 <udc_reqstd+0x118>
			case USB_REQ_SET_FEATURE:
				return udc_req_std_dev_set_feature();
800070fc:	f0 1f 00 20 	mcall	8000717c <udc_reqstd+0x140>
80007100:	18 98       	mov	r8,r12
80007102:	c2 98       	rjmp	80007154 <udc_reqstd+0x118>
			case USB_REQ_SET_CONFIGURATION:
				return udc_req_std_dev_set_configuration();
80007104:	f0 1f 00 1f 	mcall	80007180 <udc_reqstd+0x144>
80007108:	18 98       	mov	r8,r12
8000710a:	c2 58       	rjmp	80007154 <udc_reqstd+0x118>
			default:
				break;
			}
		}

		if (USB_REQ_RECIP_INTERFACE == Udd_setup_recipient()) {
8000710c:	49 48       	lddpc	r8,8000715c <udc_reqstd+0x120>
8000710e:	11 88       	ld.ub	r8,r8[0x0]
80007110:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80007114:	58 18       	cp.w	r8,1
80007116:	c0 91       	brne	80007128 <udc_reqstd+0xec>
			// Standard Set Interface request
			switch (udd_g_ctrlreq.req.bRequest) {
80007118:	49 18       	lddpc	r8,8000715c <udc_reqstd+0x120>
8000711a:	11 98       	ld.ub	r8,r8[0x1]
8000711c:	58 b8       	cp.w	r8,11
8000711e:	c0 51       	brne	80007128 <udc_reqstd+0xec>
			case USB_REQ_SET_INTERFACE:
				return udc_req_std_iface_set_setting();
80007120:	f0 1f 00 19 	mcall	80007184 <udc_reqstd+0x148>
80007124:	18 98       	mov	r8,r12
80007126:	c1 78       	rjmp	80007154 <udc_reqstd+0x118>
			default:
				break;
			}
		}
#if (0!=USB_DEVICE_MAX_EP)
		if (USB_REQ_RECIP_ENDPOINT == Udd_setup_recipient()) {
80007128:	48 d8       	lddpc	r8,8000715c <udc_reqstd+0x120>
8000712a:	11 88       	ld.ub	r8,r8[0x0]
8000712c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80007130:	58 28       	cp.w	r8,2
80007132:	c1 01       	brne	80007152 <udc_reqstd+0x116>
			// Standard Set Endpoint request
			switch (udd_g_ctrlreq.req.bRequest) {
80007134:	48 a8       	lddpc	r8,8000715c <udc_reqstd+0x120>
80007136:	11 98       	ld.ub	r8,r8[0x1]
80007138:	58 18       	cp.w	r8,1
8000713a:	c0 40       	breq	80007142 <udc_reqstd+0x106>
8000713c:	58 38       	cp.w	r8,3
8000713e:	c0 60       	breq	8000714a <udc_reqstd+0x10e>
80007140:	c0 98       	rjmp	80007152 <udc_reqstd+0x116>
			case USB_REQ_CLEAR_FEATURE:
				return udc_req_std_ep_clear_feature();
80007142:	f0 1f 00 12 	mcall	80007188 <udc_reqstd+0x14c>
80007146:	18 98       	mov	r8,r12
80007148:	c0 68       	rjmp	80007154 <udc_reqstd+0x118>
			case USB_REQ_SET_FEATURE:
				return udc_req_std_ep_set_feature();
8000714a:	f0 1f 00 11 	mcall	8000718c <udc_reqstd+0x150>
8000714e:	18 98       	mov	r8,r12
80007150:	c0 28       	rjmp	80007154 <udc_reqstd+0x118>
				break;
			}
		}
#endif
	}
	return false;
80007152:	30 08       	mov	r8,0
}
80007154:	10 9c       	mov	r12,r8
80007156:	e3 cd 80 80 	ldm	sp++,r7,pc
8000715a:	00 00       	add	r0,r0
8000715c:	00 00       	add	r0,r0
8000715e:	46 48       	lddsp	r8,sp[0x190]
80007160:	80 00       	ld.sh	r0,r0[0x0]
80007162:	6a 68       	ld.w	r8,r5[0x18]
80007164:	80 00       	ld.sh	r0,r0[0x0]
80007166:	6d 34       	ld.w	r4,r6[0x4c]
80007168:	80 00       	ld.sh	r0,r0[0x0]
8000716a:	6e 18       	ld.w	r8,r7[0x4]
8000716c:	80 00       	ld.sh	r0,r0[0x0]
8000716e:	6f 1c       	ld.w	r12,r7[0x44]
80007170:	80 00       	ld.sh	r0,r0[0x0]
80007172:	6a 9c       	ld.w	r12,r5[0x24]
80007174:	80 00       	ld.sh	r0,r0[0x0]
80007176:	6c 0c       	ld.w	r12,r6[0x0]
80007178:	80 00       	ld.sh	r0,r0[0x0]
8000717a:	6a f4       	ld.w	r4,r5[0x3c]
8000717c:	80 00       	ld.sh	r0,r0[0x0]
8000717e:	6b 70       	ld.w	r0,r5[0x5c]
80007180:	80 00       	ld.sh	r0,r0[0x0]
80007182:	6e 4c       	ld.w	r12,r7[0x10]
80007184:	80 00       	ld.sh	r0,r0[0x0]
80007186:	6f c8       	ld.w	r8,r7[0x70]
80007188:	80 00       	ld.sh	r0,r0[0x0]
8000718a:	6b 34       	ld.w	r4,r5[0x4c]
8000718c:	80 00       	ld.sh	r0,r0[0x0]
8000718e:	6b 9c       	ld.w	r12,r5[0x64]

80007190 <udc_req_iface>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_iface(void)
{
80007190:	eb cd 40 80 	pushm	r7,lr
80007194:	1a 97       	mov	r7,sp
80007196:	20 2d       	sub	sp,8
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
80007198:	4a 58       	lddpc	r8,8000722c <udc_req_iface+0x9c>
8000719a:	11 88       	ld.ub	r8,r8[0x0]
8000719c:	58 08       	cp.w	r8,0
8000719e:	c0 31       	brne	800071a4 <udc_req_iface+0x14>
		return false; // The device is not is configured state yet
800071a0:	30 08       	mov	r8,0
800071a2:	c4 08       	rjmp	80007222 <udc_req_iface+0x92>
	}
	// Check interface number
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
800071a4:	4a 38       	lddpc	r8,80007230 <udc_req_iface+0xa0>
800071a6:	90 28       	ld.sh	r8,r8[0x4]
800071a8:	ef 68 ff fb 	st.b	r7[-5],r8
	if (iface_num >= udc_ptr_conf->desc->bNumInterfaces) {
800071ac:	4a 28       	lddpc	r8,80007234 <udc_req_iface+0xa4>
800071ae:	70 08       	ld.w	r8,r8[0x0]
800071b0:	70 08       	ld.w	r8,r8[0x0]
800071b2:	11 c8       	ld.ub	r8,r8[0x4]
800071b4:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800071b8:	f0 09 18 00 	cp.b	r9,r8
800071bc:	c0 33       	brcs	800071c2 <udc_req_iface+0x32>
		return false;
800071be:	30 08       	mov	r8,0
800071c0:	c3 18       	rjmp	80007222 <udc_req_iface+0x92>
	}

	//* To update udc_ptr_iface with the selected interface in request
	// Select first alternate setting of interface to update udc_ptr_iface
	// before calling udi_api->getsetting()
	if (!udc_update_iface_desc(iface_num, 0)) {
800071c2:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800071c6:	30 0b       	mov	r11,0
800071c8:	10 9c       	mov	r12,r8
800071ca:	f0 1f 00 1c 	mcall	80007238 <udc_req_iface+0xa8>
800071ce:	18 98       	mov	r8,r12
800071d0:	ec 18 00 01 	eorl	r8,0x1
800071d4:	5c 58       	castu.b	r8
800071d6:	c0 30       	breq	800071dc <udc_req_iface+0x4c>
		return false;
800071d8:	30 08       	mov	r8,0
800071da:	c2 48       	rjmp	80007222 <udc_req_iface+0x92>
	}
	// Select the interface with the current alternate setting
	udi_api = udc_ptr_conf->udi_apis[iface_num];
800071dc:	49 68       	lddpc	r8,80007234 <udc_req_iface+0xa4>
800071de:	70 08       	ld.w	r8,r8[0x0]
800071e0:	70 19       	ld.w	r9,r8[0x4]
800071e2:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800071e6:	a3 68       	lsl	r8,0x2
800071e8:	f2 08 00 08 	add	r8,r9,r8
800071ec:	70 08       	ld.w	r8,r8[0x0]
800071ee:	ef 48 ff fc 	st.w	r7[-4],r8
	if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
800071f2:	ee f8 ff fc 	ld.w	r8,r7[-4]
800071f6:	70 38       	ld.w	r8,r8[0xc]
800071f8:	5d 18       	icall	r8
800071fa:	18 98       	mov	r8,r12
800071fc:	10 99       	mov	r9,r8
800071fe:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80007202:	12 9b       	mov	r11,r9
80007204:	10 9c       	mov	r12,r8
80007206:	f0 1f 00 0d 	mcall	80007238 <udc_req_iface+0xa8>
8000720a:	18 98       	mov	r8,r12
8000720c:	ec 18 00 01 	eorl	r8,0x1
80007210:	5c 58       	castu.b	r8
80007212:	c0 30       	breq	80007218 <udc_req_iface+0x88>
		return false;
80007214:	30 08       	mov	r8,0
80007216:	c0 68       	rjmp	80007222 <udc_req_iface+0x92>
	}

	// Send the SETUP request to the UDI corresponding to the interface number
	return udi_api->setup();
80007218:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000721c:	70 28       	ld.w	r8,r8[0x8]
8000721e:	5d 18       	icall	r8
80007220:	18 98       	mov	r8,r12
}
80007222:	10 9c       	mov	r12,r8
80007224:	2f ed       	sub	sp,-8
80007226:	e3 cd 80 80 	ldm	sp++,r7,pc
8000722a:	00 00       	add	r0,r0
8000722c:	00 00       	add	r0,r0
8000722e:	07 26       	ld.uh	r6,r3++
80007230:	00 00       	add	r0,r0
80007232:	46 48       	lddsp	r8,sp[0x190]
80007234:	00 00       	add	r0,r0
80007236:	07 28       	ld.uh	r8,r3++
80007238:	80 00       	ld.sh	r0,r0[0x0]
8000723a:	67 48       	ld.w	r8,r3[0x50]

8000723c <udc_req_ep>:
 * \brief Send the SETUP interface request to UDI
 *
 * \return true if the request is supported
 */
static bool udc_req_ep(void)
{
8000723c:	eb cd 40 80 	pushm	r7,lr
80007240:	1a 97       	mov	r7,sp
80007242:	20 2d       	sub	sp,8
	uint8_t iface_num;
	udi_api_t UDC_DESC_STORAGE *udi_api;

	if (0 == udc_num_configuration) {
80007244:	4a 48       	lddpc	r8,800072d4 <udc_req_ep+0x98>
80007246:	11 88       	ld.ub	r8,r8[0x0]
80007248:	58 08       	cp.w	r8,0
8000724a:	c0 31       	brne	80007250 <udc_req_ep+0x14>
		return false; // The device is not is configured state yet
8000724c:	30 08       	mov	r8,0
8000724e:	c3 f8       	rjmp	800072cc <udc_req_ep+0x90>
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
80007250:	4a 28       	lddpc	r8,800072d8 <udc_req_ep+0x9c>
80007252:	90 28       	ld.sh	r8,r8[0x4]
80007254:	ef 68 ff fb 	st.b	r7[-5],r8
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
80007258:	30 08       	mov	r8,0
8000725a:	ef 68 ff fb 	st.b	r7[-5],r8
8000725e:	c2 d8       	rjmp	800072b8 <udc_req_ep+0x7c>
			iface_num++) {
		// Select the interface with the current alternate setting
		udi_api = udc_ptr_conf->udi_apis[iface_num];
80007260:	49 f8       	lddpc	r8,800072dc <udc_req_ep+0xa0>
80007262:	70 08       	ld.w	r8,r8[0x0]
80007264:	70 19       	ld.w	r9,r8[0x4]
80007266:	ef 38 ff fb 	ld.ub	r8,r7[-5]
8000726a:	a3 68       	lsl	r8,0x2
8000726c:	f2 08 00 08 	add	r8,r9,r8
80007270:	70 08       	ld.w	r8,r8[0x0]
80007272:	ef 48 ff fc 	st.w	r7[-4],r8
		if (!udc_update_iface_desc(iface_num, udi_api->getsetting())) {
80007276:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000727a:	70 38       	ld.w	r8,r8[0xc]
8000727c:	5d 18       	icall	r8
8000727e:	18 98       	mov	r8,r12
80007280:	10 99       	mov	r9,r8
80007282:	ef 38 ff fb 	ld.ub	r8,r7[-5]
80007286:	12 9b       	mov	r11,r9
80007288:	10 9c       	mov	r12,r8
8000728a:	f0 1f 00 16 	mcall	800072e0 <udc_req_ep+0xa4>
8000728e:	18 98       	mov	r8,r12
80007290:	ec 18 00 01 	eorl	r8,0x1
80007294:	5c 58       	castu.b	r8
80007296:	c0 30       	breq	8000729c <udc_req_ep+0x60>
			return false;
80007298:	30 08       	mov	r8,0
8000729a:	c1 98       	rjmp	800072cc <udc_req_ep+0x90>
		}

		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
8000729c:	ee f8 ff fc 	ld.w	r8,r7[-4]
800072a0:	70 28       	ld.w	r8,r8[0x8]
800072a2:	5d 18       	icall	r8
800072a4:	18 98       	mov	r8,r12
800072a6:	58 08       	cp.w	r8,0
800072a8:	c0 30       	breq	800072ae <udc_req_ep+0x72>
			return true;
800072aa:	30 18       	mov	r8,1
800072ac:	c1 08       	rjmp	800072cc <udc_req_ep+0x90>
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
			iface_num++) {
800072ae:	ef 38 ff fb 	ld.ub	r8,r7[-5]
800072b2:	2f f8       	sub	r8,-1
800072b4:	ef 68 ff fb 	st.b	r7[-5],r8
	if (0 == udc_num_configuration) {
		return false; // The device is not is configured state yet
	}
	// Send this request on all enabled interfaces
	iface_num = udd_g_ctrlreq.req.wIndex & 0xFF;
	for (iface_num = 0; iface_num < udc_ptr_conf->desc->bNumInterfaces;
800072b8:	48 98       	lddpc	r8,800072dc <udc_req_ep+0xa0>
800072ba:	70 08       	ld.w	r8,r8[0x0]
800072bc:	70 08       	ld.w	r8,r8[0x0]
800072be:	11 c8       	ld.ub	r8,r8[0x4]
800072c0:	ef 39 ff fb 	ld.ub	r9,r7[-5]
800072c4:	f0 09 18 00 	cp.b	r9,r8
800072c8:	cc c3       	brcs	80007260 <udc_req_ep+0x24>
		// Send the SETUP request to the UDI
		if (udi_api->setup()) {
			return true;
		}
	}
	return false;
800072ca:	30 08       	mov	r8,0
}
800072cc:	10 9c       	mov	r12,r8
800072ce:	2f ed       	sub	sp,-8
800072d0:	e3 cd 80 80 	ldm	sp++,r7,pc
800072d4:	00 00       	add	r0,r0
800072d6:	07 26       	ld.uh	r6,r3++
800072d8:	00 00       	add	r0,r0
800072da:	46 48       	lddsp	r8,sp[0x190]
800072dc:	00 00       	add	r0,r0
800072de:	07 28       	ld.uh	r8,r3++
800072e0:	80 00       	ld.sh	r0,r0[0x0]
800072e2:	67 48       	ld.w	r8,r3[0x50]

800072e4 <udc_process_setup>:
 * sent to a specific application callback.
 *
 * \return true if the request is supported, else the request is stalled by UDD
 */
bool udc_process_setup(void)
{
800072e4:	eb cd 40 80 	pushm	r7,lr
800072e8:	1a 97       	mov	r7,sp
	// By default no data (receive/send) and no callbacks registered
	udd_g_ctrlreq.payload_size = 0;
800072ea:	4a 19       	lddpc	r9,8000736c <udc_process_setup+0x88>
800072ec:	30 08       	mov	r8,0
800072ee:	b2 68       	st.h	r9[0xc],r8
	udd_g_ctrlreq.callback = NULL;
800072f0:	49 f8       	lddpc	r8,8000736c <udc_process_setup+0x88>
800072f2:	30 09       	mov	r9,0
800072f4:	91 49       	st.w	r8[0x10],r9
	udd_g_ctrlreq.over_under_run = NULL;
800072f6:	49 e8       	lddpc	r8,8000736c <udc_process_setup+0x88>
800072f8:	30 09       	mov	r9,0
800072fa:	91 59       	st.w	r8[0x14],r9

	if (Udd_setup_is_in()) {
800072fc:	49 c8       	lddpc	r8,8000736c <udc_process_setup+0x88>
800072fe:	11 88       	ld.ub	r8,r8[0x0]
80007300:	10 99       	mov	r9,r8
80007302:	30 08       	mov	r8,0
80007304:	f0 09 18 00 	cp.b	r9,r8
80007308:	c0 74       	brge	80007316 <udc_process_setup+0x32>
		if (udd_g_ctrlreq.req.wLength == 0) {
8000730a:	49 98       	lddpc	r8,8000736c <udc_process_setup+0x88>
8000730c:	90 38       	ld.sh	r8,r8[0x6]
8000730e:	58 08       	cp.w	r8,0
80007310:	c0 31       	brne	80007316 <udc_process_setup+0x32>
			return false; // Error from USB host
80007312:	30 08       	mov	r8,0
80007314:	c2 88       	rjmp	80007364 <udc_process_setup+0x80>
		}
	}

	// If standard request then try to decode it in UDC
	if (Udd_setup_type() == USB_REQ_TYPE_STANDARD) {
80007316:	49 68       	lddpc	r8,8000736c <udc_process_setup+0x88>
80007318:	11 88       	ld.ub	r8,r8[0x0]
8000731a:	e2 18 00 60 	andl	r8,0x60,COH
8000731e:	c0 81       	brne	8000732e <udc_process_setup+0x4a>
		if (udc_reqstd()) {
80007320:	f0 1f 00 14 	mcall	80007370 <udc_process_setup+0x8c>
80007324:	18 98       	mov	r8,r12
80007326:	58 08       	cp.w	r8,0
80007328:	c0 30       	breq	8000732e <udc_process_setup+0x4a>
			return true;
8000732a:	30 18       	mov	r8,1
8000732c:	c1 c8       	rjmp	80007364 <udc_process_setup+0x80>
		}
	}

	// If interface request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_INTERFACE) {
8000732e:	49 08       	lddpc	r8,8000736c <udc_process_setup+0x88>
80007330:	11 88       	ld.ub	r8,r8[0x0]
80007332:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80007336:	58 18       	cp.w	r8,1
80007338:	c0 81       	brne	80007348 <udc_process_setup+0x64>
		if (udc_req_iface()) {
8000733a:	f0 1f 00 0f 	mcall	80007374 <udc_process_setup+0x90>
8000733e:	18 98       	mov	r8,r12
80007340:	58 08       	cp.w	r8,0
80007342:	c0 30       	breq	80007348 <udc_process_setup+0x64>
			return true;
80007344:	30 18       	mov	r8,1
80007346:	c0 f8       	rjmp	80007364 <udc_process_setup+0x80>
		}
	}

	// If endpoint request then try to decode it in UDI
	if (Udd_setup_recipient() == USB_REQ_RECIP_ENDPOINT) {
80007348:	48 98       	lddpc	r8,8000736c <udc_process_setup+0x88>
8000734a:	11 88       	ld.ub	r8,r8[0x0]
8000734c:	f1 d8 c0 05 	bfextu	r8,r8,0x0,0x5
80007350:	58 28       	cp.w	r8,2
80007352:	c0 81       	brne	80007362 <udc_process_setup+0x7e>
		if (udc_req_ep()) {
80007354:	f0 1f 00 09 	mcall	80007378 <udc_process_setup+0x94>
80007358:	18 98       	mov	r8,r12
8000735a:	58 08       	cp.w	r8,0
8000735c:	c0 30       	breq	80007362 <udc_process_setup+0x7e>
			return true;
8000735e:	30 18       	mov	r8,1
80007360:	c0 28       	rjmp	80007364 <udc_process_setup+0x80>
	// Here SETUP request unknown by UDC and UDIs
#ifdef USB_DEVICE_SPECIFIC_REQUEST
	// Try to decode it in specific callback
	return USB_DEVICE_SPECIFIC_REQUEST(); // Ex: Vendor request,...
#else
	return false;
80007362:	30 08       	mov	r8,0
#endif
}
80007364:	10 9c       	mov	r12,r8
80007366:	e3 cd 80 80 	ldm	sp++,r7,pc
8000736a:	00 00       	add	r0,r0
8000736c:	00 00       	add	r0,r0
8000736e:	46 48       	lddsp	r8,sp[0x190]
80007370:	80 00       	ld.sh	r0,r0[0x0]
80007372:	70 3c       	ld.w	r12,r8[0xc]
80007374:	80 00       	ld.sh	r0,r0[0x0]
80007376:	71 90       	ld.w	r0,r8[0x64]
80007378:	80 00       	ld.sh	r0,r0[0x0]
8000737a:	72 3c       	ld.w	r12,r9[0xc]

8000737c <pm_sleep>:
#else
# error Unsupported AVR UC3 series.
#endif

static inline void pm_sleep(int sleep_mode)
{
8000737c:	eb cd 40 80 	pushm	r7,lr
80007380:	1a 97       	mov	r7,sp
80007382:	20 1d       	sub	sp,4
80007384:	ef 4c ff fc 	st.w	r7[-4],r12
	switch (sleep_mode) {
80007388:	ee f8 ff fc 	ld.w	r8,r7[-4]
8000738c:	58 58       	cp.w	r8,5
8000738e:	c4 30       	breq	80007414 <pm_sleep+0x98>
80007390:	e0 89 00 10 	brgt	800073b0 <pm_sleep+0x34>
80007394:	58 28       	cp.w	r8,2
80007396:	c2 d0       	breq	800073f0 <pm_sleep+0x74>
80007398:	e0 89 00 07 	brgt	800073a6 <pm_sleep+0x2a>
8000739c:	58 08       	cp.w	r8,0
8000739e:	c1 d0       	breq	800073d8 <pm_sleep+0x5c>
800073a0:	58 18       	cp.w	r8,1
800073a2:	c2 10       	breq	800073e4 <pm_sleep+0x68>
800073a4:	c3 d8       	rjmp	8000741e <pm_sleep+0xa2>
800073a6:	58 38       	cp.w	r8,3
800073a8:	c2 a0       	breq	800073fc <pm_sleep+0x80>
800073aa:	58 48       	cp.w	r8,4
800073ac:	c2 e0       	breq	80007408 <pm_sleep+0x8c>
800073ae:	c3 88       	rjmp	8000741e <pm_sleep+0xa2>
800073b0:	e0 48 00 82 	cp.w	r8,130
800073b4:	c2 10       	breq	800073f6 <pm_sleep+0x7a>
800073b6:	e0 89 00 09 	brgt	800073c8 <pm_sleep+0x4c>
800073ba:	e0 48 00 80 	cp.w	r8,128
800073be:	c1 00       	breq	800073de <pm_sleep+0x62>
800073c0:	e0 48 00 81 	cp.w	r8,129
800073c4:	c1 30       	breq	800073ea <pm_sleep+0x6e>
800073c6:	c2 c8       	rjmp	8000741e <pm_sleep+0xa2>
800073c8:	e0 48 00 84 	cp.w	r8,132
800073cc:	c2 10       	breq	8000740e <pm_sleep+0x92>
800073ce:	c1 a5       	brlt	80007402 <pm_sleep+0x86>
800073d0:	e0 48 00 85 	cp.w	r8,133
800073d4:	c2 30       	breq	8000741a <pm_sleep+0x9e>
800073d6:	c2 48       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_IDLE:
		SLEEP(AVR32_PM_SMODE_IDLE);
800073d8:	e9 b0 00 00 	sleep	0x0
		break;
800073dc:	c2 18       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_IDLE:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_IDLE);
800073de:	e9 b0 00 80 	sleep	0x80
		break;
800073e2:	c1 e8       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_FROZEN:
		SLEEP(AVR32_PM_SMODE_FROZEN);
800073e4:	e9 b0 00 01 	sleep	0x1
		break;
800073e8:	c1 b8       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_FROZEN:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_FROZEN);
800073ea:	e9 b0 00 81 	sleep	0x81
		break;
800073ee:	c1 88       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_STANDBY:
		SLEEP(AVR32_PM_SMODE_STANDBY);
800073f0:	e9 b0 00 02 	sleep	0x2
		break;
800073f4:	c1 58       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STANDBY:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STANDBY);
800073f6:	e9 b0 00 82 	sleep	0x82
		break;
800073fa:	c1 28       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_STOP:
		SLEEP(AVR32_PM_SMODE_STOP);
800073fc:	e9 b0 00 03 	sleep	0x3
		break;
80007400:	c0 f8       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STOP:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STOP);
80007402:	e9 b0 00 83 	sleep	0x83
		break;
80007406:	c0 c8       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_DEEPSTOP:
		SLEEP(AVR32_PM_SMODE_DEEPSTOP);
80007408:	e9 b0 00 04 	sleep	0x4
		break;
8000740c:	c0 98       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_DEEPSTOP:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_DEEPSTOP);
8000740e:	e9 b0 00 84 	sleep	0x84
		break;
80007412:	c0 68       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_STATIC:
		SLEEP(AVR32_PM_SMODE_STATIC);
80007414:	e9 b0 00 05 	sleep	0x5
		break;
80007418:	c0 38       	rjmp	8000741e <pm_sleep+0xa2>
	case AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STATIC:
		SLEEP(AVR32_PM_SMODE_GMCLEAR_MASK | AVR32_PM_SMODE_STATIC);
8000741a:	e9 b0 00 85 	sleep	0x85
		break;
#endif
	default:
		break;
	}
}
8000741e:	2f fd       	sub	sp,-4
80007420:	e3 cd 80 80 	ldm	sp++,r7,pc

80007424 <sleepmgr_sleep>:
//! @}



static inline void sleepmgr_sleep(const enum sleepmgr_mode sleep_mode)
{
80007424:	eb cd 40 80 	pushm	r7,lr
80007428:	1a 97       	mov	r7,sp
8000742a:	20 1d       	sub	sp,4
8000742c:	ef 4c ff fc 	st.w	r7[-4],r12
	Assert(sleep_mode != SLEEPMGR_ACTIVE);
#ifdef CONFIG_SLEEPMGR_ENABLE
	cpu_irq_disable();
80007430:	d3 03       	ssrf	0x10

	// Atomically enable the global interrupts and enter the sleep mode.
	pm_sleep(AVR32_PM_SMODE_GMCLEAR_MASK | (sleep_mode-1));
80007432:	ee f8 ff fc 	ld.w	r8,r7[-4]
80007436:	20 18       	sub	r8,1
80007438:	a7 b8       	sbr	r8,0x7
8000743a:	10 9c       	mov	r12,r8
8000743c:	f0 1f 00 03 	mcall	80007448 <sleepmgr_sleep+0x24>
#else
	cpu_irq_enable();
#endif /* CONFIG_SLEEPMGR_ENABLE */

}
80007440:	2f fd       	sub	sp,-4
80007442:	e3 cd 80 80 	ldm	sp++,r7,pc
80007446:	00 00       	add	r0,r0
80007448:	80 00       	ld.sh	r0,r0[0x0]
8000744a:	73 7c       	ld.w	r12,r9[0x5c]

8000744c <sleepmgr_init>:
 * Sets all lock counts to 0, except the very last one, which is set to 1. This
 * is done to simplify the algorithm for finding the deepest allowable sleep
 * mode in \ref sleepmgr_enter_sleep.
 */
static inline void sleepmgr_init(void)
{
8000744c:	eb cd 40 80 	pushm	r7,lr
80007450:	1a 97       	mov	r7,sp
80007452:	20 1d       	sub	sp,4
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
80007454:	30 08       	mov	r8,0
80007456:	ef 68 ff ff 	st.b	r7[-1],r8
8000745a:	c0 c8       	rjmp	80007472 <sleepmgr_init+0x26>
		sleepmgr_locks[i] = 0;
8000745c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007460:	48 ba       	lddpc	r10,8000748c <sleepmgr_init+0x40>
80007462:	30 08       	mov	r8,0
80007464:	f4 09 0b 08 	st.b	r10[r9],r8
static inline void sleepmgr_init(void)
{
#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t i;

	for (i = 0; i < SLEEPMGR_NR_OF_MODES - 1; i++) {
80007468:	ef 38 ff ff 	ld.ub	r8,r7[-1]
8000746c:	2f f8       	sub	r8,-1
8000746e:	ef 68 ff ff 	st.b	r7[-1],r8
80007472:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007476:	30 58       	mov	r8,5
80007478:	f0 09 18 00 	cp.b	r9,r8
8000747c:	fe 98 ff f0 	brls	8000745c <sleepmgr_init+0x10>
		sleepmgr_locks[i] = 0;
	}
	sleepmgr_locks[SLEEPMGR_NR_OF_MODES - 1] = 1;
80007480:	48 39       	lddpc	r9,8000748c <sleepmgr_init+0x40>
80007482:	30 18       	mov	r8,1
80007484:	b2 e8       	st.b	r9[0x6],r8
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
80007486:	2f fd       	sub	sp,-4
80007488:	e3 cd 80 80 	ldm	sp++,r7,pc
8000748c:	00 00       	add	r0,r0
8000748e:	46 60       	lddsp	r0,sp[0x198]

80007490 <sleepmgr_get_sleep_mode>:
 * Searches through the sleep mode lock counts, starting at the shallowest sleep
 * mode, until the first non-zero lock count is found. The deepest allowable
 * sleep mode is then returned.
 */
static inline enum sleepmgr_mode sleepmgr_get_sleep_mode(void)
{
80007490:	eb cd 40 80 	pushm	r7,lr
80007494:	1a 97       	mov	r7,sp
80007496:	20 2d       	sub	sp,8
	enum sleepmgr_mode sleep_mode = SLEEPMGR_ACTIVE;
80007498:	30 08       	mov	r8,0
8000749a:	ef 48 ff f8 	st.w	r7[-8],r8

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;
8000749e:	48 d8       	lddpc	r8,800074d0 <sleepmgr_get_sleep_mode+0x40>
800074a0:	ef 48 ff fc 	st.w	r7[-4],r8

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
800074a4:	c0 b8       	rjmp	800074ba <sleepmgr_get_sleep_mode+0x2a>
		lock_ptr++;
800074a6:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074aa:	2f f8       	sub	r8,-1
800074ac:	ef 48 ff fc 	st.w	r7[-4],r8
		sleep_mode = (enum sleepmgr_mode)(sleep_mode + 1);
800074b0:	ee f8 ff f8 	ld.w	r8,r7[-8]
800074b4:	2f f8       	sub	r8,-1
800074b6:	ef 48 ff f8 	st.w	r7[-8],r8

#ifdef CONFIG_SLEEPMGR_ENABLE
	uint8_t *lock_ptr = sleepmgr_locks;

	// Find first non-zero lock count, starting with the shallowest modes.
	while (!(*lock_ptr)) {
800074ba:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074be:	11 88       	ld.ub	r8,r8[0x0]
800074c0:	58 08       	cp.w	r8,0
800074c2:	cf 20       	breq	800074a6 <sleepmgr_get_sleep_mode+0x16>
	// performed on the deepest sleep mode.
	Assert((uintptr_t)(lock_ptr - sleepmgr_locks) < SLEEPMGR_NR_OF_MODES);

#endif /* CONFIG_SLEEPMGR_ENABLE */

	return sleep_mode;
800074c4:	ee f8 ff f8 	ld.w	r8,r7[-8]
}
800074c8:	10 9c       	mov	r12,r8
800074ca:	2f ed       	sub	sp,-8
800074cc:	e3 cd 80 80 	ldm	sp++,r7,pc
800074d0:	00 00       	add	r0,r0
800074d2:	46 60       	lddsp	r0,sp[0x198]

800074d4 <sleepmgr_enter_sleep>:
 * them enabled upon return. This also applies if sleep is skipped due to ACTIVE
 * mode being locked.
 */

static inline void sleepmgr_enter_sleep(void)
{
800074d4:	eb cd 40 80 	pushm	r7,lr
800074d8:	1a 97       	mov	r7,sp
800074da:	20 1d       	sub	sp,4
#ifdef CONFIG_SLEEPMGR_ENABLE
	enum sleepmgr_mode sleep_mode;

	cpu_irq_disable();
800074dc:	d3 03       	ssrf	0x10

	// Find the deepest allowable sleep mode
	sleep_mode = sleepmgr_get_sleep_mode();
800074de:	f0 1f 00 0a 	mcall	80007504 <sleepmgr_enter_sleep+0x30>
800074e2:	18 98       	mov	r8,r12
800074e4:	ef 48 ff fc 	st.w	r7[-4],r8
	// Return right away if first mode (ACTIVE) is locked.
	if (sleep_mode==SLEEPMGR_ACTIVE) {
800074e8:	ee f8 ff fc 	ld.w	r8,r7[-4]
800074ec:	58 08       	cp.w	r8,0
800074ee:	c0 31       	brne	800074f4 <sleepmgr_enter_sleep+0x20>
		cpu_irq_enable();
800074f0:	d5 03       	csrf	0x10
		return;
800074f2:	c0 58       	rjmp	800074fc <sleepmgr_enter_sleep+0x28>
	}
	// Enter the deepest allowable sleep mode with interrupts enabled
	sleepmgr_sleep(sleep_mode);
800074f4:	ee fc ff fc 	ld.w	r12,r7[-4]
800074f8:	f0 1f 00 04 	mcall	80007508 <sleepmgr_enter_sleep+0x34>
#else
	cpu_irq_enable();
#endif /* CONFIG_SLEEPMGR_ENABLE */
}
800074fc:	2f fd       	sub	sp,-4
800074fe:	e3 cd 80 80 	ldm	sp++,r7,pc
80007502:	00 00       	add	r0,r0
80007504:	80 00       	ld.sh	r0,r0[0x0]
80007506:	74 90       	ld.w	r0,r10[0x24]
80007508:	80 00       	ld.sh	r0,r0[0x0]
8000750a:	74 24       	ld.w	r4,r10[0x8]

8000750c <udc_attach>:
 * \warning If a VBus control is included in driver,
 * then it will attach device when an acceptable Vbus
 * level from the host is detected.
 */
static inline void udc_attach(void)
{
8000750c:	eb cd 40 80 	pushm	r7,lr
80007510:	1a 97       	mov	r7,sp
	udd_attach();
80007512:	f0 1f 00 03 	mcall	8000751c <udc_attach+0x10>
}
80007516:	e3 cd 80 80 	ldm	sp++,r7,pc
8000751a:	00 00       	add	r0,r0
8000751c:	80 00       	ld.sh	r0,r0[0x0]
8000751e:	34 48       	mov	r8,68

80007520 <udc_detach>:
 * \brief Detaches the device from the bus
 *
 * The driver must remove pull-up on USB line D- or D+.
 */
static inline void udc_detach(void)
{
80007520:	eb cd 40 80 	pushm	r7,lr
80007524:	1a 97       	mov	r7,sp
	udd_detach();
80007526:	f0 1f 00 03 	mcall	80007530 <udc_detach+0x10>
}
8000752a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000752e:	00 00       	add	r0,r0
80007530:	80 00       	ld.sh	r0,r0[0x0]
80007532:	34 f8       	mov	r8,79

80007534 <main>:
static volatile bool main_b_cdc_enable = false;

/*! \brief Main function. Execution starts here.
 */
int main(void)
{
80007534:	eb cd 40 80 	pushm	r7,lr
80007538:	1a 97       	mov	r7,sp
	// Initialise system clocks.
	sysclk_init();
8000753a:	f0 1f 00 24 	mcall	800075c8 <main+0x94>
	
	// Enable all interrupts.
	irq_initialize_vectors();
8000753e:	f0 1f 00 24 	mcall	800075cc <main+0x98>
	cpu_irq_enable();
80007542:	d5 03       	csrf	0x10
	
	// Initialise board GPIO mappings.
	board_init();
80007544:	f0 1f 00 23 	mcall	800075d0 <main+0x9c>
	
	// Initialize the sleep manager
	sleepmgr_init();
80007548:	f0 1f 00 23 	mcall	800075d4 <main+0xa0>

	// Start USB stack to authorize VBus monitoring
	udc_start();
8000754c:	f0 1f 00 23 	mcall	800075d8 <main+0xa4>

	// Initialise triggers.
	readUSB			= 0;
80007550:	4a 39       	lddpc	r9,800075dc <main+0xa8>
80007552:	30 08       	mov	r8,0
80007554:	b2 88       	st.b	r9[0x0],r8
	triggerUSART	= 0;
80007556:	4a 39       	lddpc	r9,800075e0 <main+0xac>
80007558:	30 08       	mov	r8,0
8000755a:	b2 88       	st.b	r9[0x0],r8
	// The main loop manages only the power mode
	// because the USB management is done by interrupt
	while (true)
	{
		// Check to see if there is data in the USB RX FIFO to read in.
		if (readUSB == 1)
8000755c:	4a 08       	lddpc	r8,800075dc <main+0xa8>
8000755e:	11 89       	ld.ub	r9,r8[0x0]
80007560:	30 18       	mov	r8,1
80007562:	f0 09 18 00 	cp.b	r9,r8
80007566:	c0 31       	brne	8000756c <main+0x38>
		{
			receiveUSBData();
80007568:	f0 1f 00 1f 	mcall	800075e4 <main+0xb0>
		}
		
		// Check to see if a USART ISR has been triggered.
		if (triggerUSART & 0x01)
8000756c:	49 d8       	lddpc	r8,800075e0 <main+0xac>
8000756e:	11 88       	ld.ub	r8,r8[0x0]
80007570:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007574:	5c 58       	castu.b	r8
80007576:	c0 40       	breq	8000757e <main+0x4a>
		{
			// USART0.
			motorBusIntteruptController(0);
80007578:	30 0c       	mov	r12,0
8000757a:	f0 1f 00 1c 	mcall	800075e8 <main+0xb4>
		}
		
		if (triggerUSART & 0x02)
8000757e:	49 98       	lddpc	r8,800075e0 <main+0xac>
80007580:	11 88       	ld.ub	r8,r8[0x0]
80007582:	e2 18 00 02 	andl	r8,0x2,COH
80007586:	c0 40       	breq	8000758e <main+0x5a>
		{
			// USART1.
			motorBusIntteruptController(1);
80007588:	30 1c       	mov	r12,1
8000758a:	f0 1f 00 18 	mcall	800075e8 <main+0xb4>

		}
		
		if (triggerUSART & 0x04)
8000758e:	49 58       	lddpc	r8,800075e0 <main+0xac>
80007590:	11 88       	ld.ub	r8,r8[0x0]
80007592:	e2 18 00 04 	andl	r8,0x4,COH
80007596:	c0 40       	breq	8000759e <main+0x6a>
		{
			// USART2.
			motorBusIntteruptController(2);
80007598:	30 2c       	mov	r12,2
8000759a:	f0 1f 00 14 	mcall	800075e8 <main+0xb4>
		}
		
		if (triggerUSART & 0x08)
8000759e:	49 18       	lddpc	r8,800075e0 <main+0xac>
800075a0:	11 88       	ld.ub	r8,r8[0x0]
800075a2:	e2 18 00 08 	andl	r8,0x8,COH
800075a6:	c0 40       	breq	800075ae <main+0x7a>
		{
			// USART3.
			motorBusIntteruptController(3);
800075a8:	30 3c       	mov	r12,3
800075aa:	f0 1f 00 10 	mcall	800075e8 <main+0xb4>
		}
		
		if (triggerUSART & 0x10)
800075ae:	48 d8       	lddpc	r8,800075e0 <main+0xac>
800075b0:	11 88       	ld.ub	r8,r8[0x0]
800075b2:	e2 18 00 10 	andl	r8,0x10,COH
800075b6:	c0 40       	breq	800075be <main+0x8a>
		{
			// USART4.
			motorBusIntteruptController(4);
800075b8:	30 4c       	mov	r12,4
800075ba:	f0 1f 00 0c 	mcall	800075e8 <main+0xb4>
		}
		
		// Check  to see if we need to process any packets.
		processPacket();
800075be:	f0 1f 00 0c 	mcall	800075ec <main+0xb8>
		
		sleepmgr_enter_sleep();
800075c2:	f0 1f 00 0c 	mcall	800075f0 <main+0xbc>
	}
800075c6:	cc bb       	rjmp	8000755c <main+0x28>
800075c8:	80 00       	ld.sh	r0,r0[0x0]
800075ca:	54 80       	stdsp	sp[0x120],r0
800075cc:	80 00       	ld.sh	r0,r0[0x0]
800075ce:	2e 04       	sub	r4,-32
800075d0:	80 00       	ld.sh	r0,r0[0x0]
800075d2:	20 08       	sub	r8,0
800075d4:	80 00       	ld.sh	r0,r0[0x0]
800075d6:	74 4c       	ld.w	r12,r10[0x10]
800075d8:	80 00       	ld.sh	r0,r0[0x0]
800075da:	69 84       	ld.w	r4,r4[0x60]
800075dc:	00 00       	add	r0,r0
800075de:	46 44       	lddsp	r4,sp[0x190]
800075e0:	00 00       	add	r0,r0
800075e2:	46 45       	lddsp	r5,sp[0x190]
800075e4:	80 00       	ld.sh	r0,r0[0x0]
800075e6:	78 50       	ld.w	r0,r12[0x14]
800075e8:	80 00       	ld.sh	r0,r0[0x0]
800075ea:	7f f4       	ld.w	r4,pc[0x7c]
800075ec:	80 00       	ld.sh	r0,r0[0x0]
800075ee:	79 a8       	ld.w	r8,r12[0x68]
800075f0:	80 00       	ld.sh	r0,r0[0x0]
800075f2:	74 d4       	ld.w	r4,r10[0x34]

800075f4 <main_suspend_action>:
}

void main_suspend_action(void)
{
800075f4:	eb cd 40 80 	pushm	r7,lr
800075f8:	1a 97       	mov	r7,sp
	;
}
800075fa:	e3 cd 80 80 	ldm	sp++,r7,pc

800075fe <main_resume_action>:

void main_resume_action(void)
{
800075fe:	eb cd 40 80 	pushm	r7,lr
80007602:	1a 97       	mov	r7,sp
	;
}
80007604:	e3 cd 80 80 	ldm	sp++,r7,pc

80007608 <main_sof_action>:

void main_sof_action(void)
{
80007608:	eb cd 40 80 	pushm	r7,lr
8000760c:	1a 97       	mov	r7,sp
	;
}
8000760e:	e3 cd 80 80 	ldm	sp++,r7,pc
80007612:	d7 03       	nop

80007614 <main_cdc_enable>:

bool main_cdc_enable(uint8_t port)
{
80007614:	eb cd 40 80 	pushm	r7,lr
80007618:	1a 97       	mov	r7,sp
8000761a:	20 1d       	sub	sp,4
8000761c:	18 98       	mov	r8,r12
8000761e:	ef 68 ff fc 	st.b	r7[-4],r8
	main_b_cdc_enable = true;
80007622:	48 79       	lddpc	r9,8000763c <main_cdc_enable+0x28>
80007624:	30 18       	mov	r8,1
80007626:	b2 88       	st.b	r9[0x0],r8
	
	// Open communication
	uart_open(port);
80007628:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000762c:	10 9c       	mov	r12,r8
8000762e:	f0 1f 00 05 	mcall	80007640 <main_cdc_enable+0x2c>
	
	return(true);
80007632:	30 18       	mov	r8,1
}
80007634:	10 9c       	mov	r12,r8
80007636:	2f fd       	sub	sp,-4
80007638:	e3 cd 80 80 	ldm	sp++,r7,pc
8000763c:	00 00       	add	r0,r0
8000763e:	07 34       	ld.ub	r4,r3++
80007640:	80 00       	ld.sh	r0,r0[0x0]
80007642:	8b b0       	st.w	r5[0x2c],r0

80007644 <main_cdc_disable>:

void main_cdc_disable(uint8_t port)
{
80007644:	eb cd 40 80 	pushm	r7,lr
80007648:	1a 97       	mov	r7,sp
8000764a:	20 1d       	sub	sp,4
8000764c:	18 98       	mov	r8,r12
8000764e:	ef 68 ff fc 	st.b	r7[-4],r8
	main_b_cdc_enable = false;
80007652:	48 69       	lddpc	r9,80007668 <main_cdc_disable+0x24>
80007654:	30 08       	mov	r8,0
80007656:	b2 88       	st.b	r9[0x0],r8
	
	// Close communication
	uart_close(port);
80007658:	ef 38 ff fc 	ld.ub	r8,r7[-4]
8000765c:	10 9c       	mov	r12,r8
8000765e:	f0 1f 00 04 	mcall	8000766c <main_cdc_disable+0x28>
}
80007662:	2f fd       	sub	sp,-4
80007664:	e3 cd 80 80 	ldm	sp++,r7,pc
80007668:	00 00       	add	r0,r0
8000766a:	07 34       	ld.ub	r4,r3++
8000766c:	80 00       	ld.sh	r0,r0[0x0]
8000766e:	8d 48       	st.w	r6[0x10],r8

80007670 <main_cdc_set_dtr>:

void main_cdc_set_dtr(uint8_t port, bool b_enable)
{
80007670:	eb cd 40 80 	pushm	r7,lr
80007674:	1a 97       	mov	r7,sp
80007676:	20 2d       	sub	sp,8
80007678:	18 99       	mov	r9,r12
8000767a:	16 98       	mov	r8,r11
8000767c:	ef 69 ff fc 	st.b	r7[-4],r9
80007680:	ef 68 ff f8 	st.b	r7[-8],r8
	;
}
80007684:	2f ed       	sub	sp,-8
80007686:	e3 cd 80 80 	ldm	sp++,r7,pc
8000768a:	d7 03       	nop

8000768c <main_vbus_action>:


void main_vbus_action(bool b_high)
{
8000768c:	eb cd 40 80 	pushm	r7,lr
80007690:	1a 97       	mov	r7,sp
80007692:	20 1d       	sub	sp,4
80007694:	18 98       	mov	r8,r12
80007696:	ef 68 ff fc 	st.b	r7[-4],r8
	if (b_high)
8000769a:	ef 39 ff fc 	ld.ub	r9,r7[-4]
8000769e:	30 08       	mov	r8,0
800076a0:	f0 09 18 00 	cp.b	r9,r8
800076a4:	c0 40       	breq	800076ac <main_vbus_action+0x20>
	{
		// Attach USB Device
		udc_attach();
800076a6:	f0 1f 00 05 	mcall	800076b8 <main_vbus_action+0x2c>
800076aa:	c0 38       	rjmp	800076b0 <main_vbus_action+0x24>
	}
	
	else
	{
		// Vbus not present
		udc_detach();
800076ac:	f0 1f 00 04 	mcall	800076bc <main_vbus_action+0x30>
	}
800076b0:	2f fd       	sub	sp,-4
800076b2:	e3 cd 80 80 	ldm	sp++,r7,pc
800076b6:	00 00       	add	r0,r0
800076b8:	80 00       	ld.sh	r0,r0[0x0]
800076ba:	75 0c       	ld.w	r12,r10[0x40]
800076bc:	80 00       	ld.sh	r0,r0[0x0]
800076be:	75 20       	ld.w	r0,r10[0x48]

800076c0 <osc_get_rate>:
		return false;
	}
}

static inline uint32_t osc_get_rate(uint8_t id)
{
800076c0:	eb cd 40 80 	pushm	r7,lr
800076c4:	1a 97       	mov	r7,sp
800076c6:	20 1d       	sub	sp,4
800076c8:	18 98       	mov	r8,r12
800076ca:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (id) {
800076ce:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800076d2:	58 08       	cp.w	r8,0
800076d4:	c0 40       	breq	800076dc <osc_get_rate+0x1c>
800076d6:	58 28       	cp.w	r8,2
800076d8:	c0 70       	breq	800076e6 <osc_get_rate+0x26>
800076da:	c0 98       	rjmp	800076ec <osc_get_rate+0x2c>
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return BOARD_OSC0_HZ;
800076dc:	e0 68 1b 00 	mov	r8,6912
800076e0:	ea 18 00 b7 	orh	r8,0xb7
800076e4:	c0 58       	rjmp	800076ee <osc_get_rate+0x2e>
		return BOARD_OSC1_HZ;
#endif

#ifdef BOARD_OSC32_HZ
	case OSC_ID_OSC32:
		return BOARD_OSC32_HZ;
800076e6:	e0 68 80 00 	mov	r8,32768
800076ea:	c0 28       	rjmp	800076ee <osc_get_rate+0x2e>
#endif
	default:
		/* unhandled_case(id); */
		return 0;
800076ec:	30 08       	mov	r8,0
	}
}
800076ee:	10 9c       	mov	r12,r8
800076f0:	2f fd       	sub	sp,-4
800076f2:	e3 cd 80 80 	ldm	sp++,r7,pc
800076f6:	d7 03       	nop

800076f8 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern bool sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
800076f8:	eb cd 40 80 	pushm	r7,lr
800076fc:	1a 97       	mov	r7,sp
		return BOARD_OSC0_HZ;
#endif

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLL0:
		return pll_get_default_rate(0);
800076fe:	30 0c       	mov	r12,0
80007700:	f0 1f 00 04 	mcall	80007710 <sysclk_get_main_hz+0x18>
80007704:	18 98       	mov	r8,r12
80007706:	a5 68       	lsl	r8,0x4
80007708:	a1 98       	lsr	r8,0x1

	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
8000770a:	10 9c       	mov	r12,r8
8000770c:	e3 cd 80 80 	ldm	sp++,r7,pc
80007710:	80 00       	ld.sh	r0,r0[0x0]
80007712:	76 c0       	ld.w	r0,r11[0x30]

80007714 <sysclk_get_pba_hz>:
 * \brief Return the current rate in Hz of the Peripheral Bus A clock
 *
 * \return Frequency of the Peripheral Bus A clock, in Hz.
 */
static inline uint32_t sysclk_get_pba_hz(void)
{
80007714:	eb cd 40 80 	pushm	r7,lr
80007718:	1a 97       	mov	r7,sp
	return sysclk_get_main_hz() >> CONFIG_SYSCLK_PBA_DIV;
8000771a:	f0 1f 00 04 	mcall	80007728 <sysclk_get_pba_hz+0x14>
8000771e:	18 98       	mov	r8,r12
80007720:	a1 98       	lsr	r8,0x1
}
80007722:	10 9c       	mov	r12,r8
80007724:	e3 cd 80 80 	ldm	sp++,r7,pc
80007728:	80 00       	ld.sh	r0,r0[0x0]
8000772a:	76 f8       	ld.w	r8,r11[0x3c]

8000772c <sysclk_enable_pba_module>:
/**
 * \brief Enable a module clock derived from the PBA clock
 * \param index Index of the module clock in the PBAMASK register
 */
static inline void sysclk_enable_pba_module(unsigned int index)
{
8000772c:	eb cd 40 80 	pushm	r7,lr
80007730:	1a 97       	mov	r7,sp
80007732:	20 1d       	sub	sp,4
80007734:	ef 4c ff fc 	st.w	r7[-4],r12
	sysclk_priv_enable_module(AVR32_PM_CLK_GRP_PBA, index);
80007738:	ee fb ff fc 	ld.w	r11,r7[-4]
8000773c:	30 2c       	mov	r12,2
8000773e:	f0 1f 00 03 	mcall	80007748 <sysclk_enable_pba_module+0x1c>
}
80007742:	2f fd       	sub	sp,-4
80007744:	e3 cd 80 80 	ldm	sp++,r7,pc
80007748:	80 00       	ld.sh	r0,r0[0x0]
8000774a:	53 84       	stdsp	sp[0xe0],r4

8000774c <initRAM>:
void	initRAM(void);
uint8_t	calculateChecksum(const PACKET packet);
uint8_t isValidInstruction(uint8_t instruction);

void initRAM(void)
{
8000774c:	eb cd 40 80 	pushm	r7,lr
80007750:	1a 97       	mov	r7,sp
80007752:	20 2d       	sub	sp,8
	uint8_t temp[RAM_TABLE_SIZE] = {MODEL_NUMBER_L_DEFAULT, MODEL_NUMBER_H_DEFAULT, FIRMWARE_VERSION_DEFAULT, DYNAMIXEL_ID_DEFAULT, BAUD_RATE_DEFAULT};
80007754:	49 29       	lddpc	r9,8000779c <initRAM+0x50>
80007756:	ee c8 00 08 	sub	r8,r7,8
8000775a:	72 0a       	ld.w	r10,r9[0x0]
8000775c:	91 0a       	st.w	r8[0x0],r10
8000775e:	13 c9       	ld.ub	r9,r9[0x4]
80007760:	b0 c9       	st.b	r8[0x4],r9
		
	// Populate RAM with default values.
	flashc_memset((void *)RAM, 0x00, 8, RAM_TABLE_SIZE, true);
80007762:	30 19       	mov	r9,1
80007764:	30 5a       	mov	r10,5
80007766:	30 0b       	mov	r11,0
80007768:	48 ec       	lddpc	r12,800077a0 <initRAM+0x54>
8000776a:	f0 1f 00 0f 	mcall	800077a4 <initRAM+0x58>
	flashc_memcpy((void *)RAM, temp, RAM_TABLE_SIZE, true);
8000776e:	ee c8 00 08 	sub	r8,r7,8
80007772:	30 19       	mov	r9,1
80007774:	30 5a       	mov	r10,5
80007776:	10 9b       	mov	r11,r8
80007778:	48 ac       	lddpc	r12,800077a0 <initRAM+0x54>
8000777a:	f0 1f 00 0c 	mcall	800077a8 <initRAM+0x5c>
	
	BUS[0] = ((avr32_usart_t*)AVR32_USART0_ADDRESS);
8000777e:	48 c8       	lddpc	r8,800077ac <initRAM+0x60>
80007780:	fe 79 14 00 	mov	r9,-60416
80007784:	91 09       	st.w	r8[0x0],r9
	BUS[1] = ((avr32_usart_t*)AVR32_USART1_ADDRESS);
80007786:	48 a8       	lddpc	r8,800077ac <initRAM+0x60>
80007788:	fe 79 18 00 	mov	r9,-59392
8000778c:	91 19       	st.w	r8[0x4],r9
	BUS[2] = ((avr32_usart_t*)AVR32_USART2_ADDRESS);
8000778e:	48 88       	lddpc	r8,800077ac <initRAM+0x60>
80007790:	fe 79 1c 00 	mov	r9,-58368
80007794:	91 29       	st.w	r8[0x8],r9
}
80007796:	2f ed       	sub	sp,-8
80007798:	e3 cd 80 80 	ldm	sp++,r7,pc
8000779c:	80 00       	ld.sh	r0,r0[0x0]
8000779e:	96 b0       	ld.uh	r0,r11[0x6]
800077a0:	80 80       	ld.uh	r0,r0[0x0]
800077a2:	00 00       	add	r0,r0
800077a4:	80 00       	ld.sh	r0,r0[0x0]
800077a6:	23 70       	sub	r0,55
800077a8:	80 00       	ld.sh	r0,r0[0x0]
800077aa:	28 98       	sub	r8,-119
800077ac:	00 00       	add	r0,r0
800077ae:	46 34       	lddsp	r4,sp[0x18c]

800077b0 <isValidInstruction>:

uint8_t isValidInstruction(uint8_t instruction)
{
800077b0:	eb cd 40 80 	pushm	r7,lr
800077b4:	1a 97       	mov	r7,sp
800077b6:	20 1d       	sub	sp,4
800077b8:	18 98       	mov	r8,r12
800077ba:	ef 68 ff fc 	st.b	r7[-4],r8
	switch (instruction)
800077be:	ef 38 ff fc 	ld.ub	r8,r7[-4]
800077c2:	e0 48 00 83 	cp.w	r8,131
800077c6:	c0 b0       	breq	800077dc <isValidInstruction+0x2c>
800077c8:	e0 89 00 07 	brgt	800077d6 <isValidInstruction+0x26>
800077cc:	20 18       	sub	r8,1
800077ce:	58 58       	cp.w	r8,5
800077d0:	e0 8b 00 08 	brhi	800077e0 <isValidInstruction+0x30>
800077d4:	c0 48       	rjmp	800077dc <isValidInstruction+0x2c>
800077d6:	e0 48 00 92 	cp.w	r8,146
800077da:	c0 31       	brne	800077e0 <isValidInstruction+0x30>
		case ACTION:
		case RESET:
		case SYNC_WRITE:
		case BULK_READ:
		{
			return(NO_ERROR);
800077dc:	30 08       	mov	r8,0
800077de:	c0 28       	rjmp	800077e2 <isValidInstruction+0x32>
		}
		
		default:
		{
			return(INSTRUCTION_ERROR);
800077e0:	34 08       	mov	r8,64
		}
	}
}
800077e2:	10 9c       	mov	r12,r8
800077e4:	2f fd       	sub	sp,-4
800077e6:	e3 cd 80 80 	ldm	sp++,r7,pc

800077ea <calculateChecksum>:

uint8_t calculateChecksum(const PACKET packet)
{
800077ea:	eb cd 40 80 	pushm	r7,lr
800077ee:	1a 97       	mov	r7,sp
800077f0:	20 2d       	sub	sp,8
800077f2:	ee c8 ff f8 	sub	r8,r7,-8
	uint32_t checksum = packet.INSTRUCTION_PACKET.nID + packet.INSTRUCTION_PACKET.nLength + packet.INSTRUCTION_PACKET.nInstruction;
800077f6:	11 a9       	ld.ub	r9,r8[0x2]
800077f8:	12 9a       	mov	r10,r9
800077fa:	11 b9       	ld.ub	r9,r8[0x3]
800077fc:	12 0a       	add	r10,r9
800077fe:	11 c9       	ld.ub	r9,r8[0x4]
80007800:	f4 09 00 09 	add	r9,r10,r9
80007804:	ef 49 ff f8 	st.w	r7[-8],r9
	uint8_t i;
	
	for (i = 0; i < (packet.INSTRUCTION_PACKET.nLength - 2); i++)
80007808:	30 09       	mov	r9,0
8000780a:	ef 69 ff ff 	st.b	r7[-1],r9
8000780e:	c1 18       	rjmp	80007830 <calculateChecksum+0x46>
	{
		checksum += packet.INSTRUCTION_PACKET.nParameters[i];
80007810:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007814:	f0 09 00 09 	add	r9,r8,r9
80007818:	13 d9       	ld.ub	r9,r9[0x5]
8000781a:	ee fa ff f8 	ld.w	r10,r7[-8]
8000781e:	f4 09 00 09 	add	r9,r10,r9
80007822:	ef 49 ff f8 	st.w	r7[-8],r9
uint8_t calculateChecksum(const PACKET packet)
{
	uint32_t checksum = packet.INSTRUCTION_PACKET.nID + packet.INSTRUCTION_PACKET.nLength + packet.INSTRUCTION_PACKET.nInstruction;
	uint8_t i;
	
	for (i = 0; i < (packet.INSTRUCTION_PACKET.nLength - 2); i++)
80007826:	ef 39 ff ff 	ld.ub	r9,r7[-1]
8000782a:	2f f9       	sub	r9,-1
8000782c:	ef 69 ff ff 	st.b	r7[-1],r9
80007830:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80007834:	11 b9       	ld.ub	r9,r8[0x3]
80007836:	20 29       	sub	r9,2
80007838:	12 3a       	cp.w	r10,r9
8000783a:	ce b5       	brlt	80007810 <calculateChecksum+0x26>
	{
		checksum += packet.INSTRUCTION_PACKET.nParameters[i];
	}
	
	return((uint8_t)(~(checksum & 0x000000FF)));
8000783c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80007840:	5c 58       	castu.b	r8
80007842:	5c d8       	com	r8
80007844:	5c 58       	castu.b	r8
}
80007846:	10 9c       	mov	r12,r8
80007848:	2f ed       	sub	sp,-8
8000784a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000784e:	d7 03       	nop

80007850 <receiveUSBData>:

void receiveUSBData(void)
{
80007850:	eb cd 40 80 	pushm	r7,lr
80007854:	1a 97       	mov	r7,sp
	if (udi_cdc_is_rx_ready() == 0)
80007856:	f0 1f 00 4e 	mcall	8000798c <receiveUSBData+0x13c>
8000785a:	18 98       	mov	r8,r12
8000785c:	ec 18 00 01 	eorl	r8,0x1
80007860:	5c 58       	castu.b	r8
80007862:	c0 50       	breq	8000786c <receiveUSBData+0x1c>
	{
		// No data to read.
		readUSB = 0;
80007864:	4c b9       	lddpc	r9,80007990 <receiveUSBData+0x140>
80007866:	30 08       	mov	r8,0
80007868:	b2 88       	st.b	r9[0x0],r8
		return;
8000786a:	c8 f8       	rjmp	80007988 <receiveUSBData+0x138>
	}

	if (udi_cdc_read_buf(&rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[rxPosition[BUS_6_USB]], 1) != 0)
8000786c:	4c a8       	lddpc	r8,80007994 <receiveUSBData+0x144>
8000786e:	11 b8       	ld.ub	r8,r8[0x3]
80007870:	10 99       	mov	r9,r8
80007872:	e0 68 00 86 	mov	r8,134
80007876:	f2 08 02 48 	mul	r8,r9,r8
8000787a:	f0 c9 e8 72 	sub	r9,r8,-6030
8000787e:	4c 78       	lddpc	r8,80007998 <receiveUSBData+0x148>
80007880:	10 09       	add	r9,r8
80007882:	4c 78       	lddpc	r8,8000799c <receiveUSBData+0x14c>
80007884:	90 38       	ld.sh	r8,r8[0x6]
80007886:	5c 78       	castu.h	r8
80007888:	f2 08 00 08 	add	r8,r9,r8
8000788c:	30 1b       	mov	r11,1
8000788e:	10 9c       	mov	r12,r8
80007890:	f0 1f 00 44 	mcall	800079a0 <receiveUSBData+0x150>
80007894:	18 98       	mov	r8,r12
80007896:	58 08       	cp.w	r8,0
80007898:	c0 40       	breq	800078a0 <receiveUSBData+0x50>
	{
		// Failed to read a character from the USB.
		udi_cdc_signal_framing_error();
8000789a:	f0 1f 00 43 	mcall	800079a4 <receiveUSBData+0x154>
8000789e:	c7 58       	rjmp	80007988 <receiveUSBData+0x138>
	else
	{
		// We read a character, now sanity check it.
		
		// Verify each byte of the preamble.
		if ((rxPosition[BUS_6_USB] == 0) && (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[0] != 0xFF))
800078a0:	4b f8       	lddpc	r8,8000799c <receiveUSBData+0x14c>
800078a2:	90 38       	ld.sh	r8,r8[0x6]
800078a4:	58 08       	cp.w	r8,0
800078a6:	c1 61       	brne	800078d2 <receiveUSBData+0x82>
800078a8:	4b b8       	lddpc	r8,80007994 <receiveUSBData+0x144>
800078aa:	11 b8       	ld.ub	r8,r8[0x3]
800078ac:	10 9a       	mov	r10,r8
800078ae:	4b b9       	lddpc	r9,80007998 <receiveUSBData+0x148>
800078b0:	e0 68 00 86 	mov	r8,134
800078b4:	f4 08 02 48 	mul	r8,r10,r8
800078b8:	f2 08 00 08 	add	r8,r9,r8
800078bc:	f0 c8 e8 72 	sub	r8,r8,-6030
800078c0:	11 89       	ld.ub	r9,r8[0x0]
800078c2:	3f f8       	mov	r8,-1
800078c4:	f0 09 18 00 	cp.b	r9,r8
800078c8:	c0 50       	breq	800078d2 <receiveUSBData+0x82>
		{
			// Preamble is wrong. Ignore this character and start again.
			rxPosition[BUS_6_USB] = 0;
800078ca:	4b 59       	lddpc	r9,8000799c <receiveUSBData+0x14c>
800078cc:	30 08       	mov	r8,0
800078ce:	b2 38       	st.h	r9[0x6],r8
	else
	{
		// We read a character, now sanity check it.
		
		// Verify each byte of the preamble.
		if ((rxPosition[BUS_6_USB] == 0) && (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[0] != 0xFF))
800078d0:	c5 c8       	rjmp	80007988 <receiveUSBData+0x138>
		{
			// Preamble is wrong. Ignore this character and start again.
			rxPosition[BUS_6_USB] = 0;
		}
		
		else if ((rxPosition[BUS_6_USB] == 1) && (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[1] != 0xFF))
800078d2:	4b 38       	lddpc	r8,8000799c <receiveUSBData+0x14c>
800078d4:	90 39       	ld.sh	r9,r8[0x6]
800078d6:	30 18       	mov	r8,1
800078d8:	f0 09 19 00 	cp.h	r9,r8
800078dc:	c1 61       	brne	80007908 <receiveUSBData+0xb8>
800078de:	4a e8       	lddpc	r8,80007994 <receiveUSBData+0x144>
800078e0:	11 b8       	ld.ub	r8,r8[0x3]
800078e2:	10 9a       	mov	r10,r8
800078e4:	4a d9       	lddpc	r9,80007998 <receiveUSBData+0x148>
800078e6:	e0 68 00 86 	mov	r8,134
800078ea:	f4 08 02 48 	mul	r8,r10,r8
800078ee:	f2 08 00 08 	add	r8,r9,r8
800078f2:	f0 c8 e8 71 	sub	r8,r8,-6031
800078f6:	11 89       	ld.ub	r9,r8[0x0]
800078f8:	3f f8       	mov	r8,-1
800078fa:	f0 09 18 00 	cp.b	r9,r8
800078fe:	c0 50       	breq	80007908 <receiveUSBData+0xb8>
		{
			// Preamble is wrong. Ignore this character and start again.
			rxPosition[BUS_6_USB] = 0;
80007900:	4a 79       	lddpc	r9,8000799c <receiveUSBData+0x14c>
80007902:	30 08       	mov	r8,0
80007904:	b2 38       	st.h	r9[0x6],r8
		{
			// Preamble is wrong. Ignore this character and start again.
			rxPosition[BUS_6_USB] = 0;
		}
		
		else if ((rxPosition[BUS_6_USB] == 1) && (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].packet[1] != 0xFF))
80007906:	c4 18       	rjmp	80007988 <receiveUSBData+0x138>
		// When we read in the last parameter we need to jump to the checksum position.
		// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0. Less another 1 since we need to 
		// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
		// 5 - 1 + (length - 2) = length + 2.
		// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
		else if ((rxPosition[BUS_6_USB] > 3) && (rxPosition[BUS_6_USB] == (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].INSTRUCTION_PACKET.nLength + 2)))
80007908:	4a 58       	lddpc	r8,8000799c <receiveUSBData+0x14c>
8000790a:	90 39       	ld.sh	r9,r8[0x6]
8000790c:	30 38       	mov	r8,3
8000790e:	f0 09 19 00 	cp.h	r9,r8
80007912:	e0 88 00 1b 	brls	80007948 <receiveUSBData+0xf8>
80007916:	4a 28       	lddpc	r8,8000799c <receiveUSBData+0x14c>
80007918:	90 38       	ld.sh	r8,r8[0x6]
8000791a:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000791e:	49 e8       	lddpc	r8,80007994 <receiveUSBData+0x144>
80007920:	11 b8       	ld.ub	r8,r8[0x3]
80007922:	10 9b       	mov	r11,r8
80007924:	49 da       	lddpc	r10,80007998 <receiveUSBData+0x148>
80007926:	e0 68 00 86 	mov	r8,134
8000792a:	f6 08 02 48 	mul	r8,r11,r8
8000792e:	f4 08 00 08 	add	r8,r10,r8
80007932:	f0 c8 e8 72 	sub	r8,r8,-6030
80007936:	11 b8       	ld.ub	r8,r8[0x3]
80007938:	2f e8       	sub	r8,-2
8000793a:	10 39       	cp.w	r9,r8
8000793c:	c0 61       	brne	80007948 <receiveUSBData+0xf8>
		{
			rxPosition[BUS_6_USB] = MAX_PARAMETERS + 5;
8000793e:	49 89       	lddpc	r9,8000799c <receiveUSBData+0x14c>
80007940:	e0 68 00 84 	mov	r8,132
80007944:	b2 38       	st.h	r9[0x6],r8
		// When we read in the last parameter we need to jump to the checksum position.
		// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0. Less another 1 since we need to 
		// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
		// 5 - 1 + (length - 2) = length + 2.
		// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
		else if ((rxPosition[BUS_6_USB] > 3) && (rxPosition[BUS_6_USB] == (rxCircBuffer[BUS_6_USB][rxHead[BUS_6_USB]].INSTRUCTION_PACKET.nLength + 2)))
80007946:	c2 18       	rjmp	80007988 <receiveUSBData+0x138>
			rxPosition[BUS_6_USB] = MAX_PARAMETERS + 5;
		}

		// We just read in the checksum byte, so we are done.
		// The checksum byte can be verified later.
		else if (rxPosition[BUS_6_USB] == (MAX_PARAMETERS + 5))
80007948:	49 58       	lddpc	r8,8000799c <receiveUSBData+0x14c>
8000794a:	90 39       	ld.sh	r9,r8[0x6]
8000794c:	e0 68 00 84 	mov	r8,132
80007950:	f0 09 19 00 	cp.h	r9,r8
80007954:	c1 41       	brne	8000797c <receiveUSBData+0x12c>
		{
			if (++rxHead[BUS_6_USB] == NUM_BUSES)
80007956:	49 08       	lddpc	r8,80007994 <receiveUSBData+0x144>
80007958:	11 b8       	ld.ub	r8,r8[0x3]
8000795a:	2f f8       	sub	r8,-1
8000795c:	5c 58       	castu.b	r8
8000795e:	48 e9       	lddpc	r9,80007994 <receiveUSBData+0x144>
80007960:	b2 b8       	st.b	r9[0x3],r8
80007962:	48 d8       	lddpc	r8,80007994 <receiveUSBData+0x144>
80007964:	11 b9       	ld.ub	r9,r8[0x3]
80007966:	30 48       	mov	r8,4
80007968:	f0 09 18 00 	cp.b	r9,r8
8000796c:	c0 41       	brne	80007974 <receiveUSBData+0x124>
			{
				rxHead[BUS_6_USB] = 0;
8000796e:	48 a9       	lddpc	r9,80007994 <receiveUSBData+0x144>
80007970:	30 08       	mov	r8,0
80007972:	b2 b8       	st.b	r9[0x3],r8
			}

			rxPosition[BUS_6_USB] = 0;
80007974:	48 a9       	lddpc	r9,8000799c <receiveUSBData+0x14c>
80007976:	30 08       	mov	r8,0
80007978:	b2 38       	st.h	r9[0x6],r8
8000797a:	c0 78       	rjmp	80007988 <receiveUSBData+0x138>
		}

		// There is no sanity checking to perform on this byte.
		else
		{
			rxPosition[BUS_6_USB]++;
8000797c:	48 88       	lddpc	r8,8000799c <receiveUSBData+0x14c>
8000797e:	90 38       	ld.sh	r8,r8[0x6]
80007980:	2f f8       	sub	r8,-1
80007982:	5c 88       	casts.h	r8
80007984:	48 69       	lddpc	r9,8000799c <receiveUSBData+0x14c>
80007986:	b2 38       	st.h	r9[0x6],r8
		}
	}	
}
80007988:	e3 cd 80 80 	ldm	sp++,r7,pc
8000798c:	80 00       	ld.sh	r0,r0[0x0]
8000798e:	62 1c       	ld.w	r12,r1[0x4]
80007990:	00 00       	add	r0,r0
80007992:	46 44       	lddsp	r4,sp[0x190]
80007994:	00 00       	add	r0,r0
80007996:	46 24       	lddsp	r4,sp[0x188]
80007998:	00 00       	add	r0,r0
8000799a:	26 ac       	sub	r12,106
8000799c:	00 00       	add	r0,r0
8000799e:	46 2c       	lddsp	r12,sp[0x188]
800079a0:	80 00       	ld.sh	r0,r0[0x0]
800079a2:	63 b8       	ld.w	r8,r1[0x6c]
800079a4:	80 00       	ld.sh	r0,r0[0x0]
800079a6:	61 50       	ld.w	r0,r0[0x54]

800079a8 <processPacket>:

void processPacket(void)
{
800079a8:	eb cd 40 e0 	pushm	r5-r7,lr
800079ac:	1a 97       	mov	r7,sp
800079ae:	20 1d       	sub	sp,4
	uint8_t bus, txBus;
	uint8_t error;
	
	// Check each bus for anything to process.
	for (bus = BUS_1_MOTORS; bus <= BUS_6_USB; bus++)
800079b0:	30 08       	mov	r8,0
800079b2:	ef 68 ff fd 	st.b	r7[-3],r8
800079b6:	e0 8f 02 bb 	bral	80007f2c <processPacket+0x584>
		// We need only check the receive buffers to see if there is anything to process.
		// The transmit buffers are filled as a result of our processing.
		while (rxTail[bus] != rxHead[bus])
		{
			// Verify checksum and instruction.
			error = isValidInstruction(rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nInstruction);
800079ba:	ef 3b ff fd 	ld.ub	r11,r7[-3]
800079be:	ef 38 ff fd 	ld.ub	r8,r7[-3]
800079c2:	fe f9 06 06 	ld.w	r9,pc[1542]
800079c6:	f2 08 07 08 	ld.ub	r8,r9[r8]
800079ca:	10 9a       	mov	r10,r8
800079cc:	fe f9 06 00 	ld.w	r9,pc[1536]
800079d0:	e0 68 00 86 	mov	r8,134
800079d4:	b1 3a       	mul	r10,r8
800079d6:	e0 68 07 da 	mov	r8,2010
800079da:	f6 08 02 48 	mul	r8,r11,r8
800079de:	f4 08 00 08 	add	r8,r10,r8
800079e2:	f2 08 00 08 	add	r8,r9,r8
800079e6:	2f c8       	sub	r8,-4
800079e8:	11 88       	ld.ub	r8,r8[0x0]
800079ea:	10 9c       	mov	r12,r8
800079ec:	f0 1f 01 79 	mcall	80007fd0 <processPacket+0x628>
800079f0:	18 98       	mov	r8,r12
800079f2:	ef 68 ff ff 	st.b	r7[-1],r8
			error |= (calculateChecksum(rxCircBuffer[bus][rxTail[bus]]) != rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nChecksum) ? CHECKSUM_ERROR : NO_ERROR;
800079f6:	ef 3b ff fd 	ld.ub	r11,r7[-3]
800079fa:	ef 38 ff fd 	ld.ub	r8,r7[-3]
800079fe:	fe f9 05 ca 	ld.w	r9,pc[1482]
80007a02:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007a06:	10 9a       	mov	r10,r8
80007a08:	fe f9 05 c4 	ld.w	r9,pc[1476]
80007a0c:	e0 68 00 86 	mov	r8,134
80007a10:	b1 3a       	mul	r10,r8
80007a12:	e0 68 07 da 	mov	r8,2010
80007a16:	f6 08 02 48 	mul	r8,r11,r8
80007a1a:	f4 08 00 08 	add	r8,r10,r8
80007a1e:	10 09       	add	r9,r8
80007a20:	fa cd 00 88 	sub	sp,sp,136
80007a24:	1a 98       	mov	r8,sp
80007a26:	e0 6a 00 86 	mov	r10,134
80007a2a:	12 9b       	mov	r11,r9
80007a2c:	10 9c       	mov	r12,r8
80007a2e:	f0 1f 01 6a 	mcall	80007fd4 <processPacket+0x62c>
80007a32:	f0 1f 01 6a 	mcall	80007fd8 <processPacket+0x630>
80007a36:	fa cd ff 78 	sub	sp,sp,-136
80007a3a:	18 98       	mov	r8,r12
80007a3c:	10 99       	mov	r9,r8
80007a3e:	ef 3c ff fd 	ld.ub	r12,r7[-3]
80007a42:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007a46:	fe fa 05 82 	ld.w	r10,pc[1410]
80007a4a:	f4 08 07 08 	ld.ub	r8,r10[r8]
80007a4e:	10 9b       	mov	r11,r8
80007a50:	fe fa 05 7c 	ld.w	r10,pc[1404]
80007a54:	e0 68 00 86 	mov	r8,134
80007a58:	b1 3b       	mul	r11,r8
80007a5a:	e0 68 07 da 	mov	r8,2010
80007a5e:	f8 08 02 48 	mul	r8,r12,r8
80007a62:	f6 08 00 08 	add	r8,r11,r8
80007a66:	f4 08 00 08 	add	r8,r10,r8
80007a6a:	f0 c8 ff 7c 	sub	r8,r8,-132
80007a6e:	11 88       	ld.ub	r8,r8[0x0]
80007a70:	f0 09 18 00 	cp.b	r9,r8
80007a74:	c0 30       	breq	80007a7a <processPacket+0xd2>
80007a76:	31 08       	mov	r8,16
80007a78:	c0 28       	rjmp	80007a7c <processPacket+0xd4>
80007a7a:	30 08       	mov	r8,0
80007a7c:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007a80:	10 9a       	mov	r10,r8
80007a82:	12 98       	mov	r8,r9
80007a84:	f5 e8 10 08 	or	r8,r10,r8
80007a88:	5c 58       	castu.b	r8
80007a8a:	ef 68 ff ff 	st.b	r7[-1],r8
			
			if (error != NO_ERROR)
80007a8e:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80007a92:	30 08       	mov	r8,0
80007a94:	f0 09 18 00 	cp.b	r9,r8
80007a98:	e0 80 00 dc 	breq	80007c50 <processPacket+0x2a8>
			{
				// Generate an error response.
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nPreamble		= 0xFFFF;
80007a9c:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007aa0:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007aa4:	fe f9 05 38 	ld.w	r9,pc[1336]
80007aa8:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007aac:	10 9a       	mov	r10,r8
80007aae:	fe f9 05 32 	ld.w	r9,pc[1330]
80007ab2:	e0 68 00 86 	mov	r8,134
80007ab6:	b1 3a       	mul	r10,r8
80007ab8:	e0 68 07 da 	mov	r8,2010
80007abc:	f6 08 02 48 	mul	r8,r11,r8
80007ac0:	f4 08 00 08 	add	r8,r10,r8
80007ac4:	10 09       	add	r9,r8
80007ac6:	3f f8       	mov	r8,-1
80007ac8:	b2 08       	st.h	r9[0x0],r8
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nID			= RAM[DYNAMIXEL_ID];
80007aca:	ef 3c ff fd 	ld.ub	r12,r7[-3]
80007ace:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007ad2:	fe f9 05 0a 	ld.w	r9,pc[1290]
80007ad6:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007ada:	10 9b       	mov	r11,r8
80007adc:	fe f8 05 08 	ld.w	r8,pc[1288]
80007ae0:	11 b8       	ld.ub	r8,r8[0x3]
80007ae2:	fe fa 04 fe 	ld.w	r10,pc[1278]
80007ae6:	e0 69 00 86 	mov	r9,134
80007aea:	b3 3b       	mul	r11,r9
80007aec:	e0 69 07 da 	mov	r9,2010
80007af0:	f8 09 02 49 	mul	r9,r12,r9
80007af4:	f6 09 00 09 	add	r9,r11,r9
80007af8:	f4 09 00 09 	add	r9,r10,r9
80007afc:	b2 a8       	st.b	r9[0x2],r8
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nLength		= 0x02;
80007afe:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007b02:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007b06:	fe f9 04 d6 	ld.w	r9,pc[1238]
80007b0a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007b0e:	10 9a       	mov	r10,r8
80007b10:	fe f9 04 d0 	ld.w	r9,pc[1232]
80007b14:	e0 68 00 86 	mov	r8,134
80007b18:	b1 3a       	mul	r10,r8
80007b1a:	e0 68 07 da 	mov	r8,2010
80007b1e:	f6 08 02 48 	mul	r8,r11,r8
80007b22:	f4 08 00 08 	add	r8,r10,r8
80007b26:	10 09       	add	r9,r8
80007b28:	30 28       	mov	r8,2
80007b2a:	b2 b8       	st.b	r9[0x3],r8
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nInstruction	= error;
80007b2c:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007b30:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007b34:	fe f9 04 a8 	ld.w	r9,pc[1192]
80007b38:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007b3c:	10 9a       	mov	r10,r8
80007b3e:	fe f9 04 a2 	ld.w	r9,pc[1186]
80007b42:	e0 68 00 86 	mov	r8,134
80007b46:	b1 3a       	mul	r10,r8
80007b48:	e0 68 07 da 	mov	r8,2010
80007b4c:	f6 08 02 48 	mul	r8,r11,r8
80007b50:	f4 08 00 08 	add	r8,r10,r8
80007b54:	f2 08 00 08 	add	r8,r9,r8
80007b58:	f0 c9 ff fc 	sub	r9,r8,-4
80007b5c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80007b60:	b2 88       	st.b	r9[0x0],r8
				txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nChecksum		= calculateChecksum(txCircBuffer[bus][txHead[bus]]);
80007b62:	ef 36 ff fd 	ld.ub	r6,r7[-3]
80007b66:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007b6a:	fe f9 04 72 	ld.w	r9,pc[1138]
80007b6e:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007b72:	10 95       	mov	r5,r8
80007b74:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007b78:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007b7c:	fe f9 04 60 	ld.w	r9,pc[1120]
80007b80:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007b84:	10 9a       	mov	r10,r8
80007b86:	fe f9 04 5a 	ld.w	r9,pc[1114]
80007b8a:	e0 68 00 86 	mov	r8,134
80007b8e:	b1 3a       	mul	r10,r8
80007b90:	e0 68 07 da 	mov	r8,2010
80007b94:	f6 08 02 48 	mul	r8,r11,r8
80007b98:	f4 08 00 08 	add	r8,r10,r8
80007b9c:	10 09       	add	r9,r8
80007b9e:	fa cd 00 88 	sub	sp,sp,136
80007ba2:	1a 98       	mov	r8,sp
80007ba4:	e0 6a 00 86 	mov	r10,134
80007ba8:	12 9b       	mov	r11,r9
80007baa:	10 9c       	mov	r12,r8
80007bac:	f0 1f 01 0a 	mcall	80007fd4 <processPacket+0x62c>
80007bb0:	f0 1f 01 0a 	mcall	80007fd8 <processPacket+0x630>
80007bb4:	fa cd ff 78 	sub	sp,sp,-136
80007bb8:	18 98       	mov	r8,r12
80007bba:	fe fa 04 26 	ld.w	r10,pc[1062]
80007bbe:	e0 69 00 86 	mov	r9,134
80007bc2:	ea 09 02 4b 	mul	r11,r5,r9
80007bc6:	e0 69 07 da 	mov	r9,2010
80007bca:	ec 09 02 49 	mul	r9,r6,r9
80007bce:	f6 09 00 09 	add	r9,r11,r9
80007bd2:	f4 09 00 09 	add	r9,r10,r9
80007bd6:	f2 c9 ff 7c 	sub	r9,r9,-132
80007bda:	b2 88       	st.b	r9[0x0],r8
						
				if (++txHead[bus] == NUM_BUSES)
80007bdc:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007be0:	fe f9 03 fc 	ld.w	r9,pc[1020]
80007be4:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007be8:	2f f9       	sub	r9,-1
80007bea:	5c 59       	castu.b	r9
80007bec:	fe fa 03 f0 	ld.w	r10,pc[1008]
80007bf0:	f4 08 0b 09 	st.b	r10[r8],r9
80007bf4:	fe f9 03 e8 	ld.w	r9,pc[1000]
80007bf8:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007bfc:	30 48       	mov	r8,4
80007bfe:	f0 09 18 00 	cp.b	r9,r8
80007c02:	c0 81       	brne	80007c12 <processPacket+0x26a>
				{
					txHead[bus] = 0;
80007c04:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007c08:	fe fa 03 d4 	ld.w	r10,pc[980]
80007c0c:	30 08       	mov	r8,0
80007c0e:	f4 09 0b 08 	st.b	r10[r9],r8
				}
				
				if (++rxTail[bus] == NUM_BUSES)
80007c12:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007c16:	fe f9 03 b2 	ld.w	r9,pc[946]
80007c1a:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007c1e:	2f f9       	sub	r9,-1
80007c20:	5c 59       	castu.b	r9
80007c22:	fe fa 03 a6 	ld.w	r10,pc[934]
80007c26:	f4 08 0b 09 	st.b	r10[r8],r9
80007c2a:	fe f9 03 9e 	ld.w	r9,pc[926]
80007c2e:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007c32:	30 48       	mov	r8,4
80007c34:	f0 09 18 00 	cp.b	r9,r8
80007c38:	c0 81       	brne	80007c48 <processPacket+0x2a0>
				{
					rxTail[bus] = 0;
80007c3a:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007c3e:	fe fa 03 8a 	ld.w	r10,pc[906]
80007c42:	30 08       	mov	r8,0
80007c44:	f4 09 0b 08 	st.b	r10[r9],r8
				}
	
				error = NO_ERROR;		
80007c48:	30 08       	mov	r8,0
80007c4a:	ef 68 ff ff 	st.b	r7[-1],r8
				continue;
80007c4e:	c5 c9       	rjmp	80007f06 <processPacket+0x55e>
			}

			// Check the ID field and see if this message was meant for us.
			if ((rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == RAM[DYNAMIXEL_ID]) || (rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == DYNAMIXEL_ID_BROADCAST))
80007c50:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007c54:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007c58:	fe f9 03 70 	ld.w	r9,pc[880]
80007c5c:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007c60:	10 9a       	mov	r10,r8
80007c62:	fe f9 03 6a 	ld.w	r9,pc[874]
80007c66:	e0 68 00 86 	mov	r8,134
80007c6a:	b1 3a       	mul	r10,r8
80007c6c:	e0 68 07 da 	mov	r8,2010
80007c70:	f6 08 02 48 	mul	r8,r11,r8
80007c74:	f4 08 00 08 	add	r8,r10,r8
80007c78:	f2 08 00 08 	add	r8,r9,r8
80007c7c:	11 a9       	ld.ub	r9,r8[0x2]
80007c7e:	fe f8 03 66 	ld.w	r8,pc[870]
80007c82:	11 b8       	ld.ub	r8,r8[0x3]
80007c84:	f0 09 18 00 	cp.b	r9,r8
80007c88:	c1 d0       	breq	80007cc2 <processPacket+0x31a>
80007c8a:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007c8e:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007c92:	fe f9 03 36 	ld.w	r9,pc[822]
80007c96:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007c9a:	10 9a       	mov	r10,r8
80007c9c:	fe f9 03 30 	ld.w	r9,pc[816]
80007ca0:	e0 68 00 86 	mov	r8,134
80007ca4:	b1 3a       	mul	r10,r8
80007ca6:	e0 68 07 da 	mov	r8,2010
80007caa:	f6 08 02 48 	mul	r8,r11,r8
80007cae:	f4 08 00 08 	add	r8,r10,r8
80007cb2:	f2 08 00 08 	add	r8,r9,r8
80007cb6:	11 a9       	ld.ub	r9,r8[0x2]
80007cb8:	3f e8       	mov	r8,-2
80007cba:	f0 09 18 00 	cp.b	r9,r8
80007cbe:	e0 81 01 18 	brne	80007eee <processPacket+0x546>
			{
				// Packet is meant for us.
				switch (rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nInstruction)
80007cc2:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007cc6:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007cca:	fe f9 02 fe 	ld.w	r9,pc[766]
80007cce:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007cd2:	10 9a       	mov	r10,r8
80007cd4:	fe f9 02 f8 	ld.w	r9,pc[760]
80007cd8:	e0 68 00 86 	mov	r8,134
80007cdc:	b1 3a       	mul	r10,r8
80007cde:	e0 68 07 da 	mov	r8,2010
80007ce2:	f6 08 02 48 	mul	r8,r11,r8
80007ce6:	f4 08 00 08 	add	r8,r10,r8
80007cea:	f2 08 00 08 	add	r8,r9,r8
80007cee:	2f c8       	sub	r8,-4
80007cf0:	11 88       	ld.ub	r8,r8[0x0]
80007cf2:	58 18       	cp.w	r8,1
80007cf4:	e0 81 00 fd 	brne	80007eee <processPacket+0x546>
						 * Instruction:	0x01
						 * Parameter..: No parameters.
						 * Checksum...:	~((instruction + length + id) & 0xFF).
						 */
						
						for (txBus = ((rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == DYNAMIXEL_ID_BROADCAST) ? BUS_1_MOTORS : bus); txBus <= ((rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == DYNAMIXEL_ID_BROADCAST) ? BUS_3_MOTORS : bus); txBus++)
80007cf8:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007cfc:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007d00:	fe f9 02 c8 	ld.w	r9,pc[712]
80007d04:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007d08:	10 9a       	mov	r10,r8
80007d0a:	fe f9 02 c2 	ld.w	r9,pc[706]
80007d0e:	e0 68 00 86 	mov	r8,134
80007d12:	b1 3a       	mul	r10,r8
80007d14:	e0 68 07 da 	mov	r8,2010
80007d18:	f6 08 02 48 	mul	r8,r11,r8
80007d1c:	f4 08 00 08 	add	r8,r10,r8
80007d20:	f2 08 00 08 	add	r8,r9,r8
80007d24:	11 a9       	ld.ub	r9,r8[0x2]
80007d26:	3f e8       	mov	r8,-2
80007d28:	f0 09 18 00 	cp.b	r9,r8
80007d2c:	c0 40       	breq	80007d34 <processPacket+0x38c>
80007d2e:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007d32:	c0 28       	rjmp	80007d36 <processPacket+0x38e>
80007d34:	30 08       	mov	r8,0
80007d36:	ef 68 ff fe 	st.b	r7[-2],r8
80007d3a:	cb 88       	rjmp	80007eaa <processPacket+0x502>
						{
							txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nPreamble		= 0xFFFF;
80007d3c:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007d40:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007d44:	fe f9 02 98 	ld.w	r9,pc[664]
80007d48:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007d4c:	10 9a       	mov	r10,r8
80007d4e:	fe f9 02 92 	ld.w	r9,pc[658]
80007d52:	e0 68 00 86 	mov	r8,134
80007d56:	b1 3a       	mul	r10,r8
80007d58:	e0 68 07 da 	mov	r8,2010
80007d5c:	f6 08 02 48 	mul	r8,r11,r8
80007d60:	f4 08 00 08 	add	r8,r10,r8
80007d64:	10 09       	add	r9,r8
80007d66:	3f f8       	mov	r8,-1
80007d68:	b2 08       	st.h	r9[0x0],r8
							txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nID			= RAM[DYNAMIXEL_ID];
80007d6a:	ef 3c ff fd 	ld.ub	r12,r7[-3]
80007d6e:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007d72:	fe f9 02 6a 	ld.w	r9,pc[618]
80007d76:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007d7a:	10 9b       	mov	r11,r8
80007d7c:	fe f8 02 68 	ld.w	r8,pc[616]
80007d80:	11 b8       	ld.ub	r8,r8[0x3]
80007d82:	fe fa 02 5e 	ld.w	r10,pc[606]
80007d86:	e0 69 00 86 	mov	r9,134
80007d8a:	b3 3b       	mul	r11,r9
80007d8c:	e0 69 07 da 	mov	r9,2010
80007d90:	f8 09 02 49 	mul	r9,r12,r9
80007d94:	f6 09 00 09 	add	r9,r11,r9
80007d98:	f4 09 00 09 	add	r9,r10,r9
80007d9c:	b2 a8       	st.b	r9[0x2],r8
							txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nLength		= 0x02;
80007d9e:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007da2:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007da6:	fe f9 02 36 	ld.w	r9,pc[566]
80007daa:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007dae:	10 9a       	mov	r10,r8
80007db0:	fe f9 02 30 	ld.w	r9,pc[560]
80007db4:	e0 68 00 86 	mov	r8,134
80007db8:	b1 3a       	mul	r10,r8
80007dba:	e0 68 07 da 	mov	r8,2010
80007dbe:	f6 08 02 48 	mul	r8,r11,r8
80007dc2:	f4 08 00 08 	add	r8,r10,r8
80007dc6:	10 09       	add	r9,r8
80007dc8:	30 28       	mov	r8,2
80007dca:	b2 b8       	st.b	r9[0x3],r8
							txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nInstruction	= NO_ERROR;
80007dcc:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007dd0:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007dd4:	fe f9 02 08 	ld.w	r9,pc[520]
80007dd8:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007ddc:	10 9a       	mov	r10,r8
80007dde:	fe f9 02 02 	ld.w	r9,pc[514]
80007de2:	e0 68 00 86 	mov	r8,134
80007de6:	b1 3a       	mul	r10,r8
80007de8:	e0 68 07 da 	mov	r8,2010
80007dec:	f6 08 02 48 	mul	r8,r11,r8
80007df0:	f4 08 00 08 	add	r8,r10,r8
80007df4:	f2 08 00 08 	add	r8,r9,r8
80007df8:	f0 c9 ff fc 	sub	r9,r8,-4
80007dfc:	30 08       	mov	r8,0
80007dfe:	b2 88       	st.b	r9[0x0],r8
							txCircBuffer[bus][txHead[bus]].INSTRUCTION_PACKET.nChecksum		= calculateChecksum(txCircBuffer[bus][txHead[bus]]);
80007e00:	ef 36 ff fd 	ld.ub	r6,r7[-3]
80007e04:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007e08:	4f 59       	lddpc	r9,80007fdc <processPacket+0x634>
80007e0a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007e0e:	10 95       	mov	r5,r8
80007e10:	ef 3b ff fd 	ld.ub	r11,r7[-3]
80007e14:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007e18:	4f 19       	lddpc	r9,80007fdc <processPacket+0x634>
80007e1a:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007e1e:	10 9a       	mov	r10,r8
80007e20:	4f 09       	lddpc	r9,80007fe0 <processPacket+0x638>
80007e22:	e0 68 00 86 	mov	r8,134
80007e26:	b1 3a       	mul	r10,r8
80007e28:	e0 68 07 da 	mov	r8,2010
80007e2c:	f6 08 02 48 	mul	r8,r11,r8
80007e30:	f4 08 00 08 	add	r8,r10,r8
80007e34:	10 09       	add	r9,r8
80007e36:	fa cd 00 88 	sub	sp,sp,136
80007e3a:	1a 98       	mov	r8,sp
80007e3c:	e0 6a 00 86 	mov	r10,134
80007e40:	12 9b       	mov	r11,r9
80007e42:	10 9c       	mov	r12,r8
80007e44:	f0 1f 00 64 	mcall	80007fd4 <processPacket+0x62c>
80007e48:	f0 1f 00 64 	mcall	80007fd8 <processPacket+0x630>
80007e4c:	fa cd ff 78 	sub	sp,sp,-136
80007e50:	18 98       	mov	r8,r12
80007e52:	4e 4a       	lddpc	r10,80007fe0 <processPacket+0x638>
80007e54:	e0 69 00 86 	mov	r9,134
80007e58:	ea 09 02 4b 	mul	r11,r5,r9
80007e5c:	e0 69 07 da 	mov	r9,2010
80007e60:	ec 09 02 49 	mul	r9,r6,r9
80007e64:	f6 09 00 09 	add	r9,r11,r9
80007e68:	f4 09 00 09 	add	r9,r10,r9
80007e6c:	f2 c9 ff 7c 	sub	r9,r9,-132
80007e70:	b2 88       	st.b	r9[0x0],r8
							
							if (++txHead[bus] == NUM_BUSES)
80007e72:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007e76:	4d a9       	lddpc	r9,80007fdc <processPacket+0x634>
80007e78:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007e7c:	2f f9       	sub	r9,-1
80007e7e:	5c 59       	castu.b	r9
80007e80:	4d 7a       	lddpc	r10,80007fdc <processPacket+0x634>
80007e82:	f4 08 0b 09 	st.b	r10[r8],r9
80007e86:	4d 69       	lddpc	r9,80007fdc <processPacket+0x634>
80007e88:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007e8c:	30 48       	mov	r8,4
80007e8e:	f0 09 18 00 	cp.b	r9,r8
80007e92:	c0 71       	brne	80007ea0 <processPacket+0x4f8>
							{
								txHead[bus] = 0;
80007e94:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007e98:	4d 1a       	lddpc	r10,80007fdc <processPacket+0x634>
80007e9a:	30 08       	mov	r8,0
80007e9c:	f4 09 0b 08 	st.b	r10[r9],r8
						 * Instruction:	0x01
						 * Parameter..: No parameters.
						 * Checksum...:	~((instruction + length + id) & 0xFF).
						 */
						
						for (txBus = ((rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == DYNAMIXEL_ID_BROADCAST) ? BUS_1_MOTORS : bus); txBus <= ((rxCircBuffer[bus][rxTail[bus]].INSTRUCTION_PACKET.nID == DYNAMIXEL_ID_BROADCAST) ? BUS_3_MOTORS : bus); txBus++)
80007ea0:	ef 38 ff fe 	ld.ub	r8,r7[-2]
80007ea4:	2f f8       	sub	r8,-1
80007ea6:	ef 68 ff fe 	st.b	r7[-2],r8
80007eaa:	ef 3a ff fe 	ld.ub	r10,r7[-2]
80007eae:	ef 3c ff fd 	ld.ub	r12,r7[-3]
80007eb2:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007eb6:	4c 59       	lddpc	r9,80007fc8 <processPacket+0x620>
80007eb8:	f2 08 07 08 	ld.ub	r8,r9[r8]
80007ebc:	10 9b       	mov	r11,r8
80007ebe:	4c 49       	lddpc	r9,80007fcc <processPacket+0x624>
80007ec0:	e0 68 00 86 	mov	r8,134
80007ec4:	b1 3b       	mul	r11,r8
80007ec6:	e0 68 07 da 	mov	r8,2010
80007eca:	f8 08 02 48 	mul	r8,r12,r8
80007ece:	f6 08 00 08 	add	r8,r11,r8
80007ed2:	f2 08 00 08 	add	r8,r9,r8
80007ed6:	11 a9       	ld.ub	r9,r8[0x2]
80007ed8:	3f e8       	mov	r8,-2
80007eda:	f0 09 18 00 	cp.b	r9,r8
80007ede:	c0 40       	breq	80007ee6 <processPacket+0x53e>
80007ee0:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007ee4:	c0 28       	rjmp	80007ee8 <processPacket+0x540>
80007ee6:	30 28       	mov	r8,2
80007ee8:	10 3a       	cp.w	r10,r8
80007eea:	fe 9a ff 29 	brle	80007d3c <processPacket+0x394>
				// Packet is meant for a different device. So route it to the correct USART accordingly.
				;
			}
			
			// Increment the tail pointer.
			rxTail[bus]++;
80007eee:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007ef2:	4b 69       	lddpc	r9,80007fc8 <processPacket+0x620>
80007ef4:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007ef8:	2f f9       	sub	r9,-1
80007efa:	5c 59       	castu.b	r9
80007efc:	4b 3a       	lddpc	r10,80007fc8 <processPacket+0x620>
80007efe:	f4 08 0b 09 	st.b	r10[r8],r9
80007f02:	c0 28       	rjmp	80007f06 <processPacket+0x55e>
	// Check each bus for anything to process.
	for (bus = BUS_1_MOTORS; bus <= BUS_6_USB; bus++)
	{
		// We need only check the receive buffers to see if there is anything to process.
		// The transmit buffers are filled as a result of our processing.
		while (rxTail[bus] != rxHead[bus])
80007f04:	d7 03       	nop
80007f06:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007f0a:	4b 09       	lddpc	r9,80007fc8 <processPacket+0x620>
80007f0c:	f2 08 07 09 	ld.ub	r9,r9[r8]
80007f10:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007f14:	4b 5a       	lddpc	r10,80007fe8 <processPacket+0x640>
80007f16:	f4 08 07 08 	ld.ub	r8,r10[r8]
80007f1a:	f0 09 18 00 	cp.b	r9,r8
80007f1e:	fe 91 fd 4e 	brne	800079ba <processPacket+0x12>
{
	uint8_t bus, txBus;
	uint8_t error;
	
	// Check each bus for anything to process.
	for (bus = BUS_1_MOTORS; bus <= BUS_6_USB; bus++)
80007f22:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007f26:	2f f8       	sub	r8,-1
80007f28:	ef 68 ff fd 	st.b	r7[-3],r8
80007f2c:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007f30:	30 38       	mov	r8,3
80007f32:	f0 09 18 00 	cp.b	r9,r8
80007f36:	fe 98 ff e7 	brls	80007f04 <processPacket+0x55c>
			// Increment the tail pointer.
			rxTail[bus]++;
		}
	}

	for (bus = BUS_1_MOTORS; bus < BUS_6_USB; bus++)
80007f3a:	30 08       	mov	r8,0
80007f3c:	ef 68 ff fd 	st.b	r7[-3],r8
80007f40:	c3 a8       	rjmp	80007fb4 <processPacket+0x60c>
	{
		// If UART is open
		if (BUS[bus]->imr & AVR32_USART_IER_RXRDY_MASK)
80007f42:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007f46:	4a a8       	lddpc	r8,80007fec <processPacket+0x644>
80007f48:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80007f4c:	70 48       	ld.w	r8,r8[0x10]
80007f4e:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80007f52:	5c 58       	castu.b	r8
80007f54:	c2 b0       	breq	80007faa <processPacket+0x602>
		{
			// Enable UART TX interrupt to send a new value
			BUS[bus]->ier = AVR32_USART_IER_TXRDY_MASK;
80007f56:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007f5a:	4a 58       	lddpc	r8,80007fec <processPacket+0x644>
80007f5c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80007f60:	30 29       	mov	r9,2
80007f62:	91 29       	st.w	r8[0x8],r9
			
			usart_write_char(BUS[bus], BUS[bus]->csr & AVR32_USART_CSR_RXRDY_MASK);
80007f64:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007f68:	4a 18       	lddpc	r8,80007fec <processPacket+0x644>
80007f6a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80007f6e:	70 58       	ld.w	r8,r8[0x14]
80007f70:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80007f74:	ef 3a ff fd 	ld.ub	r10,r7[-3]
80007f78:	49 d8       	lddpc	r8,80007fec <processPacket+0x644>
80007f7a:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80007f7e:	12 9b       	mov	r11,r9
80007f80:	10 9c       	mov	r12,r8
80007f82:	f0 1f 00 1c 	mcall	80007ff0 <processPacket+0x648>
			usart_write_char(BUS[bus], BUS[bus]->csr & AVR32_USART_CSR_TXRDY_MASK);
80007f86:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007f8a:	49 98       	lddpc	r8,80007fec <processPacket+0x644>
80007f8c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80007f90:	70 58       	ld.w	r8,r8[0x14]
80007f92:	10 99       	mov	r9,r8
80007f94:	e2 19 00 02 	andl	r9,0x2,COH
80007f98:	ef 3a ff fd 	ld.ub	r10,r7[-3]
80007f9c:	49 48       	lddpc	r8,80007fec <processPacket+0x644>
80007f9e:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80007fa2:	12 9b       	mov	r11,r9
80007fa4:	10 9c       	mov	r12,r8
80007fa6:	f0 1f 00 13 	mcall	80007ff0 <processPacket+0x648>
			// Increment the tail pointer.
			rxTail[bus]++;
		}
	}

	for (bus = BUS_1_MOTORS; bus < BUS_6_USB; bus++)
80007faa:	ef 38 ff fd 	ld.ub	r8,r7[-3]
80007fae:	2f f8       	sub	r8,-1
80007fb0:	ef 68 ff fd 	st.b	r7[-3],r8
80007fb4:	ef 39 ff fd 	ld.ub	r9,r7[-3]
80007fb8:	30 28       	mov	r8,2
80007fba:	f0 09 18 00 	cp.b	r9,r8
80007fbe:	fe 98 ff c2 	brls	80007f42 <processPacket+0x59a>
			
			usart_write_char(BUS[bus], BUS[bus]->csr & AVR32_USART_CSR_RXRDY_MASK);
			usart_write_char(BUS[bus], BUS[bus]->csr & AVR32_USART_CSR_TXRDY_MASK);
		}
	}
}
80007fc2:	2f fd       	sub	sp,-4
80007fc4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc
80007fc8:	00 00       	add	r0,r0
80007fca:	46 28       	lddsp	r8,sp[0x188]
80007fcc:	00 00       	add	r0,r0
80007fce:	26 ac       	sub	r12,106
80007fd0:	80 00       	ld.sh	r0,r0[0x0]
80007fd2:	77 b0       	ld.w	r0,r11[0x6c]
80007fd4:	80 00       	ld.sh	r0,r0[0x0]
80007fd6:	91 28       	st.w	r8[0x8],r8
80007fd8:	80 00       	ld.sh	r0,r0[0x0]
80007fda:	77 ea       	ld.w	r10,r11[0x78]
80007fdc:	00 00       	add	r0,r0
80007fde:	46 14       	lddsp	r4,sp[0x184]
80007fe0:	00 00       	add	r0,r0
80007fe2:	07 44       	ld.w	r4,--r3
80007fe4:	80 80       	ld.uh	r0,r0[0x0]
80007fe6:	00 00       	add	r0,r0
80007fe8:	00 00       	add	r0,r0
80007fea:	46 24       	lddsp	r4,sp[0x188]
80007fec:	00 00       	add	r0,r0
80007fee:	46 34       	lddsp	r4,sp[0x18c]
80007ff0:	80 00       	ld.sh	r0,r0[0x0]
80007ff2:	2f 70       	sub	r0,-9

80007ff4 <motorBusIntteruptController>:

void motorBusIntteruptController(uint8_t motorBus)
{			
80007ff4:	eb cd 40 80 	pushm	r7,lr
80007ff8:	1a 97       	mov	r7,sp
80007ffa:	20 5d       	sub	sp,20
80007ffc:	18 98       	mov	r8,r12
80007ffe:	ef 68 ff ec 	st.b	r7[-20],r8
	// Release USART trigger.
	triggerUSART &= (1 << motorBus);
80008002:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008006:	30 19       	mov	r9,1
80008008:	f2 08 09 48 	lsl	r8,r9,r8
8000800c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80008010:	fe f8 04 80 	ld.w	r8,pc[1152]
80008014:	11 88       	ld.ub	r8,r8[0x0]
80008016:	f3 e8 00 08 	and	r8,r9,r8
8000801a:	5c 58       	castu.b	r8
8000801c:	5c 58       	castu.b	r8
8000801e:	fe f9 04 72 	ld.w	r9,pc[1138]
80008022:	b2 88       	st.b	r9[0x0],r8
			
    // There is a message being received from one of the buses.
    if (BUS[motorBus]->csr & AVR32_USART_CSR_RXRDY_MASK)
80008024:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008028:	fe f8 04 6c 	ld.w	r8,pc[1132]
8000802c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008030:	70 58       	ld.w	r8,r8[0x14]
80008032:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008036:	5c 58       	castu.b	r8
80008038:	e0 80 01 47 	breq	800082c6 <motorBusIntteruptController+0x2d2>
    {
		if (rxTail[motorBus] != rxHead[motorBus])
8000803c:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008040:	fe f9 04 58 	ld.w	r9,pc[1112]
80008044:	f2 08 07 09 	ld.ub	r9,r9[r8]
80008048:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000804c:	fe fa 04 50 	ld.w	r10,pc[1104]
80008050:	f4 08 07 08 	ld.ub	r8,r10[r8]
80008054:	f0 09 18 00 	cp.b	r9,r8
80008058:	e0 80 01 14 	breq	80008280 <motorBusIntteruptController+0x28c>
		{
			if (usart_read_char(BUS[motorBus], (int *)&rxCircBuffer[motorBus][txTail[motorBus]].packet[txPosition[motorBus]]) != USART_SUCCESS)
8000805c:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80008060:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008064:	fe f9 04 3c 	ld.w	r9,pc[1084]
80008068:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000806c:	10 99       	mov	r9,r8
8000806e:	e0 68 00 86 	mov	r8,134
80008072:	b1 39       	mul	r9,r8
80008074:	e0 68 07 da 	mov	r8,2010
80008078:	f4 08 02 48 	mul	r8,r10,r8
8000807c:	10 09       	add	r9,r8
8000807e:	fe f8 04 26 	ld.w	r8,pc[1062]
80008082:	f2 08 00 08 	add	r8,r9,r8
80008086:	10 99       	mov	r9,r8
80008088:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000808c:	fe f8 04 1c 	ld.w	r8,pc[1052]
80008090:	f0 0a 04 18 	ld.sh	r8,r8[r10<<0x1]
80008094:	5c 78       	castu.h	r8
80008096:	10 09       	add	r9,r8
80008098:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000809c:	fe f8 03 f8 	ld.w	r8,pc[1016]
800080a0:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
800080a4:	12 9b       	mov	r11,r9
800080a6:	10 9c       	mov	r12,r8
800080a8:	f0 1f 01 01 	mcall	800084ac <motorBusIntteruptController+0x4b8>
800080ac:	18 98       	mov	r8,r12
800080ae:	58 08       	cp.w	r8,0
800080b0:	c2 80       	breq	80008100 <motorBusIntteruptController+0x10c>
			{
				// Receiver was not ready or an error occurred.
				usart_reset_status(BUS[motorBus]);
800080b2:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800080b6:	fe f8 03 de 	ld.w	r8,pc[990]
800080ba:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800080be:	ef 48 ff f0 	st.w	r7[-16],r8
 *
 * \param usart   Base address of the USART instance.
 */
__always_inline static void usart_reset_status(volatile avr32_usart_t *usart)
{
  usart->cr = AVR32_USART_CR_RSTSTA_MASK;
800080c2:	ee f8 ff f0 	ld.w	r8,r7[-16]
800080c6:	e0 69 01 00 	mov	r9,256
800080ca:	91 09       	st.w	r8[0x0],r9
				BUS[motorBus]->idr = AVR32_USART_IER_RXRDY_MASK;
800080cc:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800080d0:	fe f8 03 c4 	ld.w	r8,pc[964]
800080d4:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800080d8:	30 19       	mov	r9,1
800080da:	91 39       	st.w	r8[0xc],r9
			
				// Release USART trigger.
				triggerUSART &= (1 << motorBus);
800080dc:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800080e0:	30 19       	mov	r9,1
800080e2:	f2 08 09 48 	lsl	r8,r9,r8
800080e6:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800080ea:	fe f8 03 a6 	ld.w	r8,pc[934]
800080ee:	11 88       	ld.ub	r8,r8[0x0]
800080f0:	f3 e8 00 08 	and	r8,r9,r8
800080f4:	5c 58       	castu.b	r8
800080f6:	5c 58       	castu.b	r8
800080f8:	fe f9 03 98 	ld.w	r9,pc[920]
800080fc:	b2 88       	st.b	r9[0x0],r8
				}

				// There is no sanity checking to perform on this byte.
				else
				{
					rxPosition[motorBus]++;
800080fe:	ce 48       	rjmp	800082c6 <motorBusIntteruptController+0x2d2>
			else
			{
				// We read a character, now sanity check it.
            
				// Verify each byte of the preamble.
				if ((rxPosition[motorBus] == 0) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[0] != 0xFF))
80008100:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008104:	fe f8 03 ac 	ld.w	r8,pc[940]
80008108:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000810c:	58 08       	cp.w	r8,0
8000810e:	c2 41       	brne	80008156 <motorBusIntteruptController+0x162>
80008110:	ef 3b ff ec 	ld.ub	r11,r7[-20]
80008114:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008118:	fe f9 03 84 	ld.w	r9,pc[900]
8000811c:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008120:	10 9a       	mov	r10,r8
80008122:	fe f9 03 82 	ld.w	r9,pc[898]
80008126:	e0 68 00 86 	mov	r8,134
8000812a:	b1 3a       	mul	r10,r8
8000812c:	e0 68 07 da 	mov	r8,2010
80008130:	f6 08 02 48 	mul	r8,r11,r8
80008134:	f4 08 00 08 	add	r8,r10,r8
80008138:	f2 08 00 08 	add	r8,r9,r8
8000813c:	11 89       	ld.ub	r9,r8[0x0]
8000813e:	3f f8       	mov	r8,-1
80008140:	f0 09 18 00 	cp.b	r9,r8
80008144:	c0 90       	breq	80008156 <motorBusIntteruptController+0x162>
				{
					// Preamble is wrong. Ignore this character and start again.
					rxPosition[motorBus] = 0;
80008146:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000814a:	fe f9 03 66 	ld.w	r9,pc[870]
8000814e:	30 08       	mov	r8,0
80008150:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			else
			{
				// We read a character, now sanity check it.
            
				// Verify each byte of the preamble.
				if ((rxPosition[motorBus] == 0) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[0] != 0xFF))
80008154:	cb 98       	rjmp	800082c6 <motorBusIntteruptController+0x2d2>
				{
					// Preamble is wrong. Ignore this character and start again.
					rxPosition[motorBus] = 0;
				}
            
				else if ((rxPosition[motorBus] == 1) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[1] != 0xFF))
80008156:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000815a:	fe f8 03 56 	ld.w	r8,pc[854]
8000815e:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
80008162:	30 18       	mov	r8,1
80008164:	f0 09 19 00 	cp.h	r9,r8
80008168:	c2 61       	brne	800081b4 <motorBusIntteruptController+0x1c0>
8000816a:	ef 3b ff ec 	ld.ub	r11,r7[-20]
8000816e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008172:	fe f9 03 2a 	ld.w	r9,pc[810]
80008176:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000817a:	10 9a       	mov	r10,r8
8000817c:	fe f9 03 28 	ld.w	r9,pc[808]
80008180:	e0 68 00 86 	mov	r8,134
80008184:	b1 3a       	mul	r10,r8
80008186:	e0 68 07 da 	mov	r8,2010
8000818a:	f6 08 02 48 	mul	r8,r11,r8
8000818e:	f4 08 00 08 	add	r8,r10,r8
80008192:	f2 08 00 08 	add	r8,r9,r8
80008196:	2f f8       	sub	r8,-1
80008198:	11 89       	ld.ub	r9,r8[0x0]
8000819a:	3f f8       	mov	r8,-1
8000819c:	f0 09 18 00 	cp.b	r9,r8
800081a0:	c0 a0       	breq	800081b4 <motorBusIntteruptController+0x1c0>
				{
					// Preamble is wrong. Ignore this character and start again.
					rxPosition[motorBus] = 0;
800081a2:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800081a6:	fe f9 03 0a 	ld.w	r9,pc[778]
800081aa:	30 08       	mov	r8,0
800081ac:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				{
					// Preamble is wrong. Ignore this character and start again.
					rxPosition[motorBus] = 0;
				}
            
				else if ((rxPosition[motorBus] == 1) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[1] != 0xFF))
800081b0:	d7 03       	nop
800081b2:	c8 a8       	rjmp	800082c6 <motorBusIntteruptController+0x2d2>
				// When we read in the last parameter we need to jump to the checksum position.
				// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0.
				// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
				// 5 - 1 + (length - 2) = length + 2.
				// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
				else if (rxPosition[motorBus] == (rxCircBuffer[motorBus][rxHead[motorBus]].INSTRUCTION_PACKET.nLength + 2))
800081b4:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800081b8:	fe f8 02 f8 	ld.w	r8,pc[760]
800081bc:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800081c0:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
800081c4:	ef 3c ff ec 	ld.ub	r12,r7[-20]
800081c8:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800081cc:	fe fa 02 d0 	ld.w	r10,pc[720]
800081d0:	f4 08 07 08 	ld.ub	r8,r10[r8]
800081d4:	10 9b       	mov	r11,r8
800081d6:	fe fa 02 ce 	ld.w	r10,pc[718]
800081da:	e0 68 00 86 	mov	r8,134
800081de:	b1 3b       	mul	r11,r8
800081e0:	e0 68 07 da 	mov	r8,2010
800081e4:	f8 08 02 48 	mul	r8,r12,r8
800081e8:	f6 08 00 08 	add	r8,r11,r8
800081ec:	f4 08 00 08 	add	r8,r10,r8
800081f0:	11 b8       	ld.ub	r8,r8[0x3]
800081f2:	2f e8       	sub	r8,-2
800081f4:	10 39       	cp.w	r9,r8
800081f6:	c0 a1       	brne	8000820a <motorBusIntteruptController+0x216>
				{
					rxPosition[motorBus] = MAX_PARAMETERS + 5;
800081f8:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800081fc:	fe f9 02 b4 	ld.w	r9,pc[692]
80008200:	e0 68 00 84 	mov	r8,132
80008204:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				}

				// There is no sanity checking to perform on this byte.
				else
				{
					rxPosition[motorBus]++;
80008208:	c5 f8       	rjmp	800082c6 <motorBusIntteruptController+0x2d2>
					rxPosition[motorBus] = MAX_PARAMETERS + 5;
				}

				// We just read in the checksum byte, so we are done.
				// The checksum byte can be verified later.
				else if (rxPosition[motorBus] == (MAX_PARAMETERS + 5))
8000820a:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000820e:	fe f8 02 a2 	ld.w	r8,pc[674]
80008212:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
80008216:	e0 68 00 84 	mov	r8,132
8000821a:	f0 09 19 00 	cp.h	r9,r8
8000821e:	c2 41       	brne	80008266 <motorBusIntteruptController+0x272>
				{
					if (++rxHead[motorBus] == NUM_BUSES)
80008220:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008224:	fe f9 02 78 	ld.w	r9,pc[632]
80008228:	f2 08 07 09 	ld.ub	r9,r9[r8]
8000822c:	2f f9       	sub	r9,-1
8000822e:	5c 59       	castu.b	r9
80008230:	fe fa 02 6c 	ld.w	r10,pc[620]
80008234:	f4 08 0b 09 	st.b	r10[r8],r9
80008238:	fe f9 02 64 	ld.w	r9,pc[612]
8000823c:	f2 08 07 09 	ld.ub	r9,r9[r8]
80008240:	30 48       	mov	r8,4
80008242:	f0 09 18 00 	cp.b	r9,r8
80008246:	c0 81       	brne	80008256 <motorBusIntteruptController+0x262>
					{
						rxHead[motorBus] = 0;
80008248:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000824c:	fe fa 02 50 	ld.w	r10,pc[592]
80008250:	30 08       	mov	r8,0
80008252:	f4 09 0b 08 	st.b	r10[r9],r8
					}

					rxPosition[motorBus] = 0;
80008256:	ef 3a ff ec 	ld.ub	r10,r7[-20]
8000825a:	fe f9 02 56 	ld.w	r9,pc[598]
8000825e:	30 08       	mov	r8,0
80008260:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				}

				// There is no sanity checking to perform on this byte.
				else
				{
					rxPosition[motorBus]++;
80008264:	c3 18       	rjmp	800082c6 <motorBusIntteruptController+0x2d2>
80008266:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000826a:	fe f9 02 46 	ld.w	r9,pc[582]
8000826e:	f2 08 04 19 	ld.sh	r9,r9[r8<<0x1]
80008272:	2f f9       	sub	r9,-1
80008274:	5c 89       	casts.h	r9
80008276:	fe fa 02 3a 	ld.w	r10,pc[570]
8000827a:	f4 08 0a 19 	st.h	r10[r8<<0x1],r9
8000827e:	c2 48       	rjmp	800082c6 <motorBusIntteruptController+0x2d2>
		}
				
		else
		{
			// Nothing to receive.
			usart_reset_status(BUS[motorBus]);
80008280:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008284:	fe f8 02 10 	ld.w	r8,pc[528]
80008288:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000828c:	ef 48 ff f4 	st.w	r7[-12],r8
80008290:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008294:	e0 69 01 00 	mov	r9,256
80008298:	91 09       	st.w	r8[0x0],r9
			BUS[motorBus]->idr = AVR32_USART_IER_RXRDY_MASK;
8000829a:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000829e:	4f e8       	lddpc	r8,80008494 <motorBusIntteruptController+0x4a0>
800082a0:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800082a4:	30 19       	mov	r9,1
800082a6:	91 39       	st.w	r8[0xc],r9
			
			// Release USART trigger.
			triggerUSART &= (1 << motorBus);
800082a8:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800082ac:	30 19       	mov	r9,1
800082ae:	f2 08 09 48 	lsl	r8,r9,r8
800082b2:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
800082b6:	4f 78       	lddpc	r8,80008490 <motorBusIntteruptController+0x49c>
800082b8:	11 88       	ld.ub	r8,r8[0x0]
800082ba:	f3 e8 00 08 	and	r8,r9,r8
800082be:	5c 58       	castu.b	r8
800082c0:	5c 58       	castu.b	r8
800082c2:	4f 49       	lddpc	r9,80008490 <motorBusIntteruptController+0x49c>
800082c4:	b2 88       	st.b	r9[0x0],r8
		}
    }

    // There is a message to be transmitted to one of the buses.
    if (BUS[motorBus]->csr & AVR32_USART_CSR_TXRDY_MASK)
800082c6:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800082ca:	4f 38       	lddpc	r8,80008494 <motorBusIntteruptController+0x4a0>
800082cc:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800082d0:	70 58       	ld.w	r8,r8[0x14]
800082d2:	e2 18 00 02 	andl	r8,0x2,COH
800082d6:	e0 80 00 d9 	breq	80008488 <motorBusIntteruptController+0x494>
	{
		if (txTail[motorBus] != txHead[motorBus])
800082da:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800082de:	4f 19       	lddpc	r9,800084a0 <motorBusIntteruptController+0x4ac>
800082e0:	f2 08 07 09 	ld.ub	r9,r9[r8]
800082e4:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800082e8:	4f 3a       	lddpc	r10,800084b4 <motorBusIntteruptController+0x4c0>
800082ea:	f4 08 07 08 	ld.ub	r8,r10[r8]
800082ee:	f0 09 18 00 	cp.b	r9,r8
800082f2:	e0 80 00 a9 	breq	80008444 <motorBusIntteruptController+0x450>
		{
			if (usart_write_char(BUS[motorBus], txCircBuffer[motorBus][txTail[motorBus]].packet[txPosition[motorBus]]) != USART_SUCCESS)
800082f6:	ef 3c ff ec 	ld.ub	r12,r7[-20]
800082fa:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800082fe:	4e 99       	lddpc	r9,800084a0 <motorBusIntteruptController+0x4ac>
80008300:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008304:	10 9b       	mov	r11,r8
80008306:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000830a:	4e 88       	lddpc	r8,800084a8 <motorBusIntteruptController+0x4b4>
8000830c:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80008310:	5c 78       	castu.h	r8
80008312:	4e aa       	lddpc	r10,800084b8 <motorBusIntteruptController+0x4c4>
80008314:	e0 69 00 86 	mov	r9,134
80008318:	b3 3b       	mul	r11,r9
8000831a:	e0 69 07 da 	mov	r9,2010
8000831e:	f8 09 02 49 	mul	r9,r12,r9
80008322:	f6 09 00 09 	add	r9,r11,r9
80008326:	f4 09 00 09 	add	r9,r10,r9
8000832a:	f2 08 00 08 	add	r8,r9,r8
8000832e:	11 88       	ld.ub	r8,r8[0x0]
80008330:	10 99       	mov	r9,r8
80008332:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80008336:	4d 88       	lddpc	r8,80008494 <motorBusIntteruptController+0x4a0>
80008338:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
8000833c:	12 9b       	mov	r11,r9
8000833e:	10 9c       	mov	r12,r8
80008340:	f0 1f 00 5f 	mcall	800084bc <motorBusIntteruptController+0x4c8>
80008344:	18 98       	mov	r8,r12
80008346:	58 08       	cp.w	r8,0
80008348:	c2 40       	breq	80008390 <motorBusIntteruptController+0x39c>
			{
				// Transmitter was not ready.
				usart_reset_status(BUS[motorBus]);
8000834a:	ef 39 ff ec 	ld.ub	r9,r7[-20]
8000834e:	4d 28       	lddpc	r8,80008494 <motorBusIntteruptController+0x4a0>
80008350:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008354:	ef 48 ff f8 	st.w	r7[-8],r8
80008358:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000835c:	e0 69 01 00 	mov	r9,256
80008360:	91 09       	st.w	r8[0x0],r9
				BUS[motorBus]->idr = AVR32_USART_IER_TXRDY_MASK;
80008362:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008366:	4c c8       	lddpc	r8,80008494 <motorBusIntteruptController+0x4a0>
80008368:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000836c:	30 29       	mov	r9,2
8000836e:	91 39       	st.w	r8[0xc],r9
			
				// Release USART trigger.
				triggerUSART &= (1 << motorBus);
80008370:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008374:	30 19       	mov	r9,1
80008376:	f2 08 09 48 	lsl	r8,r9,r8
8000837a:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
8000837e:	4c 58       	lddpc	r8,80008490 <motorBusIntteruptController+0x49c>
80008380:	11 88       	ld.ub	r8,r8[0x0]
80008382:	f3 e8 00 08 	and	r8,r9,r8
80008386:	5c 58       	castu.b	r8
80008388:	5c 58       	castu.b	r8
8000838a:	4c 29       	lddpc	r9,80008490 <motorBusIntteruptController+0x49c>
8000838c:	b2 88       	st.b	r9[0x0],r8
8000838e:	c7 d8       	rjmp	80008488 <motorBusIntteruptController+0x494>
				// When we write the last parameter we need to jump to the checksum position.
				// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0.
				// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
				// 5 - 1 + (length - 2) = length + 2.
				// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
				if (txPosition[motorBus] == (txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nLength + 2))
80008390:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008394:	4c 58       	lddpc	r8,800084a8 <motorBusIntteruptController+0x4b4>
80008396:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000839a:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000839e:	ef 3c ff ec 	ld.ub	r12,r7[-20]
800083a2:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800083a6:	4b fa       	lddpc	r10,800084a0 <motorBusIntteruptController+0x4ac>
800083a8:	f4 08 07 08 	ld.ub	r8,r10[r8]
800083ac:	10 9b       	mov	r11,r8
800083ae:	4c 3a       	lddpc	r10,800084b8 <motorBusIntteruptController+0x4c4>
800083b0:	e0 68 00 86 	mov	r8,134
800083b4:	b1 3b       	mul	r11,r8
800083b6:	e0 68 07 da 	mov	r8,2010
800083ba:	f8 08 02 48 	mul	r8,r12,r8
800083be:	f6 08 00 08 	add	r8,r11,r8
800083c2:	f4 08 00 08 	add	r8,r10,r8
800083c6:	11 b8       	ld.ub	r8,r8[0x3]
800083c8:	2f e8       	sub	r8,-2
800083ca:	10 39       	cp.w	r9,r8
800083cc:	c0 91       	brne	800083de <motorBusIntteruptController+0x3ea>
				{
					txPosition[motorBus] = MAX_PARAMETERS + 5;
800083ce:	ef 3a ff ec 	ld.ub	r10,r7[-20]
800083d2:	4b 69       	lddpc	r9,800084a8 <motorBusIntteruptController+0x4b4>
800083d4:	e0 68 00 84 	mov	r8,132
800083d8:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
800083dc:	c5 68       	rjmp	80008488 <motorBusIntteruptController+0x494>
				}

				// We just wrote the checksum byte, so we are done.
				else if (txPosition[motorBus] == (MAX_PARAMETERS + 5))
800083de:	ef 39 ff ec 	ld.ub	r9,r7[-20]
800083e2:	4b 28       	lddpc	r8,800084a8 <motorBusIntteruptController+0x4b4>
800083e4:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800083e8:	e0 68 00 84 	mov	r8,132
800083ec:	f0 09 19 00 	cp.h	r9,r8
800083f0:	c1 f1       	brne	8000842e <motorBusIntteruptController+0x43a>
				{
					if (++txTail[motorBus] == NUM_BUSES)
800083f2:	ef 38 ff ec 	ld.ub	r8,r7[-20]
800083f6:	4a b9       	lddpc	r9,800084a0 <motorBusIntteruptController+0x4ac>
800083f8:	f2 08 07 09 	ld.ub	r9,r9[r8]
800083fc:	2f f9       	sub	r9,-1
800083fe:	5c 59       	castu.b	r9
80008400:	4a 8a       	lddpc	r10,800084a0 <motorBusIntteruptController+0x4ac>
80008402:	f4 08 0b 09 	st.b	r10[r8],r9
80008406:	4a 79       	lddpc	r9,800084a0 <motorBusIntteruptController+0x4ac>
80008408:	f2 08 07 09 	ld.ub	r9,r9[r8]
8000840c:	30 48       	mov	r8,4
8000840e:	f0 09 18 00 	cp.b	r9,r8
80008412:	c0 71       	brne	80008420 <motorBusIntteruptController+0x42c>
					{
						txTail[motorBus] = 0;
80008414:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008418:	4a 2a       	lddpc	r10,800084a0 <motorBusIntteruptController+0x4ac>
8000841a:	30 08       	mov	r8,0
8000841c:	f4 09 0b 08 	st.b	r10[r9],r8
					}

					txPosition[motorBus] = 0;
80008420:	ef 3a ff ec 	ld.ub	r10,r7[-20]
80008424:	4a 19       	lddpc	r9,800084a8 <motorBusIntteruptController+0x4b4>
80008426:	30 08       	mov	r8,0
80008428:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
8000842c:	c2 e8       	rjmp	80008488 <motorBusIntteruptController+0x494>
				}

				else
				{
					txPosition[motorBus]++;
8000842e:	ef 38 ff ec 	ld.ub	r8,r7[-20]
80008432:	49 e9       	lddpc	r9,800084a8 <motorBusIntteruptController+0x4b4>
80008434:	f2 08 04 19 	ld.sh	r9,r9[r8<<0x1]
80008438:	2f f9       	sub	r9,-1
8000843a:	5c 89       	casts.h	r9
8000843c:	49 ba       	lddpc	r10,800084a8 <motorBusIntteruptController+0x4b4>
8000843e:	f4 08 0a 19 	st.h	r10[r8<<0x1],r9
80008442:	c2 38       	rjmp	80008488 <motorBusIntteruptController+0x494>
		}
		
		else
		{
			// Nothing to transmit.
			usart_reset_status(BUS[motorBus]);
80008444:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008448:	49 38       	lddpc	r8,80008494 <motorBusIntteruptController+0x4a0>
8000844a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000844e:	ef 48 ff fc 	st.w	r7[-4],r8
80008452:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008456:	e0 69 01 00 	mov	r9,256
8000845a:	91 09       	st.w	r8[0x0],r9
			BUS[motorBus]->idr = AVR32_USART_IER_TXRDY_MASK;
8000845c:	ef 39 ff ec 	ld.ub	r9,r7[-20]
80008460:	48 d8       	lddpc	r8,80008494 <motorBusIntteruptController+0x4a0>
80008462:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008466:	30 29       	mov	r9,2
80008468:	91 39       	st.w	r8[0xc],r9
			
			// Release USART trigger.
			triggerUSART &= (1 << motorBus);
8000846a:	ef 38 ff ec 	ld.ub	r8,r7[-20]
8000846e:	30 19       	mov	r9,1
80008470:	f2 08 09 48 	lsl	r8,r9,r8
80008474:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80008478:	48 68       	lddpc	r8,80008490 <motorBusIntteruptController+0x49c>
8000847a:	11 88       	ld.ub	r8,r8[0x0]
8000847c:	f3 e8 00 08 	and	r8,r9,r8
80008480:	5c 58       	castu.b	r8
80008482:	5c 58       	castu.b	r8
80008484:	48 39       	lddpc	r9,80008490 <motorBusIntteruptController+0x49c>
80008486:	b2 88       	st.b	r9[0x0],r8
		}
	}
}
80008488:	2f bd       	sub	sp,-20
8000848a:	e3 cd 80 80 	ldm	sp++,r7,pc
8000848e:	00 00       	add	r0,r0
80008490:	00 00       	add	r0,r0
80008492:	46 45       	lddsp	r5,sp[0x190]
80008494:	00 00       	add	r0,r0
80008496:	46 34       	lddsp	r4,sp[0x18c]
80008498:	00 00       	add	r0,r0
8000849a:	46 28       	lddsp	r8,sp[0x188]
8000849c:	00 00       	add	r0,r0
8000849e:	46 24       	lddsp	r4,sp[0x188]
800084a0:	00 00       	add	r0,r0
800084a2:	46 18       	lddsp	r8,sp[0x184]
800084a4:	00 00       	add	r0,r0
800084a6:	26 ac       	sub	r12,106
800084a8:	00 00       	add	r0,r0
800084aa:	46 1c       	lddsp	r12,sp[0x184]
800084ac:	80 00       	ld.sh	r0,r0[0x0]
800084ae:	2f b4       	sub	r4,-5
800084b0:	00 00       	add	r0,r0
800084b2:	46 2c       	lddsp	r12,sp[0x188]
800084b4:	00 00       	add	r0,r0
800084b6:	46 14       	lddsp	r4,sp[0x184]
800084b8:	00 00       	add	r0,r0
800084ba:	07 44       	ld.w	r4,--r3
800084bc:	80 00       	ld.sh	r0,r0[0x0]
800084be:	2f 70       	sub	r0,-9

800084c0 <usart_interrupt>:

__attribute__((__interrupt__)) static void usart_interrupt(void)
{
800084c0:	eb cd 40 80 	pushm	r7,lr
800084c4:	1a 97       	mov	r7,sp
800084c6:	20 5d       	sub	sp,20
//	int value;
	
//	triggerUSART |= 0x02;

	int motorBus = 1;
800084c8:	30 18       	mov	r8,1
800084ca:	ef 48 ff ec 	st.w	r7[-20],r8

    // There is a message being received from one of the buses.
    if (BUS[motorBus]->csr & AVR32_USART_CSR_RXRDY_MASK)
800084ce:	ee f9 ff ec 	ld.w	r9,r7[-20]
800084d2:	fe f8 05 b2 	ld.w	r8,pc[1458]
800084d6:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
800084da:	70 58       	ld.w	r8,r8[0x14]
800084dc:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
800084e0:	5c 58       	castu.b	r8
800084e2:	e0 80 01 4a 	breq	80008776 <usart_interrupt+0x2b6>
    {
		if (rxTail[motorBus] != rxHead[motorBus])
800084e6:	ee f8 ff ec 	ld.w	r8,r7[-20]
800084ea:	fe f9 05 9e 	ld.w	r9,pc[1438]
800084ee:	f2 08 07 09 	ld.ub	r9,r9[r8]
800084f2:	ee f8 ff ec 	ld.w	r8,r7[-20]
800084f6:	fe fa 05 96 	ld.w	r10,pc[1430]
800084fa:	f4 08 07 08 	ld.ub	r8,r10[r8]
800084fe:	f0 09 18 00 	cp.b	r9,r8
80008502:	e0 80 01 14 	breq	8000872a <usart_interrupt+0x26a>
		{
			if (usart_read_char(BUS[motorBus], (int *)&rxCircBuffer[motorBus][txTail[motorBus]].packet[txPosition[motorBus]]) != USART_SUCCESS)
80008506:	ee fa ff ec 	ld.w	r10,r7[-20]
8000850a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000850e:	fe f9 05 82 	ld.w	r9,pc[1410]
80008512:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008516:	10 99       	mov	r9,r8
80008518:	e0 68 00 86 	mov	r8,134
8000851c:	b1 39       	mul	r9,r8
8000851e:	e0 68 07 da 	mov	r8,2010
80008522:	f4 08 02 48 	mul	r8,r10,r8
80008526:	10 09       	add	r9,r8
80008528:	fe f8 05 6c 	ld.w	r8,pc[1388]
8000852c:	f2 08 00 08 	add	r8,r9,r8
80008530:	10 99       	mov	r9,r8
80008532:	ee fa ff ec 	ld.w	r10,r7[-20]
80008536:	fe f8 05 62 	ld.w	r8,pc[1378]
8000853a:	f0 0a 04 18 	ld.sh	r8,r8[r10<<0x1]
8000853e:	5c 78       	castu.h	r8
80008540:	10 09       	add	r9,r8
80008542:	ee fa ff ec 	ld.w	r10,r7[-20]
80008546:	fe f8 05 3e 	ld.w	r8,pc[1342]
8000854a:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
8000854e:	12 9b       	mov	r11,r9
80008550:	10 9c       	mov	r12,r8
80008552:	f0 1f 01 53 	mcall	80008a9c <usart_interrupt+0x5dc>
80008556:	18 98       	mov	r8,r12
80008558:	58 08       	cp.w	r8,0
8000855a:	c2 80       	breq	800085aa <usart_interrupt+0xea>
			{
				// Receiver was not ready or an error occurred.
				usart_reset_status(BUS[motorBus]);
8000855c:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008560:	fe f8 05 24 	ld.w	r8,pc[1316]
80008564:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008568:	ef 48 ff f0 	st.w	r7[-16],r8
8000856c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008570:	e0 69 01 00 	mov	r9,256
80008574:	91 09       	st.w	r8[0x0],r9
				BUS[motorBus]->idr = AVR32_USART_IER_RXRDY_MASK;
80008576:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000857a:	fe f8 05 0a 	ld.w	r8,pc[1290]
8000857e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008582:	30 19       	mov	r9,1
80008584:	91 39       	st.w	r8[0xc],r9
			
				// Release USART trigger.
				triggerUSART &= (1 << motorBus);
80008586:	30 19       	mov	r9,1
80008588:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000858c:	f2 08 09 48 	lsl	r8,r9,r8
80008590:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80008594:	fe f8 05 0c 	ld.w	r8,pc[1292]
80008598:	11 88       	ld.ub	r8,r8[0x0]
8000859a:	f3 e8 00 08 	and	r8,r9,r8
8000859e:	5c 58       	castu.b	r8
800085a0:	5c 58       	castu.b	r8
800085a2:	fe f9 04 fe 	ld.w	r9,pc[1278]
800085a6:	b2 88       	st.b	r9[0x0],r8
				}

				// There is no sanity checking to perform on this byte.
				else
				{
					rxPosition[motorBus]++;
800085a8:	ce 78       	rjmp	80008776 <usart_interrupt+0x2b6>
			else
			{
				// We read a character, now sanity check it.
            
				// Verify each byte of the preamble.
				if ((rxPosition[motorBus] == 0) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[0] != 0xFF))
800085aa:	ee f9 ff ec 	ld.w	r9,r7[-20]
800085ae:	fe f8 04 f6 	ld.w	r8,pc[1270]
800085b2:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
800085b6:	58 08       	cp.w	r8,0
800085b8:	c2 41       	brne	80008600 <usart_interrupt+0x140>
800085ba:	ee fb ff ec 	ld.w	r11,r7[-20]
800085be:	ee f8 ff ec 	ld.w	r8,r7[-20]
800085c2:	fe f9 04 ca 	ld.w	r9,pc[1226]
800085c6:	f2 08 07 08 	ld.ub	r8,r9[r8]
800085ca:	10 9a       	mov	r10,r8
800085cc:	fe f9 04 c8 	ld.w	r9,pc[1224]
800085d0:	e0 68 00 86 	mov	r8,134
800085d4:	b1 3a       	mul	r10,r8
800085d6:	e0 68 07 da 	mov	r8,2010
800085da:	f6 08 02 48 	mul	r8,r11,r8
800085de:	f4 08 00 08 	add	r8,r10,r8
800085e2:	f2 08 00 08 	add	r8,r9,r8
800085e6:	11 89       	ld.ub	r9,r8[0x0]
800085e8:	3f f8       	mov	r8,-1
800085ea:	f0 09 18 00 	cp.b	r9,r8
800085ee:	c0 90       	breq	80008600 <usart_interrupt+0x140>
				{
					// Preamble is wrong. Ignore this character and start again.
					rxPosition[motorBus] = 0;
800085f0:	ee fa ff ec 	ld.w	r10,r7[-20]
800085f4:	fe f9 04 b0 	ld.w	r9,pc[1200]
800085f8:	30 08       	mov	r8,0
800085fa:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
			else
			{
				// We read a character, now sanity check it.
            
				// Verify each byte of the preamble.
				if ((rxPosition[motorBus] == 0) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[0] != 0xFF))
800085fe:	cb c8       	rjmp	80008776 <usart_interrupt+0x2b6>
				{
					// Preamble is wrong. Ignore this character and start again.
					rxPosition[motorBus] = 0;
				}
            
				else if ((rxPosition[motorBus] == 1) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[1] != 0xFF))
80008600:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008604:	fe f8 04 a0 	ld.w	r8,pc[1184]
80008608:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
8000860c:	30 18       	mov	r8,1
8000860e:	f0 09 19 00 	cp.h	r9,r8
80008612:	c2 61       	brne	8000865e <usart_interrupt+0x19e>
80008614:	ee fb ff ec 	ld.w	r11,r7[-20]
80008618:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000861c:	fe f9 04 70 	ld.w	r9,pc[1136]
80008620:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008624:	10 9a       	mov	r10,r8
80008626:	fe f9 04 6e 	ld.w	r9,pc[1134]
8000862a:	e0 68 00 86 	mov	r8,134
8000862e:	b1 3a       	mul	r10,r8
80008630:	e0 68 07 da 	mov	r8,2010
80008634:	f6 08 02 48 	mul	r8,r11,r8
80008638:	f4 08 00 08 	add	r8,r10,r8
8000863c:	f2 08 00 08 	add	r8,r9,r8
80008640:	2f f8       	sub	r8,-1
80008642:	11 89       	ld.ub	r9,r8[0x0]
80008644:	3f f8       	mov	r8,-1
80008646:	f0 09 18 00 	cp.b	r9,r8
8000864a:	c0 a0       	breq	8000865e <usart_interrupt+0x19e>
				{
					// Preamble is wrong. Ignore this character and start again.
					rxPosition[motorBus] = 0;
8000864c:	ee fa ff ec 	ld.w	r10,r7[-20]
80008650:	fe f9 04 54 	ld.w	r9,pc[1108]
80008654:	30 08       	mov	r8,0
80008656:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				{
					// Preamble is wrong. Ignore this character and start again.
					rxPosition[motorBus] = 0;
				}
            
				else if ((rxPosition[motorBus] == 1) && (rxCircBuffer[motorBus][rxHead[motorBus]].packet[1] != 0xFF))
8000865a:	d7 03       	nop
8000865c:	c8 d8       	rjmp	80008776 <usart_interrupt+0x2b6>
				// When we read in the last parameter we need to jump to the checksum position.
				// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0.
				// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
				// 5 - 1 + (length - 2) = length + 2.
				// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
				else if (rxPosition[motorBus] == (rxCircBuffer[motorBus][rxHead[motorBus]].INSTRUCTION_PACKET.nLength + 2))
8000865e:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008662:	fe f8 04 42 	ld.w	r8,pc[1090]
80008666:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000866a:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
8000866e:	ee fc ff ec 	ld.w	r12,r7[-20]
80008672:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008676:	fe fa 04 16 	ld.w	r10,pc[1046]
8000867a:	f4 08 07 08 	ld.ub	r8,r10[r8]
8000867e:	10 9b       	mov	r11,r8
80008680:	fe fa 04 14 	ld.w	r10,pc[1044]
80008684:	e0 68 00 86 	mov	r8,134
80008688:	b1 3b       	mul	r11,r8
8000868a:	e0 68 07 da 	mov	r8,2010
8000868e:	f8 08 02 48 	mul	r8,r12,r8
80008692:	f6 08 00 08 	add	r8,r11,r8
80008696:	f4 08 00 08 	add	r8,r10,r8
8000869a:	11 b8       	ld.ub	r8,r8[0x3]
8000869c:	2f e8       	sub	r8,-2
8000869e:	10 39       	cp.w	r9,r8
800086a0:	c0 a1       	brne	800086b4 <usart_interrupt+0x1f4>
				{
					rxPosition[motorBus] = MAX_PARAMETERS + 5;
800086a2:	ee fa ff ec 	ld.w	r10,r7[-20]
800086a6:	fe f9 03 fe 	ld.w	r9,pc[1022]
800086aa:	e0 68 00 84 	mov	r8,132
800086ae:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				}

				// There is no sanity checking to perform on this byte.
				else
				{
					rxPosition[motorBus]++;
800086b2:	c6 28       	rjmp	80008776 <usart_interrupt+0x2b6>
					rxPosition[motorBus] = MAX_PARAMETERS + 5;
				}

				// We just read in the checksum byte, so we are done.
				// The checksum byte can be verified later.
				else if (rxPosition[motorBus] == (MAX_PARAMETERS + 5))
800086b4:	ee f9 ff ec 	ld.w	r9,r7[-20]
800086b8:	fe f8 03 ec 	ld.w	r8,pc[1004]
800086bc:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800086c0:	e0 68 00 84 	mov	r8,132
800086c4:	f0 09 19 00 	cp.h	r9,r8
800086c8:	c2 41       	brne	80008710 <usart_interrupt+0x250>
				{
					if (++rxHead[motorBus] == NUM_BUSES)
800086ca:	ee f8 ff ec 	ld.w	r8,r7[-20]
800086ce:	fe f9 03 be 	ld.w	r9,pc[958]
800086d2:	f2 08 07 09 	ld.ub	r9,r9[r8]
800086d6:	2f f9       	sub	r9,-1
800086d8:	5c 59       	castu.b	r9
800086da:	fe fa 03 b2 	ld.w	r10,pc[946]
800086de:	f4 08 0b 09 	st.b	r10[r8],r9
800086e2:	fe f9 03 aa 	ld.w	r9,pc[938]
800086e6:	f2 08 07 09 	ld.ub	r9,r9[r8]
800086ea:	30 48       	mov	r8,4
800086ec:	f0 09 18 00 	cp.b	r9,r8
800086f0:	c0 81       	brne	80008700 <usart_interrupt+0x240>
					{
						rxHead[motorBus] = 0;
800086f2:	ee f9 ff ec 	ld.w	r9,r7[-20]
800086f6:	fe fa 03 96 	ld.w	r10,pc[918]
800086fa:	30 08       	mov	r8,0
800086fc:	f4 09 0b 08 	st.b	r10[r9],r8
					}

					rxPosition[motorBus] = 0;
80008700:	ee fa ff ec 	ld.w	r10,r7[-20]
80008704:	fe f9 03 a0 	ld.w	r9,pc[928]
80008708:	30 08       	mov	r8,0
8000870a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
				}

				// There is no sanity checking to perform on this byte.
				else
				{
					rxPosition[motorBus]++;
8000870e:	c3 48       	rjmp	80008776 <usart_interrupt+0x2b6>
80008710:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008714:	fe f9 03 90 	ld.w	r9,pc[912]
80008718:	f2 08 04 19 	ld.sh	r9,r9[r8<<0x1]
8000871c:	2f f9       	sub	r9,-1
8000871e:	5c 89       	casts.h	r9
80008720:	fe fa 03 84 	ld.w	r10,pc[900]
80008724:	f4 08 0a 19 	st.h	r10[r8<<0x1],r9
80008728:	c2 78       	rjmp	80008776 <usart_interrupt+0x2b6>
		}
				
		else
		{
			// Nothing to receive.
			usart_reset_status(BUS[motorBus]);
8000872a:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000872e:	fe f8 03 56 	ld.w	r8,pc[854]
80008732:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008736:	ef 48 ff f4 	st.w	r7[-12],r8
8000873a:	ee f8 ff f4 	ld.w	r8,r7[-12]
8000873e:	e0 69 01 00 	mov	r9,256
80008742:	91 09       	st.w	r8[0x0],r9
			BUS[motorBus]->idr = AVR32_USART_IER_RXRDY_MASK;
80008744:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008748:	fe f8 03 3c 	ld.w	r8,pc[828]
8000874c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008750:	30 19       	mov	r9,1
80008752:	91 39       	st.w	r8[0xc],r9
			
			// Release USART trigger.
			triggerUSART &= (1 << motorBus);
80008754:	30 19       	mov	r9,1
80008756:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000875a:	f2 08 09 48 	lsl	r8,r9,r8
8000875e:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80008762:	fe f8 03 3e 	ld.w	r8,pc[830]
80008766:	11 88       	ld.ub	r8,r8[0x0]
80008768:	f3 e8 00 08 	and	r8,r9,r8
8000876c:	5c 58       	castu.b	r8
8000876e:	5c 58       	castu.b	r8
80008770:	fe f9 03 30 	ld.w	r9,pc[816]
80008774:	b2 88       	st.b	r9[0x0],r8
		}
    }

    // There is a message to be transmitted to one of the buses.
    if (BUS[motorBus]->csr & AVR32_USART_CSR_TXRDY_MASK)
80008776:	ee f9 ff ec 	ld.w	r9,r7[-20]
8000877a:	fe f8 03 0a 	ld.w	r8,pc[778]
8000877e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008782:	70 58       	ld.w	r8,r8[0x14]
80008784:	e2 18 00 02 	andl	r8,0x2,COH
80008788:	e0 80 01 79 	breq	80008a7a <usart_interrupt+0x5ba>
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nID);
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nLength);
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nInstruction);
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nChecksum);
			*/
		if (txTail[motorBus] != txHead[motorBus])
8000878c:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008790:	fe f9 03 00 	ld.w	r9,pc[768]
80008794:	f2 08 07 09 	ld.ub	r9,r9[r8]
80008798:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000879c:	fe fa 03 0c 	ld.w	r10,pc[780]
800087a0:	f4 08 07 08 	ld.ub	r8,r10[r8]
800087a4:	f0 09 18 00 	cp.b	r9,r8
800087a8:	e0 80 01 47 	breq	80008a36 <usart_interrupt+0x576>
		{
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].packet[0]);
800087ac:	ee fb ff ec 	ld.w	r11,r7[-20]
800087b0:	ee f8 ff ec 	ld.w	r8,r7[-20]
800087b4:	fe f9 02 dc 	ld.w	r9,pc[732]
800087b8:	f2 08 07 08 	ld.ub	r8,r9[r8]
800087bc:	10 9a       	mov	r10,r8
800087be:	fe f9 02 ee 	ld.w	r9,pc[750]
800087c2:	e0 68 00 86 	mov	r8,134
800087c6:	b1 3a       	mul	r10,r8
800087c8:	e0 68 07 da 	mov	r8,2010
800087cc:	f6 08 02 48 	mul	r8,r11,r8
800087d0:	f4 08 00 08 	add	r8,r10,r8
800087d4:	f2 08 00 08 	add	r8,r9,r8
800087d8:	11 88       	ld.ub	r8,r8[0x0]
800087da:	10 9c       	mov	r12,r8
800087dc:	f0 1f 00 b5 	mcall	80008ab0 <usart_interrupt+0x5f0>
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].packet[1]);
800087e0:	ee fb ff ec 	ld.w	r11,r7[-20]
800087e4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800087e8:	fe f9 02 a8 	ld.w	r9,pc[680]
800087ec:	f2 08 07 08 	ld.ub	r8,r9[r8]
800087f0:	10 9a       	mov	r10,r8
800087f2:	fe f9 02 ba 	ld.w	r9,pc[698]
800087f6:	e0 68 00 86 	mov	r8,134
800087fa:	b1 3a       	mul	r10,r8
800087fc:	e0 68 07 da 	mov	r8,2010
80008800:	f6 08 02 48 	mul	r8,r11,r8
80008804:	f4 08 00 08 	add	r8,r10,r8
80008808:	f2 08 00 08 	add	r8,r9,r8
8000880c:	2f f8       	sub	r8,-1
8000880e:	11 88       	ld.ub	r8,r8[0x0]
80008810:	10 9c       	mov	r12,r8
80008812:	f0 1f 00 a8 	mcall	80008ab0 <usart_interrupt+0x5f0>
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nID);
80008816:	ee fb ff ec 	ld.w	r11,r7[-20]
8000881a:	ee f8 ff ec 	ld.w	r8,r7[-20]
8000881e:	fe f9 02 72 	ld.w	r9,pc[626]
80008822:	f2 08 07 08 	ld.ub	r8,r9[r8]
80008826:	10 9a       	mov	r10,r8
80008828:	fe f9 02 84 	ld.w	r9,pc[644]
8000882c:	e0 68 00 86 	mov	r8,134
80008830:	b1 3a       	mul	r10,r8
80008832:	e0 68 07 da 	mov	r8,2010
80008836:	f6 08 02 48 	mul	r8,r11,r8
8000883a:	f4 08 00 08 	add	r8,r10,r8
8000883e:	f2 08 00 08 	add	r8,r9,r8
80008842:	11 a8       	ld.ub	r8,r8[0x2]
80008844:	10 9c       	mov	r12,r8
80008846:	f0 1f 00 9b 	mcall	80008ab0 <usart_interrupt+0x5f0>
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nLength);
8000884a:	ee fb ff ec 	ld.w	r11,r7[-20]
8000884e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008852:	fe f9 02 3e 	ld.w	r9,pc[574]
80008856:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000885a:	10 9a       	mov	r10,r8
8000885c:	fe f9 02 50 	ld.w	r9,pc[592]
80008860:	e0 68 00 86 	mov	r8,134
80008864:	b1 3a       	mul	r10,r8
80008866:	e0 68 07 da 	mov	r8,2010
8000886a:	f6 08 02 48 	mul	r8,r11,r8
8000886e:	f4 08 00 08 	add	r8,r10,r8
80008872:	f2 08 00 08 	add	r8,r9,r8
80008876:	11 b8       	ld.ub	r8,r8[0x3]
80008878:	10 9c       	mov	r12,r8
8000887a:	f0 1f 00 8e 	mcall	80008ab0 <usart_interrupt+0x5f0>
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nInstruction);
8000887e:	ee fb ff ec 	ld.w	r11,r7[-20]
80008882:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008886:	fe f9 02 0a 	ld.w	r9,pc[522]
8000888a:	f2 08 07 08 	ld.ub	r8,r9[r8]
8000888e:	10 9a       	mov	r10,r8
80008890:	fe f9 02 1c 	ld.w	r9,pc[540]
80008894:	e0 68 00 86 	mov	r8,134
80008898:	b1 3a       	mul	r10,r8
8000889a:	e0 68 07 da 	mov	r8,2010
8000889e:	f6 08 02 48 	mul	r8,r11,r8
800088a2:	f4 08 00 08 	add	r8,r10,r8
800088a6:	f2 08 00 08 	add	r8,r9,r8
800088aa:	2f c8       	sub	r8,-4
800088ac:	11 88       	ld.ub	r8,r8[0x0]
800088ae:	10 9c       	mov	r12,r8
800088b0:	f0 1f 00 80 	mcall	80008ab0 <usart_interrupt+0x5f0>
			udi_cdc_putc(txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nChecksum);
800088b4:	ee fb ff ec 	ld.w	r11,r7[-20]
800088b8:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088bc:	4f 59       	lddpc	r9,80008a90 <usart_interrupt+0x5d0>
800088be:	f2 08 07 08 	ld.ub	r8,r9[r8]
800088c2:	10 9a       	mov	r10,r8
800088c4:	4f a9       	lddpc	r9,80008aac <usart_interrupt+0x5ec>
800088c6:	e0 68 00 86 	mov	r8,134
800088ca:	b1 3a       	mul	r10,r8
800088cc:	e0 68 07 da 	mov	r8,2010
800088d0:	f6 08 02 48 	mul	r8,r11,r8
800088d4:	f4 08 00 08 	add	r8,r10,r8
800088d8:	f2 08 00 08 	add	r8,r9,r8
800088dc:	f0 c8 ff 7c 	sub	r8,r8,-132
800088e0:	11 88       	ld.ub	r8,r8[0x0]
800088e2:	10 9c       	mov	r12,r8
800088e4:	f0 1f 00 73 	mcall	80008ab0 <usart_interrupt+0x5f0>
			
			if (usart_write_char(BUS[motorBus], txCircBuffer[motorBus][txTail[motorBus]].packet[txPosition[motorBus]]) != USART_SUCCESS)
800088e8:	ee fc ff ec 	ld.w	r12,r7[-20]
800088ec:	ee f8 ff ec 	ld.w	r8,r7[-20]
800088f0:	4e 89       	lddpc	r9,80008a90 <usart_interrupt+0x5d0>
800088f2:	f2 08 07 08 	ld.ub	r8,r9[r8]
800088f6:	10 9b       	mov	r11,r8
800088f8:	ee f9 ff ec 	ld.w	r9,r7[-20]
800088fc:	4e 78       	lddpc	r8,80008a98 <usart_interrupt+0x5d8>
800088fe:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
80008902:	5c 78       	castu.h	r8
80008904:	4e aa       	lddpc	r10,80008aac <usart_interrupt+0x5ec>
80008906:	e0 69 00 86 	mov	r9,134
8000890a:	b3 3b       	mul	r11,r9
8000890c:	e0 69 07 da 	mov	r9,2010
80008910:	f8 09 02 49 	mul	r9,r12,r9
80008914:	f6 09 00 09 	add	r9,r11,r9
80008918:	f4 09 00 09 	add	r9,r10,r9
8000891c:	f2 08 00 08 	add	r8,r9,r8
80008920:	11 88       	ld.ub	r8,r8[0x0]
80008922:	10 99       	mov	r9,r8
80008924:	ee fa ff ec 	ld.w	r10,r7[-20]
80008928:	4d 78       	lddpc	r8,80008a84 <usart_interrupt+0x5c4>
8000892a:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
8000892e:	12 9b       	mov	r11,r9
80008930:	10 9c       	mov	r12,r8
80008932:	f0 1f 00 61 	mcall	80008ab4 <usart_interrupt+0x5f4>
80008936:	18 98       	mov	r8,r12
80008938:	58 08       	cp.w	r8,0
8000893a:	c2 40       	breq	80008982 <usart_interrupt+0x4c2>
			{
				// Transmitter was not ready.
				usart_reset_status(BUS[motorBus]);
8000893c:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008940:	4d 18       	lddpc	r8,80008a84 <usart_interrupt+0x5c4>
80008942:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008946:	ef 48 ff f8 	st.w	r7[-8],r8
8000894a:	ee f8 ff f8 	ld.w	r8,r7[-8]
8000894e:	e0 69 01 00 	mov	r9,256
80008952:	91 09       	st.w	r8[0x0],r9
				BUS[motorBus]->idr = AVR32_USART_IER_TXRDY_MASK;
80008954:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008958:	4c b8       	lddpc	r8,80008a84 <usart_interrupt+0x5c4>
8000895a:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
8000895e:	30 29       	mov	r9,2
80008960:	91 39       	st.w	r8[0xc],r9
			
				// Release USART trigger.
				triggerUSART &= (1 << motorBus);
80008962:	30 19       	mov	r9,1
80008964:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008968:	f2 08 09 48 	lsl	r8,r9,r8
8000896c:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80008970:	4c c8       	lddpc	r8,80008aa0 <usart_interrupt+0x5e0>
80008972:	11 88       	ld.ub	r8,r8[0x0]
80008974:	f3 e8 00 08 	and	r8,r9,r8
80008978:	5c 58       	castu.b	r8
8000897a:	5c 58       	castu.b	r8
8000897c:	4c 99       	lddpc	r9,80008aa0 <usart_interrupt+0x5e0>
8000897e:	b2 88       	st.b	r9[0x0],r8
80008980:	c7 d8       	rjmp	80008a7a <usart_interrupt+0x5ba>
				// When we write the last parameter we need to jump to the checksum position.
				// There is a total of 5 bytes before the parameters, less 1 since we start counting from 0.
				// The length field contains the number of parameters + 2. So, the number of bytes to reach the last parameter is
				// 5 - 1 + (length - 2) = length + 2.
				// The checksum is the last byte in the structure. With a structure length of MAX_PARATERS + 6, this equates to MAX_PARAMETS + 5.
				if (txPosition[motorBus] == (txCircBuffer[motorBus][txTail[motorBus]].INSTRUCTION_PACKET.nLength + 2))
80008982:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008986:	4c 58       	lddpc	r8,80008a98 <usart_interrupt+0x5d8>
80008988:	f0 09 04 18 	ld.sh	r8,r8[r9<<0x1]
8000898c:	f3 d8 c0 10 	bfextu	r9,r8,0x0,0x10
80008990:	ee fc ff ec 	ld.w	r12,r7[-20]
80008994:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008998:	4b ea       	lddpc	r10,80008a90 <usart_interrupt+0x5d0>
8000899a:	f4 08 07 08 	ld.ub	r8,r10[r8]
8000899e:	10 9b       	mov	r11,r8
800089a0:	4c 3a       	lddpc	r10,80008aac <usart_interrupt+0x5ec>
800089a2:	e0 68 00 86 	mov	r8,134
800089a6:	b1 3b       	mul	r11,r8
800089a8:	e0 68 07 da 	mov	r8,2010
800089ac:	f8 08 02 48 	mul	r8,r12,r8
800089b0:	f6 08 00 08 	add	r8,r11,r8
800089b4:	f4 08 00 08 	add	r8,r10,r8
800089b8:	11 b8       	ld.ub	r8,r8[0x3]
800089ba:	2f e8       	sub	r8,-2
800089bc:	10 39       	cp.w	r9,r8
800089be:	c0 91       	brne	800089d0 <usart_interrupt+0x510>
				{
					txPosition[motorBus] = MAX_PARAMETERS + 5;
800089c0:	ee fa ff ec 	ld.w	r10,r7[-20]
800089c4:	4b 59       	lddpc	r9,80008a98 <usart_interrupt+0x5d8>
800089c6:	e0 68 00 84 	mov	r8,132
800089ca:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
800089ce:	c5 68       	rjmp	80008a7a <usart_interrupt+0x5ba>
				}

				// We just wrote the checksum byte, so we are done.
				else if (txPosition[motorBus] == (MAX_PARAMETERS + 5))
800089d0:	ee f9 ff ec 	ld.w	r9,r7[-20]
800089d4:	4b 18       	lddpc	r8,80008a98 <usart_interrupt+0x5d8>
800089d6:	f0 09 04 19 	ld.sh	r9,r8[r9<<0x1]
800089da:	e0 68 00 84 	mov	r8,132
800089de:	f0 09 19 00 	cp.h	r9,r8
800089e2:	c1 f1       	brne	80008a20 <usart_interrupt+0x560>
				{
					if (++txTail[motorBus] == NUM_BUSES)
800089e4:	ee f8 ff ec 	ld.w	r8,r7[-20]
800089e8:	4a a9       	lddpc	r9,80008a90 <usart_interrupt+0x5d0>
800089ea:	f2 08 07 09 	ld.ub	r9,r9[r8]
800089ee:	2f f9       	sub	r9,-1
800089f0:	5c 59       	castu.b	r9
800089f2:	4a 8a       	lddpc	r10,80008a90 <usart_interrupt+0x5d0>
800089f4:	f4 08 0b 09 	st.b	r10[r8],r9
800089f8:	4a 69       	lddpc	r9,80008a90 <usart_interrupt+0x5d0>
800089fa:	f2 08 07 09 	ld.ub	r9,r9[r8]
800089fe:	30 48       	mov	r8,4
80008a00:	f0 09 18 00 	cp.b	r9,r8
80008a04:	c0 71       	brne	80008a12 <usart_interrupt+0x552>
					{
						txTail[motorBus] = 0;
80008a06:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008a0a:	4a 2a       	lddpc	r10,80008a90 <usart_interrupt+0x5d0>
80008a0c:	30 08       	mov	r8,0
80008a0e:	f4 09 0b 08 	st.b	r10[r9],r8
					}

					txPosition[motorBus] = 0;
80008a12:	ee fa ff ec 	ld.w	r10,r7[-20]
80008a16:	4a 19       	lddpc	r9,80008a98 <usart_interrupt+0x5d8>
80008a18:	30 08       	mov	r8,0
80008a1a:	f2 0a 0a 18 	st.h	r9[r10<<0x1],r8
80008a1e:	c2 e8       	rjmp	80008a7a <usart_interrupt+0x5ba>
				}

				else
				{
					txPosition[motorBus]++;
80008a20:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008a24:	49 d9       	lddpc	r9,80008a98 <usart_interrupt+0x5d8>
80008a26:	f2 08 04 19 	ld.sh	r9,r9[r8<<0x1]
80008a2a:	2f f9       	sub	r9,-1
80008a2c:	5c 89       	casts.h	r9
80008a2e:	49 ba       	lddpc	r10,80008a98 <usart_interrupt+0x5d8>
80008a30:	f4 08 0a 19 	st.h	r10[r8<<0x1],r9
80008a34:	c2 38       	rjmp	80008a7a <usart_interrupt+0x5ba>
		}
		
		else
		{
			// Nothing to transmit.
			usart_reset_status(BUS[motorBus]);
80008a36:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008a3a:	49 38       	lddpc	r8,80008a84 <usart_interrupt+0x5c4>
80008a3c:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008a40:	ef 48 ff fc 	st.w	r7[-4],r8
80008a44:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008a48:	e0 69 01 00 	mov	r9,256
80008a4c:	91 09       	st.w	r8[0x0],r9
			BUS[motorBus]->idr = AVR32_USART_IER_TXRDY_MASK;
80008a4e:	ee f9 ff ec 	ld.w	r9,r7[-20]
80008a52:	48 d8       	lddpc	r8,80008a84 <usart_interrupt+0x5c4>
80008a54:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008a58:	30 29       	mov	r9,2
80008a5a:	91 39       	st.w	r8[0xc],r9
			
			// Release USART trigger.
			triggerUSART &= (1 << motorBus);
80008a5c:	30 19       	mov	r9,1
80008a5e:	ee f8 ff ec 	ld.w	r8,r7[-20]
80008a62:	f2 08 09 48 	lsl	r8,r9,r8
80008a66:	f3 d8 c0 08 	bfextu	r9,r8,0x0,0x8
80008a6a:	48 e8       	lddpc	r8,80008aa0 <usart_interrupt+0x5e0>
80008a6c:	11 88       	ld.ub	r8,r8[0x0]
80008a6e:	f3 e8 00 08 	and	r8,r9,r8
80008a72:	5c 58       	castu.b	r8
80008a74:	5c 58       	castu.b	r8
80008a76:	48 b9       	lddpc	r9,80008aa0 <usart_interrupt+0x5e0>
80008a78:	b2 88       	st.b	r9[0x0],r8
		}
	}
}
80008a7a:	2f bd       	sub	sp,-20
80008a7c:	e3 cd 40 80 	ldm	sp++,r7,lr
80008a80:	d6 03       	rete
80008a82:	00 00       	add	r0,r0
80008a84:	00 00       	add	r0,r0
80008a86:	46 34       	lddsp	r4,sp[0x18c]
80008a88:	00 00       	add	r0,r0
80008a8a:	46 28       	lddsp	r8,sp[0x188]
80008a8c:	00 00       	add	r0,r0
80008a8e:	46 24       	lddsp	r4,sp[0x188]
80008a90:	00 00       	add	r0,r0
80008a92:	46 18       	lddsp	r8,sp[0x184]
80008a94:	00 00       	add	r0,r0
80008a96:	26 ac       	sub	r12,106
80008a98:	00 00       	add	r0,r0
80008a9a:	46 1c       	lddsp	r12,sp[0x184]
80008a9c:	80 00       	ld.sh	r0,r0[0x0]
80008a9e:	2f b4       	sub	r4,-5
80008aa0:	00 00       	add	r0,r0
80008aa2:	46 45       	lddsp	r5,sp[0x190]
80008aa4:	00 00       	add	r0,r0
80008aa6:	46 2c       	lddsp	r12,sp[0x188]
80008aa8:	00 00       	add	r0,r0
80008aaa:	46 14       	lddsp	r4,sp[0x184]
80008aac:	00 00       	add	r0,r0
80008aae:	07 44       	ld.w	r4,--r3
80008ab0:	80 00       	ld.sh	r0,r0[0x0]
80008ab2:	66 44       	ld.w	r4,r3[0x10]
80008ab4:	80 00       	ld.sh	r0,r0[0x0]
80008ab6:	2f 70       	sub	r0,-9

80008ab8 <usb_rx_notify>:

void usb_rx_notify(uint8_t port)
{
80008ab8:	eb cd 40 80 	pushm	r7,lr
80008abc:	1a 97       	mov	r7,sp
80008abe:	20 2d       	sub	sp,8
80008ac0:	18 98       	mov	r8,r12
80008ac2:	ef 68 ff f8 	st.b	r7[-8],r8
	uint8_t bus;
	
	readUSB = 1;
80008ac6:	4a 69       	lddpc	r9,80008b5c <usb_rx_notify+0xa4>
80008ac8:	30 18       	mov	r8,1
80008aca:	b2 88       	st.b	r9[0x0],r8
	
	// Loop through all USARTs and, if they are open, trigger the TX interrupt.
	for (bus = BUS_1_MOTORS; bus < BUS_6_USB; bus++)
80008acc:	30 08       	mov	r8,0
80008ace:	ef 68 ff ff 	st.b	r7[-1],r8
80008ad2:	c3 a8       	rjmp	80008b46 <usb_rx_notify+0x8e>
	{
		// If UART is open
		if (BUS[bus]->imr & AVR32_USART_IER_RXRDY_MASK)
80008ad4:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008ad8:	4a 28       	lddpc	r8,80008b60 <usb_rx_notify+0xa8>
80008ada:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008ade:	70 48       	ld.w	r8,r8[0x10]
80008ae0:	f1 d8 c0 01 	bfextu	r8,r8,0x0,0x1
80008ae4:	5c 58       	castu.b	r8
80008ae6:	c2 b0       	breq	80008b3c <usb_rx_notify+0x84>
		{
			// Enable UART TX interrupt to send a new value
			BUS[bus]->ier = AVR32_USART_IER_TXRDY_MASK;
80008ae8:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008aec:	49 d8       	lddpc	r8,80008b60 <usb_rx_notify+0xa8>
80008aee:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008af2:	30 29       	mov	r9,2
80008af4:	91 29       	st.w	r8[0x8],r9
			
			usart_write_char(BUS[bus], BUS[bus]->csr & AVR32_USART_CSR_RXRDY_MASK);
80008af6:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008afa:	49 a8       	lddpc	r8,80008b60 <usb_rx_notify+0xa8>
80008afc:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008b00:	70 58       	ld.w	r8,r8[0x14]
80008b02:	f3 d8 c0 01 	bfextu	r9,r8,0x0,0x1
80008b06:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80008b0a:	49 68       	lddpc	r8,80008b60 <usb_rx_notify+0xa8>
80008b0c:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80008b10:	12 9b       	mov	r11,r9
80008b12:	10 9c       	mov	r12,r8
80008b14:	f0 1f 00 14 	mcall	80008b64 <usb_rx_notify+0xac>
			usart_write_char(BUS[bus], BUS[bus]->csr & AVR32_USART_CSR_TXRDY_MASK);
80008b18:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008b1c:	49 18       	lddpc	r8,80008b60 <usb_rx_notify+0xa8>
80008b1e:	f0 09 03 28 	ld.w	r8,r8[r9<<0x2]
80008b22:	70 58       	ld.w	r8,r8[0x14]
80008b24:	10 99       	mov	r9,r8
80008b26:	e2 19 00 02 	andl	r9,0x2,COH
80008b2a:	ef 3a ff ff 	ld.ub	r10,r7[-1]
80008b2e:	48 d8       	lddpc	r8,80008b60 <usb_rx_notify+0xa8>
80008b30:	f0 0a 03 28 	ld.w	r8,r8[r10<<0x2]
80008b34:	12 9b       	mov	r11,r9
80008b36:	10 9c       	mov	r12,r8
80008b38:	f0 1f 00 0b 	mcall	80008b64 <usb_rx_notify+0xac>
	uint8_t bus;
	
	readUSB = 1;
	
	// Loop through all USARTs and, if they are open, trigger the TX interrupt.
	for (bus = BUS_1_MOTORS; bus < BUS_6_USB; bus++)
80008b3c:	ef 38 ff ff 	ld.ub	r8,r7[-1]
80008b40:	2f f8       	sub	r8,-1
80008b42:	ef 68 ff ff 	st.b	r7[-1],r8
80008b46:	ef 39 ff ff 	ld.ub	r9,r7[-1]
80008b4a:	30 28       	mov	r8,2
80008b4c:	f0 09 18 00 	cp.b	r9,r8
80008b50:	fe 98 ff c2 	brls	80008ad4 <usb_rx_notify+0x1c>
	 *						Bit 1: Angle Limit Error. Goal position is out of range from CW Angle Limit to CCW Angle Limit.
	 *						Bit 0: Input Voltage Error. Applied input voltage is out of range.
	 * N-Byte Parameter.	N = Length - 2. This is the packet data.
	 * 1 Byte Checksum.		Checksum = ~((ID + Length + Instruction + Parameter1 + .... = Parameter N) & 0xFF).
	 */	
}
80008b54:	2f ed       	sub	sp,-8
80008b56:	e3 cd 80 80 	ldm	sp++,r7,pc
80008b5a:	00 00       	add	r0,r0
80008b5c:	00 00       	add	r0,r0
80008b5e:	46 44       	lddsp	r4,sp[0x190]
80008b60:	00 00       	add	r0,r0
80008b62:	46 34       	lddsp	r4,sp[0x18c]
80008b64:	80 00       	ld.sh	r0,r0[0x0]
80008b66:	2f 70       	sub	r0,-9

80008b68 <uart_config>:


void uart_config(uint8_t port, usb_cdc_line_coding_t * cfg)
{
80008b68:	eb cd 40 80 	pushm	r7,lr
80008b6c:	1a 97       	mov	r7,sp
80008b6e:	20 2d       	sub	sp,8
80008b70:	18 98       	mov	r8,r12
80008b72:	ef 4b ff f8 	st.w	r7[-8],r11
80008b76:	ef 68 ff fc 	st.b	r7[-4],r8
	// Initialise RAM table.
	initRAM();
80008b7a:	f0 1f 00 0c 	mcall	80008ba8 <uart_config+0x40>

	// Options for USART.
	usart_options.baudrate		= 921600; // RAM[BAUD_RATE] * 500000; // 921600;
80008b7e:	48 c8       	lddpc	r8,80008bac <uart_config+0x44>
80008b80:	ee 69 10 00 	mov	r9,921600
80008b84:	91 09       	st.w	r8[0x0],r9
	usart_options.charlength	= 0x08;
80008b86:	48 a9       	lddpc	r9,80008bac <uart_config+0x44>
80008b88:	30 88       	mov	r8,8
80008b8a:	b2 c8       	st.b	r9[0x4],r8
	usart_options.paritytype	= USART_NO_PARITY;
80008b8c:	48 89       	lddpc	r9,80008bac <uart_config+0x44>
80008b8e:	30 48       	mov	r8,4
80008b90:	b2 d8       	st.b	r9[0x5],r8
	usart_options.stopbits		= 1;
80008b92:	48 79       	lddpc	r9,80008bac <uart_config+0x44>
80008b94:	30 18       	mov	r8,1
80008b96:	b2 38       	st.h	r9[0x6],r8
	usart_options.channelmode	= USART_NORMAL_CHMODE;
80008b98:	48 59       	lddpc	r9,80008bac <uart_config+0x44>
80008b9a:	30 08       	mov	r8,0
80008b9c:	f3 68 00 08 	st.b	r9[8],r8
}
80008ba0:	2f ed       	sub	sp,-8
80008ba2:	e3 cd 80 80 	ldm	sp++,r7,pc
80008ba6:	00 00       	add	r0,r0
80008ba8:	80 00       	ld.sh	r0,r0[0x0]
80008baa:	77 4c       	ld.w	r12,r11[0x50]
80008bac:	00 00       	add	r0,r0
80008bae:	07 38       	ld.ub	r8,r3++

80008bb0 <uart_open>:

void uart_open(uint8_t port)
{
80008bb0:	eb cd 40 80 	pushm	r7,lr
80008bb4:	1a 97       	mov	r7,sp
80008bb6:	20 5d       	sub	sp,20
80008bb8:	18 98       	mov	r8,r12
80008bba:	ef 68 ff ec 	st.b	r7[-20],r8
	// Enable interrupt with priority higher than USB
	irq_register_handler(usart_interrupt, USART_IRQ, 3);
80008bbe:	30 3a       	mov	r10,3
80008bc0:	e0 6b 00 c0 	mov	r11,192
80008bc4:	4d 8c       	lddpc	r12,80008d24 <uart_open+0x174>
80008bc6:	f0 1f 00 59 	mcall	80008d28 <uart_open+0x178>

	// Initialize it in RS232 mode.
	sysclk_enable_pba_module(USART_SYSCLK);
80008bca:	30 8c       	mov	r12,8
80008bcc:	f0 1f 00 58 	mcall	80008d2c <uart_open+0x17c>

	// Calculate baud rate parameters.
	unsigned int over = (sysclk_get_pba_hz() >= 16 * usart_options.baudrate) ? 16 : 8;
80008bd0:	f0 1f 00 58 	mcall	80008d30 <uart_open+0x180>
80008bd4:	18 99       	mov	r9,r12
80008bd6:	4d 88       	lddpc	r8,80008d34 <uart_open+0x184>
80008bd8:	70 08       	ld.w	r8,r8[0x0]
80008bda:	a5 68       	lsl	r8,0x4
80008bdc:	10 39       	cp.w	r9,r8
80008bde:	c0 33       	brcs	80008be4 <uart_open+0x34>
80008be0:	31 08       	mov	r8,16
80008be2:	c0 28       	rjmp	80008be6 <uart_open+0x36>
80008be4:	30 88       	mov	r8,8
80008be6:	ef 48 ff f0 	st.w	r7[-16],r8
	unsigned int cd_fp = (0x08 * sysclk_get_pba_hz()) / (over * usart_options.baudrate) + 0.5;
80008bea:	f0 1f 00 52 	mcall	80008d30 <uart_open+0x180>
80008bee:	18 98       	mov	r8,r12
80008bf0:	a3 78       	lsl	r8,0x3
80008bf2:	4d 19       	lddpc	r9,80008d34 <uart_open+0x184>
80008bf4:	72 0a       	ld.w	r10,r9[0x0]
80008bf6:	ee f9 ff f0 	ld.w	r9,r7[-16]
80008bfa:	f4 09 02 49 	mul	r9,r10,r9
80008bfe:	f0 09 0d 08 	divu	r8,r8,r9
80008c02:	10 9c       	mov	r12,r8
80008c04:	f0 1f 00 4d 	mcall	80008d38 <uart_open+0x188>
80008c08:	30 08       	mov	r8,0
80008c0a:	30 09       	mov	r9,0
80008c0c:	ea 19 3f e0 	orh	r9,0x3fe0
80008c10:	f0 1f 00 4b 	mcall	80008d3c <uart_open+0x18c>
80008c14:	14 98       	mov	r8,r10
80008c16:	16 99       	mov	r9,r11
80008c18:	10 9a       	mov	r10,r8
80008c1a:	12 9b       	mov	r11,r9
80008c1c:	f0 1f 00 49 	mcall	80008d40 <uart_open+0x190>
80008c20:	18 98       	mov	r8,r12
80008c22:	ef 48 ff f4 	st.w	r7[-12],r8
	unsigned int cd = cd_fp >> 3;
80008c26:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008c2a:	a3 98       	lsr	r8,0x3
80008c2c:	ef 48 ff f8 	st.w	r7[-8],r8
	unsigned int fp = cd_fp & 0x07;
80008c30:	ee f8 ff f4 	ld.w	r8,r7[-12]
80008c34:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80008c38:	ef 48 ff fc 	st.w	r7[-4],r8
	
	// Set required fields in USART Mode Register.
	if ((cd >= 1) || (cd <= 0x0000FFFF))
80008c3c:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008c40:	58 08       	cp.w	r8,0
80008c42:	c0 71       	brne	80008c50 <uart_open+0xa0>
80008c44:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008c48:	e0 48 ff ff 	cp.w	r8,65535
80008c4c:	e0 8b 00 64 	brhi	80008d14 <uart_open+0x164>
	{
		USART->mr = 0;
80008c50:	fe 78 18 00 	mov	r8,-59392
80008c54:	30 09       	mov	r9,0
80008c56:	91 19       	st.w	r8[0x4],r9
		USART->MR.over = (over == 16);
80008c58:	fe 79 18 00 	mov	r9,-59392
80008c5c:	ee f8 ff f0 	ld.w	r8,r7[-16]
80008c60:	59 08       	cp.w	r8,16
80008c62:	5f 08       	sreq	r8
80008c64:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80008c68:	72 18       	ld.w	r8,r9[0x4]
80008c6a:	f1 da d2 61 	bfins	r8,r10,0x13,0x1
80008c6e:	93 18       	st.w	r9[0x4],r8
		USART->MR.chrl = 0x3;
80008c70:	fe 79 18 00 	mov	r9,-59392
80008c74:	72 18       	ld.w	r8,r9[0x4]
80008c76:	30 3a       	mov	r10,3
80008c78:	f1 da d0 c2 	bfins	r8,r10,0x6,0x2
80008c7c:	93 18       	st.w	r9[0x4],r8
		USART->MR.par = USART_NO_PARITY;
80008c7e:	fe 79 18 00 	mov	r9,-59392
80008c82:	72 18       	ld.w	r8,r9[0x4]
80008c84:	30 4a       	mov	r10,4
80008c86:	f1 da d1 23 	bfins	r8,r10,0x9,0x3
80008c8a:	93 18       	st.w	r9[0x4],r8
		
		USART->brgr = 0;
80008c8c:	fe 78 18 00 	mov	r8,-59392
80008c90:	30 09       	mov	r9,0
80008c92:	91 89       	st.w	r8[0x20],r9
		USART->BRGR.cd = cd;
80008c94:	fe 79 18 00 	mov	r9,-59392
80008c98:	ee f8 ff f8 	ld.w	r8,r7[-8]
80008c9c:	f5 d8 b0 10 	bfexts	r10,r8,0x0,0x10
80008ca0:	72 88       	ld.w	r8,r9[0x20]
80008ca2:	f1 da d0 10 	bfins	r8,r10,0x0,0x10
80008ca6:	93 88       	st.w	r9[0x20],r8
		USART->BRGR.fp = fp;
80008ca8:	fe 79 18 00 	mov	r9,-59392
80008cac:	ee f8 ff fc 	ld.w	r8,r7[-4]
80008cb0:	5c 58       	castu.b	r8
80008cb2:	f1 d8 c0 03 	bfextu	r8,r8,0x0,0x3
80008cb6:	f5 d8 c0 08 	bfextu	r10,r8,0x0,0x8
80008cba:	72 88       	ld.w	r8,r9[0x20]
80008cbc:	f1 da d2 03 	bfins	r8,r10,0x10,0x3
80008cc0:	93 88       	st.w	r9[0x20],r8
		
		USART->cr = 0;
80008cc2:	fe 78 18 00 	mov	r8,-59392
80008cc6:	30 09       	mov	r9,0
80008cc8:	91 09       	st.w	r8[0x0],r9
		USART->CR.rxen = 1;
80008cca:	fe 79 18 00 	mov	r9,-59392
80008cce:	72 08       	ld.w	r8,r9[0x0]
80008cd0:	30 1a       	mov	r10,1
80008cd2:	f1 da d0 81 	bfins	r8,r10,0x4,0x1
80008cd6:	93 08       	st.w	r9[0x0],r8
		USART->CR.txen = 1;
80008cd8:	fe 79 18 00 	mov	r9,-59392
80008cdc:	72 08       	ld.w	r8,r9[0x0]
80008cde:	30 1a       	mov	r10,1
80008ce0:	f1 da d0 c1 	bfins	r8,r10,0x6,0x1
80008ce4:	93 08       	st.w	r9[0x0],r8
		
		USART->idr = 0xFFFFFFFF;
80008ce6:	fe 78 18 00 	mov	r8,-59392
80008cea:	3f f9       	mov	r9,-1
80008cec:	91 39       	st.w	r8[0xc],r9

		USART->ier = 0;
80008cee:	fe 78 18 00 	mov	r8,-59392
80008cf2:	30 09       	mov	r9,0
80008cf4:	91 29       	st.w	r8[0x8],r9
		USART->IER.rxrdy = 1;
80008cf6:	fe 79 18 00 	mov	r9,-59392
80008cfa:	72 28       	ld.w	r8,r9[0x8]
80008cfc:	30 1a       	mov	r10,1
80008cfe:	f1 da d0 01 	bfins	r8,r10,0x0,0x1
80008d02:	93 28       	st.w	r9[0x8],r8
		USART->IER.txrdy = 1;		
80008d04:	fe 79 18 00 	mov	r9,-59392
80008d08:	72 28       	ld.w	r8,r9[0x8]
80008d0a:	30 1a       	mov	r10,1
80008d0c:	f1 da d0 21 	bfins	r8,r10,0x1,0x1
80008d10:	93 28       	st.w	r9[0x8],r8
	unsigned int cd_fp = (0x08 * sysclk_get_pba_hz()) / (over * usart_options.baudrate) + 0.5;
	unsigned int cd = cd_fp >> 3;
	unsigned int fp = cd_fp & 0x07;
	
	// Set required fields in USART Mode Register.
	if ((cd >= 1) || (cd <= 0x0000FFFF))
80008d12:	c0 58       	rjmp	80008d1c <uart_open+0x16c>
	}

	else
	{
		// Baud rate is not possible with the provided clock.
		udi_cdc_putc(0x00);
80008d14:	30 0c       	mov	r12,0
80008d16:	f0 1f 00 0c 	mcall	80008d44 <uart_open+0x194>
		return;
80008d1a:	d7 03       	nop
	}
}
80008d1c:	2f bd       	sub	sp,-20
80008d1e:	e3 cd 80 80 	ldm	sp++,r7,pc
80008d22:	00 00       	add	r0,r0
80008d24:	80 00       	ld.sh	r0,r0[0x0]
80008d26:	84 c0       	ld.uh	r0,r2[0x8]
80008d28:	80 00       	ld.sh	r0,r0[0x0]
80008d2a:	2e 9c       	sub	r12,-23
80008d2c:	80 00       	ld.sh	r0,r0[0x0]
80008d2e:	77 2c       	ld.w	r12,r11[0x48]
80008d30:	80 00       	ld.sh	r0,r0[0x0]
80008d32:	77 14       	ld.w	r4,r11[0x44]
80008d34:	00 00       	add	r0,r0
80008d36:	07 38       	ld.ub	r8,r3++
80008d38:	80 00       	ld.sh	r0,r0[0x0]
80008d3a:	90 3e       	ld.sh	lr,r8[0x6]
80008d3c:	80 00       	ld.sh	r0,r0[0x0]
80008d3e:	8f 04       	st.w	r7[0x0],r4
80008d40:	80 00       	ld.sh	r0,r0[0x0]
80008d42:	90 14       	ld.sh	r4,r8[0x2]
80008d44:	80 00       	ld.sh	r0,r0[0x0]
80008d46:	66 44       	ld.w	r4,r3[0x10]

80008d48 <uart_close>:

void uart_close(uint8_t port)
{
80008d48:	eb cd 40 80 	pushm	r7,lr
80008d4c:	1a 97       	mov	r7,sp
80008d4e:	20 1d       	sub	sp,4
80008d50:	18 98       	mov	r8,r12
80008d52:	ef 68 ff fc 	st.b	r7[-4],r8
	// Disable interrupts
	// Close RS232 communication
	USART->idr = 0xFFFFFFFF;
80008d56:	fe 78 18 00 	mov	r8,-59392
80008d5a:	3f f9       	mov	r9,-1
80008d5c:	91 39       	st.w	r8[0xc],r9
}
80008d5e:	2f fd       	sub	sp,-4
80008d60:	e3 cd 80 80 	ldm	sp++,r7,pc

80008d64 <__avr32_f64_sub_from_add>:
80008d64:	ee 19 80 00 	eorh	r9,0x8000

80008d68 <__avr32_f64_sub>:
80008d68:	f7 e9 20 0c 	eor	r12,r11,r9
80008d6c:	e0 86 00 ca 	brmi	80008f00 <__avr32_f64_add_from_sub>
80008d70:	eb cd 40 e0 	pushm	r5-r7,lr
80008d74:	16 9c       	mov	r12,r11
80008d76:	e6 1c 80 00 	andh	r12,0x8000,COH
80008d7a:	bf db       	cbr	r11,0x1f
80008d7c:	bf d9       	cbr	r9,0x1f
80008d7e:	10 3a       	cp.w	r10,r8
80008d80:	f2 0b 13 00 	cpc	r11,r9
80008d84:	c0 92       	brcc	80008d96 <__avr32_f64_sub+0x2e>
80008d86:	16 97       	mov	r7,r11
80008d88:	12 9b       	mov	r11,r9
80008d8a:	0e 99       	mov	r9,r7
80008d8c:	14 97       	mov	r7,r10
80008d8e:	10 9a       	mov	r10,r8
80008d90:	0e 98       	mov	r8,r7
80008d92:	ee 1c 80 00 	eorh	r12,0x8000
80008d96:	f6 07 16 14 	lsr	r7,r11,0x14
80008d9a:	ab 7b       	lsl	r11,0xb
80008d9c:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80008da0:	ab 7a       	lsl	r10,0xb
80008da2:	bf bb       	sbr	r11,0x1f
80008da4:	f2 06 16 14 	lsr	r6,r9,0x14
80008da8:	c4 50       	breq	80008e32 <__avr32_f64_sub_opL_subnormal>
80008daa:	ab 79       	lsl	r9,0xb
80008dac:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80008db0:	ab 78       	lsl	r8,0xb
80008db2:	bf b9       	sbr	r9,0x1f

80008db4 <__avr32_f64_sub_opL_subnormal_done>:
80008db4:	e0 47 07 ff 	cp.w	r7,2047
80008db8:	c5 00       	breq	80008e58 <__avr32_f64_sub_opH_nan_or_inf>
80008dba:	0e 26       	rsub	r6,r7
80008dbc:	c1 20       	breq	80008de0 <__avr32_f64_sub_shift_done>
80008dbe:	ec 05 11 20 	rsub	r5,r6,32
80008dc2:	e0 46 00 20 	cp.w	r6,32
80008dc6:	c7 d2       	brcc	80008ec0 <__avr32_f64_sub_longshift>
80008dc8:	f0 05 09 4e 	lsl	lr,r8,r5
80008dcc:	f2 05 09 45 	lsl	r5,r9,r5
80008dd0:	f0 06 0a 48 	lsr	r8,r8,r6
80008dd4:	f2 06 0a 49 	lsr	r9,r9,r6
80008dd8:	0a 48       	or	r8,r5
80008dda:	58 0e       	cp.w	lr,0
80008ddc:	5f 1e       	srne	lr
80008dde:	1c 48       	or	r8,lr

80008de0 <__avr32_f64_sub_shift_done>:
80008de0:	10 1a       	sub	r10,r8
80008de2:	f6 09 01 4b 	sbc	r11,r11,r9
80008de6:	f6 06 12 00 	clz	r6,r11
80008dea:	c0 e0       	breq	80008e06 <__avr32_f64_sub_longnormalize_done>
80008dec:	c7 93       	brcs	80008ede <__avr32_f64_sub_longnormalize>
80008dee:	ec 0e 11 20 	rsub	lr,r6,32
80008df2:	f6 06 09 4b 	lsl	r11,r11,r6
80008df6:	f4 0e 0a 4e 	lsr	lr,r10,lr
80008dfa:	1c 4b       	or	r11,lr
80008dfc:	f4 06 09 4a 	lsl	r10,r10,r6
80008e00:	0c 17       	sub	r7,r6
80008e02:	e0 8a 00 3a 	brle	80008e76 <__avr32_f64_sub_subnormal_result>

80008e06 <__avr32_f64_sub_longnormalize_done>:
80008e06:	f4 09 15 15 	lsl	r9,r10,0x15
80008e0a:	ab 9a       	lsr	r10,0xb
80008e0c:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
80008e10:	ab 9b       	lsr	r11,0xb
80008e12:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80008e16:	18 4b       	or	r11,r12

80008e18 <__avr32_f64_sub_round>:
80008e18:	30 07       	mov	r7,0
80008e1a:	ea 17 80 00 	orh	r7,0x8000
80008e1e:	ed ba 00 00 	bld	r10,0x0
80008e22:	f7 b7 01 ff 	subne	r7,-1
80008e26:	0e 39       	cp.w	r9,r7
80008e28:	5f 29       	srhs	r9
80008e2a:	12 0a       	add	r10,r9
80008e2c:	5c 0b       	acr	r11
80008e2e:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008e32 <__avr32_f64_sub_opL_subnormal>:
80008e32:	ab 79       	lsl	r9,0xb
80008e34:	f3 e8 13 59 	or	r9,r9,r8>>0x15
80008e38:	ab 78       	lsl	r8,0xb
80008e3a:	f3 e8 10 0e 	or	lr,r9,r8
80008e3e:	f9 b6 01 01 	movne	r6,1
80008e42:	ee 0e 11 00 	rsub	lr,r7,0
80008e46:	f9 b7 00 01 	moveq	r7,1
80008e4a:	ef bb 00 1f 	bst	r11,0x1f
80008e4e:	f7 ea 10 0e 	or	lr,r11,r10
80008e52:	f9 b7 00 00 	moveq	r7,0
80008e56:	ca fb       	rjmp	80008db4 <__avr32_f64_sub_opL_subnormal_done>

80008e58 <__avr32_f64_sub_opH_nan_or_inf>:
80008e58:	bf db       	cbr	r11,0x1f
80008e5a:	f7 ea 10 0e 	or	lr,r11,r10
80008e5e:	c0 81       	brne	80008e6e <__avr32_f64_sub_return_nan>
80008e60:	e0 46 07 ff 	cp.w	r6,2047
80008e64:	c0 50       	breq	80008e6e <__avr32_f64_sub_return_nan>
80008e66:	f9 e7 11 4b 	or	r11,r12,r7<<0x14
80008e6a:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008e6e <__avr32_f64_sub_return_nan>:
80008e6e:	3f fa       	mov	r10,-1
80008e70:	3f fb       	mov	r11,-1
80008e72:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008e76 <__avr32_f64_sub_subnormal_result>:
80008e76:	5c 37       	neg	r7
80008e78:	2f f7       	sub	r7,-1
80008e7a:	f1 b7 04 c0 	satu	r7,0x6
80008e7e:	e0 47 00 20 	cp.w	r7,32
80008e82:	c1 14       	brge	80008ea4 <__avr32_f64_sub_subnormal_result+0x2e>
80008e84:	ee 08 11 20 	rsub	r8,r7,32
80008e88:	f4 08 09 49 	lsl	r9,r10,r8
80008e8c:	5f 16       	srne	r6
80008e8e:	f4 07 0a 4a 	lsr	r10,r10,r7
80008e92:	0c 4a       	or	r10,r6
80008e94:	f6 08 09 49 	lsl	r9,r11,r8
80008e98:	f5 e9 10 0a 	or	r10,r10,r9
80008e9c:	f4 07 0a 4b 	lsr	r11,r10,r7
80008ea0:	30 07       	mov	r7,0
80008ea2:	cb 2b       	rjmp	80008e06 <__avr32_f64_sub_longnormalize_done>
80008ea4:	ee 08 11 40 	rsub	r8,r7,64
80008ea8:	f6 08 09 49 	lsl	r9,r11,r8
80008eac:	14 49       	or	r9,r10
80008eae:	5f 16       	srne	r6
80008eb0:	f6 07 0a 4a 	lsr	r10,r11,r7
80008eb4:	0c 4a       	or	r10,r6
80008eb6:	30 0b       	mov	r11,0
80008eb8:	30 07       	mov	r7,0
80008eba:	ca 6b       	rjmp	80008e06 <__avr32_f64_sub_longnormalize_done>
80008ebc:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008ec0 <__avr32_f64_sub_longshift>:
80008ec0:	f1 b6 04 c0 	satu	r6,0x6
80008ec4:	f0 0e 17 00 	moveq	lr,r8
80008ec8:	c0 40       	breq	80008ed0 <__avr32_f64_sub_longshift+0x10>
80008eca:	f2 05 09 4e 	lsl	lr,r9,r5
80008ece:	10 4e       	or	lr,r8
80008ed0:	f2 06 0a 48 	lsr	r8,r9,r6
80008ed4:	30 09       	mov	r9,0
80008ed6:	58 0e       	cp.w	lr,0
80008ed8:	5f 1e       	srne	lr
80008eda:	1c 48       	or	r8,lr
80008edc:	c8 2b       	rjmp	80008de0 <__avr32_f64_sub_shift_done>

80008ede <__avr32_f64_sub_longnormalize>:
80008ede:	f4 06 12 00 	clz	r6,r10
80008ee2:	f9 b7 03 00 	movlo	r7,0
80008ee6:	f9 b6 03 00 	movlo	r6,0
80008eea:	f9 bc 03 00 	movlo	r12,0
80008eee:	f7 b6 02 e0 	subhs	r6,-32
80008ef2:	f4 06 09 4b 	lsl	r11,r10,r6
80008ef6:	30 0a       	mov	r10,0
80008ef8:	0c 17       	sub	r7,r6
80008efa:	fe 9a ff be 	brle	80008e76 <__avr32_f64_sub_subnormal_result>
80008efe:	c8 4b       	rjmp	80008e06 <__avr32_f64_sub_longnormalize_done>

80008f00 <__avr32_f64_add_from_sub>:
80008f00:	ee 19 80 00 	eorh	r9,0x8000

80008f04 <__avr32_f64_add>:
80008f04:	f7 e9 20 0c 	eor	r12,r11,r9
80008f08:	fe 96 ff 2e 	brmi	80008d64 <__avr32_f64_sub_from_add>
80008f0c:	eb cd 40 e0 	pushm	r5-r7,lr
80008f10:	16 9c       	mov	r12,r11
80008f12:	e6 1c 80 00 	andh	r12,0x8000,COH
80008f16:	bf db       	cbr	r11,0x1f
80008f18:	bf d9       	cbr	r9,0x1f
80008f1a:	12 3b       	cp.w	r11,r9
80008f1c:	c0 72       	brcc	80008f2a <__avr32_f64_add+0x26>
80008f1e:	16 97       	mov	r7,r11
80008f20:	12 9b       	mov	r11,r9
80008f22:	0e 99       	mov	r9,r7
80008f24:	14 97       	mov	r7,r10
80008f26:	10 9a       	mov	r10,r8
80008f28:	0e 98       	mov	r8,r7
80008f2a:	30 0e       	mov	lr,0
80008f2c:	ef db c2 8b 	bfextu	r7,r11,0x14,0xb
80008f30:	f7 db c0 14 	bfextu	r11,r11,0x0,0x14
80008f34:	b5 ab       	sbr	r11,0x14
80008f36:	ed d9 c2 8b 	bfextu	r6,r9,0x14,0xb
80008f3a:	c6 30       	breq	80009000 <__avr32_f64_add_op2_subnormal>
80008f3c:	f3 d9 c0 14 	bfextu	r9,r9,0x0,0x14
80008f40:	b5 a9       	sbr	r9,0x14
80008f42:	e0 47 07 ff 	cp.w	r7,2047
80008f46:	c2 80       	breq	80008f96 <__avr32_f64_add_opH_nan_or_inf>
80008f48:	0e 26       	rsub	r6,r7
80008f4a:	c1 20       	breq	80008f6e <__avr32_f64_add_shift_done>
80008f4c:	e0 46 00 36 	cp.w	r6,54
80008f50:	c1 52       	brcc	80008f7a <__avr32_f64_add_res_of_done>
80008f52:	ec 05 11 20 	rsub	r5,r6,32
80008f56:	e0 46 00 20 	cp.w	r6,32
80008f5a:	c3 62       	brcc	80008fc6 <__avr32_f64_add_longshift>
80008f5c:	f0 05 09 4e 	lsl	lr,r8,r5
80008f60:	f2 05 09 45 	lsl	r5,r9,r5
80008f64:	f0 06 0a 48 	lsr	r8,r8,r6
80008f68:	f2 06 0a 49 	lsr	r9,r9,r6
80008f6c:	0a 48       	or	r8,r5

80008f6e <__avr32_f64_add_shift_done>:
80008f6e:	10 0a       	add	r10,r8
80008f70:	f6 09 00 4b 	adc	r11,r11,r9
80008f74:	ed bb 00 15 	bld	r11,0x15
80008f78:	c3 50       	breq	80008fe2 <__avr32_f64_add_res_of>

80008f7a <__avr32_f64_add_res_of_done>:
80008f7a:	f7 d7 d2 8b 	bfins	r11,r7,0x14,0xb
80008f7e:	18 4b       	or	r11,r12

80008f80 <__avr32_f64_add_round>:
80008f80:	f9 da c0 01 	bfextu	r12,r10,0x0,0x1
80008f84:	18 4e       	or	lr,r12
80008f86:	ee 1e 80 00 	eorh	lr,0x8000
80008f8a:	f1 be 04 20 	satu	lr,0x1
80008f8e:	1c 0a       	add	r10,lr
80008f90:	5c 0b       	acr	r11
80008f92:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008f96 <__avr32_f64_add_opH_nan_or_inf>:
80008f96:	b5 cb       	cbr	r11,0x14
80008f98:	f7 ea 10 0e 	or	lr,r11,r10
80008f9c:	c1 11       	brne	80008fbe <__avr32_f64_add_return_nan>
80008f9e:	e0 46 07 ff 	cp.w	r6,2047
80008fa2:	c0 30       	breq	80008fa8 <__avr32_f64_add_opL_nan_or_inf>
80008fa4:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008fa8 <__avr32_f64_add_opL_nan_or_inf>:
80008fa8:	b5 c9       	cbr	r9,0x14
80008faa:	f3 e8 10 0e 	or	lr,r9,r8
80008fae:	c0 81       	brne	80008fbe <__avr32_f64_add_return_nan>
80008fb0:	30 0a       	mov	r10,0
80008fb2:	30 0b       	mov	r11,0
80008fb4:	ea 1b 7f f0 	orh	r11,0x7ff0
80008fb8:	18 4b       	or	r11,r12
80008fba:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008fbe <__avr32_f64_add_return_nan>:
80008fbe:	3f fa       	mov	r10,-1
80008fc0:	3f fb       	mov	r11,-1
80008fc2:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80008fc6 <__avr32_f64_add_longshift>:
80008fc6:	f1 b6 04 c0 	satu	r6,0x6
80008fca:	f0 0e 17 00 	moveq	lr,r8
80008fce:	c0 60       	breq	80008fda <__avr32_f64_add_longshift+0x14>
80008fd0:	f2 05 09 4e 	lsl	lr,r9,r5
80008fd4:	58 08       	cp.w	r8,0
80008fd6:	5f 18       	srne	r8
80008fd8:	10 4e       	or	lr,r8
80008fda:	f2 06 0a 48 	lsr	r8,r9,r6
80008fde:	30 09       	mov	r9,0
80008fe0:	cc 7b       	rjmp	80008f6e <__avr32_f64_add_shift_done>

80008fe2 <__avr32_f64_add_res_of>:
80008fe2:	fd ee 10 1e 	or	lr,lr,lr<<0x1
80008fe6:	a1 9b       	lsr	r11,0x1
80008fe8:	5d 0a       	ror	r10
80008fea:	5d 0e       	ror	lr
80008fec:	2f f7       	sub	r7,-1
80008fee:	e0 47 07 ff 	cp.w	r7,2047
80008ff2:	f9 ba 00 00 	moveq	r10,0
80008ff6:	f9 bb 00 00 	moveq	r11,0
80008ffa:	f9 be 00 00 	moveq	lr,0
80008ffe:	cb eb       	rjmp	80008f7a <__avr32_f64_add_res_of_done>

80009000 <__avr32_f64_add_op2_subnormal>:
80009000:	30 16       	mov	r6,1
80009002:	58 07       	cp.w	r7,0
80009004:	c9 f1       	brne	80008f42 <__avr32_f64_add+0x3e>
80009006:	b5 cb       	cbr	r11,0x14
80009008:	10 0a       	add	r10,r8
8000900a:	f6 09 00 4b 	adc	r11,r11,r9
8000900e:	18 4b       	or	r11,r12
80009010:	e3 cd 80 e0 	ldm	sp++,r5-r7,pc

80009014 <__avr32_f64_to_u32>:
80009014:	58 0b       	cp.w	r11,0
80009016:	5e 6d       	retmi	0

80009018 <__avr32_f64_to_s32>:
80009018:	f6 0c 15 01 	lsl	r12,r11,0x1
8000901c:	b5 9c       	lsr	r12,0x15
8000901e:	e0 2c 03 ff 	sub	r12,1023
80009022:	5e 3d       	retlo	0
80009024:	f8 0c 11 1f 	rsub	r12,r12,31
80009028:	16 99       	mov	r9,r11
8000902a:	ab 7b       	lsl	r11,0xb
8000902c:	bf bb       	sbr	r11,0x1f
8000902e:	f7 ea 13 5b 	or	r11,r11,r10>>0x15
80009032:	f6 0c 0a 4b 	lsr	r11,r11,r12
80009036:	a1 79       	lsl	r9,0x1
80009038:	5e 2b       	reths	r11
8000903a:	5c 3b       	neg	r11
8000903c:	5e fb       	retal	r11

8000903e <__avr32_u32_to_f64>:
8000903e:	f8 cb 00 00 	sub	r11,r12,0
80009042:	30 0c       	mov	r12,0
80009044:	c0 38       	rjmp	8000904a <__avr32_s32_to_f64+0x4>

80009046 <__avr32_s32_to_f64>:
80009046:	18 9b       	mov	r11,r12
80009048:	5c 4b       	abs	r11
8000904a:	30 0a       	mov	r10,0
8000904c:	5e 0b       	reteq	r11
8000904e:	d4 01       	pushm	lr
80009050:	e0 69 04 1e 	mov	r9,1054
80009054:	f6 08 12 00 	clz	r8,r11
80009058:	c1 70       	breq	80009086 <__avr32_s32_to_f64+0x40>
8000905a:	c0 c3       	brcs	80009072 <__avr32_s32_to_f64+0x2c>
8000905c:	f0 0e 11 20 	rsub	lr,r8,32
80009060:	f6 08 09 4b 	lsl	r11,r11,r8
80009064:	f4 0e 0a 4e 	lsr	lr,r10,lr
80009068:	1c 4b       	or	r11,lr
8000906a:	f4 08 09 4a 	lsl	r10,r10,r8
8000906e:	10 19       	sub	r9,r8
80009070:	c0 b8       	rjmp	80009086 <__avr32_s32_to_f64+0x40>
80009072:	f4 08 12 00 	clz	r8,r10
80009076:	f9 b8 03 00 	movlo	r8,0
8000907a:	f7 b8 02 e0 	subhs	r8,-32
8000907e:	f4 08 09 4b 	lsl	r11,r10,r8
80009082:	30 0a       	mov	r10,0
80009084:	10 19       	sub	r9,r8
80009086:	58 09       	cp.w	r9,0
80009088:	e0 89 00 30 	brgt	800090e8 <__avr32_s32_to_f64+0xa2>
8000908c:	5c 39       	neg	r9
8000908e:	2f f9       	sub	r9,-1
80009090:	e0 49 00 36 	cp.w	r9,54
80009094:	c0 43       	brcs	8000909c <__avr32_s32_to_f64+0x56>
80009096:	30 0b       	mov	r11,0
80009098:	30 0a       	mov	r10,0
8000909a:	c2 68       	rjmp	800090e6 <__avr32_s32_to_f64+0xa0>
8000909c:	2f 69       	sub	r9,-10
8000909e:	f2 08 11 20 	rsub	r8,r9,32
800090a2:	e0 49 00 20 	cp.w	r9,32
800090a6:	c0 b2       	brcc	800090bc <__avr32_s32_to_f64+0x76>
800090a8:	f4 08 09 4e 	lsl	lr,r10,r8
800090ac:	f6 08 09 48 	lsl	r8,r11,r8
800090b0:	f4 09 0a 4a 	lsr	r10,r10,r9
800090b4:	f6 09 0a 4b 	lsr	r11,r11,r9
800090b8:	10 4b       	or	r11,r8
800090ba:	c0 88       	rjmp	800090ca <__avr32_s32_to_f64+0x84>
800090bc:	f6 08 09 4e 	lsl	lr,r11,r8
800090c0:	14 4e       	or	lr,r10
800090c2:	16 9a       	mov	r10,r11
800090c4:	30 0b       	mov	r11,0
800090c6:	f4 09 0a 4a 	lsr	r10,r10,r9
800090ca:	ed ba 00 00 	bld	r10,0x0
800090ce:	c0 92       	brcc	800090e0 <__avr32_s32_to_f64+0x9a>
800090d0:	1c 7e       	tst	lr,lr
800090d2:	c0 41       	brne	800090da <__avr32_s32_to_f64+0x94>
800090d4:	ed ba 00 01 	bld	r10,0x1
800090d8:	c0 42       	brcc	800090e0 <__avr32_s32_to_f64+0x9a>
800090da:	2f fa       	sub	r10,-1
800090dc:	f7 bb 02 ff 	subhs	r11,-1
800090e0:	5c fc       	rol	r12
800090e2:	5d 0b       	ror	r11
800090e4:	5d 0a       	ror	r10
800090e6:	d8 02       	popm	pc
800090e8:	e0 68 03 ff 	mov	r8,1023
800090ec:	ed ba 00 0b 	bld	r10,0xb
800090f0:	f7 b8 00 ff 	subeq	r8,-1
800090f4:	10 0a       	add	r10,r8
800090f6:	5c 0b       	acr	r11
800090f8:	f7 b9 03 fe 	sublo	r9,-2
800090fc:	e0 49 07 ff 	cp.w	r9,2047
80009100:	c0 65       	brlt	8000910c <__avr32_s32_to_f64+0xc6>
80009102:	30 0a       	mov	r10,0
80009104:	30 0b       	mov	r11,0
80009106:	ea 1b ff e0 	orh	r11,0xffe0
8000910a:	c0 c8       	rjmp	80009122 <__floatsidf_return_op1>
8000910c:	ed bb 00 1f 	bld	r11,0x1f
80009110:	f7 b9 01 01 	subne	r9,1
80009114:	ab 9a       	lsr	r10,0xb
80009116:	f5 eb 11 5a 	or	r10,r10,r11<<0x15
8000911a:	a1 7b       	lsl	r11,0x1
8000911c:	ab 9b       	lsr	r11,0xb
8000911e:	f7 e9 11 5b 	or	r11,r11,r9<<0x15

80009122 <__floatsidf_return_op1>:
80009122:	a1 7c       	lsl	r12,0x1
80009124:	5d 0b       	ror	r11
80009126:	d8 02       	popm	pc

80009128 <memcpy>:
80009128:	58 8a       	cp.w	r10,8
8000912a:	c2 f5       	brlt	80009188 <memcpy+0x60>
8000912c:	f9 eb 10 09 	or	r9,r12,r11
80009130:	e2 19 00 03 	andl	r9,0x3,COH
80009134:	e0 81 00 97 	brne	80009262 <memcpy+0x13a>
80009138:	e0 4a 00 20 	cp.w	r10,32
8000913c:	c3 b4       	brge	800091b2 <memcpy+0x8a>
8000913e:	f4 08 14 02 	asr	r8,r10,0x2
80009142:	f0 09 11 08 	rsub	r9,r8,8
80009146:	fe 09 00 2f 	add	pc,pc,r9<<0x2
8000914a:	76 69       	ld.w	r9,r11[0x18]
8000914c:	99 69       	st.w	r12[0x18],r9
8000914e:	76 59       	ld.w	r9,r11[0x14]
80009150:	99 59       	st.w	r12[0x14],r9
80009152:	76 49       	ld.w	r9,r11[0x10]
80009154:	99 49       	st.w	r12[0x10],r9
80009156:	76 39       	ld.w	r9,r11[0xc]
80009158:	99 39       	st.w	r12[0xc],r9
8000915a:	76 29       	ld.w	r9,r11[0x8]
8000915c:	99 29       	st.w	r12[0x8],r9
8000915e:	76 19       	ld.w	r9,r11[0x4]
80009160:	99 19       	st.w	r12[0x4],r9
80009162:	76 09       	ld.w	r9,r11[0x0]
80009164:	99 09       	st.w	r12[0x0],r9
80009166:	f6 08 00 2b 	add	r11,r11,r8<<0x2
8000916a:	f8 08 00 28 	add	r8,r12,r8<<0x2
8000916e:	e0 1a 00 03 	andl	r10,0x3
80009172:	f4 0a 11 04 	rsub	r10,r10,4
80009176:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
8000917a:	17 a9       	ld.ub	r9,r11[0x2]
8000917c:	b0 a9       	st.b	r8[0x2],r9
8000917e:	17 99       	ld.ub	r9,r11[0x1]
80009180:	b0 99       	st.b	r8[0x1],r9
80009182:	17 89       	ld.ub	r9,r11[0x0]
80009184:	b0 89       	st.b	r8[0x0],r9
80009186:	5e fc       	retal	r12
80009188:	f4 0a 11 09 	rsub	r10,r10,9
8000918c:	fe 0a 00 2f 	add	pc,pc,r10<<0x2
80009190:	17 f9       	ld.ub	r9,r11[0x7]
80009192:	b8 f9       	st.b	r12[0x7],r9
80009194:	17 e9       	ld.ub	r9,r11[0x6]
80009196:	b8 e9       	st.b	r12[0x6],r9
80009198:	17 d9       	ld.ub	r9,r11[0x5]
8000919a:	b8 d9       	st.b	r12[0x5],r9
8000919c:	17 c9       	ld.ub	r9,r11[0x4]
8000919e:	b8 c9       	st.b	r12[0x4],r9
800091a0:	17 b9       	ld.ub	r9,r11[0x3]
800091a2:	b8 b9       	st.b	r12[0x3],r9
800091a4:	17 a9       	ld.ub	r9,r11[0x2]
800091a6:	b8 a9       	st.b	r12[0x2],r9
800091a8:	17 99       	ld.ub	r9,r11[0x1]
800091aa:	b8 99       	st.b	r12[0x1],r9
800091ac:	17 89       	ld.ub	r9,r11[0x0]
800091ae:	b8 89       	st.b	r12[0x0],r9
800091b0:	5e fc       	retal	r12
800091b2:	eb cd 40 c0 	pushm	r6-r7,lr
800091b6:	18 99       	mov	r9,r12
800091b8:	22 0a       	sub	r10,32
800091ba:	b7 07       	ld.d	r6,r11++
800091bc:	b3 26       	st.d	r9++,r6
800091be:	b7 07       	ld.d	r6,r11++
800091c0:	b3 26       	st.d	r9++,r6
800091c2:	b7 07       	ld.d	r6,r11++
800091c4:	b3 26       	st.d	r9++,r6
800091c6:	b7 07       	ld.d	r6,r11++
800091c8:	b3 26       	st.d	r9++,r6
800091ca:	22 0a       	sub	r10,32
800091cc:	cf 74       	brge	800091ba <memcpy+0x92>
800091ce:	2f 0a       	sub	r10,-16
800091d0:	c0 65       	brlt	800091dc <memcpy+0xb4>
800091d2:	b7 07       	ld.d	r6,r11++
800091d4:	b3 26       	st.d	r9++,r6
800091d6:	b7 07       	ld.d	r6,r11++
800091d8:	b3 26       	st.d	r9++,r6
800091da:	21 0a       	sub	r10,16
800091dc:	5c 3a       	neg	r10
800091de:	fe 0a 00 3f 	add	pc,pc,r10<<0x3
800091e2:	d7 03       	nop
800091e4:	d7 03       	nop
800091e6:	f7 36 00 0e 	ld.ub	r6,r11[14]
800091ea:	f3 66 00 0e 	st.b	r9[14],r6
800091ee:	f7 36 00 0d 	ld.ub	r6,r11[13]
800091f2:	f3 66 00 0d 	st.b	r9[13],r6
800091f6:	f7 36 00 0c 	ld.ub	r6,r11[12]
800091fa:	f3 66 00 0c 	st.b	r9[12],r6
800091fe:	f7 36 00 0b 	ld.ub	r6,r11[11]
80009202:	f3 66 00 0b 	st.b	r9[11],r6
80009206:	f7 36 00 0a 	ld.ub	r6,r11[10]
8000920a:	f3 66 00 0a 	st.b	r9[10],r6
8000920e:	f7 36 00 09 	ld.ub	r6,r11[9]
80009212:	f3 66 00 09 	st.b	r9[9],r6
80009216:	f7 36 00 08 	ld.ub	r6,r11[8]
8000921a:	f3 66 00 08 	st.b	r9[8],r6
8000921e:	f7 36 00 07 	ld.ub	r6,r11[7]
80009222:	f3 66 00 07 	st.b	r9[7],r6
80009226:	f7 36 00 06 	ld.ub	r6,r11[6]
8000922a:	f3 66 00 06 	st.b	r9[6],r6
8000922e:	f7 36 00 05 	ld.ub	r6,r11[5]
80009232:	f3 66 00 05 	st.b	r9[5],r6
80009236:	f7 36 00 04 	ld.ub	r6,r11[4]
8000923a:	f3 66 00 04 	st.b	r9[4],r6
8000923e:	f7 36 00 03 	ld.ub	r6,r11[3]
80009242:	f3 66 00 03 	st.b	r9[3],r6
80009246:	f7 36 00 02 	ld.ub	r6,r11[2]
8000924a:	f3 66 00 02 	st.b	r9[2],r6
8000924e:	f7 36 00 01 	ld.ub	r6,r11[1]
80009252:	f3 66 00 01 	st.b	r9[1],r6
80009256:	f7 36 00 00 	ld.ub	r6,r11[0]
8000925a:	f3 66 00 00 	st.b	r9[0],r6
8000925e:	e3 cd 80 c0 	ldm	sp++,r6-r7,pc
80009262:	20 1a       	sub	r10,1
80009264:	f6 0a 07 09 	ld.ub	r9,r11[r10]
80009268:	f8 0a 0b 09 	st.b	r12[r10],r9
8000926c:	cf b1       	brne	80009262 <memcpy+0x13a>
8000926e:	5e fc       	retal	r12

Disassembly of section .exception:

80009400 <_evba>:
_evba:

	.org  0x000
	// Unrecoverable Exception.
_handle_Unrecoverable_Exception:
	rjmp $
80009400:	c0 08       	rjmp	80009400 <_evba>
	...

80009404 <_handle_TLB_Multiple_Hit>:

	.org  0x004
	// TLB Multiple Hit.
_handle_TLB_Multiple_Hit:
	rjmp $
80009404:	c0 08       	rjmp	80009404 <_handle_TLB_Multiple_Hit>
	...

80009408 <_handle_Bus_Error_Data_Fetch>:

	.org  0x008
	// Bus Error Data Fetch.
_handle_Bus_Error_Data_Fetch:
	rjmp $
80009408:	c0 08       	rjmp	80009408 <_handle_Bus_Error_Data_Fetch>
	...

8000940c <_handle_Bus_Error_Instruction_Fetch>:

	.org  0x00C
	// Bus Error Instruction Fetch.
_handle_Bus_Error_Instruction_Fetch:
	rjmp $
8000940c:	c0 08       	rjmp	8000940c <_handle_Bus_Error_Instruction_Fetch>
	...

80009410 <_handle_NMI>:

	.org  0x010
	// NMI.
_handle_NMI:
	rjmp $
80009410:	c0 08       	rjmp	80009410 <_handle_NMI>
	...

80009414 <_handle_Instruction_Address>:

	.org  0x014
	// Instruction Address.
_handle_Instruction_Address:
	rjmp $
80009414:	c0 08       	rjmp	80009414 <_handle_Instruction_Address>
	...

80009418 <_handle_ITLB_Protection>:

	.org  0x018
	// ITLB Protection.
_handle_ITLB_Protection:
	rjmp $
80009418:	c0 08       	rjmp	80009418 <_handle_ITLB_Protection>
	...

8000941c <_handle_Breakpoint>:

	.org  0x01C
	// Breakpoint.
_handle_Breakpoint:
	rjmp $
8000941c:	c0 08       	rjmp	8000941c <_handle_Breakpoint>
	...

80009420 <_handle_Illegal_Opcode>:

	.org  0x020
	// Illegal Opcode.
_handle_Illegal_Opcode:
	rjmp $
80009420:	c0 08       	rjmp	80009420 <_handle_Illegal_Opcode>
	...

80009424 <_handle_Unimplemented_Instruction>:

	.org  0x024
	// Unimplemented Instruction.
_handle_Unimplemented_Instruction:
	rjmp $
80009424:	c0 08       	rjmp	80009424 <_handle_Unimplemented_Instruction>
	...

80009428 <_handle_Privilege_Violation>:

	.org  0x028
	// Privilege Violation.
_handle_Privilege_Violation:
	rjmp $
80009428:	c0 08       	rjmp	80009428 <_handle_Privilege_Violation>
	...

8000942c <_handle_Floating_Point>:

	.org  0x02C
	// Floating-Point: UNUSED IN AVR32UC and AVR32AP.
_handle_Floating_Point:
	rjmp $
8000942c:	c0 08       	rjmp	8000942c <_handle_Floating_Point>
	...

80009430 <_handle_Coprocessor_Absent>:

	.org  0x030
	// Coprocessor Absent: UNUSED IN AVR32UC.
_handle_Coprocessor_Absent:
	rjmp $
80009430:	c0 08       	rjmp	80009430 <_handle_Coprocessor_Absent>
	...

80009434 <_handle_Data_Address_Read>:

	.org  0x034
	// Data Address (Read).
_handle_Data_Address_Read:
	rjmp $
80009434:	c0 08       	rjmp	80009434 <_handle_Data_Address_Read>
	...

80009438 <_handle_Data_Address_Write>:

	.org  0x038
	// Data Address (Write).
_handle_Data_Address_Write:
	rjmp $
80009438:	c0 08       	rjmp	80009438 <_handle_Data_Address_Write>
	...

8000943c <_handle_DTLB_Protection_Read>:

	.org  0x03C
	// DTLB Protection (Read).
_handle_DTLB_Protection_Read:
	rjmp $
8000943c:	c0 08       	rjmp	8000943c <_handle_DTLB_Protection_Read>
	...

80009440 <_handle_DTLB_Protection_Write>:

	.org  0x040
	// DTLB Protection (Write).
_handle_DTLB_Protection_Write:
	rjmp $
80009440:	c0 08       	rjmp	80009440 <_handle_DTLB_Protection_Write>
	...

80009444 <_handle_DTLB_Modified>:

	.org  0x044
	// DTLB Modified: UNUSED IN AVR32UC.
_handle_DTLB_Modified:
	rjmp $
80009444:	c0 08       	rjmp	80009444 <_handle_DTLB_Modified>
	...

80009450 <_handle_ITLB_Miss>:

	.org  0x050
	// ITLB Miss.
_handle_ITLB_Miss:
	rjmp $
80009450:	c0 08       	rjmp	80009450 <_handle_ITLB_Miss>
	...

80009460 <_handle_DTLB_Miss_Read>:

	.org  0x060
	// DTLB Miss (Read).
_handle_DTLB_Miss_Read:
	rjmp $
80009460:	c0 08       	rjmp	80009460 <_handle_DTLB_Miss_Read>
	...

80009470 <_handle_DTLB_Miss_Write>:

	.org  0x070
	// DTLB Miss (Write).
_handle_DTLB_Miss_Write:
	rjmp $
80009470:	c0 08       	rjmp	80009470 <_handle_DTLB_Miss_Write>
	...

80009500 <_handle_Supervisor_Call>:

	.org  0x100
	// Supervisor Call.
_handle_Supervisor_Call:
	rjmp $
80009500:	c0 08       	rjmp	80009500 <_handle_Supervisor_Call>
80009502:	d7 03       	nop

80009504 <_int0>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80009504:	30 0c       	mov	r12,0
80009506:	fe b0 cc 3d 	rcall	80002d80 <_get_interrupt_handler>
8000950a:	58 0c       	cp.w	r12,0
8000950c:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
80009510:	d6 03       	rete

80009512 <_int1>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80009512:	30 1c       	mov	r12,1
80009514:	fe b0 cc 36 	rcall	80002d80 <_get_interrupt_handler>
80009518:	58 0c       	cp.w	r12,0
8000951a:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000951e:	d6 03       	rete

80009520 <_int2>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
80009520:	30 2c       	mov	r12,2
80009522:	fe b0 cc 2f 	rcall	80002d80 <_get_interrupt_handler>
80009526:	58 0c       	cp.w	r12,0
80009528:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000952c:	d6 03       	rete

8000952e <_int3>:
	 * RSR_INTx by the CPU upon interrupt entry. No other register is saved
	 * by hardware.
	 */
	pushm   r8-r12, lr
#endif
	// Pass the int_level parameter to the _get_interrupt_handler function.
8000952e:	30 3c       	mov	r12,3
80009530:	fe b0 cc 28 	rcall	80002d80 <_get_interrupt_handler>
80009534:	58 0c       	cp.w	r12,0
80009536:	f8 0f 17 10 	movne	pc,r12
	popm    r8-r12, lr
#endif
	/*
	 * If this was a spurious interrupt (R12 == NULL), return from event
	 * handler.
	 */
8000953a:	d6 03       	rete
8000953c:	d7 03       	nop
8000953e:	d7 03       	nop
80009540:	d7 03       	nop
80009542:	d7 03       	nop
80009544:	d7 03       	nop
80009546:	d7 03       	nop
80009548:	d7 03       	nop
8000954a:	d7 03       	nop
8000954c:	d7 03       	nop
8000954e:	d7 03       	nop
80009550:	d7 03       	nop
80009552:	d7 03       	nop
80009554:	d7 03       	nop
80009556:	d7 03       	nop
80009558:	d7 03       	nop
8000955a:	d7 03       	nop
8000955c:	d7 03       	nop
8000955e:	d7 03       	nop
80009560:	d7 03       	nop
80009562:	d7 03       	nop
80009564:	d7 03       	nop
80009566:	d7 03       	nop
80009568:	d7 03       	nop
8000956a:	d7 03       	nop
8000956c:	d7 03       	nop
8000956e:	d7 03       	nop
80009570:	d7 03       	nop
80009572:	d7 03       	nop
80009574:	d7 03       	nop
80009576:	d7 03       	nop
80009578:	d7 03       	nop
8000957a:	d7 03       	nop
8000957c:	d7 03       	nop
8000957e:	d7 03       	nop
80009580:	d7 03       	nop
80009582:	d7 03       	nop
80009584:	d7 03       	nop
80009586:	d7 03       	nop
80009588:	d7 03       	nop
8000958a:	d7 03       	nop
8000958c:	d7 03       	nop
8000958e:	d7 03       	nop
80009590:	d7 03       	nop
80009592:	d7 03       	nop
80009594:	d7 03       	nop
80009596:	d7 03       	nop
80009598:	d7 03       	nop
8000959a:	d7 03       	nop
8000959c:	d7 03       	nop
8000959e:	d7 03       	nop
800095a0:	d7 03       	nop
800095a2:	d7 03       	nop
800095a4:	d7 03       	nop
800095a6:	d7 03       	nop
800095a8:	d7 03       	nop
800095aa:	d7 03       	nop
800095ac:	d7 03       	nop
800095ae:	d7 03       	nop
800095b0:	d7 03       	nop
800095b2:	d7 03       	nop
800095b4:	d7 03       	nop
800095b6:	d7 03       	nop
800095b8:	d7 03       	nop
800095ba:	d7 03       	nop
800095bc:	d7 03       	nop
800095be:	d7 03       	nop
800095c0:	d7 03       	nop
800095c2:	d7 03       	nop
800095c4:	d7 03       	nop
800095c6:	d7 03       	nop
800095c8:	d7 03       	nop
800095ca:	d7 03       	nop
800095cc:	d7 03       	nop
800095ce:	d7 03       	nop
800095d0:	d7 03       	nop
800095d2:	d7 03       	nop
800095d4:	d7 03       	nop
800095d6:	d7 03       	nop
800095d8:	d7 03       	nop
800095da:	d7 03       	nop
800095dc:	d7 03       	nop
800095de:	d7 03       	nop
800095e0:	d7 03       	nop
800095e2:	d7 03       	nop
800095e4:	d7 03       	nop
800095e6:	d7 03       	nop
800095e8:	d7 03       	nop
800095ea:	d7 03       	nop
800095ec:	d7 03       	nop
800095ee:	d7 03       	nop
800095f0:	d7 03       	nop
800095f2:	d7 03       	nop
800095f4:	d7 03       	nop
800095f6:	d7 03       	nop
800095f8:	d7 03       	nop
800095fa:	d7 03       	nop
800095fc:	d7 03       	nop
800095fe:	d7 03       	nop
